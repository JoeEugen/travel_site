(function(){var __webpack_modules__={8748:function(module){eval('var e,t;e=this,t=function(){"use strict";function e(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function t(t){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?e(Object(i),!0).forEach((function(e){r(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e){return function(e){if(Array.isArray(e))return s(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||o(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){if(e){if("string"==typeof e)return s(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?s(e,t):void 0}}function s(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var u=function(e){return"string"==typeof e?document.querySelector(e):e()},a=function(e,t){var n="string"==typeof e?document.createElement(e):e;for(var r in t){var i=t[r];if("inside"===r)i.append(n);else if("dest"===r)u(i[0]).insertAdjacentElement(i[1],n);else if("around"===r){var o=i;o.parentNode.insertBefore(n,o),n.append(o),null!=o.getAttribute("autofocus")&&o.focus()}else r in n?n[r]=i:n.setAttribute(r,i)}return n},c=function(e,t){return e=String(e).toLowerCase(),t?e.normalize("NFD").replace(/[\\u0300-\\u036f]/g,"").normalize("NFC"):e},l=function(e,n){return a("mark",t({innerHTML:e},"string"==typeof n&&{class:n})).outerHTML},f=function(e,t){t.input.dispatchEvent(new CustomEvent(e,{bubbles:!0,detail:t.feedback,cancelable:!0}))},p=function(e,t,n){var r=n||{},i=r.mode,o=r.diacritics,s=r.highlight,u=c(t,o);if(t=String(t),e=c(e,o),"loose"===i){var a=(e=e.replace(/ /g,"")).length,f=0,p=Array.from(t).map((function(t,n){return f<a&&u[n]===e[f]&&(t=s?l(t,s):t,f++),t})).join("");if(f===a)return p}else{var d=u.indexOf(e);if(~d)return e=t.substring(d,d+e.length),d=s?t.replace(e,l(e,s)):t}},d=function(e,t){return new Promise((function(n,r){var i;return(i=e.data).cache&&i.store?n():new Promise((function(e,n){return"function"==typeof i.src?i.src(t).then(e,n):e(i.src)})).then((function(t){try{return e.feedback=i.store=t,f("response",e),n()}catch(e){return r(e)}}),r)}))},h=function(e,t){var n=t.data,r=t.searchEngine,i=[];n.store.forEach((function(s,u){var a=function(n){var o=n?s[n]:s,u="function"==typeof r?r(e,o):p(e,o,{mode:r,diacritics:t.diacritics,highlight:t.resultItem.highlight});if(u){var a={match:u,value:s};n&&(a.key=n),i.push(a)}};if(n.keys){var c,l=function(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=o(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,i=function(){};return{s:i,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,u=!0,a=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return u=e.done,e},e:function(e){a=!0,s=e},f:function(){try{u||null==n.return||n.return()}finally{if(a)throw s}}}}(n.keys);try{for(l.s();!(c=l.n()).done;)a(c.value)}catch(e){l.e(e)}finally{l.f()}}else a()})),n.filter&&(i=n.filter(i));var s=i.slice(0,t.resultsList.maxResults);t.feedback={query:e,matches:i,results:s},f("results",t)},m="aria-expanded",b="aria-activedescendant",y="aria-selected",v=function(e,n){e.feedback.selection=t({index:n},e.feedback.results[n])},g=function(e){e.isOpen||((e.wrapper||e.input).setAttribute(m,!0),e.list.removeAttribute("hidden"),e.isOpen=!0,f("open",e))},w=function(e){e.isOpen&&((e.wrapper||e.input).setAttribute(m,!1),e.input.setAttribute(b,""),e.list.setAttribute("hidden",""),e.isOpen=!1,f("close",e))},O=function(e,t){var n=t.resultItem,r=t.list.getElementsByTagName(n.tag),o=!!n.selected&&n.selected.split(" ");if(t.isOpen&&r.length){var s,u,a=t.cursor;e>=r.length&&(e=0),e<0&&(e=r.length-1),t.cursor=e,a>-1&&(r[a].removeAttribute(y),o&&(u=r[a].classList).remove.apply(u,i(o))),r[e].setAttribute(y,!0),o&&(s=r[e].classList).add.apply(s,i(o)),t.input.setAttribute(b,r[t.cursor].id),t.list.scrollTop=r[e].offsetTop-t.list.clientHeight+r[e].clientHeight+5,t.feedback.cursor=t.cursor,v(t,e),f("navigate",t)}},A=function(e){O(e.cursor+1,e)},k=function(e){O(e.cursor-1,e)},L=function(e,t,n){(n=n>=0?n:e.cursor)<0||(e.feedback.event=t,v(e,n),f("selection",e),w(e))};function j(e,n){var r=this;return new Promise((function(i,o){var s,u;return s=n||((u=e.input)instanceof HTMLInputElement||u instanceof HTMLTextAreaElement?u.value:u.innerHTML),function(e,t,n){return t?t(e):e.length>=n}(s=e.query?e.query(s):s,e.trigger,e.threshold)?d(e,s).then((function(n){try{return e.feedback instanceof Error?i():(h(s,e),e.resultsList&&function(e){var n=e.resultsList,r=e.list,i=e.resultItem,o=e.feedback,s=o.matches,u=o.results;if(e.cursor=-1,r.innerHTML="",s.length||n.noResults){var c=new DocumentFragment;u.forEach((function(e,n){var r=a(i.tag,t({id:"".concat(i.id,"_").concat(n),role:"option",innerHTML:e.match,inside:c},i.class&&{class:i.class}));i.element&&i.element(r,e)})),r.append(c),n.element&&n.element(r,o),g(e)}else w(e)}(e),c.call(r))}catch(e){return o(e)}}),o):(w(e),c.call(r));function c(){return i()}}))}var S=function(e,t){for(var n in e)for(var r in e[n])t(n,r)},T=function(e){var n,r,i,o=e.events,s=(n=function(){return j(e)},r=e.debounce,function(){clearTimeout(i),i=setTimeout((function(){return n()}),r)}),u=e.events=t({input:t({},o&&o.input)},e.resultsList&&{list:o?t({},o.list):{}}),a={input:{input:function(){s()},keydown:function(t){!function(e,t){switch(e.keyCode){case 40:case 38:e.preventDefault(),40===e.keyCode?A(t):k(t);break;case 13:t.submit||e.preventDefault(),t.cursor>=0&&L(t,e);break;case 9:t.resultsList.tabSelect&&t.cursor>=0&&L(t,e);break;case 27:t.input.value="",w(t)}}(t,e)},blur:function(){w(e)}},list:{mousedown:function(e){e.preventDefault()},click:function(t){!function(e,t){var n=t.resultItem.tag.toUpperCase(),r=Array.from(t.list.querySelectorAll(n)),i=e.target.closest(n);i&&i.nodeName===n&&L(t,e,r.indexOf(i))}(t,e)}}};S(a,(function(t,n){(e.resultsList||"input"===n)&&(u[t][n]||(u[t][n]=a[t][n]))})),S(u,(function(t,n){e[t].addEventListener(n,u[t][n])}))};function E(e){var n=this;return new Promise((function(r,i){var o,s,u;if(o=e.placeHolder,u={role:"combobox","aria-owns":(s=e.resultsList).id,"aria-haspopup":!0,"aria-expanded":!1},a(e.input,t(t({"aria-controls":s.id,"aria-autocomplete":"both"},o&&{placeholder:o}),!e.wrapper&&t({},u))),e.wrapper&&(e.wrapper=a("div",t({around:e.input,class:e.name+"_wrapper"},u))),s&&(e.list=a(s.tag,t({dest:[s.destination,s.position],id:s.id,role:"listbox",hidden:"hidden"},s.class&&{class:s.class}))),T(e),e.data.cache)return d(e).then((function(e){try{return c.call(n)}catch(e){return i(e)}}),i);function c(){return f("init",e),r()}return c.call(n)}))}function x(e){var t=e.prototype;t.init=function(){E(this)},t.start=function(e){j(this,e)},t.unInit=function(){if(this.wrapper){var e=this.wrapper.parentNode;e.insertBefore(this.input,this.wrapper),e.removeChild(this.wrapper)}var t;S((t=this).events,(function(e,n){t[e].removeEventListener(n,t.events[e][n])}))},t.open=function(){g(this)},t.close=function(){w(this)},t.goTo=function(e){O(e,this)},t.next=function(){A(this)},t.previous=function(){k(this)},t.select=function(e){L(this,null,e)},t.search=function(e,t,n){return p(e,t,n)}}return function e(t){this.options=t,this.id=e.instances=(e.instances||0)+1,this.name="autoComplete",this.wrapper=1,this.threshold=1,this.debounce=0,this.resultsList={position:"afterend",tag:"ul",maxResults:5},this.resultItem={tag:"li"},function(e){var t=e.name,r=e.options,i=e.resultsList,o=e.resultItem;for(var s in r)if("object"===n(r[s]))for(var a in e[s]||(e[s]={}),r[s])e[s][a]=r[s][a];else e[s]=r[s];e.selector=e.selector||"#"+t,i.destination=i.destination||e.selector,i.id=i.id||t+"_list_"+e.id,o.id=o.id||t+"_result",e.input=u(e.selector)}(this),x.call(this,e),E(this)}}, true?module.exports=t():0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU0saUNBQWlDLDJDQUEyQyxHQUFHLG1CQUFtQixRQUFRLG9CQUFvQixRQUFRLG9CQUFvQixVQUFVLG1CQUFtQixRQUFRLHVCQUF1QixRQUFRLHNCQUFzQixlQUFlLDBCQUEwQixpQkFBaUIscUJBQXFCLGlKQUFpSiwwQ0FBMEMsa0JBQWtCLFNBQVMsYUFBYSx3REFBd0QsZ0VBQWdFLHVCQUF1QixlQUFlLDZJQUE2SSwrQkFBK0IsQ0FBQyxLQUFvRCxvQkFBb0IsQ0FBc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9AdGFyZWtyYWFmYXQvYXV0b2NvbXBsZXRlLmpzL2Rpc3QvYXV0b0NvbXBsZXRlLm1pbi5qcz84YzZlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlLHQ7ZT10aGlzLHQ9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTt0JiYocj1yLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSx0KS5lbnVtZXJhYmxlfSkpKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiB0KHQpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciBpPW51bGwhPWFyZ3VtZW50c1tuXT9hcmd1bWVudHNbbl06e307biUyP2UoT2JqZWN0KGkpLCEwKS5mb3JFYWNoKChmdW5jdGlvbihlKXtyKHQsZSxpW2VdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGkpKTplKE9iamVjdChpKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksZSkpfSkpfXJldHVybiB0fWZ1bmN0aW9uIG4oZSl7cmV0dXJuIG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0sbihlKX1mdW5jdGlvbiByKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBpKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBzKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9ZVtTeW1ib2wuaXRlcmF0b3JdfHxudWxsIT1lW1wiQEBpdGVyYXRvclwiXSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fG8oZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gbyhlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBzKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1uJiZlLmNvbnN0cnVjdG9yJiYobj1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bj9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9zKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBzKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBuPTAscj1uZXcgQXJyYXkodCk7bjx0O24rKylyW25dPWVbbl07cmV0dXJuIHJ9dmFyIHU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlKTplKCl9LGE9ZnVuY3Rpb24oZSx0KXt2YXIgbj1cInN0cmluZ1wiPT10eXBlb2YgZT9kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpOmU7Zm9yKHZhciByIGluIHQpe3ZhciBpPXRbcl07aWYoXCJpbnNpZGVcIj09PXIpaS5hcHBlbmQobik7ZWxzZSBpZihcImRlc3RcIj09PXIpdShpWzBdKS5pbnNlcnRBZGphY2VudEVsZW1lbnQoaVsxXSxuKTtlbHNlIGlmKFwiYXJvdW5kXCI9PT1yKXt2YXIgbz1pO28ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobixvKSxuLmFwcGVuZChvKSxudWxsIT1vLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSYmby5mb2N1cygpfWVsc2UgciBpbiBuP25bcl09aTpuLnNldEF0dHJpYnV0ZShyLGkpfXJldHVybiBufSxjPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCksdD9lLm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLFwiXCIpLm5vcm1hbGl6ZShcIk5GQ1wiKTplfSxsPWZ1bmN0aW9uKGUsbil7cmV0dXJuIGEoXCJtYXJrXCIsdCh7aW5uZXJIVE1MOmV9LFwic3RyaW5nXCI9PXR5cGVvZiBuJiZ7Y2xhc3M6bn0pKS5vdXRlckhUTUx9LGY9ZnVuY3Rpb24oZSx0KXt0LmlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGUse2J1YmJsZXM6ITAsZGV0YWlsOnQuZmVlZGJhY2ssY2FuY2VsYWJsZTohMH0pKX0scD1mdW5jdGlvbihlLHQsbil7dmFyIHI9bnx8e30saT1yLm1vZGUsbz1yLmRpYWNyaXRpY3Mscz1yLmhpZ2hsaWdodCx1PWModCxvKTtpZih0PVN0cmluZyh0KSxlPWMoZSxvKSxcImxvb3NlXCI9PT1pKXt2YXIgYT0oZT1lLnJlcGxhY2UoLyAvZyxcIlwiKSkubGVuZ3RoLGY9MCxwPUFycmF5LmZyb20odCkubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiBmPGEmJnVbbl09PT1lW2ZdJiYodD1zP2wodCxzKTp0LGYrKyksdH0pKS5qb2luKFwiXCIpO2lmKGY9PT1hKXJldHVybiBwfWVsc2V7dmFyIGQ9dS5pbmRleE9mKGUpO2lmKH5kKXJldHVybiBlPXQuc3Vic3RyaW5nKGQsZCtlLmxlbmd0aCksZD1zP3QucmVwbGFjZShlLGwoZSxzKSk6dH19LGQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4scil7dmFyIGk7cmV0dXJuKGk9ZS5kYXRhKS5jYWNoZSYmaS5zdG9yZT9uKCk6bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsbil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgaS5zcmM/aS5zcmModCkudGhlbihlLG4pOmUoaS5zcmMpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZS5mZWVkYmFjaz1pLnN0b3JlPXQsZihcInJlc3BvbnNlXCIsZSksbigpfWNhdGNoKGUpe3JldHVybiByKGUpfX0pLHIpfSkpfSxoPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kYXRhLHI9dC5zZWFyY2hFbmdpbmUsaT1bXTtuLnN0b3JlLmZvckVhY2goKGZ1bmN0aW9uKHMsdSl7dmFyIGE9ZnVuY3Rpb24obil7dmFyIG89bj9zW25dOnMsdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IoZSxvKTpwKGUsbyx7bW9kZTpyLGRpYWNyaXRpY3M6dC5kaWFjcml0aWNzLGhpZ2hsaWdodDp0LnJlc3VsdEl0ZW0uaGlnaGxpZ2h0fSk7aWYodSl7dmFyIGE9e21hdGNoOnUsdmFsdWU6c307biYmKGEua2V5PW4pLGkucHVzaChhKX19O2lmKG4ua2V5cyl7dmFyIGMsbD1mdW5jdGlvbihlLHQpe3ZhciBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVtcIkBAaXRlcmF0b3JcIl07aWYoIW4pe2lmKEFycmF5LmlzQXJyYXkoZSl8fChuPW8oZSkpfHx0JiZlJiZcIm51bWJlclwiPT10eXBlb2YgZS5sZW5ndGgpe24mJihlPW4pO3ZhciByPTAsaT1mdW5jdGlvbigpe307cmV0dXJue3M6aSxuOmZ1bmN0aW9uKCl7cmV0dXJuIHI+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW3IrK119fSxlOmZ1bmN0aW9uKGUpe3Rocm93IGV9LGY6aX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBzLHU9ITAsYT0hMTtyZXR1cm57czpmdW5jdGlvbigpe249bi5jYWxsKGUpfSxuOmZ1bmN0aW9uKCl7dmFyIGU9bi5uZXh0KCk7cmV0dXJuIHU9ZS5kb25lLGV9LGU6ZnVuY3Rpb24oZSl7YT0hMCxzPWV9LGY6ZnVuY3Rpb24oKXt0cnl7dXx8bnVsbD09bi5yZXR1cm58fG4ucmV0dXJuKCl9ZmluYWxseXtpZihhKXRocm93IHN9fX19KG4ua2V5cyk7dHJ5e2ZvcihsLnMoKTshKGM9bC5uKCkpLmRvbmU7KWEoYy52YWx1ZSl9Y2F0Y2goZSl7bC5lKGUpfWZpbmFsbHl7bC5mKCl9fWVsc2UgYSgpfSkpLG4uZmlsdGVyJiYoaT1uLmZpbHRlcihpKSk7dmFyIHM9aS5zbGljZSgwLHQucmVzdWx0c0xpc3QubWF4UmVzdWx0cyk7dC5mZWVkYmFjaz17cXVlcnk6ZSxtYXRjaGVzOmkscmVzdWx0czpzfSxmKFwicmVzdWx0c1wiLHQpfSxtPVwiYXJpYS1leHBhbmRlZFwiLGI9XCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIix5PVwiYXJpYS1zZWxlY3RlZFwiLHY9ZnVuY3Rpb24oZSxuKXtlLmZlZWRiYWNrLnNlbGVjdGlvbj10KHtpbmRleDpufSxlLmZlZWRiYWNrLnJlc3VsdHNbbl0pfSxnPWZ1bmN0aW9uKGUpe2UuaXNPcGVufHwoKGUud3JhcHBlcnx8ZS5pbnB1dCkuc2V0QXR0cmlidXRlKG0sITApLGUubGlzdC5yZW1vdmVBdHRyaWJ1dGUoXCJoaWRkZW5cIiksZS5pc09wZW49ITAsZihcIm9wZW5cIixlKSl9LHc9ZnVuY3Rpb24oZSl7ZS5pc09wZW4mJigoZS53cmFwcGVyfHxlLmlucHV0KS5zZXRBdHRyaWJ1dGUobSwhMSksZS5pbnB1dC5zZXRBdHRyaWJ1dGUoYixcIlwiKSxlLmxpc3Quc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsXCJcIiksZS5pc09wZW49ITEsZihcImNsb3NlXCIsZSkpfSxPPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5yZXN1bHRJdGVtLHI9dC5saXN0LmdldEVsZW1lbnRzQnlUYWdOYW1lKG4udGFnKSxvPSEhbi5zZWxlY3RlZCYmbi5zZWxlY3RlZC5zcGxpdChcIiBcIik7aWYodC5pc09wZW4mJnIubGVuZ3RoKXt2YXIgcyx1LGE9dC5jdXJzb3I7ZT49ci5sZW5ndGgmJihlPTApLGU8MCYmKGU9ci5sZW5ndGgtMSksdC5jdXJzb3I9ZSxhPi0xJiYoclthXS5yZW1vdmVBdHRyaWJ1dGUoeSksbyYmKHU9clthXS5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseSh1LGkobykpKSxyW2VdLnNldEF0dHJpYnV0ZSh5LCEwKSxvJiYocz1yW2VdLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHMsaShvKSksdC5pbnB1dC5zZXRBdHRyaWJ1dGUoYixyW3QuY3Vyc29yXS5pZCksdC5saXN0LnNjcm9sbFRvcD1yW2VdLm9mZnNldFRvcC10Lmxpc3QuY2xpZW50SGVpZ2h0K3JbZV0uY2xpZW50SGVpZ2h0KzUsdC5mZWVkYmFjay5jdXJzb3I9dC5jdXJzb3Isdih0LGUpLGYoXCJuYXZpZ2F0ZVwiLHQpfX0sQT1mdW5jdGlvbihlKXtPKGUuY3Vyc29yKzEsZSl9LGs9ZnVuY3Rpb24oZSl7TyhlLmN1cnNvci0xLGUpfSxMPWZ1bmN0aW9uKGUsdCxuKXsobj1uPj0wP246ZS5jdXJzb3IpPDB8fChlLmZlZWRiYWNrLmV2ZW50PXQsdihlLG4pLGYoXCJzZWxlY3Rpb25cIixlKSx3KGUpKX07ZnVuY3Rpb24gaihlLG4pe3ZhciByPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLG8pe3ZhciBzLHU7cmV0dXJuIHM9bnx8KCh1PWUuaW5wdXQpaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50fHx1IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudD91LnZhbHVlOnUuaW5uZXJIVE1MKSxmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ/dChlKTplLmxlbmd0aD49bn0ocz1lLnF1ZXJ5P2UucXVlcnkocyk6cyxlLnRyaWdnZXIsZS50aHJlc2hvbGQpP2QoZSxzKS50aGVuKChmdW5jdGlvbihuKXt0cnl7cmV0dXJuIGUuZmVlZGJhY2sgaW5zdGFuY2VvZiBFcnJvcj9pKCk6KGgocyxlKSxlLnJlc3VsdHNMaXN0JiZmdW5jdGlvbihlKXt2YXIgbj1lLnJlc3VsdHNMaXN0LHI9ZS5saXN0LGk9ZS5yZXN1bHRJdGVtLG89ZS5mZWVkYmFjayxzPW8ubWF0Y2hlcyx1PW8ucmVzdWx0cztpZihlLmN1cnNvcj0tMSxyLmlubmVySFRNTD1cIlwiLHMubGVuZ3RofHxuLm5vUmVzdWx0cyl7dmFyIGM9bmV3IERvY3VtZW50RnJhZ21lbnQ7dS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe3ZhciByPWEoaS50YWcsdCh7aWQ6XCJcIi5jb25jYXQoaS5pZCxcIl9cIikuY29uY2F0KG4pLHJvbGU6XCJvcHRpb25cIixpbm5lckhUTUw6ZS5tYXRjaCxpbnNpZGU6Y30saS5jbGFzcyYme2NsYXNzOmkuY2xhc3N9KSk7aS5lbGVtZW50JiZpLmVsZW1lbnQocixlKX0pKSxyLmFwcGVuZChjKSxuLmVsZW1lbnQmJm4uZWxlbWVudChyLG8pLGcoZSl9ZWxzZSB3KGUpfShlKSxjLmNhbGwocikpfWNhdGNoKGUpe3JldHVybiBvKGUpfX0pLG8pOih3KGUpLGMuY2FsbChyKSk7ZnVuY3Rpb24gYygpe3JldHVybiBpKCl9fSkpfXZhciBTPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIGUpZm9yKHZhciByIGluIGVbbl0pdChuLHIpfSxUPWZ1bmN0aW9uKGUpe3ZhciBuLHIsaSxvPWUuZXZlbnRzLHM9KG49ZnVuY3Rpb24oKXtyZXR1cm4gaihlKX0scj1lLmRlYm91bmNlLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkscil9KSx1PWUuZXZlbnRzPXQoe2lucHV0OnQoe30sbyYmby5pbnB1dCl9LGUucmVzdWx0c0xpc3QmJntsaXN0Om8/dCh7fSxvLmxpc3QpOnt9fSksYT17aW5wdXQ6e2lucHV0OmZ1bmN0aW9uKCl7cygpfSxrZXlkb3duOmZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlLHQpe3N3aXRjaChlLmtleUNvZGUpe2Nhc2UgNDA6Y2FzZSAzODplLnByZXZlbnREZWZhdWx0KCksNDA9PT1lLmtleUNvZGU/QSh0KTprKHQpO2JyZWFrO2Nhc2UgMTM6dC5zdWJtaXR8fGUucHJldmVudERlZmF1bHQoKSx0LmN1cnNvcj49MCYmTCh0LGUpO2JyZWFrO2Nhc2UgOTp0LnJlc3VsdHNMaXN0LnRhYlNlbGVjdCYmdC5jdXJzb3I+PTAmJkwodCxlKTticmVhaztjYXNlIDI3OnQuaW5wdXQudmFsdWU9XCJcIix3KHQpfX0odCxlKX0sYmx1cjpmdW5jdGlvbigpe3coZSl9fSxsaXN0Onttb3VzZWRvd246ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpfSxjbGljazpmdW5jdGlvbih0KXshZnVuY3Rpb24oZSx0KXt2YXIgbj10LnJlc3VsdEl0ZW0udGFnLnRvVXBwZXJDYXNlKCkscj1BcnJheS5mcm9tKHQubGlzdC5xdWVyeVNlbGVjdG9yQWxsKG4pKSxpPWUudGFyZ2V0LmNsb3Nlc3Qobik7aSYmaS5ub2RlTmFtZT09PW4mJkwodCxlLHIuaW5kZXhPZihpKSl9KHQsZSl9fX07UyhhLChmdW5jdGlvbih0LG4peyhlLnJlc3VsdHNMaXN0fHxcImlucHV0XCI9PT1uKSYmKHVbdF1bbl18fCh1W3RdW25dPWFbdF1bbl0pKX0pKSxTKHUsKGZ1bmN0aW9uKHQsbil7ZVt0XS5hZGRFdmVudExpc3RlbmVyKG4sdVt0XVtuXSl9KSl9O2Z1bmN0aW9uIEUoZSl7dmFyIG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsaSl7dmFyIG8scyx1O2lmKG89ZS5wbGFjZUhvbGRlcix1PXtyb2xlOlwiY29tYm9ib3hcIixcImFyaWEtb3duc1wiOihzPWUucmVzdWx0c0xpc3QpLmlkLFwiYXJpYS1oYXNwb3B1cFwiOiEwLFwiYXJpYS1leHBhbmRlZFwiOiExfSxhKGUuaW5wdXQsdCh0KHtcImFyaWEtY29udHJvbHNcIjpzLmlkLFwiYXJpYS1hdXRvY29tcGxldGVcIjpcImJvdGhcIn0sbyYme3BsYWNlaG9sZGVyOm99KSwhZS53cmFwcGVyJiZ0KHt9LHUpKSksZS53cmFwcGVyJiYoZS53cmFwcGVyPWEoXCJkaXZcIix0KHthcm91bmQ6ZS5pbnB1dCxjbGFzczplLm5hbWUrXCJfd3JhcHBlclwifSx1KSkpLHMmJihlLmxpc3Q9YShzLnRhZyx0KHtkZXN0OltzLmRlc3RpbmF0aW9uLHMucG9zaXRpb25dLGlkOnMuaWQscm9sZTpcImxpc3Rib3hcIixoaWRkZW46XCJoaWRkZW5cIn0scy5jbGFzcyYme2NsYXNzOnMuY2xhc3N9KSkpLFQoZSksZS5kYXRhLmNhY2hlKXJldHVybiBkKGUpLnRoZW4oKGZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gYy5jYWxsKG4pfWNhdGNoKGUpe3JldHVybiBpKGUpfX0pLGkpO2Z1bmN0aW9uIGMoKXtyZXR1cm4gZihcImluaXRcIixlKSxyKCl9cmV0dXJuIGMuY2FsbChuKX0pKX1mdW5jdGlvbiB4KGUpe3ZhciB0PWUucHJvdG90eXBlO3QuaW5pdD1mdW5jdGlvbigpe0UodGhpcyl9LHQuc3RhcnQ9ZnVuY3Rpb24oZSl7aih0aGlzLGUpfSx0LnVuSW5pdD1mdW5jdGlvbigpe2lmKHRoaXMud3JhcHBlcil7dmFyIGU9dGhpcy53cmFwcGVyLnBhcmVudE5vZGU7ZS5pbnNlcnRCZWZvcmUodGhpcy5pbnB1dCx0aGlzLndyYXBwZXIpLGUucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKX12YXIgdDtTKCh0PXRoaXMpLmV2ZW50cywoZnVuY3Rpb24oZSxuKXt0W2VdLnJlbW92ZUV2ZW50TGlzdGVuZXIobix0LmV2ZW50c1tlXVtuXSl9KSl9LHQub3Blbj1mdW5jdGlvbigpe2codGhpcyl9LHQuY2xvc2U9ZnVuY3Rpb24oKXt3KHRoaXMpfSx0LmdvVG89ZnVuY3Rpb24oZSl7TyhlLHRoaXMpfSx0Lm5leHQ9ZnVuY3Rpb24oKXtBKHRoaXMpfSx0LnByZXZpb3VzPWZ1bmN0aW9uKCl7ayh0aGlzKX0sdC5zZWxlY3Q9ZnVuY3Rpb24oZSl7TCh0aGlzLG51bGwsZSl9LHQuc2VhcmNoPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gcChlLHQsbil9fXJldHVybiBmdW5jdGlvbiBlKHQpe3RoaXMub3B0aW9ucz10LHRoaXMuaWQ9ZS5pbnN0YW5jZXM9KGUuaW5zdGFuY2VzfHwwKSsxLHRoaXMubmFtZT1cImF1dG9Db21wbGV0ZVwiLHRoaXMud3JhcHBlcj0xLHRoaXMudGhyZXNob2xkPTEsdGhpcy5kZWJvdW5jZT0wLHRoaXMucmVzdWx0c0xpc3Q9e3Bvc2l0aW9uOlwiYWZ0ZXJlbmRcIix0YWc6XCJ1bFwiLG1heFJlc3VsdHM6NX0sdGhpcy5yZXN1bHRJdGVtPXt0YWc6XCJsaVwifSxmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWUscj1lLm9wdGlvbnMsaT1lLnJlc3VsdHNMaXN0LG89ZS5yZXN1bHRJdGVtO2Zvcih2YXIgcyBpbiByKWlmKFwib2JqZWN0XCI9PT1uKHJbc10pKWZvcih2YXIgYSBpbiBlW3NdfHwoZVtzXT17fSkscltzXSllW3NdW2FdPXJbc11bYV07ZWxzZSBlW3NdPXJbc107ZS5zZWxlY3Rvcj1lLnNlbGVjdG9yfHxcIiNcIit0LGkuZGVzdGluYXRpb249aS5kZXN0aW5hdGlvbnx8ZS5zZWxlY3RvcixpLmlkPWkuaWR8fHQrXCJfbGlzdF9cIitlLmlkLG8uaWQ9by5pZHx8dCtcIl9yZXN1bHRcIixlLmlucHV0PXUoZS5zZWxlY3Rvcil9KHRoaXMpLHguY2FsbCh0aGlzLGUpLEUodGhpcyl9fSxcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTooZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLmF1dG9Db21wbGV0ZT10KCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8748\n')},5579:function(){eval('var mobileMenu = document.querySelector(".nav__burger-icon ");\nvar mobileMenuList = document.querySelector(".nav__mobile-menu");\nmobileMenu.addEventListener("click", function () {\n  mobileMenu.classList.toggle("active");\n  mobileMenuList.classList.toggle("hidden");\n  if (mobileMenu.classList.contains("active")) {\n    document.body.style.overflow = "hidden";\n  } else {\n    document.body.style.overflow = "auto";\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3OS5qcyIsIm5hbWVzIjpbIm1vYmlsZU1lbnUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb2JpbGVNZW51TGlzdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJjb250YWlucyIsImJvZHkiLCJzdHlsZSIsIm92ZXJmbG93Il0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9qcy9tb2JpbGUtbWVudS5qcz8zNTEyIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBtb2JpbGVNZW51ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5uYXZfX2J1cmdlci1pY29uIFwiKTtcbmxldCBtb2JpbGVNZW51TGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X19tb2JpbGUtbWVudVwiKTtcblxubW9iaWxlTWVudS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICBtb2JpbGVNZW51LmNsYXNzTGlzdC50b2dnbGUoXCJhY3RpdmVcIik7XG4gIG1vYmlsZU1lbnVMaXN0LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIik7XG5cbiAgaWYgKG1vYmlsZU1lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiO1xuICB9XG59KTtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsVUFBVSxHQUFHQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQztBQUM3RCxJQUFJQyxjQUFjLEdBQUdGLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLG1CQUFtQixDQUFDO0FBRWhFRixVQUFVLENBQUNJLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxZQUFNO0VBQ3pDSixVQUFVLENBQUNLLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLFFBQVEsQ0FBQztFQUNyQ0gsY0FBYyxDQUFDRSxTQUFTLENBQUNDLE1BQU0sQ0FBQyxRQUFRLENBQUM7RUFFekMsSUFBSU4sVUFBVSxDQUFDSyxTQUFTLENBQUNFLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtJQUMzQ04sUUFBUSxDQUFDTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsUUFBUSxHQUFHLFFBQVE7RUFDekMsQ0FBQyxNQUFNO0lBQ0xULFFBQVEsQ0FBQ08sSUFBSSxDQUFDQyxLQUFLLENBQUNDLFFBQVEsR0FBRyxNQUFNO0VBQ3ZDO0FBQ0YsQ0FBQyxDQUFDIiwiaWdub3JlTGlzdCI6W119\n//# sourceURL=webpack-internal:///5579\n')},5637:function(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__){"use strict";eval("\n// EXTERNAL MODULE: ./src/html/index.pug\nvar html = __webpack_require__(4278);\n// EXTERNAL MODULE: ./node_modules/@tarekraafat/autocomplete.js/dist/autoComplete.min.js\nvar autoComplete_min = __webpack_require__(8748);\nvar autoComplete_min_default = /*#__PURE__*/__webpack_require__.n(autoComplete_min);\n;// CONCATENATED MODULE: ./src/js/_countres.js\nvar countries = [\"Afghanistan\", \"Albania\", \"Algeria\", \"Andorra\", \"Angola\", \"Antigua and Barbuda\", \"Argentina\", \"Armenia\", \"Australia\", \"Austria\", \"Azerbaijan\", \"Bahamas\", \"Bahrain\", \"Bangladesh\", \"Barbados\", \"Belarus\", \"Belgium\", \"Belize\", \"Benin\", \"Bhutan\", \"Bolivia\", \"Bosnia and Herzegovina\", \"Botswana\", \"Brazil\", \"Brunei\", \"Bulgaria\", \"Burkina Faso\", \"Burundi\", \"Cabo Verde\", \"Cambodia\", \"Cameroon\", \"Canada\", \"Central African Republic\", \"Chad\", \"Chile\", \"China\", \"Colombia\", \"Comoros\", \"Congo (Congo-Brazzaville)\", \"Costa Rica\", \"Cote d'Ivoire\", \"Croatia\", \"Cuba\", \"Cyprus\", \"Czech Republic\", \"Denmark\", \"Djibouti\", \"Dominica\", \"Dominican Republic\", \"East Timor (Timor Timur)\", \"Ecuador\", \"Egypt\", \"El Salvador\", \"Equatorial Guinea\", \"Eritrea\", \"Estonia\", \"Ethiopia\", \"Fiji\", \"Finland\", \"France\", \"Gabon\", \"Gambia\", \"Georgia\", \"Germany\", \"Ghana\", \"Greece\", \"Grenada\", \"Guatemala\", \"Guinea\", \"Guinea-Bissau\", \"Guyana\", \"Haiti\", \"Honduras\", \"Hungary\", \"Iceland\", \"India\", \"Indonesia\", \"Iran\", \"Iraq\", \"Ireland {Republic}\", \"Israel\", \"Italy\", \"Jamaica\", \"Japan\", \"Jordan\", \"Kazakhstan\", \"Kenya\", \"Kiribati\", \"Korea, North\", \"Korea, South\", \"Kosovo\", \"Kuwait\", \"Kyrgyzstan\", \"Laos\", \"Latvia\", \"Lebanon\", \"Lesotho\", \"Liberia\", \"Libya\", \"Liechtenstein\", \"Lithuania\", \"Luxembourg\", \"Macedonia\", \"Madagascar\", \"Malawi\", \"Malaysia\", \"Maldives\", \"Mali\", \"Malta\", \"Marshall Islands\", \"Mauritania\", \"Mauritius\", \"Mexico\", \"Micronesia\", \"Moldova\", \"Monaco\", \"Mongolia\", \"Montenegro\", \"Morocco\", \"Mozambique\", \"Myanmar\", \"Namibia\", \"Nauru\", \"Nepal\", \"Netherlands\", \"New Zealand\", \"Nicaragua\", \"Niger\", \"Nigeria\", \"Norway\", \"Oman\", \"Pakistan\", \"Palau\", \"Panama\", \"Papua New Guinea\", \"Paraguay\", \"Peru\", \"Philippines\", \"Poland\", \"Portugal\", \"Qatar\", \"Romania\", \"Russia\", \"Rwanda\", \"Saint Kitts and Nevis\", \"Saint Lucia\", \"Saint Vincent\", \"Samoa\", \"San Marino\", \"Sao Tome and Principe\", \"Saudi Arabia\", \"Senegal\", \"Serbia\", \"Seychelles\", \"Sierra Leone\", \"Singapore\", \"Slovakia\", \"Slovenia\", \"Solomon Islands\", \"Somalia\", \"South Africa\", \"Spain\", \"Sri Lanka\", \"Sudan\", \"Suriname\", \"Swaziland\", \"Sweden\", \"Switzerland\", \"Syria\", \"Taiwan\", \"Tajikistan\", \"Tanzania\", \"Thailand\", \"Togo\", \"Tonga\", \"Trinidad and Tobago\", \"Tunisia\", \"Turkey\", \"Turkmenistan\", \"Tuvalu\", \"Uganda\", \"Ukraine\", \"United Arab Emirates\", \"United Kingdom\", \"United States\", \"Uruguay\", \"Uzbekistan\", \"Vanuatu\", \"Vatican City\", \"Venezuela\", \"Vietnam\", \"Yemen\", \"Zambia\", \"Zimbabwe\", \"Австралия\", \"Австрия\", \"Азербайджан\", \"Албания\", \"Алжир\", \"Ангола\", \"Аргентина\", \"Армения\", \"Афганистан\", \"Бангладеш\", \"Беларусь\", \"Бельгия\", \"Болгария\", \"Бразилия\", \"Великобритания\", \"Венгрия\", \"Венесуэла\", \"Вьетнам\", \"Гаити\", \"Германия\", \"Греция\", \"Грузия\", \"Дания\", \"Египет\", \"Израиль\", \"Индия\", \"Индонезия\", \"Иордания\", \"Иран\", \"Ирландия\", \"Исландия\", \"Испания\", \"Италия\", \"Казахстан\", \"Камбоджа\", \"Канада\", \"Катар\", \"Кения\", \"Кипр\", \"Китай\", \"Колумбия\", \"Корея (Южная)\", \"Куба\", \"Кувейт\", \"Лаос\", \"Латвия\", \"Ливан\", \"Ливия\", \"Литва\", \"Люксембург\", \"Македония\", \"Малайзия\", \"Мали\", \"Мальта\", \"Марокко\", \"Мексика\", \"Мозамбик\", \"Молдавия\", \"Монако\", \"Монголия\", \"Мьянма\", \"Намибия\", \"Непал\", \"Нигер\", \"Нигерия\", \"Нидерланды\", \"Никарагуа\", \"Новая Зеландия\", \"Норвегия\", \"ОАЭ\", \"Оман\", \"Пакистан\", \"Панама\", \"Парагвай\", \"Перу\", \"Польша\", \"Португалия\", \"Россия\", \"Румыния\", \"Сальвадор\", \"Саудовская Аравия\", \"Сенегал\", \"Сербия\", \"Сингапур\", \"Сирия\", \"Словакия\", \"Словения\", \"США\", \"Таджикистан\", \"Таиланд\", \"Тайвань\", \"Танзания\", \"Тунис\", \"Туркменистан\", \"Турция\", \"Уганда\", \"Узбекистан\", \"Украина\", \"Уругвай\", \"Филиппины\", \"Финляндия\", \"Франция\", \"Хорватия\", \"Черногория\", \"Чехия\", \"Чили\", \"Швейцария\", \"Швеция\", \"Шри-Ланка\", \"Эквадор\", \"Эстония\", \"Эфиопия\", \"ЮАР\", \"Ямайка\", \"Япония\"];\n/* harmony default export */ var _countres = (countries);\n;// CONCATENATED MODULE: ./src/js/autocomplete.js\n\n\nvar autoCompleteJS = new (autoComplete_min_default())({\n  selector: \"#location\",\n  placeHolder: \"e.g Bali, Indonesia\",\n  data: {\n    src: _countres,\n    cache: true\n  },\n  resultItem: {\n    highlight: true\n  },\n  events: {\n    input: {\n      selection: function selection(event) {\n        var selection = event.detail.selection.value;\n        autoCompleteJS.input.value = selection;\n      }\n    }\n  }\n});\n;// CONCATENATED MODULE: ./node_modules/@easepick/bundle/dist/index.esm.js\nclass t extends Date{static parseDateTime(e,i=\"YYYY-MM-DD\",n=\"en-US\"){if(!e)return new Date((new Date).setHours(0,0,0,0));if(e instanceof t)return e.toJSDate();if(e instanceof Date)return e;if(/^-?\\d{10,}$/.test(String(e)))return new Date(Number(e));if(\"string\"==typeof e){const s=[];let o=null;for(;null!=(o=t.regex.exec(i));)\"\\\\\"!==o[1]&&s.push(o);if(s.length){const i={year:null,month:null,shortMonth:null,longMonth:null,day:null,hour:0,minute:0,second:0,ampm:null,value:\"\"};s[0].index>0&&(i.value+=\".*?\");for(const[e,o]of Object.entries(s)){const s=Number(e),{group:a,pattern:r}=t.formatPatterns(o[0],n);i[a]=s+1,i.value+=r,i.value+=\".*?\"}const o=new RegExp(`^${i.value}$`);if(o.test(e)){const s=o.exec(e),a=Number(s[i.year]);let r=null;i.month?r=Number(s[i.month])-1:i.shortMonth?r=t.shortMonths(n).indexOf(s[i.shortMonth]):i.longMonth&&(r=t.longMonths(n).indexOf(s[i.longMonth]));const c=Number(s[i.day])||1,l=Number(s[i.hour]);let h=Number.isNaN(l)?0:l;const d=Number(s[i.minute]),p=Number.isNaN(d)?0:d,u=Number(s[i.second]),g=Number.isNaN(u)?0:u,m=s[i.ampm];return m&&\"PM\"===m&&(h+=12,24===h&&(h=0)),new Date(a,r,c,h,p,g,0)}}}return new Date((new Date).setHours(0,0,0,0))}static regex=/(\\\\)?(Y{2,4}|M{1,4}|D{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|A|a)/g;static MONTH_JS=[0,1,2,3,4,5,6,7,8,9,10,11];static shortMonths(e){return t.MONTH_JS.map((t=>new Date(2019,t).toLocaleString(e,{month:\"short\"})))}static longMonths(e){return t.MONTH_JS.map((t=>new Date(2019,t).toLocaleString(e,{month:\"long\"})))}static formatPatterns(e,i){switch(e){case\"YY\":case\"YYYY\":return{group:\"year\",pattern:`(\\\\d{${e.length}})`};case\"M\":return{group:\"month\",pattern:\"(\\\\d{1,2})\"};case\"MM\":return{group:\"month\",pattern:\"(\\\\d{2})\"};case\"MMM\":return{group:\"shortMonth\",pattern:`(${t.shortMonths(i).join(\"|\")})`};case\"MMMM\":return{group:\"longMonth\",pattern:`(${t.longMonths(i).join(\"|\")})`};case\"D\":return{group:\"day\",pattern:\"(\\\\d{1,2})\"};case\"DD\":return{group:\"day\",pattern:\"(\\\\d{2})\"};case\"h\":case\"H\":return{group:\"hour\",pattern:\"(\\\\d{1,2})\"};case\"hh\":case\"HH\":return{group:\"hour\",pattern:\"(\\\\d{2})\"};case\"m\":return{group:\"minute\",pattern:\"(\\\\d{1,2})\"};case\"mm\":return{group:\"minute\",pattern:\"(\\\\d{2})\"};case\"s\":return{group:\"second\",pattern:\"(\\\\d{1,2})\"};case\"ss\":return{group:\"second\",pattern:\"(\\\\d{2})\"};case\"a\":case\"A\":return{group:\"ampm\",pattern:\"(AM|PM|am|pm)\"}}}lang;constructor(e=null,i=\"YYYY-MM-DD\",n=\"en-US\"){super(t.parseDateTime(e,i,n)),this.lang=n}getWeek(t){const e=new Date(this.midnight_ts(this)),i=(this.getDay()+(7-t))%7;e.setDate(e.getDate()-i);const n=e.getTime();return e.setMonth(0,1),e.getDay()!==t&&e.setMonth(0,1+(4-e.getDay()+7)%7),1+Math.ceil((n-e.getTime())/6048e5)}clone(){return new t(this)}toJSDate(){return new Date(this)}inArray(t,e=\"[]\"){return t.some((t=>t instanceof Array?this.isBetween(t[0],t[1],e):this.isSame(t,\"day\")))}isBetween(t,e,i=\"()\"){switch(i){default:case\"()\":return this.midnight_ts(this)>this.midnight_ts(t)&&this.midnight_ts(this)<this.midnight_ts(e);case\"[)\":return this.midnight_ts(this)>=this.midnight_ts(t)&&this.midnight_ts(this)<this.midnight_ts(e);case\"(]\":return this.midnight_ts(this)>this.midnight_ts(t)&&this.midnight_ts(this)<=this.midnight_ts(e);case\"[]\":return this.midnight_ts()>=this.midnight_ts(t)&&this.midnight_ts()<=this.midnight_ts(e)}}isBefore(t,e=\"days\"){switch(e){case\"day\":case\"days\":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case\"month\":case\"months\":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>new Date(this.getFullYear(),this.getMonth(),1).getTime();case\"year\":case\"years\":return t.getFullYear()>this.getFullYear()}throw new Error(\"isBefore: Invalid unit!\")}isSameOrBefore(t,e=\"days\"){switch(e){case\"day\":case\"days\":return new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()>=new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime();case\"month\":case\"months\":return new Date(t.getFullYear(),t.getMonth(),1).getTime()>=new Date(this.getFullYear(),this.getMonth(),1).getTime()}throw new Error(\"isSameOrBefore: Invalid unit!\")}isAfter(t,e=\"days\"){switch(e){case\"day\":case\"days\":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case\"month\":case\"months\":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>new Date(t.getFullYear(),t.getMonth(),1).getTime();case\"year\":case\"years\":return this.getFullYear()>t.getFullYear()}throw new Error(\"isAfter: Invalid unit!\")}isSameOrAfter(t,e=\"days\"){switch(e){case\"day\":case\"days\":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()>=new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case\"month\":case\"months\":return new Date(this.getFullYear(),this.getMonth(),1).getTime()>=new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error(\"isSameOrAfter: Invalid unit!\")}isSame(t,e=\"days\"){switch(e){case\"day\":case\"days\":return new Date(this.getFullYear(),this.getMonth(),this.getDate()).getTime()===new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime();case\"month\":case\"months\":return new Date(this.getFullYear(),this.getMonth(),1).getTime()===new Date(t.getFullYear(),t.getMonth(),1).getTime()}throw new Error(\"isSame: Invalid unit!\")}add(t,e=\"days\"){switch(e){case\"day\":case\"days\":this.setDate(this.getDate()+t);break;case\"month\":case\"months\":this.setMonth(this.getMonth()+t)}return this}subtract(t,e=\"days\"){switch(e){case\"day\":case\"days\":this.setDate(this.getDate()-t);break;case\"month\":case\"months\":this.setMonth(this.getMonth()-t)}return this}diff(t,e=\"days\"){switch(e){default:case\"day\":case\"days\":return Math.round((this.midnight_ts()-this.midnight_ts(t))/864e5);case\"month\":case\"months\":let e=12*(t.getFullYear()-this.getFullYear());return e-=t.getMonth(),e+=this.getMonth(),e}}format(e,i=\"en-US\"){let n=\"\";const s=[];let o=null;for(;null!=(o=t.regex.exec(e));)\"\\\\\"!==o[1]&&s.push(o);if(s.length){s[0].index>0&&(n+=e.substring(0,s[0].index));for(const[t,o]of Object.entries(s)){const a=Number(t);n+=this.formatTokens(o[0],i),s[a+1]&&(n+=e.substring(o.index+o[0].length,s[a+1].index)),a===s.length-1&&(n+=e.substring(o.index+o[0].length))}}return n.replace(/\\\\/g,\"\")}midnight_ts(t){return t?new Date(t.getFullYear(),t.getMonth(),t.getDate(),0,0,0,0).getTime():new Date(this.getFullYear(),this.getMonth(),this.getDate(),0,0,0,0).getTime()}formatTokens(e,i){switch(e){case\"YY\":return String(this.getFullYear()).slice(-2);case\"YYYY\":return String(this.getFullYear());case\"M\":return String(this.getMonth()+1);case\"MM\":return`0${this.getMonth()+1}`.slice(-2);case\"MMM\":return t.shortMonths(i)[this.getMonth()];case\"MMMM\":return t.longMonths(i)[this.getMonth()];case\"D\":return String(this.getDate());case\"DD\":return`0${this.getDate()}`.slice(-2);case\"H\":return String(this.getHours());case\"HH\":return`0${this.getHours()}`.slice(-2);case\"h\":return String(this.getHours()%12||12);case\"hh\":return`0${this.getHours()%12||12}`.slice(-2);case\"m\":return String(this.getMinutes());case\"mm\":return`0${this.getMinutes()}`.slice(-2);case\"s\":return String(this.getSeconds());case\"ss\":return`0${this.getSeconds()}`.slice(-2);case\"a\":return this.getHours()<12||24===this.getHours()?\"am\":\"pm\";case\"A\":return this.getHours()<12||24===this.getHours()?\"AM\":\"PM\";default:return\"\"}}}class e{picker;constructor(t){this.picker=t}render(e,i){e||(e=new t),e.setDate(1),e.setHours(0,0,0,0),\"function\"==typeof this[`get${i}View`]&&this[`get${i}View`](e)}getContainerView(t){this.picker.ui.container.innerHTML=\"\",this.picker.options.header&&this.picker.trigger(\"render\",{date:t.clone(),view:\"Header\"}),this.picker.trigger(\"render\",{date:t.clone(),view:\"Main\"}),this.picker.options.autoApply||this.picker.trigger(\"render\",{date:t.clone(),view:\"Footer\"})}getHeaderView(t){const e=document.createElement(\"header\");this.picker.options.header instanceof HTMLElement&&e.appendChild(this.picker.options.header),\"string\"==typeof this.picker.options.header&&(e.innerHTML=this.picker.options.header),this.picker.ui.container.appendChild(e),this.picker.trigger(\"view\",{target:e,date:t.clone(),view:\"Header\"})}getMainView(t){const e=document.createElement(\"main\");this.picker.ui.container.appendChild(e);const i=document.createElement(\"div\");i.className=`calendars grid-${this.picker.options.grid}`;for(let e=0;e<this.picker.options.calendars;e++){const n=document.createElement(\"div\");n.className=\"calendar\",i.appendChild(n);const s=this.getCalendarHeaderView(t.clone());n.appendChild(s),this.picker.trigger(\"view\",{date:t.clone(),view:\"CalendarHeader\",index:e,target:s});const o=this.getCalendarDayNamesView();n.appendChild(o),this.picker.trigger(\"view\",{date:t.clone(),view:\"CalendarDayNames\",index:e,target:o});const a=this.getCalendarDaysView(t.clone());n.appendChild(a),this.picker.trigger(\"view\",{date:t.clone(),view:\"CalendarDays\",index:e,target:a});const r=this.getCalendarFooterView(this.picker.options.lang,t.clone());n.appendChild(r),this.picker.trigger(\"view\",{date:t.clone(),view:\"CalendarFooter\",index:e,target:r}),this.picker.trigger(\"view\",{date:t.clone(),view:\"CalendarItem\",index:e,target:n}),t.add(1,\"month\")}e.appendChild(i),this.picker.trigger(\"view\",{date:t.clone(),view:\"Calendars\",target:i}),this.picker.trigger(\"view\",{date:t.clone(),view:\"Main\",target:e})}getFooterView(t){const e=document.createElement(\"footer\"),i=document.createElement(\"div\");i.className=\"footer-buttons\";const n=document.createElement(\"button\");n.className=\"cancel-button unit\",n.innerHTML=this.picker.options.locale.cancel,i.appendChild(n);const s=document.createElement(\"button\");s.className=\"apply-button unit\",s.innerHTML=this.picker.options.locale.apply,s.disabled=!0,i.appendChild(s),e.appendChild(i),this.picker.ui.container.appendChild(e),this.picker.trigger(\"view\",{date:t,target:e,view:\"Footer\"})}getCalendarHeaderView(t){const e=document.createElement(\"div\");e.className=\"header\";const i=document.createElement(\"div\");i.className=\"month-name\",i.innerHTML=`<span>${t.toLocaleString(this.picker.options.lang,{month:\"long\"})}</span> ${t.format(\"YYYY\")}`,e.appendChild(i);const n=document.createElement(\"button\");n.className=\"previous-button unit\",n.innerHTML=this.picker.options.locale.previousMonth,e.appendChild(n);const s=document.createElement(\"button\");return s.className=\"next-button unit\",s.innerHTML=this.picker.options.locale.nextMonth,e.appendChild(s),e}getCalendarDayNamesView(){const t=document.createElement(\"div\");t.className=\"daynames-row\";for(let e=1;e<=7;e++){const i=3+this.picker.options.firstDay+e,n=document.createElement(\"div\");n.className=\"dayname\",n.innerHTML=new Date(1970,0,i,12,0,0,0).toLocaleString(this.picker.options.lang,{weekday:\"short\"}),n.title=new Date(1970,0,i,12,0,0,0).toLocaleString(this.picker.options.lang,{weekday:\"long\"}),t.appendChild(n),this.picker.trigger(\"view\",{dayIdx:i,view:\"CalendarDayName\",target:n})}return t}getCalendarDaysView(t){const e=document.createElement(\"div\");e.className=\"days-grid\";const i=this.calcOffsetDays(t,this.picker.options.firstDay),n=32-new Date(t.getFullYear(),t.getMonth(),32).getDate();for(let t=0;t<i;t++){const t=document.createElement(\"div\");t.className=\"offset\",e.appendChild(t)}for(let i=1;i<=n;i++){t.setDate(i);const n=this.getCalendarDayView(t);e.appendChild(n),this.picker.trigger(\"view\",{date:t,view:\"CalendarDay\",target:n})}return e}getCalendarDayView(e){const i=this.picker.options.date?new t(this.picker.options.date):null,n=new t,s=document.createElement(\"div\");return s.className=\"day unit\",s.innerHTML=e.format(\"D\"),s.dataset.time=String(e.getTime()),e.isSame(n,\"day\")&&s.classList.add(\"today\"),[0,6].includes(e.getDay())&&s.classList.add(\"weekend\"),this.picker.datePicked.length?this.picker.datePicked[0].isSame(e,\"day\")&&s.classList.add(\"selected\"):i&&e.isSame(i,\"day\")&&s.classList.add(\"selected\"),this.picker.trigger(\"view\",{date:e,view:\"CalendarDay\",target:s}),s}getCalendarFooterView(t,e){const i=document.createElement(\"div\");return i.className=\"footer\",i}calcOffsetDays(t,e){let i=t.getDay()-e;return i<0&&(i+=7),i}}class i{picker;instances={};constructor(t){this.picker=t}initialize(){const t=[];this.picker.options.plugins.forEach((e=>{\"function\"==typeof e?t.push(new e):\"string\"==typeof e&&\"undefined\"!=typeof easepick&&Object.prototype.hasOwnProperty.call(easepick,e)?t.push(new easepick[e]):console.warn(`easepick: ${e} not found.`)})),t.sort(((t,e)=>t.priority>e.priority?-1:t.priority<e.priority||t.dependencies.length>e.dependencies.length?1:t.dependencies.length<e.dependencies.length?-1:0)),t.forEach((t=>{t.attach(this.picker),this.instances[t.getName()]=t}))}getInstance(t){return this.instances[t]}addInstance(t){if(Object.prototype.hasOwnProperty.call(this.instances,t))console.warn(`easepick: ${t} already added.`);else{if(\"undefined\"!=typeof easepick&&Object.prototype.hasOwnProperty.call(easepick,t)){const e=new easepick[t];return e.attach(this.picker),this.instances[e.getName()]=e,e}if(\"undefined\"!==this.getPluginFn(t)){const e=new(this.getPluginFn(t));return e.attach(this.picker),this.instances[e.getName()]=e,e}console.warn(`easepick: ${t} not found.`)}return null}removeInstance(t){return t in this.instances&&this.instances[t].detach(),delete this.instances[t]}reloadInstance(t){return this.removeInstance(t),this.addInstance(t)}getPluginFn(t){return[...this.picker.options.plugins].filter((e=>\"function\"==typeof e&&(new e).getName()===t)).shift()}}class n{Calendar=new e(this);PluginManager=new i(this);calendars=[];datePicked=[];cssLoaded=0;binds={hidePicker:this.hidePicker.bind(this),show:this.show.bind(this)};options={doc:document,css:[],element:null,firstDay:1,grid:1,calendars:1,lang:\"en-US\",date:null,format:\"YYYY-MM-DD\",readonly:!0,autoApply:!0,header:!1,inline:!1,scrollToDate:!0,locale:{nextMonth:'<svg width=\"11\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.748 16L0 13.333 5.333 8 0 2.667 2.748 0l7.919 8z\" fill-rule=\"nonzero\"/></svg>',previousMonth:'<svg width=\"11\" height=\"16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.919 0l2.748 2.667L5.333 8l5.334 5.333L7.919 16 0 8z\" fill-rule=\"nonzero\"/></svg>',cancel:\"Cancel\",apply:\"Apply\"},documentClick:this.binds.hidePicker,plugins:[]};ui={container:null,shadowRoot:null,wrapper:null};version=\"1.2.1\";constructor(t){const e={...this.options.locale,...t.locale};this.options={...this.options,...t},this.options.locale=e,this.handleOptions(),this.ui.wrapper=document.createElement(\"span\"),this.ui.wrapper.style.display=\"none\",this.ui.wrapper.style.position=\"absolute\",this.ui.wrapper.style.pointerEvents=\"none\",this.ui.wrapper.className=\"easepick-wrapper\",this.ui.wrapper.attachShadow({mode:\"open\"}),this.ui.shadowRoot=this.ui.wrapper.shadowRoot,this.ui.container=document.createElement(\"div\"),this.ui.container.className=\"container\",this.options.zIndex&&(this.ui.container.style.zIndex=String(this.options.zIndex)),this.options.inline&&(this.ui.wrapper.style.position=\"relative\",this.ui.container.classList.add(\"inline\")),this.ui.shadowRoot.appendChild(this.ui.container),this.options.element.after(this.ui.wrapper),this.handleCSS(),this.options.element.addEventListener(\"click\",this.binds.show),this.on(\"view\",this.onView.bind(this)),this.on(\"render\",this.onRender.bind(this)),this.PluginManager.initialize(),this.parseValues(),\"function\"==typeof this.options.setup&&this.options.setup(this),this.on(\"click\",this.onClick.bind(this));const i=this.options.scrollToDate?this.getDate():null;this.renderAll(i)}on(t,e,i={}){this.ui.container.addEventListener(t,e,i)}off(t,e,i={}){this.ui.container.removeEventListener(t,e,i)}trigger(t,e={}){return this.ui.container.dispatchEvent(new CustomEvent(t,{detail:e}))}destroy(){this.options.element.removeEventListener(\"click\",this.binds.show),\"function\"==typeof this.options.documentClick&&document.removeEventListener(\"click\",this.options.documentClick,!0),Object.keys(this.PluginManager.instances).forEach((t=>{this.PluginManager.removeInstance(t)})),this.ui.wrapper.remove()}onRender(t){const{view:e,date:i}=t.detail;this.Calendar.render(i,e)}onView(t){const{view:e,target:i}=t.detail;\"Footer\"===e&&this.datePicked.length&&(i.querySelector(\".apply-button\").disabled=!1)}onClickHeaderButton(t){this.isCalendarHeaderButton(t)&&(t.classList.contains(\"next-button\")?this.calendars[0].add(1,\"month\"):this.calendars[0].subtract(1,\"month\"),this.renderAll(this.calendars[0]))}onClickCalendarDay(e){if(this.isCalendarDay(e)){const i=new t(e.dataset.time);this.options.autoApply?(this.setDate(i),this.trigger(\"select\",{date:this.getDate()}),this.hide()):(this.datePicked[0]=i,this.trigger(\"preselect\",{date:this.getDate()}),this.renderAll())}}onClickApplyButton(t){if(this.isApplyButton(t)){if(this.datePicked[0]instanceof Date){const t=this.datePicked[0].clone();this.setDate(t)}this.hide(),this.trigger(\"select\",{date:this.getDate()})}}onClickCancelButton(t){this.isCancelButton(t)&&this.hide()}onClick(t){const e=t.target;if(e instanceof HTMLElement){const t=e.closest(\".unit\");if(!(t instanceof HTMLElement))return;this.onClickHeaderButton(t),this.onClickCalendarDay(t),this.onClickApplyButton(t),this.onClickCancelButton(t)}}isShown(){return this.ui.container.classList.contains(\"inline\")||this.ui.container.classList.contains(\"show\")}show(t){if(this.isShown())return;const e=t&&\"target\"in t?t.target:this.options.element,{top:i,left:n}=this.adjustPosition(e);this.ui.container.style.top=`${i}px`,this.ui.container.style.left=`${n}px`,this.ui.container.classList.add(\"show\"),this.trigger(\"show\",{target:e})}hide(){this.ui.container.classList.remove(\"show\"),this.datePicked.length=0,this.renderAll(),this.trigger(\"hide\")}setDate(e){const i=new t(e,this.options.format);this.options.date=i.clone(),this.updateValues(),this.calendars.length&&this.renderAll()}getDate(){return this.options.date instanceof t?this.options.date.clone():null}parseValues(){this.options.date?this.setDate(this.options.date):this.options.element instanceof HTMLInputElement&&this.options.element.value.length&&this.setDate(this.options.element.value),this.options.date instanceof Date||(this.options.date=null)}updateValues(){const t=this.getDate(),e=t instanceof Date?t.format(this.options.format,this.options.lang):\"\",i=this.options.element;i instanceof HTMLInputElement?i.value=e:i instanceof HTMLElement&&(i.innerText=e)}hidePicker(t){let e=t.target,i=null;e.shadowRoot&&(e=t.composedPath()[0],i=e.getRootNode().host),this.isShown()&&i!==this.ui.wrapper&&e!==this.options.element&&this.hide()}renderAll(t){this.trigger(\"render\",{view:\"Container\",date:(t||this.calendars[0]).clone()})}isCalendarHeaderButton(t){return[\"previous-button\",\"next-button\"].some((e=>t.classList.contains(e)))}isCalendarDay(t){return t.classList.contains(\"day\")}isApplyButton(t){return t.classList.contains(\"apply-button\")}isCancelButton(t){return t.classList.contains(\"cancel-button\")}gotoDate(e){const i=new t(e,this.options.format);i.setDate(1),this.calendars[0]=i.clone(),this.renderAll()}clear(){this.options.date=null,this.datePicked.length=0,this.updateValues(),this.renderAll(),this.trigger(\"clear\")}handleOptions(){this.options.element instanceof HTMLElement||(this.options.element=this.options.doc.querySelector(this.options.element)),\"function\"==typeof this.options.documentClick&&document.addEventListener(\"click\",this.options.documentClick,!0),this.options.element instanceof HTMLInputElement&&(this.options.element.readOnly=this.options.readonly),this.options.date?this.calendars[0]=new t(this.options.date,this.options.format):this.calendars[0]=new t}handleCSS(){if(Array.isArray(this.options.css))this.options.css.forEach((t=>{const e=document.createElement(\"link\");e.href=t,e.rel=\"stylesheet\";const i=()=>{this.cssLoaded++,this.cssLoaded===this.options.css.length&&(this.ui.wrapper.style.display=\"\")};e.addEventListener(\"load\",i),e.addEventListener(\"error\",i),this.ui.shadowRoot.append(e)}));else if(\"string\"==typeof this.options.css){const t=document.createElement(\"style\"),e=document.createTextNode(this.options.css);t.appendChild(e),this.ui.shadowRoot.append(t),this.ui.wrapper.style.display=\"\"}else\"function\"==typeof this.options.css&&(this.options.css.call(this,this),this.ui.wrapper.style.display=\"\")}adjustPosition(t){const e=t.getBoundingClientRect(),i=this.ui.wrapper.getBoundingClientRect();this.ui.container.classList.add(\"calc\");const n=this.ui.container.getBoundingClientRect();this.ui.container.classList.remove(\"calc\");let s=e.bottom-i.bottom,o=e.left-i.left;return\"undefined\"!=typeof window&&(window.innerHeight<s+n.height&&s-n.height>=0&&(s=e.top-i.top-n.height),window.innerWidth<o+n.width&&e.right-n.width>=0&&(o=e.right-i.right-n.width)),{left:o,top:s}}}var s=Object.freeze({__proto__:null,Core:n,create:n});class o{picker;options;priority=0;dependencies=[];attach(t){const e=this.getName(),i={...this.options};this.options={...this.options,...t.options[e]||{}};for(const n of Object.keys(i))if(null!==i[n]&&\"object\"==typeof i[n]&&Object.keys(i[n]).length&&e in t.options&&n in t.options[e]){const s={...t.options[e][n]};null!==s&&\"object\"==typeof s&&Object.keys(s).length&&Object.keys(s).every((t=>Object.keys(i[n]).includes(t)))&&(this.options[n]={...i[n],...s})}if(this.picker=t,this.dependenciesNotFound()){const t=this.dependencies.filter((t=>!this.pluginsAsStringArray().includes(t)));return void console.warn(`${this.getName()}: required dependencies (${t.join(\", \")}).`)}const n=this.camelCaseToKebab(this.getName());this.picker.ui.container.classList.add(n),this.onAttach()}detach(){const t=this.camelCaseToKebab(this.getName());this.picker.ui.container.classList.remove(t),\"function\"==typeof this.onDetach&&this.onDetach()}dependenciesNotFound(){return this.dependencies.length&&!this.dependencies.every((t=>this.pluginsAsStringArray().includes(t)))}pluginsAsStringArray(){return this.picker.options.plugins.map((t=>\"function\"==typeof t?(new t).getName():t))}camelCaseToKebab(t){return t.replace(/([a-zA-Z])(?=[A-Z])/g,\"$1-\").toLowerCase()}}class a extends (/* unused pure expression or super */ null && (o)){priority=1;binds={onView:this.onView.bind(this)};options={minDate:null,maxDate:null,minDays:null,maxDays:null,selectForward:null,selectBackward:null,presets:!0,inseparable:!1,filter:null};getName(){return\"LockPlugin\"}onAttach(){if(this.options.minDate&&(this.options.minDate=new t(this.options.minDate,this.picker.options.format,this.picker.options.lang)),this.options.maxDate&&(this.options.maxDate=new t(this.options.maxDate,this.picker.options.format,this.picker.options.lang),this.options.maxDate instanceof t&&this.picker.options.calendars>1&&this.picker.calendars[0].isSame(this.options.maxDate,\"month\"))){const t=this.picker.calendars[0].clone().subtract(1,\"month\");this.picker.gotoDate(t)}if((this.options.minDays||this.options.maxDays||this.options.selectForward||this.options.selectBackward)&&!this.picker.options.plugins.includes(\"RangePlugin\")){const t=[\"minDays\",\"maxDays\",\"selectForward\",\"selectBackward\"];console.warn(`${this.getName()}: options ${t.join(\", \")} required RangePlugin.`)}this.picker.on(\"view\",this.binds.onView)}onDetach(){this.picker.off(\"view\",this.binds.onView)}onView(e){const{view:i,target:n,date:s}=e.detail;if(\"CalendarHeader\"===i&&(this.options.minDate instanceof t&&s.isSameOrBefore(this.options.minDate,\"month\")&&n.classList.add(\"no-previous-month\"),this.options.maxDate instanceof t&&s.isSameOrAfter(this.options.maxDate,\"month\")&&n.classList.add(\"no-next-month\")),\"CalendarDay\"===i){const t=this.picker.datePicked.length?this.picker.datePicked[0]:null;if(this.testFilter(s))return void n.classList.add(\"locked\");if(this.options.inseparable){if(this.options.minDays){const t=s.clone().subtract(this.options.minDays-1,\"day\"),e=s.clone().add(this.options.minDays-1,\"day\");let i=!1,o=!1;for(;t.isBefore(s,\"day\");){if(this.testFilter(t)){i=!0;break}t.add(1,\"day\")}for(;e.isAfter(s,\"day\");){if(this.testFilter(e)){o=!0;break}e.subtract(1,\"day\")}i&&o&&n.classList.add(\"not-available\")}this.rangeIsNotAvailable(s,t)&&n.classList.add(\"not-available\")}this.dateIsNotAvailable(s,t)&&n.classList.add(\"not-available\")}if(this.options.presets&&\"PresetPluginButton\"===i){const e=new t(Number(n.dataset.start)),i=new t(Number(n.dataset.end)),s=i.diff(e,\"day\"),o=this.options.minDays&&s<this.options.minDays,a=this.options.maxDays&&s>this.options.maxDays;(o||a||this.lockMinDate(e)||this.lockMaxDate(e)||this.lockMinDate(i)||this.lockMaxDate(i)||this.rangeIsNotAvailable(e,i))&&n.setAttribute(\"disabled\",\"disabled\")}}dateIsNotAvailable(t,e){return this.lockMinDate(t)||this.lockMaxDate(t)||this.lockMinDays(t,e)||this.lockMaxDays(t,e)||this.lockSelectForward(t)||this.lockSelectBackward(t)}rangeIsNotAvailable(t,e){if(!t||!e)return!1;const i=(t.isSameOrBefore(e,\"day\")?t:e).clone(),n=(e.isSameOrAfter(t,\"day\")?e:t).clone();for(;i.isSameOrBefore(n,\"day\");){if(this.testFilter(i))return!0;i.add(1,\"day\")}return!1}lockMinDate(e){return this.options.minDate instanceof t&&e.isBefore(this.options.minDate,\"day\")}lockMaxDate(e){return this.options.maxDate instanceof t&&e.isAfter(this.options.maxDate,\"day\")}lockMinDays(t,e){if(this.options.minDays&&e){const i=e.clone().subtract(this.options.minDays-1,\"day\"),n=e.clone().add(this.options.minDays-1,\"day\");return t.isBetween(i,n)}return!1}lockMaxDays(t,e){if(this.options.maxDays&&e){const i=e.clone().subtract(this.options.maxDays,\"day\"),n=e.clone().add(this.options.maxDays,\"day\");return!t.isBetween(i,n)}return!1}lockSelectForward(t){if(1===this.picker.datePicked.length&&this.options.selectForward){const e=this.picker.datePicked[0].clone();return t.isBefore(e,\"day\")}return!1}lockSelectBackward(t){if(1===this.picker.datePicked.length&&this.options.selectBackward){const e=this.picker.datePicked[0].clone();return t.isAfter(e,\"day\")}return!1}testFilter(t){return\"function\"==typeof this.options.filter&&this.options.filter(t,this.picker.datePicked)}}class r extends (/* unused pure expression or super */ null && (o)){dependencies=[\"RangePlugin\"];binds={onView:this.onView.bind(this),onClick:this.onClick.bind(this)};options={customLabels:[\"Today\",\"Yesterday\",\"Last 7 Days\",\"Last 30 Days\",\"This Month\",\"Last Month\"],customPreset:{},position:\"left\"};getName(){return\"PresetPlugin\"}onAttach(){if(!Object.keys(this.options.customPreset).length){const e=new t,i=()=>{const i=e.clone();i.setDate(1);const n=new Date(e.getFullYear(),e.getMonth()+1,0);return[new t(i),new t(n)]},n=()=>{const i=e.clone();i.setMonth(i.getMonth()-1),i.setDate(1);const n=new Date(e.getFullYear(),e.getMonth(),0);return[new t(i),new t(n)]},s=[[e.clone(),e.clone()],[e.clone().subtract(1,\"day\"),e.clone().subtract(1,\"day\")],[e.clone().subtract(6,\"day\"),e.clone()],[e.clone().subtract(29,\"day\"),e.clone()],i(),n()];Object.values(this.options.customLabels).forEach(((t,e)=>{this.options.customPreset[t]=s[e]}))}this.picker.on(\"view\",this.binds.onView),this.picker.on(\"click\",this.binds.onClick)}onDetach(){this.picker.off(\"view\",this.binds.onView),this.picker.off(\"click\",this.binds.onClick)}onView(t){const{view:e,target:i}=t.detail;if(\"Main\"===e){const t=document.createElement(\"div\");t.className=\"preset-plugin-container\",Object.keys(this.options.customPreset).forEach((e=>{if(Object.prototype.hasOwnProperty.call(this.options.customPreset,e)){const i=this.options.customPreset[e],n=document.createElement(\"button\");n.className=\"preset-button unit\",n.innerHTML=e,n.dataset.start=i[0].getTime(),n.dataset.end=i[1].getTime(),t.appendChild(n),this.picker.trigger(\"view\",{view:\"PresetPluginButton\",target:n})}})),i.appendChild(t),i.classList.add(`preset-${this.options.position}`),this.picker.trigger(\"view\",{view:\"PresetPluginContainer\",target:t})}}onClick(e){const i=e.target;if(i instanceof HTMLElement){const e=i.closest(\".unit\");if(!(e instanceof HTMLElement))return;if(this.isPresetButton(e)){const i=new t(Number(e.dataset.start)),n=new t(Number(e.dataset.end));this.picker.options.autoApply?(this.picker.setDateRange(i,n),this.picker.trigger(\"select\",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide()):(this.picker.datePicked=[i,n],this.picker.renderAll())}}}isPresetButton(t){return t.classList.contains(\"preset-button\")}}class c extends (/* unused pure expression or super */ null && (o)){tooltipElement;triggerElement;binds={setStartDate:this.setStartDate.bind(this),setEndDate:this.setEndDate.bind(this),setDateRange:this.setDateRange.bind(this),getStartDate:this.getStartDate.bind(this),getEndDate:this.getEndDate.bind(this),onView:this.onView.bind(this),onShow:this.onShow.bind(this),onMouseEnter:this.onMouseEnter.bind(this),onMouseLeave:this.onMouseLeave.bind(this),onClickCalendarDay:this.onClickCalendarDay.bind(this),onClickApplyButton:this.onClickApplyButton.bind(this),parseValues:this.parseValues.bind(this),updateValues:this.updateValues.bind(this),clear:this.clear.bind(this)};options={elementEnd:null,startDate:null,endDate:null,repick:!1,strict:!0,delimiter:\" - \",tooltip:!0,tooltipNumber:t=>t,locale:{zero:\"\",one:\"day\",two:\"\",few:\"\",many:\"\",other:\"days\"},documentClick:this.hidePicker.bind(this)};getName(){return\"RangePlugin\"}onAttach(){this.binds._setStartDate=this.picker.setStartDate,this.binds._setEndDate=this.picker.setEndDate,this.binds._setDateRange=this.picker.setDateRange,this.binds._getStartDate=this.picker.getStartDate,this.binds._getEndDate=this.picker.getEndDate,this.binds._parseValues=this.picker.parseValues,this.binds._updateValues=this.picker.updateValues,this.binds._clear=this.picker.clear,this.binds._onClickCalendarDay=this.picker.onClickCalendarDay,this.binds._onClickApplyButton=this.picker.onClickApplyButton,Object.defineProperties(this.picker,{setStartDate:{configurable:!0,value:this.binds.setStartDate},setEndDate:{configurable:!0,value:this.binds.setEndDate},setDateRange:{configurable:!0,value:this.binds.setDateRange},getStartDate:{configurable:!0,value:this.binds.getStartDate},getEndDate:{configurable:!0,value:this.binds.getEndDate},parseValues:{configurable:!0,value:this.binds.parseValues},updateValues:{configurable:!0,value:this.binds.updateValues},clear:{configurable:!0,value:this.binds.clear},onClickCalendarDay:{configurable:!0,value:this.binds.onClickCalendarDay},onClickApplyButton:{configurable:!0,value:this.binds.onClickApplyButton}}),this.options.elementEnd&&(this.options.elementEnd instanceof HTMLElement||(this.options.elementEnd=this.picker.options.doc.querySelector(this.options.elementEnd)),this.options.elementEnd instanceof HTMLInputElement&&(this.options.elementEnd.readOnly=this.picker.options.readonly),\"function\"==typeof this.picker.options.documentClick&&(document.removeEventListener(\"click\",this.picker.options.documentClick,!0),\"function\"==typeof this.options.documentClick&&document.addEventListener(\"click\",this.options.documentClick,!0)),this.options.elementEnd.addEventListener(\"click\",this.picker.show.bind(this.picker))),this.options.repick=this.options.repick&&this.options.elementEnd instanceof HTMLElement,this.picker.options.date=null,this.picker.on(\"view\",this.binds.onView),this.picker.on(\"show\",this.binds.onShow),this.picker.on(\"mouseenter\",this.binds.onMouseEnter,!0),this.picker.on(\"mouseleave\",this.binds.onMouseLeave,!0),this.checkIntlPluralLocales()}onDetach(){Object.defineProperties(this.picker,{setStartDate:{configurable:!0,value:this.binds._setStartDate},setEndDate:{configurable:!0,value:this.binds._setEndDate},setDateRange:{configurable:!0,value:this.binds._setDateRange},getStartDate:{configurable:!0,value:this.binds._getStartDate},getEndDate:{configurable:!0,value:this.binds._getEndDate},parseValues:{configurable:!0,value:this.binds._parseValues},updateValues:{configurable:!0,value:this.binds._updateValues},clear:{configurable:!0,value:this.binds._clear},onClickCalendarDay:{configurable:!0,value:this.binds._onClickCalendarDay},onClickApplyButton:{configurable:!0,value:this.binds._onClickApplyButton}}),this.picker.off(\"view\",this.binds.onView),this.picker.off(\"show\",this.binds.onShow),this.picker.off(\"mouseenter\",this.binds.onMouseEnter,!0),this.picker.off(\"mouseleave\",this.binds.onMouseLeave,!0)}parseValues(){if(this.options.startDate||this.options.endDate)this.options.strict?this.options.startDate&&this.options.endDate?this.setDateRange(this.options.startDate,this.options.endDate):(this.options.startDate=null,this.options.endDate=null):(this.options.startDate&&this.setStartDate(this.options.startDate),this.options.endDate&&this.setEndDate(this.options.endDate));else if(this.options.elementEnd)this.options.strict?this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.options.elementEnd instanceof HTMLInputElement&&this.options.elementEnd.value.length&&this.setDateRange(this.picker.options.element.value,this.options.elementEnd.value):(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.setStartDate(this.picker.options.element.value),this.options.elementEnd instanceof HTMLInputElement&&this.options.elementEnd.value.length&&this.setEndDate(this.options.elementEnd.value));else if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const[t,e]=this.picker.options.element.value.split(this.options.delimiter);this.options.strict?t&&e&&this.setDateRange(t,e):(t&&this.setStartDate(t),e&&this.setEndDate(e))}}updateValues(){const t=this.picker.options.element,e=this.options.elementEnd,i=this.picker.getStartDate(),n=this.picker.getEndDate(),s=i instanceof Date?i.format(this.picker.options.format,this.picker.options.lang):\"\",o=n instanceof Date?n.format(this.picker.options.format,this.picker.options.lang):\"\";if(e)t instanceof HTMLInputElement?t.value=s:t instanceof HTMLElement&&(t.innerText=s),e instanceof HTMLInputElement?e.value=o:e instanceof HTMLElement&&(e.innerText=o);else{const e=`${s}${s||o?this.options.delimiter:\"\"}${o}`;t instanceof HTMLInputElement?t.value=e:t instanceof HTMLElement&&(t.innerText=e)}}clear(){this.options.startDate=null,this.options.endDate=null,this.picker.datePicked.length=0,this.updateValues(),this.picker.renderAll(),this.picker.trigger(\"clear\")}onShow(t){const{target:e}=t.detail;this.triggerElement=e,this.picker.options.scrollToDate&&this.getStartDate()instanceof Date&&this.picker.gotoDate(this.getStartDate()),this.initializeRepick()}onView(e){const{view:i,target:n}=e.detail;if(\"Main\"===i&&(this.tooltipElement=document.createElement(\"span\"),this.tooltipElement.className=\"range-plugin-tooltip\",n.appendChild(this.tooltipElement)),\"CalendarDay\"===i){const e=new t(n.dataset.time),i=this.picker.datePicked,s=i.length?this.picker.datePicked[0]:this.getStartDate(),o=i.length?this.picker.datePicked[1]:this.getEndDate();s&&s.isSame(e,\"day\")&&n.classList.add(\"start\"),s&&o&&(o.isSame(e,\"day\")&&n.classList.add(\"end\"),e.isBetween(s,o)&&n.classList.add(\"in-range\"))}if(\"Footer\"===i){const t=1===this.picker.datePicked.length&&!this.options.strict||2===this.picker.datePicked.length;n.querySelector(\".apply-button\").disabled=!t}}hidePicker(t){let e=t.target,i=null;e.shadowRoot&&(e=t.composedPath()[0],i=e.getRootNode().host),this.picker.isShown()&&i!==this.picker.ui.wrapper&&e!==this.picker.options.element&&e!==this.options.elementEnd&&this.picker.hide()}setStartDate(e){const i=new t(e,this.picker.options.format);this.options.startDate=i?i.clone():null,this.updateValues(),this.picker.renderAll()}setEndDate(e){const i=new t(e,this.picker.options.format);this.options.endDate=i?i.clone():null,this.updateValues(),this.picker.renderAll()}setDateRange(e,i){const n=new t(e,this.picker.options.format),s=new t(i,this.picker.options.format);this.options.startDate=n?n.clone():null,this.options.endDate=s?s.clone():null,this.updateValues(),this.picker.renderAll()}getStartDate(){return this.options.startDate instanceof Date?this.options.startDate.clone():null}getEndDate(){return this.options.endDate instanceof Date?this.options.endDate.clone():null}onMouseEnter(e){const i=e.target;if(i instanceof HTMLElement){this.isContainer(i)&&this.initializeRepick();const e=i.closest(\".unit\");if(!(e instanceof HTMLElement))return;if(this.picker.isCalendarDay(e)){if(1!==this.picker.datePicked.length)return;let i=this.picker.datePicked[0].clone(),n=new t(e.dataset.time),s=!1;if(i.isAfter(n,\"day\")){const t=i.clone();i=n.clone(),n=t.clone(),s=!0}if([...this.picker.ui.container.querySelectorAll(\".day\")].forEach((o=>{const a=new t(o.dataset.time),r=this.picker.Calendar.getCalendarDayView(a);a.isBetween(i,n)&&r.classList.add(\"in-range\"),a.isSame(this.picker.datePicked[0],\"day\")&&(r.classList.add(\"start\"),r.classList.toggle(\"flipped\",s)),o===e&&(r.classList.add(\"end\"),r.classList.toggle(\"flipped\",s)),o.className=r.className})),this.options.tooltip){const t=this.options.tooltipNumber(n.diff(i,\"day\")+1);if(t>0){const i=new Intl.PluralRules(this.picker.options.lang).select(t),n=`${t} ${this.options.locale[i]}`;this.showTooltip(e,n)}else this.hideTooltip()}}}}onMouseLeave(t){if(this.isContainer(t.target)&&this.options.repick){const t=this.getStartDate(),e=this.getEndDate();t&&e&&(this.picker.datePicked.length=0,this.picker.renderAll())}}onClickCalendarDay(e){if(this.picker.isCalendarDay(e)){2===this.picker.datePicked.length&&(this.picker.datePicked.length=0);const i=new t(e.dataset.time);if(this.picker.datePicked[this.picker.datePicked.length]=i,2===this.picker.datePicked.length&&this.picker.datePicked[0].isAfter(this.picker.datePicked[1])){const t=this.picker.datePicked[1].clone();this.picker.datePicked[1]=this.picker.datePicked[0].clone(),this.picker.datePicked[0]=t.clone()}1!==this.picker.datePicked.length&&this.picker.options.autoApply||this.picker.trigger(\"preselect\",{start:this.picker.datePicked[0]instanceof Date?this.picker.datePicked[0].clone():null,end:this.picker.datePicked[1]instanceof Date?this.picker.datePicked[1].clone():null}),1===this.picker.datePicked.length&&(!this.options.strict&&this.picker.options.autoApply&&(this.picker.options.element===this.triggerElement&&this.setStartDate(this.picker.datePicked[0]),this.options.elementEnd===this.triggerElement&&this.setEndDate(this.picker.datePicked[0]),this.picker.trigger(\"select\",{start:this.picker.getStartDate(),end:this.picker.getEndDate()})),this.picker.renderAll()),2===this.picker.datePicked.length&&(this.picker.options.autoApply?(this.setDateRange(this.picker.datePicked[0],this.picker.datePicked[1]),this.picker.trigger(\"select\",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide()):(this.hideTooltip(),this.picker.renderAll()))}}onClickApplyButton(t){this.picker.isApplyButton(t)&&(1!==this.picker.datePicked.length||this.options.strict||(this.picker.options.element===this.triggerElement&&(this.options.endDate=null,this.setStartDate(this.picker.datePicked[0])),this.options.elementEnd===this.triggerElement&&(this.options.startDate=null,this.setEndDate(this.picker.datePicked[0]))),2===this.picker.datePicked.length&&this.setDateRange(this.picker.datePicked[0],this.picker.datePicked[1]),this.picker.trigger(\"select\",{start:this.picker.getStartDate(),end:this.picker.getEndDate()}),this.picker.hide())}showTooltip(t,e){this.tooltipElement.style.visibility=\"visible\",this.tooltipElement.innerHTML=e;const i=this.picker.ui.container.getBoundingClientRect(),n=this.tooltipElement.getBoundingClientRect(),s=t.getBoundingClientRect();let o=s.top,a=s.left;o-=i.top,a-=i.left,o-=n.height,a-=n.width/2,a+=s.width/2,this.tooltipElement.style.top=`${o}px`,this.tooltipElement.style.left=`${a}px`}hideTooltip(){this.tooltipElement.style.visibility=\"hidden\"}checkIntlPluralLocales(){if(!this.options.tooltip)return;const t=[...new Set([new Intl.PluralRules(this.picker.options.lang).select(0),new Intl.PluralRules(this.picker.options.lang).select(1),new Intl.PluralRules(this.picker.options.lang).select(2),new Intl.PluralRules(this.picker.options.lang).select(6),new Intl.PluralRules(this.picker.options.lang).select(18)])],e=Object.keys(this.options.locale);t.every((t=>e.includes(t)))||console.warn(`${this.getName()}: provide locales (${t.join(\", \")}) for correct tooltip text.`)}initializeRepick(){if(!this.options.repick)return;const t=this.getStartDate(),e=this.getEndDate();e&&this.triggerElement===this.picker.options.element&&(this.picker.datePicked[0]=e),t&&this.triggerElement===this.options.elementEnd&&(this.picker.datePicked[0]=t)}isContainer(t){return t===this.picker.ui.container}}class l extends (/* unused pure expression or super */ null && (o)){options={native:!1,seconds:!1,stepHours:1,stepMinutes:5,stepSeconds:5,format12:!1};rangePlugin;timePicked={input:null,start:null,end:null};timePrePicked={input:null,start:null,end:null};binds={getDate:this.getDate.bind(this),getStartDate:this.getStartDate.bind(this),getEndDate:this.getEndDate.bind(this),onView:this.onView.bind(this),onInput:this.onInput.bind(this),onChange:this.onChange.bind(this),onClick:this.onClick.bind(this),setTime:this.setTime.bind(this),setStartTime:this.setStartTime.bind(this),setEndTime:this.setEndTime.bind(this)};getName(){return\"TimePlugin\"}onAttach(){this.binds._getDate=this.picker.getDate,this.binds._getStartDate=this.picker.getStartDate,this.binds._getEndDate=this.picker.getEndDate,Object.defineProperties(this.picker,{getDate:{configurable:!0,value:this.binds.getDate},getStartDate:{configurable:!0,value:this.binds.getStartDate},getEndDate:{configurable:!0,value:this.binds.getEndDate},setTime:{configurable:!0,value:this.binds.setTime},setStartTime:{configurable:!0,value:this.binds.setStartTime},setEndTime:{configurable:!0,value:this.binds.setEndTime}}),this.rangePlugin=this.picker.PluginManager.getInstance(\"RangePlugin\"),this.parseValues(),this.picker.on(\"view\",this.binds.onView),this.picker.on(\"input\",this.binds.onInput),this.picker.on(\"change\",this.binds.onChange),this.picker.on(\"click\",this.binds.onClick)}onDetach(){delete this.picker.setTime,delete this.picker.setStartTime,delete this.picker.setEndTime,Object.defineProperties(this.picker,{getDate:{configurable:!0,value:this.binds._getDate},getStartDate:{configurable:!0,value:this.binds._getStartDate},getEndDate:{configurable:!0,value:this.binds._getEndDate}}),this.picker.off(\"view\",this.binds.onView),this.picker.off(\"input\",this.binds.onInput),this.picker.off(\"change\",this.binds.onChange),this.picker.off(\"click\",this.binds.onClick)}onView(t){const{view:e,target:i}=t.detail;if(\"Main\"===e){this.rangePlugin=this.picker.PluginManager.getInstance(\"RangePlugin\");const t=document.createElement(\"div\");if(t.className=\"time-plugin-container\",this.rangePlugin){const e=this.getStartInput();t.appendChild(e),this.picker.trigger(\"view\",{view:\"TimePluginInput\",target:e});const i=this.getEndInput();t.appendChild(i),this.picker.trigger(\"view\",{view:\"TimePluginInput\",target:i})}else{const e=this.getSingleInput();t.appendChild(e),this.picker.trigger(\"view\",{view:\"TimePluginInput\",target:e})}i.appendChild(t),this.picker.trigger(\"view\",{view:\"TimePluginContainer\",target:t})}}onInput(e){const i=e.target;if(i instanceof HTMLInputElement&&i.classList.contains(\"time-plugin-input\")){const e=this.timePicked[i.name]||new t,[n,s]=i.value.split(\":\");e.setHours(Number(n)||0,Number(s)||0,0,0),this.picker.options.autoApply?(this.timePicked[i.name]=e,this.picker.updateValues()):this.timePrePicked[i.name]=e}}onChange(e){const i=e.target;if(i instanceof HTMLSelectElement&&i.classList.contains(\"time-plugin-custom-input\")){const e=/(\\w+)\\[(\\w+)\\]/,[,n,s]=i.name.match(e),o=Number(i.value);let a=new t;switch(!this.picker.options.autoApply&&this.timePrePicked[n]instanceof Date?a=this.timePrePicked[n].clone():this.timePicked[n]instanceof Date&&(a=this.timePicked[n].clone()),s){case\"HH\":if(this.options.format12){const t=i.closest(\".time-plugin-custom-block\").querySelector(`select[name=\"${n}[period]\"]`).value,e=this.handleFormat12(t,a,o);a.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),0)}else a.setHours(o,a.getMinutes(),a.getSeconds(),0);break;case\"mm\":a.setHours(a.getHours(),o,a.getSeconds(),0);break;case\"ss\":a.setHours(a.getHours(),a.getMinutes(),o,0);break;case\"period\":if(this.options.format12){const t=i.closest(\".time-plugin-custom-block\").querySelector(`select[name=\"${n}[HH]\"]`).value,e=this.handleFormat12(i.value,a,Number(t));a.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),0)}}if(this.picker.options.autoApply)this.timePicked[n]=a,this.picker.updateValues();else{this.timePrePicked[n]=a;const t=this.picker.ui.container.querySelector(\".apply-button\");if(this.rangePlugin){const e=this.rangePlugin.options,i=this.picker.datePicked,n=e.strict&&2===i.length||!e.strict&&i.length>0||!i.length&&e.strict&&e.startDate instanceof Date&&e.endDate instanceof Date||!i.length&&!e.strict&&(e.startDate instanceof Date||e.endDate instanceof Date);t.disabled=!n}else this.picker.datePicked.length&&(t.disabled=!1)}}}onClick(t){const e=t.target;if(e instanceof HTMLElement){const t=e.closest(\".unit\");if(!(t instanceof HTMLElement))return;this.picker.isApplyButton(t)&&(Object.keys(this.timePicked).forEach((t=>{this.timePrePicked[t]instanceof Date&&(this.timePicked[t]=this.timePrePicked[t].clone())})),this.picker.updateValues(),this.timePrePicked={input:null,start:null,end:null}),this.picker.isCancelButton(t)&&(this.timePrePicked={input:null,start:null,end:null},this.picker.renderAll())}}setTime(t){const e=this.handleTimeString(t);this.timePicked.input=e.clone(),this.picker.renderAll(),this.picker.updateValues()}setStartTime(t){const e=this.handleTimeString(t);this.timePicked.start=e.clone(),this.picker.renderAll(),this.picker.updateValues()}setEndTime(t){const e=this.handleTimeString(t);this.timePicked.end=e.clone(),this.picker.renderAll(),this.picker.updateValues()}handleTimeString(e){const i=new t,[n,s,o]=e.split(\":\").map((t=>Number(t))),a=n&&!Number.isNaN(n)?n:0,r=s&&!Number.isNaN(s)?s:0,c=o&&!Number.isNaN(o)?o:0;return i.setHours(a,r,c,0),i}getDate(){if(this.picker.options.date instanceof Date){const e=new t(this.picker.options.date,this.picker.options.format);if(this.timePicked.input instanceof Date){const t=this.timePicked.input;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getStartDate(){if(this.rangePlugin.options.startDate instanceof Date){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format);if(this.timePicked.start instanceof Date){const t=this.timePicked.start;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getEndDate(){if(this.rangePlugin.options.endDate instanceof Date){const e=new t(this.rangePlugin.options.endDate,this.picker.options.format);if(this.timePicked.end instanceof Date){const t=this.timePicked.end;e.setHours(t.getHours(),t.getMinutes(),t.getSeconds(),0)}return e}return null}getSingleInput(){return this.options.native?this.getNativeInput(\"input\"):this.getCustomInput(\"input\")}getStartInput(){return this.options.native?this.getNativeInput(\"start\"):this.getCustomInput(\"start\")}getEndInput(){return this.options.native?this.getNativeInput(\"end\"):this.getCustomInput(\"end\")}getNativeInput(t){const e=document.createElement(\"input\");e.type=\"time\",e.name=t,e.className=\"time-plugin-input unit\";const i=this.timePicked[t];if(i){const t=`0${i.getHours()}`.slice(-2),n=`0${i.getMinutes()}`.slice(-2);e.value=`${t}:${n}`}return e}getCustomInput(t){const e=document.createElement(\"div\");e.className=\"time-plugin-custom-block\";const i=document.createElement(\"select\");i.className=\"time-plugin-custom-input unit\",i.name=`${t}[HH]`;const n=this.options.format12?1:0,s=this.options.format12?13:24;let o=null;!this.picker.options.autoApply&&this.timePrePicked[t]instanceof Date?o=this.timePrePicked[t].clone():this.timePicked[t]instanceof Date&&(o=this.timePicked[t].clone());for(let t=n;t<s;t+=this.options.stepHours){const e=document.createElement(\"option\");e.value=String(t),e.text=String(t),o&&(this.options.format12?(o.getHours()%12?o.getHours()%12:12)===t&&(e.selected=!0):o.getHours()===t&&(e.selected=!0)),i.appendChild(e)}e.appendChild(i);const a=document.createElement(\"select\");a.className=\"time-plugin-custom-input unit\",a.name=`${t}[mm]`;for(let t=0;t<60;t+=this.options.stepMinutes){const e=document.createElement(\"option\");e.value=`0${String(t)}`.slice(-2),e.text=`0${String(t)}`.slice(-2),o&&o.getMinutes()===t&&(e.selected=!0),a.appendChild(e)}if(e.appendChild(a),this.options.seconds){const i=document.createElement(\"select\");i.className=\"time-plugin-custom-input unit\",i.name=`${t}[ss]`;const n=60;for(let t=0;t<n;t+=this.options.stepSeconds){const e=document.createElement(\"option\");e.value=`0${String(t)}`.slice(-2),e.text=`0${String(t)}`.slice(-2),o&&o.getSeconds()===t&&(e.selected=!0),i.appendChild(e)}e.appendChild(i)}if(this.options.format12){const i=document.createElement(\"select\");i.className=\"time-plugin-custom-input unit\",i.name=`${t}[period]`,[\"AM\",\"PM\"].forEach((t=>{const e=document.createElement(\"option\");e.value=t,e.text=t,o&&\"PM\"===t&&o.getHours()>=12&&(e.selected=!0),i.appendChild(e)})),e.appendChild(i)}return e}handleFormat12(t,e,i){const n=e.clone();switch(t){case\"AM\":12===i?n.setHours(0,n.getMinutes(),n.getSeconds(),0):n.setHours(i,n.getMinutes(),n.getSeconds(),0);break;case\"PM\":12!==i?n.setHours(i+12,n.getMinutes(),n.getSeconds(),0):n.setHours(i,n.getMinutes(),n.getSeconds(),0)}return n}parseValues(){if(this.rangePlugin){if(this.rangePlugin.options.strict){if(this.rangePlugin.options.startDate&&this.rangePlugin.options.endDate){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format),i=new t(this.rangePlugin.options.endDate,this.picker.options.format);this.timePicked.start=e.clone(),this.timePicked.end=i.clone()}}else{if(this.rangePlugin.options.startDate){const e=new t(this.rangePlugin.options.startDate,this.picker.options.format);this.timePicked.start=e.clone()}if(this.rangePlugin.options.endDate){const e=new t(this.rangePlugin.options.endDate,this.picker.options.format);this.timePicked.end=e.clone()}}if(this.rangePlugin.options.elementEnd)if(this.rangePlugin.options.strict){if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length&&this.rangePlugin.options.elementEnd instanceof HTMLInputElement&&this.rangePlugin.options.elementEnd.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format),i=new t(this.rangePlugin.options.elementEnd.value,this.picker.options.format);this.timePicked.start=e.clone(),this.timePicked.end=i.clone()}}else{if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format);this.timePicked.start=e.clone()}if(this.rangePlugin.options.elementEnd instanceof HTMLInputElement&&this.rangePlugin.options.elementEnd.value.length){const e=new t(this.rangePlugin.options.elementEnd.value,this.picker.options.format);this.timePicked.start=e.clone()}}else if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const[e,i]=this.picker.options.element.value.split(this.rangePlugin.options.delimiter);if(this.rangePlugin.options.strict){if(e&&i){const n=new t(e,this.picker.options.format),s=new t(i,this.picker.options.format);this.timePicked.start=n.clone(),this.timePicked.end=s.clone()}}else{if(e){const i=new t(e,this.picker.options.format);this.timePicked.start=i.clone()}if(i){const e=new t(i,this.picker.options.format);this.timePicked.start=e.clone()}}}}else{if(this.picker.options.date){const e=new t(this.picker.options.date,this.picker.options.format);this.timePicked.input=e.clone()}if(this.picker.options.element instanceof HTMLInputElement&&this.picker.options.element.value.length){const e=new t(this.picker.options.element.value,this.picker.options.format);this.timePicked.input=e.clone()}}}}class h extends (/* unused pure expression or super */ null && (o)){docElement=null;rangePlugin;binds={onView:this.onView.bind(this),onKeydown:this.onKeydown.bind(this)};options={unitIndex:1,dayIndex:2};getName(){return\"KbdPlugin\"}onAttach(){const t=this.picker.options.element,e=t.getBoundingClientRect();if(this.docElement=document.createElement(\"span\"),this.docElement.style.position=\"absolute\",this.docElement.style.top=`${t.offsetTop}px`,this.docElement.style.left=t.offsetLeft+e.width-25+\"px\",this.docElement.attachShadow({mode:\"open\"}),this.options.html)this.docElement.shadowRoot.innerHTML=this.options.html;else{const t=`\\n      <style>\\n      button {\\n        border: none;\\n        background: transparent;\\n        font-size: ${window.getComputedStyle(this.picker.options.element).fontSize};\\n      }\\n      </style>\\n\\n      <button>&#128197;</button>\\n      `;this.docElement.shadowRoot.innerHTML=t}const i=this.docElement.shadowRoot.querySelector(\"button\");i&&(i.addEventListener(\"click\",(t=>{t.preventDefault(),this.picker.show({target:this.picker.options.element})}),{capture:!0}),i.addEventListener(\"keydown\",(t=>{\"Escape\"===t.code&&this.picker.hide()}),{capture:!0})),this.picker.options.element.after(this.docElement),this.picker.on(\"view\",this.binds.onView),this.picker.on(\"keydown\",this.binds.onKeydown)}onDetach(){this.docElement&&this.docElement.isConnected&&this.docElement.remove(),this.picker.off(\"view\",this.binds.onView),this.picker.off(\"keydown\",this.binds.onKeydown)}onView(t){const{view:e,target:i}=t.detail;i&&\"querySelector\"in i&&(\"CalendarDay\"!==e||[\"locked\",\"not-available\"].some((t=>i.classList.contains(t)))?[...i.querySelectorAll(\".unit:not(.day)\")].forEach((t=>t.tabIndex=this.options.unitIndex)):i.tabIndex=this.options.dayIndex)}onKeydown(t){switch(this.onMouseEnter(t),t.code){case\"ArrowUp\":case\"ArrowDown\":this.verticalMove(t);break;case\"ArrowLeft\":case\"ArrowRight\":this.horizontalMove(t);break;case\"Enter\":case\"Space\":this.handleEnter(t);break;case\"Escape\":this.picker.hide()}}findAllowableDaySibling(t,e,i){const n=Array.from(t.querySelectorAll(`.day[tabindex=\"${this.options.dayIndex}\"]`)),s=n.indexOf(e);return n.filter(((t,e)=>i(e,s)&&t.tabIndex===this.options.dayIndex))[0]}changeMonth(t){const e={ArrowLeft:\"previous\",ArrowRight:\"next\"},i=this.picker.ui.container.querySelector(`.${e[t.code]}-button[tabindex=\"${this.options.unitIndex}\"]`);i&&!i.parentElement.classList.contains(`no-${e[t.code]}-month`)&&(i.dispatchEvent(new Event(\"click\",{bubbles:!0})),setTimeout((()=>{let e=null;switch(t.code){case\"ArrowLeft\":const t=this.picker.ui.container.querySelectorAll(`.day[tabindex=\"${this.options.dayIndex}\"]`);e=t[t.length-1];break;case\"ArrowRight\":e=this.picker.ui.container.querySelector(`.day[tabindex=\"${this.options.dayIndex}\"]`)}e&&e.focus()})))}verticalMove(t){const e=t.target;if(e.classList.contains(\"day\")){t.preventDefault();const i=this.findAllowableDaySibling(this.picker.ui.container,e,((e,i)=>e===(\"ArrowUp\"===t.code?i-7:i+7)));i&&i.focus()}}horizontalMove(t){const e=t.target;if(e.classList.contains(\"day\")){t.preventDefault();const i=this.findAllowableDaySibling(this.picker.ui.container,e,((e,i)=>e===(\"ArrowLeft\"===t.code?i-1:i+1)));i?i.focus():this.changeMonth(t)}}handleEnter(t){const e=t.target;e.classList.contains(\"day\")&&(t.preventDefault(),e.dispatchEvent(new Event(\"click\",{bubbles:!0})),setTimeout((()=>{if(this.rangePlugin=this.picker.PluginManager.getInstance(\"RangePlugin\"),this.rangePlugin||!this.picker.options.autoApply){const t=this.picker.ui.container.querySelector(\".day.selected\");t&&setTimeout((()=>{t.focus()}))}})))}onMouseEnter(t){t.target.classList.contains(\"day\")&&setTimeout((()=>{const t=this.picker.ui.shadowRoot.activeElement;t&&t.dispatchEvent(new Event(\"mouseenter\",{bubbles:!0}))}))}}class d extends (/* unused pure expression or super */ null && (o)){rangePlugin;lockPlugin;priority=10;binds={onView:this.onView.bind(this),onColorScheme:this.onColorScheme.bind(this)};options={dropdown:{months:!1,years:!1,minYear:1950,maxYear:null},darkMode:!0,locale:{resetButton:'<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24\" width=\"24\"><path d=\"M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z\"/></svg>'}};matchMedia;getName(){return\"AmpPlugin\"}onAttach(){this.options.darkMode&&window&&\"matchMedia\"in window&&(this.matchMedia=window.matchMedia(\"(prefers-color-scheme: dark)\"),this.matchMedia.matches&&(this.picker.ui.container.dataset.theme=\"dark\"),this.matchMedia.addEventListener(\"change\",this.binds.onColorScheme)),this.options.weekNumbers&&this.picker.ui.container.classList.add(\"week-numbers\"),this.picker.on(\"view\",this.binds.onView)}onDetach(){this.options.darkMode&&window&&\"matchMedia\"in window&&this.matchMedia.removeEventListener(\"change\",this.binds.onColorScheme),this.picker.ui.container.removeAttribute(\"data-theme\"),this.picker.ui.container.classList.remove(\"week-numbers\"),this.picker.off(\"view\",this.binds.onView)}onView(t){this.lockPlugin=this.picker.PluginManager.getInstance(\"LockPlugin\"),this.rangePlugin=this.picker.PluginManager.getInstance(\"RangePlugin\"),this.handleDropdown(t),this.handleResetButton(t),this.handleWeekNumbers(t)}onColorScheme(t){const e=t.matches?\"dark\":\"light\";this.picker.ui.container.dataset.theme=e}handleDropdown(e){const{view:i,target:n,date:s,index:o}=e.detail;if(\"CalendarHeader\"===i){const e=n.querySelector(\".month-name\");if(this.options.dropdown.months){e.childNodes[0].remove();const i=document.createElement(\"select\");i.className=\"month-name--select month-name--dropdown\";for(let e=0;e<12;e+=1){const n=document.createElement(\"option\"),o=new t(new Date(s.getFullYear(),e,2,0,0,0)),a=new t(new Date(s.getFullYear(),e,1,0,0,0));n.value=String(e),n.text=o.toLocaleString(this.picker.options.lang,{month:\"long\"}),this.lockPlugin&&(n.disabled=this.lockPlugin.options.minDate&&a.isBefore(new t(this.lockPlugin.options.minDate),\"month\")||this.lockPlugin.options.maxDate&&a.isAfter(new t(this.lockPlugin.options.maxDate),\"month\")),n.selected=a.getMonth()===s.getMonth(),i.appendChild(n)}i.addEventListener(\"change\",(t=>{const e=t.target;this.picker.calendars[0].setDate(1),this.picker.calendars[0].setMonth(Number(e.value)),this.picker.renderAll()})),e.prepend(i)}if(this.options.dropdown.years){e.childNodes[1].remove();const i=document.createElement(\"select\");i.className=\"month-name--select\";const n=this.options.dropdown.minYear,o=this.options.dropdown.maxYear?this.options.dropdown.maxYear:(new Date).getFullYear();if(s.getFullYear()>o){const t=document.createElement(\"option\");t.value=String(s.getFullYear()),t.text=String(s.getFullYear()),t.selected=!0,t.disabled=!0,i.appendChild(t)}for(let e=o;e>=n;e-=1){const n=document.createElement(\"option\"),o=new t(new Date(e,0,1,0,0,0));n.value=String(e),n.text=String(e),this.lockPlugin&&(n.disabled=this.lockPlugin.options.minDate&&o.isBefore(new t(this.lockPlugin.options.minDate),\"year\")||this.lockPlugin.options.maxDate&&o.isAfter(new t(this.lockPlugin.options.maxDate),\"year\")),n.selected=s.getFullYear()===e,i.appendChild(n)}if(s.getFullYear()<n){const t=document.createElement(\"option\");t.value=String(s.getFullYear()),t.text=String(s.getFullYear()),t.selected=!0,t.disabled=!0,i.appendChild(t)}if(\"asc\"===this.options.dropdown.years){const t=Array.prototype.slice.call(i.childNodes).reverse();i.innerHTML=\"\",t.forEach((t=>{t.innerHTML=t.value,i.appendChild(t)}))}i.addEventListener(\"change\",(t=>{const e=t.target;this.picker.calendars[0].setFullYear(Number(e.value)),this.picker.renderAll()})),e.appendChild(i)}}}handleResetButton(t){const{view:e,target:i}=t.detail;if(\"CalendarHeader\"===e&&this.options.resetButton){const t=document.createElement(\"button\");t.className=\"reset-button unit\",t.innerHTML=this.options.locale.resetButton,t.addEventListener(\"click\",(t=>{t.preventDefault();let e=!0;\"function\"==typeof this.options.resetButton&&(e=this.options.resetButton.call(this)),e&&this.picker.clear()})),i.appendChild(t)}}handleWeekNumbers(e){if(this.options.weekNumbers){const{view:i,target:n}=e.detail;if(\"CalendarDayNames\"===i){const t=document.createElement(\"div\");t.className=\"wnum-header\",t.innerHTML=\"Wk\",n.prepend(t)}\"CalendarDays\"===i&&[...n.children].forEach(((e,i)=>{if(0===i||i%7==0){let i;if(e.classList.contains(\"day\"))i=new t(e.dataset.time);else{const e=n.querySelector(\".day\");i=new t(e.dataset.time)}let s=i.getWeek(this.picker.options.firstDay);53===s&&0===i.getMonth()&&(s=\"53/1\");const o=document.createElement(\"div\");o.className=\"wnum-item\",o.innerHTML=String(s),n.insertBefore(o,e)}}))}}}\n\n;// CONCATENATED MODULE: ./src/js/datePicker.js\n\nvar picker = new s.create({\n  element: \"#date\",\n  css: [\"https://cdn.jsdelivr.net/npm/@easepick/bundle@1.2.1/dist/index.css\"],\n  zIndex: 10,\n  format: \"DD MMMM YYYY\"\n});\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/ssr-window.esm.mjs\n/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n}\nfunction extend(target, src) {\n  if (target === void 0) {\n    target = {};\n  }\n  if (src === void 0) {\n    src = {};\n  }\n  Object.keys(src).forEach(key => {\n    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n      extend(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {},\n  removeEventListener() {},\n  activeElement: {\n    blur() {},\n    nodeName: ''\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {}\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {},\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== 'undefined' ? document : {};\n  extend(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: ''\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  },\n  history: {\n    replaceState() {},\n    pushState() {},\n    go() {},\n    back() {}\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {},\n  removeEventListener() {},\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return '';\n      }\n    };\n  },\n  Image() {},\n  Date() {},\n  screen: {},\n  setTimeout() {},\n  clearTimeout() {},\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === 'undefined') {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === 'undefined') {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== 'undefined' ? window : {};\n  extend(win, ssrWindow);\n  return win;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/utils.mjs\n\n\nfunction classesToTokens(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n  return classes.trim().split(' ').filter(c => !!c.trim());\n}\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach(key => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction utils_getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis) {\n  if (axis === void 0) {\n    axis = 'x';\n  }\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = utils_getComputedStyle(el);\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction utils_isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction utils_extend() {\n  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < arguments.length; i += 1) {\n    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              utils_extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              utils_extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n  let {\n    swiper,\n    targetPosition,\n    side\n  } = _ref;\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n  const isOutOfBound = (current, target) => {\n    return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n  };\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction getSlideTransformEl(slideEl) {\n  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n}\nfunction elementChildren(element, selector) {\n  if (selector === void 0) {\n    selector = '';\n  }\n  return [...element.children].filter(el => el.matches(selector));\n}\nfunction showWarning(text) {\n  try {\n    console.warn(text);\n    return;\n  } catch (err) {\n    // err\n  }\n}\nfunction createElement(tag, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = getWindow();\n  const document = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = getWindow();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = getWindow();\n  if (includeMargins) {\n    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n  }\n  return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n  return (Array.isArray(el) ? el : [el]).filter(e => !!e);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/swiper-core.mjs\n\n\n\nlet support;\nfunction calcSupport() {\n  const window = getWindow();\n  const document = getDocument();\n  return {\n    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nlet deviceCached;\nfunction calcDevice(_temp) {\n  let {\n    userAgent\n  } = _temp === void 0 ? {} : _temp;\n  const support = getSupport();\n  const window = getWindow();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\nfunction getDevice(overrides) {\n  if (overrides === void 0) {\n    overrides = {};\n  }\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nlet browser;\nfunction calcBrowser() {\n  const window = getWindow();\n  const device = getDevice();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window.navigator.userAgent);\n    if (ua.includes('Version/')) {\n      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n      needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n    }\n  }\n  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);\n  const isSafariBrowser = isSafari();\n  const need3dFix = isSafariBrowser || isWebView && device.ios;\n  return {\n    isSafari: needPerspectiveFix || isSafariBrowser,\n    needPerspectiveFix,\n    need3dFix,\n    isWebView\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nfunction Resize(_ref) {\n  let {\n    swiper,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver(entries => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(_ref2 => {\n          let {\n            contentBoxSize,\n            contentRect,\n            target\n          } = _ref2;\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n\nfunction Observer(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const observers = [];\n  const window = getWindow();\n  const attach = function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc(mutations => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (swiper.__preventObserver__) return;\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.hostEl);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.hostEl, {\n      childList: swiper.params.observeSlideChildren\n    });\n\n    // Observe wrapper\n    attach(swiper.wrapperEl, {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach(observer => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n\n/* eslint-disable no-underscore-dangle */\n\nvar eventsEmitter = {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach(event => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler() {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach(event => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit() {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach(event => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach(eventHandler => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach(eventHandler => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\n\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\n\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  slides.forEach(slideEl => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slides);\n  } else if (swiper.grid) {\n    swiper.grid.unsetSlides();\n  }\n\n  // Calc slides\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slides);\n    }\n    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[swiper.getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop) return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach(slideEl => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap <= 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);\n    if (allSlidesSize + offsetSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  swiper.emit('slidesUpdated');\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\n\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = index => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach(slide => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\n\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  // eslint-disable-next-line\n  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n  }\n}\n\nconst toggleSlideClasses$1 = (slideEl, condition, className) => {\n  if (condition && !slideEl.classList.contains(className)) {\n    slideEl.classList.add(className);\n  } else if (!condition && slideEl.classList.contains(className)) {\n    slideEl.classList.remove(className);\n  }\n};\nfunction updateSlidesProgress(translate) {\n  if (translate === void 0) {\n    translate = this && this.translate || 0;\n  }\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n    }\n    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);\n    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\n\nfunction updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd,\n    progressLoop\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded) progress = 0;\n    if (isEndRounded) progress = 1;\n  }\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1) progressLoop -= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit('fromEdge');\n  }\n  swiper.emit('progress', progress);\n}\n\nconst toggleSlideClasses = (slideEl, condition, className) => {\n  if (condition && !slideEl.classList.contains(className)) {\n    slideEl.classList.add(className);\n  } else if (!condition && slideEl.classList.contains(className)) {\n    slideEl.classList.remove(className);\n  }\n};\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    slidesEl,\n    activeIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  const getFilteredSlide = selector => {\n    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n  };\n  let activeSlide;\n  let prevSlide;\n  let nextSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    if (gridEnabled) {\n      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];\n      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];\n      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];\n    } else {\n      activeSlide = slides[activeIndex];\n    }\n  }\n  if (activeSlide) {\n    if (!gridEnabled) {\n      // Next Slide\n      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !nextSlide) {\n        nextSlide = slides[0];\n      }\n\n      // Prev Slide\n      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !prevSlide === 0) {\n        prevSlide = slides[slides.length - 1];\n      }\n    }\n  }\n  slides.forEach(slideEl => {\n    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n  });\n  swiper.emitSlidesClasses();\n}\n\nconst processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (!lazyEl && swiper.isElement) {\n      if (slideEl.shadowRoot) {\n        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n      } else {\n        // init later\n        requestAnimationFrame(() => {\n          if (slideEl.shadowRoot) {\n            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl) lazyEl.remove();\n          }\n        });\n      }\n    }\n    if (lazyEl) lazyEl.remove();\n  }\n};\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index]) return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl) imageEl.removeAttribute('loading');\n};\nconst preload = swiper => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0) return;\n  amount = Math.min(amount, len);\n  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(...Array.from({\n      length: amount\n    }).map((_, i) => {\n      return activeColumn + slidesPerView + i;\n    }));\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = (i % len + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n    }\n  } else {\n    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\n\nfunction getActiveIndexByTranslate(swiper) {\n  const {\n    slidesGrid,\n    params\n  } = swiper;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== 'undefined') {\n      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n        activeIndex = i;\n      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n  }\n  return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  const getVirtualRealIndex = aIndex => {\n    let realIndex = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex < 0) {\n      realIndex = swiper.virtual.slides.length + realIndex;\n    }\n    if (realIndex >= swiper.virtual.slides.length) {\n      realIndex -= swiper.virtual.slides.length;\n    }\n    return realIndex;\n  };\n  if (typeof activeIndex === 'undefined') {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex && !swiper.params.loop) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n    swiper.realIndex = getVirtualRealIndex(activeIndex);\n    return;\n  }\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\n  // Get real index\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (gridEnabled) {\n    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];\n    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);\n    if (Number.isNaN(activeSlideIndex)) {\n      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n    }\n    realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n  } else if (swiper.slides[activeIndex]) {\n    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');\n    if (slideIndex) {\n      realIndex = parseInt(slideIndex, 10);\n    } else {\n      realIndex = activeIndex;\n    }\n  } else {\n    realIndex = activeIndex;\n  }\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    if (previousRealIndex !== realIndex) {\n      swiper.emit('realIndexChange');\n    }\n    swiper.emit('slideChange');\n  }\n}\n\nfunction updateClickedSlide(el, path) {\n  const swiper = this;\n  const params = swiper.params;\n  let slide = el.closest(`.${params.slideClass}, swiper-slide`);\n  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {\n      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n        slide = pathEl;\n      }\n    });\n  }\n  let slideFound = false;\n  let slideIndex;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\n\nfunction getSwiperTranslate(axis) {\n  if (axis === void 0) {\n    axis = this.isHorizontal() ? 'x' : 'y';\n  }\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate,\n    wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl) currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\n\nfunction setTranslate(translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\n\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (translateBounds === void 0) {\n    translateBounds = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          swiper.animating = false;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\n\nvar translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\n\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';\n  }\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionEmit(_ref) {\n  let {\n    swiper,\n    runCallbacks,\n    direction,\n    step\n  } = _ref;\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n\nfunction transitionStart(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'Start'\n  });\n}\n\nfunction transitionEnd(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'End'\n  });\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\n\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n  if (index === void 0) {\n    index = 0;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n  // Update Index\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\n\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n  if (index === void 0) {\n    index = 0;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index === 'string') {\n    const indexAsNumber = parseInt(index, 10);\n    index = indexAsNumber;\n  }\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      // eslint-disable-next-line\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      let targetSlideIndex;\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n      } else {\n        targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n      }\n      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n      const {\n        centeredSlides\n      } = swiper.params;\n      let slidesPerView = swiper.params.slidesPerView;\n      if (slidesPerView === 'auto') {\n        slidesPerView = swiper.slidesPerViewDynamic();\n      } else {\n        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n        if (centeredSlides && slidesPerView % 2 === 0) {\n          slidesPerView = slidesPerView + 1;\n        }\n      }\n      let needLoopFix = cols - targetSlideIndex < slidesPerView;\n      if (centeredSlides) {\n        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n      }\n      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {\n        needLoopFix = false;\n      }\n      if (needLoopFix) {\n        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';\n        swiper.loopFix({\n          direction,\n          slideTo: true,\n          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined\n        });\n      }\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;\n      } else {\n        newIndex = swiper.getSlideIndexByData(newIndex);\n      }\n    }\n  }\n  requestAnimationFrame(() => {\n    swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  });\n  return swiper;\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    enabled,\n    params,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed) return swiper;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'next'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n      requestAnimationFrame(() => {\n        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n      });\n      return true;\n    }\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed) return swiper;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'prev'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n    requestAnimationFrame(() => {\n      swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    });\n    return true;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset(speed, runCallbacks, internal) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide() {\n  const swiper = this;\n  if (swiper.destroyed) return;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\n\nfunction loopCreate(slideRealIndex) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n  const initSlides = () => {\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    slides.forEach((el, index) => {\n      el.setAttribute('data-swiper-slide-index', index);\n    });\n  };\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n  const addBlankSlides = amountOfSlides => {\n    for (let i = 0; i < amountOfSlides; i += 1) {\n      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);\n      swiper.slidesEl.append(slideEl);\n    }\n  };\n  if (shouldFillGroup) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n    }\n    initSlides();\n  } else if (shouldFillGrid) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n    }\n    initSlides();\n  } else {\n    initSlides();\n  }\n  swiper.loopFix({\n    slideRealIndex,\n    direction: params.centeredSlides ? undefined : 'next'\n  });\n}\n\nfunction loopFix(_temp) {\n  let {\n    slideRealIndex,\n    slideTo = true,\n    direction,\n    setTranslate,\n    activeSlideIndex,\n    byController,\n    byMousewheel\n  } = _temp === void 0 ? {} : _temp;\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  const {\n    centeredSlides\n  } = params;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n  let slidesPerView = params.slidesPerView;\n  if (slidesPerView === 'auto') {\n    slidesPerView = swiper.slidesPerViewDynamic();\n  } else {\n    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n    if (centeredSlides && slidesPerView % 2 === 0) {\n      slidesPerView = slidesPerView + 1;\n    }\n  }\n  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n  let loopedSlides = slidesPerGroup;\n  if (loopedSlides % slidesPerGroup !== 0) {\n    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n  }\n  loopedSlides += params.loopAdditionalSlides;\n  swiper.loopedSlides = loopedSlides;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  if (slides.length < slidesPerView + loopedSlides) {\n    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');\n  } else if (gridEnabled && params.grid.fill === 'row') {\n    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');\n  }\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);\n  // prepend last slides before start\n  if (activeColIndexWithShift < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {\n      const index = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        const colIndexToPrepend = cols - index - 1;\n        for (let i = slides.length - 1; i >= 0; i -= 1) {\n          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n        }\n        // slides.forEach((slide, slideIndex) => {\n        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n        // });\n      } else {\n        prependSlidesIndexes.push(cols - index - 1);\n      }\n    }\n  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        slides.forEach((slide, slideIndex) => {\n          if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n        });\n      } else {\n        appendSlidesIndexes.push(index);\n      }\n    }\n  }\n  swiper.__preventObserver__ = true;\n  requestAnimationFrame(() => {\n    swiper.__preventObserver__ = false;\n  });\n  if (isPrev) {\n    prependSlidesIndexes.forEach(index => {\n      slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(slides[index]);\n      slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach(index => {\n      slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(slides[index]);\n      slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  swiper.recalcSlides();\n  if (params.slidesPerView === 'auto') {\n    swiper.updateSlides();\n  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n    swiper.slides.forEach((slide, slideIndex) => {\n      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n    });\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n          if (setTranslate) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        if (setTranslate) {\n          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n          swiper.touchEventsData.currentTranslate = swiper.translate;\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach(c => {\n        if (!c.destroyed && c.params.loop) c.loopFix({\n          ...loopParams,\n          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n        });\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix({\n        ...loopParams,\n        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n      });\n    }\n  }\n  swiper.emit('loopFix');\n}\n\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n  swiper.recalcSlides();\n  const newSlidesOrder = [];\n  swiper.slides.forEach(slideEl => {\n    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach(slideEl => {\n    slideEl.removeAttribute('data-swiper-slide-index');\n  });\n  newSlidesOrder.forEach(slideEl => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\n\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base) {\n  if (base === void 0) {\n    base = this;\n  }\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n  const window = getWindow();\n  const {\n    params\n  } = swiper;\n  const edgeSwipeDetection = params.edgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction onTouchStart(event) {\n  const swiper = this;\n  const document = getDocument();\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  const data = swiper.touchEventsData;\n  if (e.type === 'pointerdown') {\n    if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n      return;\n    }\n    data.pointerId = e.pointerId;\n  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {\n    data.touchId = e.targetTouches[0].identifier;\n  }\n  if (e.type === 'touchstart') {\n    // don't proceed touch event\n    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n    return;\n  }\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && e.pointerType === 'mouse') return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let targetEl = e.target;\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!swiper.wrapperEl.contains(targetEl)) return;\n  }\n  if ('which' in e && e.which === 3) return;\n  if ('button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = e.composedPath ? e.composedPath() : e.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler)) return;\n  }\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  if (!preventEdgeSwipe(swiper, e, startX)) {\n    return;\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === 'SELECT') {\n      data.isTouched = false;\n    }\n  }\n  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n    document.activeElement.blur();\n  }\n  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n    e.preventDefault();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove(event) {\n  const document = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (e.type === 'pointermove') {\n    if (data.touchId !== null) return; // return from pointer if we use touch\n    const id = e.pointerId;\n    if (id !== data.pointerId) return;\n  }\n  let targetTouch;\n  if (e.type === 'touchmove') {\n    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n    if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n  } else {\n    targetTouch = e;\n  }\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n  if (document.activeElement) {\n    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  touches.previousX = touches.currentX;\n  touches.previousY = touches.currentY;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n  const isLoop = swiper.params.loop && !params.cssMode;\n  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;\n  if (!data.isMoved) {\n    if (isLoop && allowLoopFix) {\n      swiper.loopFix({\n        direction: swiper.swipeDirection\n      });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent('transitionend', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          bySwiperTouchMove: true\n        }\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  let loopFixed;\n  new Date().getTime();\n  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n    Object.assign(touches, {\n      startX: pageX,\n      startY: pageY,\n      currentX: pageX,\n      currentY: pageY,\n      startTranslate: data.currentTranslate\n    });\n    data.loopSwapReset = true;\n    data.startTranslate = data.currentTranslate;\n    return;\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n      swiper.loopFix({\n        direction: 'prev',\n        setTranslate: true,\n        activeSlideIndex: 0\n      });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n      swiper.loopFix({\n        direction: 'next',\n        setTranslate: true,\n        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let targetTouch;\n  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';\n  if (!isTouchEvent) {\n    if (data.touchId !== null) return; // return from pointer if we use touch\n    if (e.pointerId !== data.pointerId) return;\n    targetTouch = e;\n  } else {\n    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];\n    if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n  }\n  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {\n    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n  data.pointerId = null;\n  data.touchId = null;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && e.pointerType === 'mouse') return;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n\n  // Find current slide\n  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n\nfunction onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n    return;\n  }\n  swiper.update();\n}\n\nfunction onDocumentTouchStart() {\n  const swiper = this;\n  if (swiper.documentTouchHandlerProceeded) return;\n  swiper.documentTouchHandlerProceeded = true;\n  if (swiper.params.touchReleaseOnEdges) {\n    swiper.el.style.touchAction = 'auto';\n  }\n}\n\nconst events = (swiper, method) => {\n  const document = getDocument();\n  const {\n    params,\n    el,\n    wrapperEl,\n    device\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n  if (!el || typeof el === 'string') return;\n\n  // Touch Events\n  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {\n    passive: false,\n    capture\n  });\n  el[domMethod]('touchstart', swiper.onTouchStart, {\n    passive: false\n  });\n  el[domMethod]('pointerdown', swiper.onTouchStart, {\n    passive: false\n  });\n  document[domMethod]('touchmove', swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document[domMethod]('pointermove', swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document[domMethod]('touchend', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerup', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointercancel', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('touchcancel', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerout', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerleave', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('contextmenu', swiper.onTouchEnd, {\n    passive: true\n  });\n\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n\n  // Images loader\n  el[domMethod]('load', swiper.onLoad, {\n    capture: true\n  });\n};\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n  events(swiper, 'on');\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\nvar events$1 = {\n  attachEvents,\n  detachEvents\n};\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    realIndex,\n    initialized,\n    params,\n    el\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasGrabCursor = swiper.params.grabCursor;\n  const isGrabCursor = breakpointParams.grabCursor;\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n  if (wasGrabCursor && !isGrabCursor) {\n    swiper.unsetGrabCursor();\n  } else if (!wasGrabCursor && isGrabCursor) {\n    swiper.setGrabCursor();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n    if (typeof breakpointParams[prop] === 'undefined') return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  const wasLoop = params.loop;\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  utils_extend(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  const hasLoop = swiper.params.loop;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n  if (initialized) {\n    if (needsReLoop) {\n      swiper.loopDestroy();\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (!wasLoop && hasLoop) {\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (wasLoop && !hasLoop) {\n      swiper.loopDestroy();\n    }\n  }\n  swiper.emit('breakpoint', breakpointParams);\n}\n\nfunction getBreakpoint(breakpoints, base, containerEl) {\n  if (base === void 0) {\n    base = 'window';\n  }\n  if (!breakpoints || base === 'container' && !containerEl) return undefined;\n  let breakpoint = false;\n  const window = getWindow();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints).map(point => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\n\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach(item => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach(classNames => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    el,\n    device\n  } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses(['initialized', params.direction, {\n    'free-mode': swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    'autoheight': params.autoHeight\n  }, {\n    'rtl': rtl\n  }, {\n    'grid': params.grid && params.grid.rows > 1\n  }, {\n    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n  }, {\n    'android': device.android\n  }, {\n    'ios': device.ios\n  }, {\n    'css-mode': params.cssMode\n  }, {\n    'centered': params.cssMode && params.centeredSlides\n  }, {\n    'watch-progress': params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\n\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    el,\n    classNames\n  } = swiper;\n  if (!el || typeof el === 'string') return;\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\n\nvar classes = {\n  addClasses,\n  removeClasses\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\nvar checkOverflow$1 = {\n  checkOverflow\n};\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  oneWayMovement: false,\n  swiperElementNodeName: 'SWIPER-CONTAINER',\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  eventsPrefix: 'swiper',\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: 'slide',\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // loop\n  loop: false,\n  loopAddBlankSlides: true,\n  loopAdditionalSlides: 0,\n  loopPreventsSliding: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: 'swiper-',\n  // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideFullyVisibleClass: 'swiper-slide-fully-visible',\n  slideNextClass: 'swiper-slide-next',\n  slidePrevClass: 'swiper-slide-prev',\n  wrapperClass: 'swiper-wrapper',\n  lazyPreloaderClass: 'swiper-lazy-preloader',\n  lazyPreloadPrevNext: 0,\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\n\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj) {\n    if (obj === void 0) {\n      obj = {};\n    }\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      utils_extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n      params[moduleParamName].auto = true;\n    }\n    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n      params[moduleParamName].auto = true;\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      utils_extend(allModulesParams, obj);\n      return;\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = {\n      enabled: false\n    };\n    utils_extend(allModulesParams, obj);\n  };\n}\n\n/* eslint no-param-reassign: \"off\" */\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor() {\n    let el;\n    let params;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n    params = utils_extend({}, params);\n    if (el && !params.el) params.el = el;\n    const document = getDocument();\n    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n      const swipers = [];\n      document.querySelectorAll(params.el).forEach(containerEl => {\n        const newParams = utils_extend({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach(mod => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = utils_extend({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = utils_extend({}, swiper.params);\n    swiper.passedParams = utils_extend({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach(eventName => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      cssOverflowAdjustment() {\n        // Returns 0 unless `translate` is > 2**23\n        // Should be subtracted from css values to prevent overflow\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        startMoving: undefined,\n        pointerId: null,\n        touchId: null\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n  getDirectionLabel(property) {\n    if (this.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n  getSlideIndex(slideEl) {\n    const {\n      slidesEl,\n      params\n    } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n  }\n  recalcSlides() {\n    const swiper = this;\n    const {\n      slidesEl,\n      params\n    } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter(className => {\n      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n    return slideEl.className.split(' ').filter(className => {\n      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(' ');\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.forEach(slideEl => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n  slidesPerViewDynamic(view, exact) {\n    if (view === void 0) {\n      view = 'current';\n    }\n    if (exact === void 0) {\n      exact = false;\n    }\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (typeof params.slidesPerView === 'number') return params.slidesPerView;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += Math.ceil(slides[i].swiperSlideSize);\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n  changeDirection(newDirection, needUpdate) {\n    if (needUpdate === void 0) {\n      needUpdate = true;\n    }\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n      return swiper;\n    }\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.forEach(slideEl => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    let el = element || swiper.params.el;\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n      swiper.isElement = true;\n    }\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        // Children needs to return slot items\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    // Find Wrapper\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement('div', swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n        wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n      hostEl: swiper.isElement ? el.parentNode.host : el,\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Attach events\n    swiper.attachEvents();\n    const lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n    if (swiper.isElement) {\n      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n    }\n    lazyElements.forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener('load', e => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n\n    // Init Flag\n    swiper.initialized = true;\n    preload(swiper);\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n    return swiper;\n  }\n  destroy(deleteInstance, cleanStyles) {\n    if (deleteInstance === void 0) {\n      deleteInstance = true;\n    }\n    if (cleanStyles === void 0) {\n      cleanStyles = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      el,\n      wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      if (el && typeof el !== 'string') {\n        el.removeAttribute('style');\n      }\n      if (wrapperEl) {\n        wrapperEl.removeAttribute('style');\n      }\n      if (slides && slides.length) {\n        slides.forEach(slideEl => {\n          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n          slideEl.removeAttribute('style');\n          slideEl.removeAttribute('data-swiper-slide-index');\n        });\n      }\n    }\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach(eventName => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      if (swiper.el && typeof swiper.el !== 'string') {\n        swiper.el.swiper = null;\n      }\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    utils_extend(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach(m => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach(prototypeGroup => {\n  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/virtual.mjs\n\n\n\nfunction Virtual(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0\n    }\n  });\n  let cssModeTimeout;\n  const document = getDocument();\n  swiper.virtual = {\n    cache: {},\n    from: undefined,\n    to: undefined,\n    slides: [],\n    offset: 0,\n    slidesGrid: []\n  };\n  const tempDOM = document.createElement('div');\n  function renderSlide(slide, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    // eslint-disable-next-line\n    let slideEl;\n    if (params.renderSlide) {\n      slideEl = params.renderSlide.call(swiper, slide, index);\n      if (typeof slideEl === 'string') {\n        tempDOM.innerHTML = slideEl;\n        slideEl = tempDOM.children[0];\n      }\n    } else if (swiper.isElement) {\n      slideEl = createElement('swiper-slide');\n    } else {\n      slideEl = createElement('div', swiper.params.slideClass);\n    }\n    slideEl.setAttribute('data-swiper-slide-index', index);\n    if (!params.renderSlide) {\n      slideEl.innerHTML = slide;\n    }\n    if (params.cache) {\n      swiper.virtual.cache[index] = slideEl;\n    }\n    return slideEl;\n  }\n  function update(force, beforeInit) {\n    const {\n      slidesPerView,\n      slidesPerGroup,\n      centeredSlides,\n      loop: isLoop,\n      initialSlide\n    } = swiper.params;\n    if (beforeInit && !isLoop && initialSlide > 0) {\n      return;\n    }\n    const {\n      addSlidesBefore,\n      addSlidesAfter\n    } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n    const activeIndex = swiper.activeIndex || 0;\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n    }\n    let from = activeIndex - slidesBefore;\n    let to = activeIndex + slidesAfter;\n    if (!isLoop) {\n      from = Math.max(from, 0);\n      to = Math.min(to, slides.length - 1);\n    }\n    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n    if (isLoop && activeIndex >= slidesBefore) {\n      from -= slidesBefore;\n      if (!centeredSlides) offset += swiper.slidesGrid[0];\n    } else if (isLoop && activeIndex < slidesBefore) {\n      from = -slidesBefore;\n      if (centeredSlides) offset += swiper.slidesGrid[0];\n    }\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n      slidesBefore,\n      slidesAfter\n    });\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      emit('virtualUpdate');\n    }\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.forEach(slideEl => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n      }\n      swiper.updateProgress();\n      emit('virtualUpdate');\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit('virtualUpdate');\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    const getSlideIndex = index => {\n      let slideIndex = index;\n      if (index < 0) {\n        slideIndex = slides.length + index;\n      } else if (slideIndex >= slides.length) {\n        // eslint-disable-next-line\n        slideIndex = slideIndex - slides.length;\n      }\n      return slideIndex;\n    };\n    if (force) {\n      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {\n        slideEl.remove();\n      });\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          const slideIndex = getSlideIndex(i);\n          swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`)).forEach(slideEl => {\n            slideEl.remove();\n          });\n        }\n      }\n    }\n    const loopFrom = isLoop ? -slides.length : 0;\n    const loopTo = isLoop ? slides.length * 2 : slides.length;\n    for (let i = loopFrom; i < loopTo; i += 1) {\n      if (i >= from && i <= to) {\n        const slideIndex = getSlideIndex(i);\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(slideIndex);\n        } else {\n          if (i > previousTo) appendIndexes.push(slideIndex);\n          if (i < previousFrom) prependIndexes.push(slideIndex);\n        }\n      }\n    }\n    appendIndexes.forEach(index => {\n      swiper.slidesEl.append(renderSlide(slides[index], index));\n    });\n    if (isLoop) {\n      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n        const index = prependIndexes[i];\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      }\n    } else {\n      prependIndexes.sort((a, b) => b - a);\n      prependIndexes.forEach(index => {\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      });\n    }\n    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n    });\n    onRendered();\n  }\n  function appendSlide(slides) {\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update(true);\n  }\n  function prependSlide(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach(cachedIndex => {\n        const cachedEl = cache[cachedIndex];\n        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n        if (cachedElIndex) {\n          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide(slidesIndexes) {\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n          // shift cache indexes\n          Object.keys(swiper.virtual.cache).forEach(key => {\n            if (key > slidesIndexes) {\n              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n              swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n              delete swiper.virtual.cache[key];\n            }\n          });\n        }\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n        // shift cache indexes\n        Object.keys(swiper.virtual.cache).forEach(key => {\n          if (key > slidesIndexes) {\n            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n            delete swiper.virtual.cache[key];\n          }\n        });\n      }\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update(true);\n    swiper.slideTo(0, 0);\n  }\n  on('beforeInit', () => {\n    if (!swiper.params.virtual.enabled) return;\n    let domSlidesAssigned;\n    if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n      if (slides && slides.length) {\n        swiper.virtual.slides = [...slides];\n        domSlidesAssigned = true;\n        slides.forEach((slideEl, slideIndex) => {\n          slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n          swiper.virtual.cache[slideIndex] = slideEl;\n          slideEl.remove();\n        });\n      }\n    }\n    if (!domSlidesAssigned) {\n      swiper.virtual.slides = swiper.params.virtual.slides;\n    }\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n    update(false, true);\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update();\n      }, 100);\n    } else {\n      update();\n    }\n  });\n  on('init update resize', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n    }\n  });\n  Object.assign(swiper.virtual, {\n    appendSlide,\n    prependSlide,\n    removeSlide,\n    removeAllSlides,\n    update\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/keyboard.mjs\n\n\n\n/* eslint-disable consistent-return */\nfunction Keyboard(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const document = getDocument();\n  const window = getWindow();\n  swiper.keyboard = {\n    enabled: false\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true\n    }\n  });\n  function handle(event) {\n    if (!swiper.enabled) return;\n    const {\n      rtlTranslate: rtl\n    } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n      return undefined;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n        return undefined;\n      }\n      const el = swiper.el;\n      const swiperWidth = el.clientWidth;\n      const swiperHeight = el.clientHeight;\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = elementOffset(el);\n      if (rtl) swiperOffset.left -= el.scrollLeft;\n      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      }\n      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext();\n      if (isPageUp || isArrowUp) swiper.slidePrev();\n    }\n    emit('keyPress', kc);\n    return undefined;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled) return;\n    document.addEventListener('keydown', handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled) return;\n    document.removeEventListener('keydown', handle);\n    swiper.keyboard.enabled = false;\n  }\n  on('init', () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/mousewheel.mjs\n\n\n\n/* eslint-disable consistent-return */\nfunction Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n          return true;\n        }\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/create-element-if-not-defined.mjs\n\n\nfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach(key => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement('div', checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/navigation.mjs\n\n\n\nfunction Navigation(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n      navigationDisabledClass: 'swiper-navigation-disabled'\n    }\n  });\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null\n  };\n  function getEl(el) {\n    let res;\n    if (el && typeof el === 'string' && swiper.isElement) {\n      res = swiper.el.querySelector(el);\n      if (res) return res;\n    }\n    if (el) {\n      if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n        res = swiper.el.querySelector(el);\n      } else if (res && res.length === 1) {\n        res = res[0];\n      }\n    }\n    if (el && !res) return el;\n    // if (Array.isArray(res) && res.length === 1) res = res[0];\n    return res;\n  }\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      if (subEl) {\n        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      }\n    });\n  }\n  function update() {\n    // Update Navigation Buttons\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slidePrev();\n    emit('navigationPrev');\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slideNext();\n    emit('navigationNext');\n  }\n  function init() {\n    const params = swiper.params.navigation;\n    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n      nextEl: 'swiper-button-next',\n      prevEl: 'swiper-button-prev'\n    });\n    if (!(params.nextEl || params.prevEl)) return;\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const initButton = (el, dir) => {\n      if (el) {\n        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(' '));\n      }\n    };\n    nextEl.forEach(el => initButton(el, 'next'));\n    prevEl.forEach(el => initButton(el, 'prev'));\n  }\n  function destroy() {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n    };\n    nextEl.forEach(el => destroyButton(el, 'next'));\n    prevEl.forEach(el => destroyButton(el, 'prev'));\n  }\n  on('init', () => {\n    if (swiper.params.navigation.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      update();\n    }\n  });\n  on('toEdge fromEdge lock unlock', () => {\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (swiper.enabled) {\n      update();\n      return;\n    }\n    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));\n  });\n  on('click', (_s, e) => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);\n    if (swiper.isElement && !targetIsButton) {\n      const path = e.path || e.composedPath && e.composedPath();\n      if (path) {\n        targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));\n      }\n    }\n    if (swiper.params.navigation.hideOnClick && !targetIsButton) {\n      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit('navigationShow');\n      } else {\n        emit('navigationHide');\n      }\n      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    init();\n    update();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    destroy();\n  };\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update,\n    init,\n    destroy\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/classes-to-selector.mjs\nfunction classesToSelector(classes) {\n  if (classes === void 0) {\n    classes = '';\n  }\n  return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/pagination.mjs\n\n\n\n\nfunction Pagination(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const pfx = 'swiper-pagination';\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets',\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: number => number,\n      formatFractionTotal: number => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`\n    }\n  });\n  swiper.pagination = {\n    el: null,\n    bullets: []\n  };\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n  function isPaginationDisabled() {\n    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n  }\n  function setSideBullets(bulletEl, position) {\n    const {\n      bulletActiveClass\n    } = swiper.params.pagination;\n    if (!bulletEl) return;\n    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index) return;\n      swiper.slideToLoop(index);\n    } else {\n      swiper.slideTo(index);\n    }\n  }\n  function update() {\n    // Render || Update Pagination bullets/items\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    // Current/Total\n    let current;\n    let previousIndex;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n        el.forEach(subEl => {\n          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach(bulletEl => {\n        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n      if (el.length > 1) {\n        bullets.forEach(bullet => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          } else if (swiper.isElement) {\n            bullet.setAttribute('part', 'bullet');\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, 'prev');\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, 'next');\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(' '));\n        }\n        if (swiper.isElement) {\n          bullets.forEach((bulletEl, bulletIndex) => {\n            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n          });\n        }\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n          }\n          setSideBullets(firstDisplayedBullet, 'prev');\n          setSideBullets(lastDisplayedBullet, 'next');\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.forEach(bullet => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === 'fraction') {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === 'progressbar') {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === 'horizontal') {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        });\n      }\n      if (params.type === 'custom' && params.renderCustom) {\n        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n        if (subElIndex === 0) emit('paginationRender', subEl);\n      } else {\n        if (subElIndex === 0) emit('paginationRender', subEl);\n        emit('paginationUpdate', subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    // Render Container\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          // prettier-ignore\n          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach(subEl => {\n      if (params.type !== 'custom') {\n        subEl.innerHTML = paginationHTML || '';\n      }\n      if (params.type === 'bullets') {\n        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n      }\n    });\n    if (params.type !== 'custom') {\n      emit('paginationRender', el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n      el: 'swiper-pagination'\n    });\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0) return;\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      // check if it belongs to another nested Swiper\n      if (el.length > 1) {\n        el = el.filter(subEl => {\n          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n          return true;\n        })[0];\n      }\n    }\n    if (Array.isArray(el) && el.length === 1) el = el[0];\n    Object.assign(swiper.pagination, {\n      el\n    });\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      if (params.type === 'bullets' && params.clickable) {\n        subEl.classList.add(...(params.clickableClass || '').split(' '));\n      }\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      if (params.type === 'bullets' && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n      if (params.clickable) {\n        subEl.addEventListener('click', onBulletClick);\n      }\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.clickable) {\n          subEl.classList.remove(...(params.clickableClass || '').split(' '));\n          subEl.removeEventListener('click', onBulletClick);\n        }\n      });\n    }\n    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n  }\n  on('changeDirection', () => {\n    if (!swiper.pagination || !swiper.pagination.el) return;\n    const params = swiper.params.pagination;\n    let {\n      el\n    } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on('init', () => {\n    if (swiper.params.pagination.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      render();\n      update();\n    }\n  });\n  on('activeIndexChange', () => {\n    if (typeof swiper.snapIndex === 'undefined') {\n      update();\n    }\n  });\n  on('snapIndexChange', () => {\n    update();\n  });\n  on('snapGridLengthChange', () => {\n    render();\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n    }\n  });\n  on('lock unlock', () => {\n    update();\n  });\n  on('click', (_s, e) => {\n    const targetEl = e.target;\n    const el = makeElementsArray(swiper.pagination.el);\n    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit('paginationShow');\n      } else {\n        emit('paginationHide');\n      }\n      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n    }\n    init();\n    render();\n    update();\n  };\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update,\n    init,\n    destroy\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/scrollbar.mjs\n\n\n\n\n\nfunction Scrollbar(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const document = getDocument();\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n      scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`\n    }\n  });\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null\n  };\n  function setTranslate() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n      dragEl.style.width = `${newSize}px`;\n    } else {\n      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n      dragEl.style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      el.style.opacity = 1;\n      timeout = setTimeout(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n  }\n  function setTransition(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n  }\n  function updateSize() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const {\n      scrollbar\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    dragEl.style.width = '';\n    dragEl.style.height = '';\n    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.width = `${dragSize}px`;\n    } else {\n      dragEl.style.height = `${dragSize}px`;\n    }\n    if (divider >= 1) {\n      el.style.display = 'none';\n    } else {\n      el.style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      el.style.opacity = 0;\n    }\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function getPointerPosition(e) {\n    return swiper.isHorizontal() ? e.clientX : e.clientY;\n  }\n  function setDragPosition(e) {\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    let positionRatio;\n    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    isTouched = true;\n    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n    e.preventDefault();\n    e.stopPropagation();\n    wrapperEl.style.transitionDuration = '100ms';\n    dragEl.style.transitionDuration = '100ms';\n    setDragPosition(e);\n    clearTimeout(dragTimeout);\n    el.style.transitionDuration = '0ms';\n    if (params.hide) {\n      el.style.opacity = 1;\n    }\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n    }\n    emit('scrollbarDragStart', e);\n  }\n  function onDragMove(e) {\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    if (!isTouched) return;\n    if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;\n    setDragPosition(e);\n    wrapperEl.style.transitionDuration = '0ms';\n    el.style.transitionDuration = '0ms';\n    dragEl.style.transitionDuration = '0ms';\n    emit('scrollbarDragMove', e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    if (!isTouched) return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = '';\n      wrapperEl.style.transitionDuration = '';\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n    emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n  function events(method) {\n    const {\n      scrollbar,\n      params\n    } = swiper;\n    const el = scrollbar.el;\n    if (!el) return;\n    const target = el;\n    const activeListener = params.passiveListeners ? {\n      passive: false,\n      capture: false\n    } : false;\n    const passiveListener = params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    if (!target) return;\n    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    target[eventMethod]('pointerdown', onDragStart, activeListener);\n    document[eventMethod]('pointermove', onDragMove, activeListener);\n    document[eventMethod]('pointerup', onDragEnd, passiveListener);\n  }\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('on');\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('off');\n  }\n  function init() {\n    const {\n      scrollbar,\n      el: swiperEl\n    } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n      el: 'swiper-scrollbar'\n    });\n    const params = swiper.params.scrollbar;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = document.querySelectorAll(params.el);\n      if (!el.length) return;\n    } else if (!el) {\n      el = params.el;\n    }\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n      el = swiperEl.querySelector(params.el);\n    }\n    if (el.length > 0) el = el[0];\n    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    let dragEl;\n    if (el) {\n      dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));\n      if (!dragEl) {\n        dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n        el.append(dragEl);\n      }\n    }\n    Object.assign(scrollbar, {\n      el,\n      dragEl\n    });\n    if (params.draggable) {\n      enableDraggable();\n    }\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const el = swiper.scrollbar.el;\n    if (el) {\n      el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));\n    }\n    disableDraggable();\n  }\n  on('changeDirection', () => {\n    if (!swiper.scrollbar || !swiper.scrollbar.el) return;\n    const params = swiper.params.scrollbar;\n    let {\n      el\n    } = swiper.scrollbar;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on('init', () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      updateSize();\n      setTranslate();\n    }\n  });\n  on('update resize observerUpdate lock unlock changeDirection', () => {\n    updateSize();\n  });\n  on('setTranslate', () => {\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    setTransition(duration);\n  });\n  on('enable disable', () => {\n    const {\n      el\n    } = swiper.scrollbar;\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    }\n    init();\n    updateSize();\n    setTranslate();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize,\n    setTranslate,\n    init,\n    destroy\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/parallax.mjs\n\n\nfunction Parallax(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    parallax: {\n      enabled: false\n    }\n  });\n  const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';\n  const setTransform = (el, progress) => {\n    const {\n      rtl\n    } = swiper;\n    const rtlFactor = rtl ? -1 : 1;\n    const p = el.getAttribute('data-swiper-parallax') || '0';\n    let x = el.getAttribute('data-swiper-parallax-x');\n    let y = el.getAttribute('data-swiper-parallax-y');\n    const scale = el.getAttribute('data-swiper-parallax-scale');\n    const opacity = el.getAttribute('data-swiper-parallax-opacity');\n    const rotate = el.getAttribute('data-swiper-parallax-rotate');\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n    if (x.indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      el.style.opacity = currentOpacity;\n    }\n    let transform = `translate3d(${x}, ${y}, 0px)`;\n    if (typeof scale !== 'undefined' && scale !== null) {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      transform += ` scale(${currentScale})`;\n    }\n    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n      const currentRotate = rotate * progress * -1;\n      transform += ` rotate(${currentRotate}deg)`;\n    }\n    el.style.transform = transform;\n  };\n  const setTranslate = () => {\n    const {\n      el,\n      slides,\n      progress,\n      snapGrid,\n      isElement\n    } = swiper;\n    const elements = elementChildren(el, elementsSelector);\n    if (swiper.isElement) {\n      elements.push(...elementChildren(swiper.hostEl, elementsSelector));\n    }\n    elements.forEach(subEl => {\n      setTransform(subEl, progress);\n    });\n    slides.forEach((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {\n        setTransform(subEl, slideProgress);\n      });\n    });\n  };\n  const setTransition = function (duration) {\n    if (duration === void 0) {\n      duration = swiper.params.speed;\n    }\n    const {\n      el,\n      hostEl\n    } = swiper;\n    const elements = [...el.querySelectorAll(elementsSelector)];\n    if (swiper.isElement) {\n      elements.push(...hostEl.querySelectorAll(elementsSelector));\n    }\n    elements.forEach(parallaxEl => {\n      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n      if (duration === 0) parallaxDuration = 0;\n      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n    });\n  };\n  on('beforeInit', () => {\n    if (!swiper.params.parallax.enabled) return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on('init', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTransition', (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled) return;\n    setTransition(duration);\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/zoom.mjs\n\n\n\nfunction Zoom(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      limitToOriginalSize: false,\n      maxRatio: 3,\n      minRatio: 1,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed'\n    }\n  });\n  swiper.zoom = {\n    enabled: false\n  };\n  let currentScale = 1;\n  let isScaling = false;\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    imageEl: undefined,\n    imageWrapEl: undefined,\n    maxRatio: 3\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {}\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined\n  };\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    }\n  });\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2) return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function getMaxRatio() {\n    const params = swiper.params.zoom;\n    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {\n      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;\n      return Math.min(imageMaxRatio, maxRatio);\n    }\n    return maxRatio;\n  }\n  function getScaleOrigin() {\n    if (evCache.length < 2) return {\n      x: null,\n      y: null\n    };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n  }\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector)) return true;\n    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector)) return true;\n    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    if (e.pointerType === 'mouse') {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = undefined;\n        return;\n      }\n      gesture.maxRatio = getMaxRatio();\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = '0ms';\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n    if (!gesture.imageEl) {\n      return;\n    }\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e)) return;\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = undefined;\n    }\n  }\n  let allowTouchMoveTimeout;\n  function allowTouchMove() {\n    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;\n  }\n  function preventTouchMove() {\n    clearTimeout(allowTouchMoveTimeout);\n    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;\n    allowTouchMoveTimeout = setTimeout(() => {\n      allowTouchMove();\n    });\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {\n      return;\n    }\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) {\n      return;\n    }\n    if (!image.isTouched || !gesture.slideEl) {\n      return;\n    }\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n    if (!image.isMoved && !isScaling) {\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n        image.isTouched = false;\n        allowTouchMove();\n        return;\n      }\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n        image.isTouched = false;\n        allowTouchMove();\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    preventTouchMove();\n    image.isMoved = true;\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const {\n      originX,\n      originY\n    } = gesture;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = undefined;\n      gesture.imageEl = undefined;\n      gesture.imageWrapEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n    const forceZoomRatio = typeof e === 'number' ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = undefined;\n      touchY = undefined;\n    }\n    const maxRatio = getMaxRatio();\n    zoom.scale = forceZoomRatio || maxRatio;\n    currentScale = forceZoomRatio || maxRatio;\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n      translateX = diffX * zoom.scale;\n      translateY = diffY * zoom.scale;\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = undefined;\n    gesture.originX = 0;\n    gesture.originY = 0;\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\n      passive: false,\n      capture: true\n    } : true;\n    return {\n      passiveListener,\n      activeListenerWithCapture\n    };\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    zoom.enabled = false;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd();\n  });\n  on('doubleTap', (_s, e) => {\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/controller.mjs\n\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nfunction Controller(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide' // or 'container'\n    }\n  });\n\n  swiper.controller = {\n    control: undefined\n  };\n  function LinearSpline(x, y) {\n    const binarySearch = function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n    };\n    return this;\n  }\n  function getInterpolateFunction(c) {\n    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n  }\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n    function setControlledTranslate(c) {\n      if (c.destroyed) return;\n\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n          multiplier = 1;\n        }\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      if (c.destroyed) return;\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        elementTransitionEnd(c.wrapperEl, () => {\n          if (!controlled) return;\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n  on('beforeInit', () => {\n    if (typeof window !== 'undefined' && (\n    // eslint-disable-line\n    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n      const controlElement = document.querySelector(swiper.params.controller.control);\n      if (controlElement && controlElement.swiper) {\n        swiper.controller.control = controlElement.swiper;\n      } else if (controlElement) {\n        const onControllerSwiper = e => {\n          swiper.controller.control = e.detail[0];\n          swiper.update();\n          controlElement.removeEventListener('init', onControllerSwiper);\n        };\n        controlElement.addEventListener('init', onControllerSwiper);\n      }\n      return;\n    }\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/a11y.mjs\n\n\n\n\nfunction A11y(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n      slideLabelMessage: '{{index}} / {{slidesLength}}',\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: 'group',\n      id: null\n    }\n  });\n  swiper.a11y = {\n    clicked: false\n  };\n  let liveRegion = null;\n  let preventFocusHandler;\n  let focusTargetSlideEl;\n  let visibilityChangedTimestamp = new Date().getTime();\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0) return;\n    notification.innerHTML = '';\n    notification.innerHTML = message;\n  }\n  function getRandomNumber(size) {\n    if (size === void 0) {\n      size = 16;\n    }\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return 'x'.repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('tabIndex', '0');\n    });\n  }\n  function makeElNotFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('tabIndex', '-1');\n    });\n  }\n  function addElRole(el, role) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('role', role);\n    });\n  }\n  function addElRoleDescription(el, description) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-roledescription', description);\n    });\n  }\n  function addElControls(el, controls) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-controls', controls);\n    });\n  }\n  function addElLabel(el, label) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-label', label);\n    });\n  }\n  function addElId(el, id) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('id', id);\n    });\n  }\n  function addElLive(el, live) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-live', live);\n    });\n  }\n  function disableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-disabled', true);\n    });\n  }\n  function enableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-disabled', false);\n    });\n  }\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32) return;\n    const params = swiper.params.a11y;\n    const targetEl = e.target;\n    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n    }\n    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {\n      const prevEls = makeElementsArray(swiper.navigation.prevEl);\n      const nextEls = makeElementsArray(swiper.navigation.nextEl);\n      if (nextEls.includes(targetEl)) {\n        if (!(swiper.isEnd && !swiper.params.loop)) {\n          swiper.slideNext();\n        }\n        if (swiper.isEnd) {\n          notify(params.lastSlideMessage);\n        } else {\n          notify(params.nextSlideMessage);\n        }\n      }\n      if (prevEls.includes(targetEl)) {\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\n          swiper.slidePrev();\n        }\n        if (swiper.isBeginning) {\n          notify(params.firstSlideMessage);\n        } else {\n          notify(params.prevSlideMessage);\n        }\n      }\n    }\n    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n      targetEl.click();\n    }\n  }\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (prevEl) {\n      if (swiper.isBeginning) {\n        disableEl(prevEl);\n        makeElNotFocusable(prevEl);\n      } else {\n        enableEl(prevEl);\n        makeElFocusable(prevEl);\n      }\n    }\n    if (nextEl) {\n      if (swiper.isEnd) {\n        disableEl(nextEl);\n        makeElNotFocusable(nextEl);\n      } else {\n        enableEl(nextEl);\n        makeElFocusable(nextEl);\n      }\n    }\n  }\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination()) return;\n    swiper.pagination.bullets.forEach(bulletEl => {\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable(bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole(bulletEl, 'button');\n          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n        }\n      }\n      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n        bulletEl.setAttribute('aria-current', 'true');\n      } else {\n        bulletEl.removeAttribute('aria-current');\n      }\n    });\n  }\n  const initNavEl = (el, wrapperId, message) => {\n    makeElFocusable(el);\n    if (el.tagName !== 'BUTTON') {\n      addElRole(el, 'button');\n      el.addEventListener('keydown', onEnterOrSpaceKey);\n    }\n    addElLabel(el, message);\n    addElControls(el, wrapperId);\n  };\n  const handlePointerDown = e => {\n    if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {\n      preventFocusHandler = true;\n    }\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    preventFocusHandler = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        if (!swiper.destroyed) {\n          swiper.a11y.clicked = false;\n        }\n      });\n    });\n  };\n  const onVisibilityChange = e => {\n    visibilityChangedTimestamp = new Date().getTime();\n  };\n  const handleFocus = e => {\n    if (swiper.a11y.clicked) return;\n    if (new Date().getTime() - visibilityChangedTimestamp < 100) return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n    if (!slideEl || !swiper.slides.includes(slideEl)) return;\n    focusTargetSlideEl = slideEl;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible) return;\n    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    requestAnimationFrame(() => {\n      if (preventFocusHandler) return;\n      if (swiper.params.loop) {\n        swiper.slideToLoop(parseInt(slideEl.getAttribute('data-swiper-slide-index')), 0);\n      } else {\n        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n      }\n      preventFocusHandler = false;\n    });\n  };\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole(swiper.slides, params.slideRole);\n    }\n    const slidesLength = swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.forEach((slideEl, index) => {\n        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n        const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel(slideEl, ariaLabelMessage);\n      });\n    }\n  };\n  const init = () => {\n    const params = swiper.params.a11y;\n    swiper.el.append(liveRegion);\n\n    // Container\n    const containerEl = swiper.el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel(containerEl, params.containerMessage);\n    }\n\n    // Wrapper\n    const wrapperEl = swiper.wrapperEl;\n    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n    addElId(wrapperEl, wrapperId);\n    addElLive(wrapperEl, live);\n\n    // Slide\n    initSlides();\n\n    // Navigation\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n    }\n    if (prevEl) {\n      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = makeElementsArray(swiper.pagination.el);\n      paginationEl.forEach(el => {\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    swiper.el.addEventListener('focus', handleFocus, true);\n    swiper.el.addEventListener('focus', handleFocus, true);\n    swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.addEventListener('pointerup', handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion) liveRegion.remove();\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n    if (prevEl) {\n      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = makeElementsArray(swiper.pagination.el);\n      paginationEl.forEach(el => {\n        el.removeEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n    // Tab focus\n    if (swiper.el && typeof swiper.el !== 'string') {\n      swiper.el.removeEventListener('focus', handleFocus, true);\n      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n    }\n  }\n  on('beforeInit', () => {\n    liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n    liveRegion.setAttribute('aria-live', 'assertive');\n    liveRegion.setAttribute('aria-atomic', 'true');\n  });\n  on('afterInit', () => {\n    if (!swiper.params.a11y.enabled) return;\n    init();\n  });\n  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n    if (!swiper.params.a11y.enabled) return;\n    initSlides();\n  });\n  on('fromEdge toEdge afterInit lock unlock', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updateNavigation();\n  });\n  on('paginationUpdate', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updatePagination();\n  });\n  on('destroy', () => {\n    if (!swiper.params.a11y.enabled) return;\n    destroy();\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/history.mjs\n\n\nfunction History(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    history: {\n      enabled: false,\n      root: '',\n      replaceState: false,\n      key: 'slides',\n      keepQuery: false\n    }\n  });\n  let initialized = false;\n  let paths = {};\n  const slugify = text => {\n    return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n  };\n  const getPathValues = urlOverride => {\n    const window = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window.location;\n    }\n    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return {\n      key,\n      value\n    };\n  };\n  const setHistory = (key, index) => {\n    const window = getWindow();\n    if (!initialized || !swiper.params.history.enabled) return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window.location;\n    }\n    const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${index}\"]`) : swiper.slides[index];\n    let value = slugify(slide.getAttribute('data-history'));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n      value = `${root}/${key ? `${key}/` : ''}${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key ? `${key}/` : ''}${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({\n        value\n      }, null, value);\n    } else {\n      window.history.pushState({\n        value\n      }, null, value);\n    }\n  };\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides[i];\n        const slideHistory = slugify(slide.getAttribute('data-history'));\n        if (slideHistory === value) {\n          const index = swiper.getSlideIndex(slide);\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n  const init = () => {\n    const window = getWindow();\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) {\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n      return;\n    }\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', setHistoryPopState);\n    }\n  };\n  on('init', () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/hash-navigation.mjs\n\n\n\nfunction HashNavigation(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    on\n  } = _ref;\n  let initialized = false;\n  const document = getDocument();\n  const window = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n      getSlideIndex(_s, hash) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n          if (!slideWithHash) return 0;\n          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n          return index;\n        }\n        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n      }\n    }\n  });\n  const onHashChange = () => {\n    emit('hashChange');\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled) return;\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n      window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n      emit('hashSet');\n    } else {\n      document.location.hash = activeSlideHash || '';\n      emit('hashSet');\n    }\n  };\n  const init = () => {\n    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n    initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      window.addEventListener('hashchange', onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      window.removeEventListener('hashchange', onHashChange);\n    }\n  };\n  on('init', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/autoplay.mjs\n\n\n/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nfunction Autoplay(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit,\n    params\n  } = _ref;\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: false,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime();\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let slideChanged;\n  let pausedByInteraction;\n  let pausedByPointerEnter;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {\n      return;\n    }\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n  const run = delayForce => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n    autoplayDelayTotal = swiper.params.autoplay.delay;\n    autoplayDelayCurrent = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n      delay = currentSlideDelay;\n      autoplayDelayTotal = currentSlideDelay;\n      autoplayDelayCurrent = currentSlideDelay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n  const start = () => {\n    autoplayStartTime = new Date().getTime();\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      if (slideChanged) {\n        autoplayTimeLeft = swiper.params.autoplay.delay;\n      }\n      slideChanged = false;\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n  const onPointerEnter = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pausedByPointerEnter = true;\n    if (swiper.animating || swiper.autoplay.paused) return;\n    pause(true);\n  };\n  const onPointerLeave = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByPointerEnter = false;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    if (swiper.el && typeof swiper.el !== 'string') {\n      swiper.el.removeEventListener('pointerenter', onPointerEnter);\n      swiper.el.removeEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      start();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on('_freeModeStaticRelease', () => {\n    if (pausedByTouch || pausedByInteraction) {\n      resume();\n    }\n  });\n  on('_freeModeNoMomentumRelease', () => {\n    if (!swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    slideChanged = true;\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/thumbs.mjs\n\n\n\nfunction Thumb(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-thumbs'\n    }\n  });\n  let initialized = false;\n  let swiperCreated = false;\n  swiper.thumbs = {\n    swiper: null\n  };\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      swiper.slideToLoop(slideToIndex);\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n  function init() {\n    const {\n      thumbs: thumbsParams\n    } = swiper.params;\n    if (initialized) return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper.update();\n    } else if (utils_isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', onThumbClick);\n    return true;\n  }\n  function update(initial) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n    thumbsToActivate = Math.floor(thumbsToActivate);\n    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n          slideEl.classList.add(thumbActiveClass);\n        });\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        if (thumbsSwiper.slides[swiper.realIndex + i]) {\n          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n        }\n      }\n    }\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      const currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n      }\n    }\n  }\n  on('beforeInit', () => {\n    const {\n      thumbs\n    } = swiper.params;\n    if (!thumbs || !thumbs.swiper) return;\n    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n      const document = getDocument();\n      const getThumbsElementAndInit = () => {\n        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n        if (thumbsElement && thumbsElement.swiper) {\n          thumbs.swiper = thumbsElement.swiper;\n          init();\n          update(true);\n        } else if (thumbsElement) {\n          const onThumbsSwiper = e => {\n            thumbs.swiper = e.detail[0];\n            thumbsElement.removeEventListener('init', onThumbsSwiper);\n            init();\n            update(true);\n            thumbs.swiper.update();\n            swiper.update();\n          };\n          thumbsElement.addEventListener('init', onThumbsSwiper);\n        }\n        return thumbsElement;\n      };\n      const watchForThumbsToAppear = () => {\n        if (swiper.destroyed) return;\n        const thumbsElement = getThumbsElementAndInit();\n        if (!thumbsElement) {\n          requestAnimationFrame(watchForThumbsToAppear);\n        }\n      };\n      requestAnimationFrame(watchForThumbsToAppear);\n    } else {\n      init();\n      update(true);\n    }\n  });\n  on('slideChange update resize observerUpdate', () => {\n    update();\n  });\n  on('setTransition', (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on('beforeDestroy', () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n  Object.assign(swiper.thumbs, {\n    init,\n    update\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/free-mode.mjs\n\n\nfunction freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      emit('_freeModeStaticRelease');\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/grid.mjs\nfunction Grid(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: 'column'\n    }\n  });\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n  let wasMultiRow;\n  const getSpaceBetween = () => {\n    let spaceBetween = swiper.params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    return spaceBetween;\n  };\n  const initSlides = slides => {\n    const {\n      slidesPerView\n    } = swiper.params;\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== 'auto' && fill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n    slidesPerRow = slidesNumberEvenToRows / rows;\n  };\n  const unsetSlides = () => {\n    if (swiper.slides) {\n      swiper.slides.forEach(slide => {\n        if (slide.swiperSlideGridSet) {\n          slide.style.height = '';\n          slide.style[swiper.getDirectionLabel('margin-top')] = '';\n        }\n      });\n    }\n  };\n  const updateSlide = (i, slide, slides) => {\n    const {\n      slidesPerGroup\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n    // Set slides order\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === 'row' && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n      slide.style.order = newSlideOrderIndex;\n    } else if (fill === 'column') {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide.row = row;\n    slide.column = column;\n    slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;\n    slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n    slide.swiperSlideGridSet = true;\n  };\n  const updateWrapperSize = (slideSize, snapGrid) => {\n    const {\n      centeredSlides,\n      roundLengths\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows\n    } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    if (!swiper.params.cssMode) {\n      swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.splice(0, snapGrid.length);\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n  const onInit = () => {\n    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;\n  };\n  const onUpdate = () => {\n    const {\n      params,\n      el\n    } = swiper;\n    const isMultiRow = params.grid && params.grid.rows > 1;\n    if (wasMultiRow && !isMultiRow) {\n      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n      numFullColumns = 1;\n      swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n      el.classList.add(`${params.containerModifierClass}grid`);\n      if (params.grid.fill === 'column') {\n        el.classList.add(`${params.containerModifierClass}grid-column`);\n      }\n      swiper.emitContainerClasses();\n    }\n    wasMultiRow = isMultiRow;\n  };\n  on('init', onInit);\n  on('update', onUpdate);\n  swiper.grid = {\n    initSlides,\n    unsetSlides,\n    updateSlide,\n    updateWrapperSize\n  };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/manipulation.mjs\nfunction appendSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  const appendElement = slideEl => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.append(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.append(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) appendElement(slides[i]);\n    }\n  } else {\n    appendElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n}\n\nfunction prependSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  const prependElement = slideEl => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      tempDOM.innerHTML = slideEl;\n      slidesEl.prepend(tempDOM.children[0]);\n      tempDOM.innerHTML = '';\n    } else {\n      slidesEl.prepend(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) prependElement(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    prependElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\nfunction addSlide(index, slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.recalcSlides();\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides[i];\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) slidesEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    slidesEl.append(slides);\n  }\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    slidesEl.append(slidesBuffer[i]);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeSlide(slidesIndexes) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeAllSlides() {\n  const swiper = this;\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n\nfunction Manipulation(_ref) {\n  let {\n    swiper\n  } = _ref;\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper)\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/effect-init.mjs\nfunction effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.forEach(slideEl => {\n        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/effect-target.mjs\n\n\nfunction effectTarget(effectParams, slideEl) {\n  const transformEl = getSlideTransformEl(slideEl);\n  if (transformEl !== slideEl) {\n    transformEl.style.backfaceVisibility = 'hidden';\n    transformEl.style['-webkit-backface-visibility'] = 'hidden';\n  }\n  return transformEl;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/effect-virtual-transition-end.mjs\n\n\nfunction effectVirtualTransitionEnd(_ref) {\n  let {\n    swiper,\n    duration,\n    transformElements,\n    allSlides\n  } = _ref;\n  const {\n    activeIndex\n  } = swiper;\n  const getSlide = el => {\n    if (!el.parentElement) {\n      // assume shadow root\n      const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n      return slide;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter(transformEl => {\n        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach(el => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-fade.mjs\n\n\n\n\n\nfunction EffectFade(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    fadeEffect: {\n      crossFade: false\n    }\n  });\n  const setTranslate = () => {\n    const {\n      slides\n    } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = swiper.slides[i];\n      const offset = slideEl.swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.opacity = slideOpacity;\n      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-cube.mjs\n\n\n\nfunction EffectCube(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94\n    }\n  });\n  const createSlideShadows = (slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n      slideEl.append(shadowBefore);\n    }\n    if (!shadowAfter) {\n      shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n      slideEl.append(shadowAfter);\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    // create new ones\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.forEach(slideEl => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows(slideEl, progress, isHorizontal);\n    });\n  };\n  const setTranslate = () => {\n    const {\n      el,\n      wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser\n    } = swiper;\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          swiper.wrapperEl.append(cubeShadowEl);\n        }\n        cubeShadowEl.style.height = `${swiperWidth}px`;\n      } else {\n        cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          el.append(cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n        if (swiper.browser && swiper.browser.need3dFix && Math.abs(wrapperRotate) / 90 % 2 === 1) {\n          wrapperRotate += 0.001;\n        }\n      }\n      slideEl.style.transform = transform;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, isHorizontal);\n      }\n    }\n    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;\n      }\n    }\n    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n  };\n  const setTransition = duration => {\n    const {\n      el,\n      slides\n    } = swiper;\n    slides.forEach(slideEl => {\n      slideEl.style.transitionDuration = `${duration}ms`;\n      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n        subEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      const shadowEl = el.querySelector('.swiper-cube-shadow');\n      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n    }\n  };\n  effectInit({\n    effect: 'cube',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/shared/create-shadow.mjs\n\n\nfunction createShadow(suffix, slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n  const shadowContainer = getSlideTransformEl(slideEl);\n  let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n  if (!shadowEl) {\n    shadowEl = createElement('div', shadowClass.split(' '));\n    shadowContainer.append(shadowEl);\n  }\n  return shadowEl;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-flip.mjs\n\n\n\n\n\n\nfunction EffectFlip(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true\n    }\n  });\n  const createSlideShadows = (slideEl, progress) => {\n    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n    }\n    if (!shadowAfter) {\n      shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    // Set shadows\n    swiper.params.flipEffect;\n    swiper.slides.forEach(slideEl => {\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows(slideEl, progress);\n    });\n  };\n  const setTranslate = () => {\n    const {\n      slides,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.flipEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n      if (swiper.browser && swiper.browser.need3dFix) {\n        if (Math.abs(rotateY) / 90 % 2 === 1) {\n          rotateY += 0.001;\n        }\n        if (Math.abs(rotateX) / 90 % 2 === 1) {\n          rotateX += 0.001;\n        }\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: 'flip',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-coverflow.mjs\n\n\n\n\n\nfunction EffectCoverflow(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true\n    }\n  });\n  const setTranslate = () => {\n    const {\n      width: swiperWidth,\n      height: swiperHeight,\n      slides,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const slideEl = slides[i];\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = slideEl.swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = parseFloat(params.stretch) / 100 * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n      if (swiper.browser && swiper.browser.need3dFix) {\n        if (Math.abs(rotateY) / 90 % 2 === 1) {\n          rotateY += 0.001;\n        }\n        if (Math.abs(rotateX) / 90 % 2 === 1) {\n          rotateX += 0.001;\n        }\n      }\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = slideTransform;\n      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBeforeEl) {\n          shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n        }\n        if (!shadowAfterEl) {\n          shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n        }\n        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n  };\n  effectInit({\n    effect: 'coverflow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-creative.mjs\n\n\n\n\n\n\nfunction EffectCreative(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    creativeEffect: {\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      }\n    }\n  });\n  const getTranslateValue = value => {\n    if (typeof value === 'string') return value;\n    return `${value}px`;\n  };\n  const setTranslate = () => {\n    const {\n      slides,\n      wrapperEl,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.creativeEffect;\n    const {\n      progressMultiplier: multiplier\n    } = params;\n    const isCenteredSlides = swiper.params.centeredSlides;\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n      let originalProgress = progress;\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      // set translate\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n      });\n      // set rotates\n      r.forEach((value, index) => {\n        let val = data.rotate[index] * Math.abs(progress * multiplier);\n        if (swiper.browser && swiper.browser.need3dFix && Math.abs(val) / 90 % 2 === 1) {\n          val += 0.001;\n        }\n        r[index] = val;\n      });\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const translateString = t.join(', ');\n      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n      // Set shadows\n      if (custom && data.shadow || !custom) {\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl && data.shadow) {\n          shadowEl = createShadow('creative', slideEl);\n        }\n        if (shadowEl) {\n          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n      targetEl.style.opacity = opacityString;\n      if (data.origin) {\n        targetEl.style.transformOrigin = data.origin;\n      }\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: 'creative',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/modules/effect-cards.mjs\n\n\n\n\n\n\nfunction EffectCards(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on\n  } = _ref;\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8\n    }\n  });\n  const setTranslate = () => {\n    const {\n      slides,\n      activeIndex,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.cardsEffect;\n    const {\n      startTranslate,\n      isTouched\n    } = swiper.touchEventsData;\n    const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = slideEl.swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${-25 * subProgress * Math.abs(progress)}%`;\n      }\n      if (progress < 0) {\n        // next\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        // prev\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n      /* eslint-disable */\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n      /* eslint-enable */\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl) {\n          shadowEl = createShadow('cards', slideEl);\n        }\n        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: 'cards',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/swiper/swiper-bundle.mjs\n/**\n * Swiper 11.1.4\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2024 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: May 30, 2024\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Swiper Class\nconst modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\nSwiper.use(modules);\n\n\n\n;// CONCATENATED MODULE: ./src/js/swiper.js\n\n\nvar swiper = new Swiper(\".swiper\", {\n  slidesPerView: 4,\n  autoWidth: true,\n  breakpoints: {\n    200: {\n      slidesPerView: 1,\n      spaceBetween: 12\n    },\n    425: {\n      slidesPerView: 2,\n      spaceBetween: 14\n    },\n    768: {\n      slidesPerView: 3,\n      spaceBetween: 24\n    },\n    1024: {\n      slidesPerView: 4\n    }\n  },\n  spaceBetween: 32,\n  navigation: {\n    nextEl: \".popular__next\",\n    prevEl: \".popular__prew\"\n  }\n});\n\n// Testimonials swiper config\n\nvar swiperConfig = {\n  direction: \"vertical\",\n  slidesPerView: \"auto\",\n  spaceBetween: 32,\n  grabCursor: true,\n  freeMode: true,\n  speed: 6000,\n  loop: true,\n  autoplay: {\n    delay: 0.0,\n    disableOnInteraction: false\n  },\n  loopAdditionalSlides: 9\n};\nvar swiperHorizontalConfig = {\n  slidesPerView: 3,\n  autoHeight: true,\n  breakpoints: {\n    200: {\n      slidesPerView: 1\n    },\n    480: {\n      slidesPerView: 2\n    },\n    780: {\n      slidesPerView: 3\n    }\n  },\n  spaceBetween: 20,\n  speed: 6000,\n  loop: true,\n  grabCursor: true,\n  freeMode: true,\n  autoplay: {\n    delay: 0.0,\n    disableOnInteraction: false\n  }\n};\nvar testimonialsSwiper;\nvar testimonialsSwiper2;\nvar testimonialsSwiper3;\nvar testimonialsHorizontal;\nvar swiperBreackpoint = window.matchMedia(\"(max-width: 1024px)\");\nvar swiperTestimonials = function swiperTestimonials() {\n  if (swiperBreackpoint.matches === true) {\n    if (testimonialsSwiper) {\n      testimonialsSwiper.destroy(true, true);\n      testimonialsSwiper = undefined;\n    }\n    if (testimonialsSwiper2) {\n      testimonialsSwiper2.destroy(true, true);\n      testimonialsSwiper2 = undefined;\n    }\n    if (testimonialsSwiper3) {\n      testimonialsSwiper3.destroy(true, true);\n      testimonialsSwiper3 = undefined;\n    }\n    horizontalSwiper();\n    return;\n  } else if (!swiperBreackpoint.matches) {\n    if (testimonialsHorizontal) {\n      testimonialsHorizontal.destroy(true, true);\n      testimonialsHorizontal = undefined;\n    }\n    testimonialsSwipers();\n    return;\n  }\n};\nvar testimonialsSwipers = function testimonialsSwipers() {\n  testimonialsSwiper = new Swiper(\".testimonials__first-block\", swiperConfig);\n  testimonialsSwiper2 = new Swiper(\".testimonials__second-block\", swiperConfig);\n  testimonialsSwiper3 = new Swiper(\".testimonials__third-block\", swiperConfig);\n};\nvar horizontalSwiper = function horizontalSwiper() {\n  testimonialsHorizontal = new Swiper(\".testimonials__horizontal-slider\", swiperHorizontalConfig);\n};\nswiperBreackpoint.addListener(swiperTestimonials);\nswiperTestimonials();\n;// CONCATENATED MODULE: ./node_modules/is-dom-node/dist/is-dom-node.es.js\n/*! @license is-dom-node v1.0.4\n\n\tCopyright 2018 Fisssion LLC.\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\n*/\nfunction isDomNode(x) {\n\treturn typeof window.Node === 'object'\n\t\t? x instanceof window.Node\n\t\t: x !== null &&\n\t\t\t\ttypeof x === 'object' &&\n\t\t\t\ttypeof x.nodeType === 'number' &&\n\t\t\t\ttypeof x.nodeName === 'string'\n}\n\n/* harmony default export */ var is_dom_node_es = (isDomNode);\n\n;// CONCATENATED MODULE: ./node_modules/is-dom-node-list/dist/is-dom-node-list.es.js\n/*! @license is-dom-node-list v1.2.1\n\n\tCopyright 2018 Fisssion LLC.\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\n*/\n\n\nfunction isDomNodeList(x) {\n\tvar prototypeToString = Object.prototype.toString.call(x);\n\tvar regex = /^\\[object (HTMLCollection|NodeList|Object)\\]$/;\n\n\treturn typeof window.NodeList === 'object'\n\t\t? x instanceof window.NodeList\n\t\t: x !== null &&\n\t\t\t\ttypeof x === 'object' &&\n\t\t\t\ttypeof x.length === 'number' &&\n\t\t\t\tregex.test(prototypeToString) &&\n\t\t\t\t(x.length === 0 || is_dom_node_es(x[0]))\n}\n\n/* harmony default export */ var is_dom_node_list_es = (isDomNodeList);\n\n;// CONCATENATED MODULE: ./node_modules/tealight/dist/tealight.es.js\n/*! @license Tealight v0.3.6\n\n\tCopyright 2018 Fisssion LLC.\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\n*/\n\n\n\nfunction tealight(target, context) {\n  if ( context === void 0 ) context = document;\n\n  if (target instanceof Array) { return target.filter(is_dom_node_es); }\n  if (is_dom_node_es(target)) { return [target]; }\n  if (is_dom_node_list_es(target)) { return Array.prototype.slice.call(target); }\n  if (typeof target === \"string\") {\n    try {\n      var query = context.querySelectorAll(target);\n      return Array.prototype.slice.call(query);\n    } catch (err) {\n      return [];\n    }\n  }\n  return [];\n}\n\n/* harmony default export */ var tealight_es = (tealight);\n\n;// CONCATENATED MODULE: ./node_modules/rematrix/dist/rematrix.es.js\n/*! @license Rematrix v0.3.0\n\n\tCopyright 2018 Julian Lloyd.\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n*/\n/**\n * @module Rematrix\n */\n\n/**\n * Transformation matrices in the browser come in two flavors:\n *\n *  - `matrix` using 6 values (short)\n *  - `matrix3d` using 16 values (long)\n *\n * This utility follows this [conversion guide](https://goo.gl/EJlUQ1)\n * to expand short form matrices to their equivalent long form.\n *\n * @param  {array} source - Accepts both short and long form matrices.\n * @return {array}\n */\nfunction format(source) {\n\tif (source.constructor !== Array) {\n\t\tthrow new TypeError('Expected array.')\n\t}\n\tif (source.length === 16) {\n\t\treturn source\n\t}\n\tif (source.length === 6) {\n\t\tvar matrix = identity();\n\t\tmatrix[0] = source[0];\n\t\tmatrix[1] = source[1];\n\t\tmatrix[4] = source[2];\n\t\tmatrix[5] = source[3];\n\t\tmatrix[12] = source[4];\n\t\tmatrix[13] = source[5];\n\t\treturn matrix\n\t}\n\tthrow new RangeError('Expected array with either 6 or 16 values.')\n}\n\n/**\n * Returns a matrix representing no transformation. The product of any matrix\n * multiplied by the identity matrix will be the original matrix.\n *\n * > **Tip:** Similar to how `5 * 1 === 5`, where `1` is the identity.\n *\n * @return {array}\n */\nfunction identity() {\n\tvar matrix = [];\n\tfor (var i = 0; i < 16; i++) {\n\t\ti % 5 == 0 ? matrix.push(1) : matrix.push(0);\n\t}\n\treturn matrix\n}\n\n/**\n * Returns a matrix describing the inverse transformation of the source\n * matrix. The product of any matrix multiplied by its inverse will be the\n * identity matrix.\n *\n * > **Tip:** Similar to how `5 * (1/5) === 1`, where `1/5` is the inverse.\n *\n * @param  {array} source - Accepts both short and long form matrices.\n * @return {array}\n */\nfunction inverse(source) {\n\tvar m = format(source);\n\n\tvar s0 = m[0] * m[5] - m[4] * m[1];\n\tvar s1 = m[0] * m[6] - m[4] * m[2];\n\tvar s2 = m[0] * m[7] - m[4] * m[3];\n\tvar s3 = m[1] * m[6] - m[5] * m[2];\n\tvar s4 = m[1] * m[7] - m[5] * m[3];\n\tvar s5 = m[2] * m[7] - m[6] * m[3];\n\n\tvar c5 = m[10] * m[15] - m[14] * m[11];\n\tvar c4 = m[9] * m[15] - m[13] * m[11];\n\tvar c3 = m[9] * m[14] - m[13] * m[10];\n\tvar c2 = m[8] * m[15] - m[12] * m[11];\n\tvar c1 = m[8] * m[14] - m[12] * m[10];\n\tvar c0 = m[8] * m[13] - m[12] * m[9];\n\n\tvar determinant = 1 / (s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0);\n\n\tif (isNaN(determinant) || determinant === Infinity) {\n\t\tthrow new Error('Inverse determinant attempted to divide by zero.')\n\t}\n\n\treturn [\n\t\t(m[5] * c5 - m[6] * c4 + m[7] * c3) * determinant,\n\t\t(-m[1] * c5 + m[2] * c4 - m[3] * c3) * determinant,\n\t\t(m[13] * s5 - m[14] * s4 + m[15] * s3) * determinant,\n\t\t(-m[9] * s5 + m[10] * s4 - m[11] * s3) * determinant,\n\n\t\t(-m[4] * c5 + m[6] * c2 - m[7] * c1) * determinant,\n\t\t(m[0] * c5 - m[2] * c2 + m[3] * c1) * determinant,\n\t\t(-m[12] * s5 + m[14] * s2 - m[15] * s1) * determinant,\n\t\t(m[8] * s5 - m[10] * s2 + m[11] * s1) * determinant,\n\n\t\t(m[4] * c4 - m[5] * c2 + m[7] * c0) * determinant,\n\t\t(-m[0] * c4 + m[1] * c2 - m[3] * c0) * determinant,\n\t\t(m[12] * s4 - m[13] * s2 + m[15] * s0) * determinant,\n\t\t(-m[8] * s4 + m[9] * s2 - m[11] * s0) * determinant,\n\n\t\t(-m[4] * c3 + m[5] * c1 - m[6] * c0) * determinant,\n\t\t(m[0] * c3 - m[1] * c1 + m[2] * c0) * determinant,\n\t\t(-m[12] * s3 + m[13] * s1 - m[14] * s0) * determinant,\n\t\t(m[8] * s3 - m[9] * s1 + m[10] * s0) * determinant\n\t]\n}\n\n/**\n * Returns a 4x4 matrix describing the combined transformations\n * of both arguments.\n *\n * > **Note:** Order is very important. For example, rotating 45°\n * along the Z-axis, followed by translating 500 pixels along the\n * Y-axis... is not the same as translating 500 pixels along the\n * Y-axis, followed by rotating 45° along on the Z-axis.\n *\n * @param  {array} m - Accepts both short and long form matrices.\n * @param  {array} x - Accepts both short and long form matrices.\n * @return {array}\n */\nfunction multiply(m, x) {\n\tvar fm = format(m);\n\tvar fx = format(x);\n\tvar product = [];\n\n\tfor (var i = 0; i < 4; i++) {\n\t\tvar row = [fm[i], fm[i + 4], fm[i + 8], fm[i + 12]];\n\t\tfor (var j = 0; j < 4; j++) {\n\t\t\tvar k = j * 4;\n\t\t\tvar col = [fx[k], fx[k + 1], fx[k + 2], fx[k + 3]];\n\t\t\tvar result =\n\t\t\t\trow[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];\n\n\t\t\tproduct[i + k] = result;\n\t\t}\n\t}\n\n\treturn product\n}\n\n/**\n * Attempts to return a 4x4 matrix describing the CSS transform\n * matrix passed in, but will return the identity matrix as a\n * fallback.\n *\n * > **Tip:** This method is used to convert a CSS matrix (retrieved as a\n * `string` from computed styles) to its equivalent array format.\n *\n * @param  {string} source - `matrix` or `matrix3d` CSS Transform value.\n * @return {array}\n */\nfunction parse(source) {\n\tif (typeof source === 'string') {\n\t\tvar match = source.match(/matrix(3d)?\\(([^)]+)\\)/);\n\t\tif (match) {\n\t\t\tvar raw = match[2].split(', ').map(parseFloat);\n\t\t\treturn format(raw)\n\t\t}\n\t}\n\treturn identity()\n}\n\n/**\n * Returns a 4x4 matrix describing Z-axis rotation.\n *\n * > **Tip:** This is just an alias for `Rematrix.rotateZ` for parity with CSS\n *\n * @param  {number} angle - Measured in degrees.\n * @return {array}\n */\nfunction rotate(angle) {\n\treturn rotateZ(angle)\n}\n\n/**\n * Returns a 4x4 matrix describing X-axis rotation.\n *\n * @param  {number} angle - Measured in degrees.\n * @return {array}\n */\nfunction rotateX(angle) {\n\tvar theta = Math.PI / 180 * angle;\n\tvar matrix = identity();\n\n\tmatrix[5] = matrix[10] = Math.cos(theta);\n\tmatrix[6] = matrix[9] = Math.sin(theta);\n\tmatrix[9] *= -1;\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Y-axis rotation.\n *\n * @param  {number} angle - Measured in degrees.\n * @return {array}\n */\nfunction rotateY(angle) {\n\tvar theta = Math.PI / 180 * angle;\n\tvar matrix = identity();\n\n\tmatrix[0] = matrix[10] = Math.cos(theta);\n\tmatrix[2] = matrix[8] = Math.sin(theta);\n\tmatrix[2] *= -1;\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Z-axis rotation.\n *\n * @param  {number} angle - Measured in degrees.\n * @return {array}\n */\nfunction rotateZ(angle) {\n\tvar theta = Math.PI / 180 * angle;\n\tvar matrix = identity();\n\n\tmatrix[0] = matrix[5] = Math.cos(theta);\n\tmatrix[1] = matrix[4] = Math.sin(theta);\n\tmatrix[4] *= -1;\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing 2D scaling. The first argument\n * is used for both X and Y-axis scaling, unless an optional\n * second argument is provided to explicitly define Y-axis scaling.\n *\n * @param  {number} scalar    - Decimal multiplier.\n * @param  {number} [scalarY] - Decimal multiplier.\n * @return {array}\n */\nfunction scale(scalar, scalarY) {\n\tvar matrix = identity();\n\n\tmatrix[0] = scalar;\n\tmatrix[5] = typeof scalarY === 'number' ? scalarY : scalar;\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing X-axis scaling.\n *\n * @param  {number} scalar - Decimal multiplier.\n * @return {array}\n */\nfunction scaleX(scalar) {\n\tvar matrix = identity();\n\tmatrix[0] = scalar;\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Y-axis scaling.\n *\n * @param  {number} scalar - Decimal multiplier.\n * @return {array}\n */\nfunction scaleY(scalar) {\n\tvar matrix = identity();\n\tmatrix[5] = scalar;\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Z-axis scaling.\n *\n * @param  {number} scalar - Decimal multiplier.\n * @return {array}\n */\nfunction scaleZ(scalar) {\n\tvar matrix = identity();\n\tmatrix[10] = scalar;\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing shear. The first argument\n * defines X-axis shearing, and an optional second argument\n * defines Y-axis shearing.\n *\n * @param  {number} angleX   - Measured in degrees.\n * @param  {number} [angleY] - Measured in degrees.\n * @return {array}\n */\nfunction skew(angleX, angleY) {\n\tvar thetaX = Math.PI / 180 * angleX;\n\tvar matrix = identity();\n\n\tmatrix[4] = Math.tan(thetaX);\n\n\tif (angleY) {\n\t\tvar thetaY = Math.PI / 180 * angleY;\n\t\tmatrix[1] = Math.tan(thetaY);\n\t}\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing X-axis shear.\n *\n * @param  {number} angle - Measured in degrees.\n * @return {array}\n */\nfunction skewX(angle) {\n\tvar theta = Math.PI / 180 * angle;\n\tvar matrix = identity();\n\n\tmatrix[4] = Math.tan(theta);\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Y-axis shear.\n *\n * @param  {number} angle - Measured in degrees\n * @return {array}\n */\nfunction skewY(angle) {\n\tvar theta = Math.PI / 180 * angle;\n\tvar matrix = identity();\n\n\tmatrix[1] = Math.tan(theta);\n\n\treturn matrix\n}\n\n/**\n * Returns a CSS Transform property value equivalent to the source matrix.\n *\n * @param  {array} source - Accepts both short and long form matrices.\n * @return {string}\n */\nfunction rematrix_es_toString(source) {\n\treturn (\"matrix3d(\" + (format(source).join(', ')) + \")\")\n}\n\n/**\n * Returns a 4x4 matrix describing 2D translation. The first\n * argument defines X-axis translation, and an optional second\n * argument defines Y-axis translation.\n *\n * @param  {number} distanceX   - Measured in pixels.\n * @param  {number} [distanceY] - Measured in pixels.\n * @return {array}\n */\nfunction rematrix_es_translate(distanceX, distanceY) {\n\tvar matrix = identity();\n\tmatrix[12] = distanceX;\n\n\tif (distanceY) {\n\t\tmatrix[13] = distanceY;\n\t}\n\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing X-axis translation.\n *\n * @param  {number} distance - Measured in pixels.\n * @return {array}\n */\nfunction translateX(distance) {\n\tvar matrix = identity();\n\tmatrix[12] = distance;\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Y-axis translation.\n *\n * @param  {number} distance - Measured in pixels.\n * @return {array}\n */\nfunction translateY(distance) {\n\tvar matrix = identity();\n\tmatrix[13] = distance;\n\treturn matrix\n}\n\n/**\n * Returns a 4x4 matrix describing Z-axis translation.\n *\n * @param  {number} distance - Measured in pixels.\n * @return {array}\n */\nfunction translateZ(distance) {\n\tvar matrix = identity();\n\tmatrix[14] = distance;\n\treturn matrix\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/miniraf/dist/miniraf.es.js\n/*! @license miniraf v1.0.0\n\n\tCopyright 2018 Fisssion LLC.\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\n*/\nvar polyfill = (function () {\n\tvar clock = Date.now();\n\n\treturn function (callback) {\n\t\tvar currentTime = Date.now();\n\t\tif (currentTime - clock > 16) {\n\t\t\tclock = currentTime;\n\t\t\tcallback(currentTime);\n\t\t} else {\n\t\t\tsetTimeout(function () { return polyfill(callback); }, 0);\n\t\t}\n\t}\n})();\n\nvar index = window.requestAnimationFrame ||\n\twindow.webkitRequestAnimationFrame ||\n\twindow.mozRequestAnimationFrame ||\n\tpolyfill;\n\n/* harmony default export */ var miniraf_es = (index);\n\n;// CONCATENATED MODULE: ./node_modules/scrollreveal/dist/scrollreveal.es.js\n/*! @license ScrollReveal v4.0.9\n\n\tCopyright 2021 Fisssion LLC.\n\n\tLicensed under the GNU General Public License 3.0 for\n\tcompatible open source projects and non-commercial use.\n\n\tFor commercial sites, themes, projects, and applications,\n\tkeep your source code private/proprietary by purchasing\n\ta commercial license from https://scrollrevealjs.org/\n*/\n\n\n\n\nvar scrollreveal_es_defaults = {\n\tdelay: 0,\n\tdistance: '0',\n\tduration: 600,\n\teasing: 'cubic-bezier(0.5, 0, 0, 1)',\n\tinterval: 0,\n\topacity: 0,\n\torigin: 'bottom',\n\trotate: {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t},\n\tscale: 1,\n\tcleanup: false,\n\tcontainer: document.documentElement,\n\tdesktop: true,\n\tmobile: true,\n\treset: false,\n\tuseDelay: 'always',\n\tviewFactor: 0.0,\n\tviewOffset: {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: 0,\n\t\tleft: 0\n\t},\n\tafterReset: function afterReset() {},\n\tafterReveal: function afterReveal() {},\n\tbeforeReset: function beforeReset() {},\n\tbeforeReveal: function beforeReveal() {}\n};\n\nfunction failure() {\n\tdocument.documentElement.classList.remove('sr');\n\n\treturn {\n\t\tclean: function clean() {},\n\t\tdestroy: function destroy() {},\n\t\treveal: function reveal() {},\n\t\tsync: function sync() {},\n\t\tget noop() {\n\t\t\treturn true\n\t\t}\n\t}\n}\n\nfunction success() {\n\tdocument.documentElement.classList.add('sr');\n\n\tif (document.body) {\n\t\tdocument.body.style.height = '100%';\n\t} else {\n\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\tdocument.body.style.height = '100%';\n\t\t});\n\t}\n}\n\nvar mount = { success: success, failure: failure };\n\nfunction scrollreveal_es_isObject(x) {\n\treturn (\n\t\tx !== null &&\n\t\tx instanceof Object &&\n\t\t(x.constructor === Object ||\n\t\t\tObject.prototype.toString.call(x) === '[object Object]')\n\t)\n}\n\nfunction each(collection, callback) {\n\tif (scrollreveal_es_isObject(collection)) {\n\t\tvar keys = Object.keys(collection);\n\t\treturn keys.forEach(function (key) { return callback(collection[key], key, collection); })\n\t}\n\tif (collection instanceof Array) {\n\t\treturn collection.forEach(function (item, i) { return callback(item, i, collection); })\n\t}\n\tthrow new TypeError('Expected either an array or object literal.')\n}\n\nfunction logger(message) {\n\tvar details = [], len = arguments.length - 1;\n\twhile ( len-- > 0 ) details[ len ] = arguments[ len + 1 ];\n\n\tif (this.constructor.debug && console) {\n\t\tvar report = \"%cScrollReveal: \" + message;\n\t\tdetails.forEach(function (detail) { return (report += \"\\n — \" + detail); });\n\t\tconsole.log(report, 'color: #ea654b;'); // eslint-disable-line no-console\n\t}\n}\n\nfunction rinse() {\n\tvar this$1 = this;\n\n\tvar struct = function () { return ({\n\t\tactive: [],\n\t\tstale: []\n\t}); };\n\n\tvar elementIds = struct();\n\tvar sequenceIds = struct();\n\tvar containerIds = struct();\n\n\t/**\n\t * Take stock of active element IDs.\n\t */\n\ttry {\n\t\teach(tealight_es('[data-sr-id]'), function (node) {\n\t\t\tvar id = parseInt(node.getAttribute('data-sr-id'));\n\t\t\telementIds.active.push(id);\n\t\t});\n\t} catch (e) {\n\t\tthrow e\n\t}\n\t/**\n\t * Destroy stale elements.\n\t */\n\teach(this.store.elements, function (element) {\n\t\tif (elementIds.active.indexOf(element.id) === -1) {\n\t\t\telementIds.stale.push(element.id);\n\t\t}\n\t});\n\n\teach(elementIds.stale, function (staleId) { return delete this$1.store.elements[staleId]; });\n\n\t/**\n\t * Take stock of active container and sequence IDs.\n\t */\n\teach(this.store.elements, function (element) {\n\t\tif (containerIds.active.indexOf(element.containerId) === -1) {\n\t\t\tcontainerIds.active.push(element.containerId);\n\t\t}\n\t\tif (element.hasOwnProperty('sequence')) {\n\t\t\tif (sequenceIds.active.indexOf(element.sequence.id) === -1) {\n\t\t\t\tsequenceIds.active.push(element.sequence.id);\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * Destroy stale containers.\n\t */\n\teach(this.store.containers, function (container) {\n\t\tif (containerIds.active.indexOf(container.id) === -1) {\n\t\t\tcontainerIds.stale.push(container.id);\n\t\t}\n\t});\n\n\teach(containerIds.stale, function (staleId) {\n\t\tvar stale = this$1.store.containers[staleId].node;\n\t\tstale.removeEventListener('scroll', this$1.delegate);\n\t\tstale.removeEventListener('resize', this$1.delegate);\n\t\tdelete this$1.store.containers[staleId];\n\t});\n\n\t/**\n\t * Destroy stale sequences.\n\t */\n\teach(this.store.sequences, function (sequence) {\n\t\tif (sequenceIds.active.indexOf(sequence.id) === -1) {\n\t\t\tsequenceIds.stale.push(sequence.id);\n\t\t}\n\t});\n\n\teach(sequenceIds.stale, function (staleId) { return delete this$1.store.sequences[staleId]; });\n}\n\nvar getPrefixedCssProp = (function () {\n\tvar properties = {};\n\tvar style = document.documentElement.style;\n\n\tfunction getPrefixedCssProperty(name, source) {\n\t\tif ( source === void 0 ) source = style;\n\n\t\tif (name && typeof name === 'string') {\n\t\t\tif (properties[name]) {\n\t\t\t\treturn properties[name]\n\t\t\t}\n\t\t\tif (typeof source[name] === 'string') {\n\t\t\t\treturn (properties[name] = name)\n\t\t\t}\n\t\t\tif (typeof source[(\"-webkit-\" + name)] === 'string') {\n\t\t\t\treturn (properties[name] = \"-webkit-\" + name)\n\t\t\t}\n\t\t\tthrow new RangeError((\"Unable to find \\\"\" + name + \"\\\" style property.\"))\n\t\t}\n\t\tthrow new TypeError('Expected a string.')\n\t}\n\n\tgetPrefixedCssProperty.clearCache = function () { return (properties = {}); };\n\n\treturn getPrefixedCssProperty\n})();\n\nfunction style(element) {\n\tvar computed = window.getComputedStyle(element.node);\n\tvar position = computed.position;\n\tvar config = element.config;\n\n\t/**\n\t * Generate inline styles\n\t */\n\tvar inline = {};\n\tvar inlineStyle = element.node.getAttribute('style') || '';\n\tvar inlineMatch = inlineStyle.match(/[\\w-]+\\s*:\\s*[^;]+\\s*/gi) || [];\n\n\tinline.computed = inlineMatch ? inlineMatch.map(function (m) { return m.trim(); }).join('; ') + ';' : '';\n\n\tinline.generated = inlineMatch.some(function (m) { return m.match(/visibility\\s?:\\s?visible/i); })\n\t\t? inline.computed\n\t\t: inlineMatch.concat( ['visibility: visible']).map(function (m) { return m.trim(); }).join('; ') + ';';\n\n\t/**\n\t * Generate opacity styles\n\t */\n\tvar computedOpacity = parseFloat(computed.opacity);\n\tvar configOpacity = !isNaN(parseFloat(config.opacity))\n\t\t? parseFloat(config.opacity)\n\t\t: parseFloat(computed.opacity);\n\n\tvar opacity = {\n\t\tcomputed: computedOpacity !== configOpacity ? (\"opacity: \" + computedOpacity + \";\") : '',\n\t\tgenerated: computedOpacity !== configOpacity ? (\"opacity: \" + configOpacity + \";\") : ''\n\t};\n\n\t/**\n\t * Generate transformation styles\n\t */\n\tvar transformations = [];\n\n\tif (parseFloat(config.distance)) {\n\t\tvar axis = config.origin === 'top' || config.origin === 'bottom' ? 'Y' : 'X';\n\n\t\t/**\n\t\t * Let’s make sure our our pixel distances are negative for top and left.\n\t\t * e.g. { origin: 'top', distance: '25px' } starts at `top: -25px` in CSS.\n\t\t */\n\t\tvar distance = config.distance;\n\t\tif (config.origin === 'top' || config.origin === 'left') {\n\t\t\tdistance = /^-/.test(distance) ? distance.substr(1) : (\"-\" + distance);\n\t\t}\n\n\t\tvar ref = distance.match(/(^-?\\d+\\.?\\d?)|(em$|px$|%$)/g);\n\t\tvar value = ref[0];\n\t\tvar unit = ref[1];\n\n\t\tswitch (unit) {\n\t\t\tcase 'em':\n\t\t\t\tdistance = parseInt(computed.fontSize) * value;\n\t\t\t\tbreak\n\t\t\tcase 'px':\n\t\t\t\tdistance = value;\n\t\t\t\tbreak\n\t\t\tcase '%':\n\t\t\t\t/**\n\t\t\t\t * Here we use `getBoundingClientRect` instead of\n\t\t\t\t * the existing data attached to `element.geometry`\n\t\t\t\t * because only the former includes any transformations\n\t\t\t\t * current applied to the element.\n\t\t\t\t *\n\t\t\t\t * If that behavior ends up being unintuitive, this\n\t\t\t\t * logic could instead utilize `element.geometry.height`\n\t\t\t\t * and `element.geoemetry.width` for the distance calculation\n\t\t\t\t */\n\t\t\t\tdistance =\n\t\t\t\t\taxis === 'Y'\n\t\t\t\t\t\t? (element.node.getBoundingClientRect().height * value) / 100\n\t\t\t\t\t\t: (element.node.getBoundingClientRect().width * value) / 100;\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new RangeError('Unrecognized or missing distance unit.')\n\t\t}\n\n\t\tif (axis === 'Y') {\n\t\t\ttransformations.push(translateY(distance));\n\t\t} else {\n\t\t\ttransformations.push(translateX(distance));\n\t\t}\n\t}\n\n\tif (config.rotate.x) { transformations.push(rotateX(config.rotate.x)); }\n\tif (config.rotate.y) { transformations.push(rotateY(config.rotate.y)); }\n\tif (config.rotate.z) { transformations.push(rotateZ(config.rotate.z)); }\n\tif (config.scale !== 1) {\n\t\tif (config.scale === 0) {\n\t\t\t/**\n\t\t\t * The CSS Transforms matrix interpolation specification\n\t\t\t * basically disallows transitions of non-invertible\n\t\t\t * matrixes, which means browsers won't transition\n\t\t\t * elements with zero scale.\n\t\t\t *\n\t\t\t * That’s inconvenient for the API and developer\n\t\t\t * experience, so we simply nudge their value\n\t\t\t * slightly above zero; this allows browsers\n\t\t\t * to transition our element as expected.\n\t\t\t *\n\t\t\t * `0.0002` was the smallest number\n\t\t\t * that performed across browsers.\n\t\t\t */\n\t\t\ttransformations.push(scale(0.0002));\n\t\t} else {\n\t\t\ttransformations.push(scale(config.scale));\n\t\t}\n\t}\n\n\tvar transform = {};\n\tif (transformations.length) {\n\t\ttransform.property = getPrefixedCssProp('transform');\n\t\t/**\n\t\t * The default computed transform value should be one of:\n\t\t * undefined || 'none' || 'matrix()' || 'matrix3d()'\n\t\t */\n\t\ttransform.computed = {\n\t\t\traw: computed[transform.property],\n\t\t\tmatrix: parse(computed[transform.property])\n\t\t};\n\n\t\ttransformations.unshift(transform.computed.matrix);\n\t\tvar product = transformations.reduce(multiply);\n\n\t\ttransform.generated = {\n\t\t\tinitial: ((transform.property) + \": matrix3d(\" + (product.join(', ')) + \");\"),\n\t\t\tfinal: ((transform.property) + \": matrix3d(\" + (transform.computed.matrix.join(', ')) + \");\")\n\t\t};\n\t} else {\n\t\ttransform.generated = {\n\t\t\tinitial: '',\n\t\t\tfinal: ''\n\t\t};\n\t}\n\n\t/**\n\t * Generate transition styles\n\t */\n\tvar transition = {};\n\tif (opacity.generated || transform.generated.initial) {\n\t\ttransition.property = getPrefixedCssProp('transition');\n\t\ttransition.computed = computed[transition.property];\n\t\ttransition.fragments = [];\n\n\t\tvar delay = config.delay;\n\t\tvar duration = config.duration;\n\t\tvar easing = config.easing;\n\n\t\tif (opacity.generated) {\n\t\t\ttransition.fragments.push({\n\t\t\t\tdelayed: (\"opacity \" + (duration / 1000) + \"s \" + easing + \" \" + (delay / 1000) + \"s\"),\n\t\t\t\tinstant: (\"opacity \" + (duration / 1000) + \"s \" + easing + \" 0s\")\n\t\t\t});\n\t\t}\n\n\t\tif (transform.generated.initial) {\n\t\t\ttransition.fragments.push({\n\t\t\t\tdelayed: ((transform.property) + \" \" + (duration / 1000) + \"s \" + easing + \" \" + (delay / 1000) + \"s\"),\n\t\t\t\tinstant: ((transform.property) + \" \" + (duration / 1000) + \"s \" + easing + \" 0s\")\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * The default computed transition property should be undefined, or one of:\n\t\t * '' || 'none 0s ease 0s' || 'all 0s ease 0s' || 'all 0s 0s cubic-bezier()'\n\t\t */\n\t\tvar hasCustomTransition =\n\t\t\ttransition.computed && !transition.computed.match(/all 0s|none 0s/);\n\n\t\tif (hasCustomTransition) {\n\t\t\ttransition.fragments.unshift({\n\t\t\t\tdelayed: transition.computed,\n\t\t\t\tinstant: transition.computed\n\t\t\t});\n\t\t}\n\n\t\tvar composed = transition.fragments.reduce(\n\t\t\tfunction (composition, fragment, i) {\n\t\t\t\tcomposition.delayed += i === 0 ? fragment.delayed : (\", \" + (fragment.delayed));\n\t\t\t\tcomposition.instant += i === 0 ? fragment.instant : (\", \" + (fragment.instant));\n\t\t\t\treturn composition\n\t\t\t},\n\t\t\t{\n\t\t\t\tdelayed: '',\n\t\t\t\tinstant: ''\n\t\t\t}\n\t\t);\n\n\t\ttransition.generated = {\n\t\t\tdelayed: ((transition.property) + \": \" + (composed.delayed) + \";\"),\n\t\t\tinstant: ((transition.property) + \": \" + (composed.instant) + \";\")\n\t\t};\n\t} else {\n\t\ttransition.generated = {\n\t\t\tdelayed: '',\n\t\t\tinstant: ''\n\t\t};\n\t}\n\n\treturn {\n\t\tinline: inline,\n\t\topacity: opacity,\n\t\tposition: position,\n\t\ttransform: transform,\n\t\ttransition: transition\n\t}\n}\n\n/**\n * apply a CSS string to an element using the CSSOM (element.style) rather\n * than setAttribute, which may violate the content security policy.\n *\n * @param {Node}   [el]  Element to receive styles.\n * @param {string} [declaration] Styles to apply.\n */\nfunction applyStyle (el, declaration) {\n\tdeclaration.split(';').forEach(function (pair) {\n\t\tvar ref = pair.split(':');\n\t\tvar property = ref[0];\n\t\tvar value = ref.slice(1);\n\t\tif (property && value) {\n\t\t\tel.style[property.trim()] = value.join(':');\n\t\t}\n\t});\n}\n\nfunction clean(target) {\n\tvar this$1 = this;\n\n\tvar dirty;\n\ttry {\n\t\teach(tealight_es(target), function (node) {\n\t\t\tvar id = node.getAttribute('data-sr-id');\n\t\t\tif (id !== null) {\n\t\t\t\tdirty = true;\n\t\t\t\tvar element = this$1.store.elements[id];\n\t\t\t\tif (element.callbackTimer) {\n\t\t\t\t\twindow.clearTimeout(element.callbackTimer.clock);\n\t\t\t\t}\n\t\t\t\tapplyStyle(element.node, element.styles.inline.generated);\n\t\t\t\tnode.removeAttribute('data-sr-id');\n\t\t\t\tdelete this$1.store.elements[id];\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\treturn logger.call(this, 'Clean failed.', e.message)\n\t}\n\n\tif (dirty) {\n\t\ttry {\n\t\t\trinse.call(this);\n\t\t} catch (e) {\n\t\t\treturn logger.call(this, 'Clean failed.', e.message)\n\t\t}\n\t}\n}\n\nfunction destroy() {\n\tvar this$1 = this;\n\n\t/**\n\t * Remove all generated styles and element ids\n\t */\n\teach(this.store.elements, function (element) {\n\t\tapplyStyle(element.node, element.styles.inline.generated);\n\t\telement.node.removeAttribute('data-sr-id');\n\t});\n\n\t/**\n\t * Remove all event listeners.\n\t */\n\teach(this.store.containers, function (container) {\n\t\tvar target =\n\t\t\tcontainer.node === document.documentElement ? window : container.node;\n\t\ttarget.removeEventListener('scroll', this$1.delegate);\n\t\ttarget.removeEventListener('resize', this$1.delegate);\n\t});\n\n\t/**\n\t * Clear all data from the store\n\t */\n\tthis.store = {\n\t\tcontainers: {},\n\t\telements: {},\n\t\thistory: [],\n\t\tsequences: {}\n\t};\n}\n\nfunction deepAssign(target) {\n\tvar sources = [], len = arguments.length - 1;\n\twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n\tif (scrollreveal_es_isObject(target)) {\n\t\teach(sources, function (source) {\n\t\t\teach(source, function (data, key) {\n\t\t\t\tif (scrollreveal_es_isObject(data)) {\n\t\t\t\t\tif (!target[key] || !scrollreveal_es_isObject(target[key])) {\n\t\t\t\t\t\ttarget[key] = {};\n\t\t\t\t\t}\n\t\t\t\t\tdeepAssign(target[key], data);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = data;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn target\n\t} else {\n\t\tthrow new TypeError('Target must be an object literal.')\n\t}\n}\n\nfunction isMobile(agent) {\n\tif ( agent === void 0 ) agent = navigator.userAgent;\n\n\treturn /Android|iPhone|iPad|iPod/i.test(agent)\n}\n\nvar nextUniqueId = (function () {\n\tvar uid = 0;\n\treturn function () { return uid++; }\n})();\n\nfunction initialize() {\n\tvar this$1 = this;\n\n\trinse.call(this);\n\n\teach(this.store.elements, function (element) {\n\t\tvar styles = [element.styles.inline.generated];\n\n\t\tif (element.visible) {\n\t\t\tstyles.push(element.styles.opacity.computed);\n\t\t\tstyles.push(element.styles.transform.generated.final);\n\t\t\telement.revealed = true;\n\t\t} else {\n\t\t\tstyles.push(element.styles.opacity.generated);\n\t\t\tstyles.push(element.styles.transform.generated.initial);\n\t\t\telement.revealed = false;\n\t\t}\n\n\t\tapplyStyle(element.node, styles.filter(function (s) { return s !== ''; }).join(' '));\n\t});\n\n\teach(this.store.containers, function (container) {\n\t\tvar target =\n\t\t\tcontainer.node === document.documentElement ? window : container.node;\n\t\ttarget.addEventListener('scroll', this$1.delegate);\n\t\ttarget.addEventListener('resize', this$1.delegate);\n\t});\n\n\t/**\n\t * Manually invoke delegate once to capture\n\t * element and container dimensions, container\n\t * scroll position, and trigger any valid reveals\n\t */\n\tthis.delegate();\n\n\t/**\n\t * Wipe any existing `setTimeout` now\n\t * that initialization has completed.\n\t */\n\tthis.initTimeout = null;\n}\n\nfunction animate(element, force) {\n\tif ( force === void 0 ) force = {};\n\n\tvar pristine = force.pristine || this.pristine;\n\tvar delayed =\n\t\telement.config.useDelay === 'always' ||\n\t\t(element.config.useDelay === 'onload' && pristine) ||\n\t\t(element.config.useDelay === 'once' && !element.seen);\n\n\tvar shouldReveal = element.visible && !element.revealed;\n\tvar shouldReset = !element.visible && element.revealed && element.config.reset;\n\n\tif (force.reveal || shouldReveal) {\n\t\treturn triggerReveal.call(this, element, delayed)\n\t}\n\n\tif (force.reset || shouldReset) {\n\t\treturn triggerReset.call(this, element)\n\t}\n}\n\nfunction triggerReveal(element, delayed) {\n\tvar styles = [\n\t\telement.styles.inline.generated,\n\t\telement.styles.opacity.computed,\n\t\telement.styles.transform.generated.final\n\t];\n\tif (delayed) {\n\t\tstyles.push(element.styles.transition.generated.delayed);\n\t} else {\n\t\tstyles.push(element.styles.transition.generated.instant);\n\t}\n\telement.revealed = element.seen = true;\n\tapplyStyle(element.node, styles.filter(function (s) { return s !== ''; }).join(' '));\n\tregisterCallbacks.call(this, element, delayed);\n}\n\nfunction triggerReset(element) {\n\tvar styles = [\n\t\telement.styles.inline.generated,\n\t\telement.styles.opacity.generated,\n\t\telement.styles.transform.generated.initial,\n\t\telement.styles.transition.generated.instant\n\t];\n\telement.revealed = false;\n\tapplyStyle(element.node, styles.filter(function (s) { return s !== ''; }).join(' '));\n\tregisterCallbacks.call(this, element);\n}\n\nfunction registerCallbacks(element, isDelayed) {\n\tvar this$1 = this;\n\n\tvar duration = isDelayed\n\t\t? element.config.duration + element.config.delay\n\t\t: element.config.duration;\n\n\tvar beforeCallback = element.revealed\n\t\t? element.config.beforeReveal\n\t\t: element.config.beforeReset;\n\n\tvar afterCallback = element.revealed\n\t\t? element.config.afterReveal\n\t\t: element.config.afterReset;\n\n\tvar elapsed = 0;\n\tif (element.callbackTimer) {\n\t\telapsed = Date.now() - element.callbackTimer.start;\n\t\twindow.clearTimeout(element.callbackTimer.clock);\n\t}\n\n\tbeforeCallback(element.node);\n\n\telement.callbackTimer = {\n\t\tstart: Date.now(),\n\t\tclock: window.setTimeout(function () {\n\t\t\tafterCallback(element.node);\n\t\t\telement.callbackTimer = null;\n\t\t\tif (element.revealed && !element.config.reset && element.config.cleanup) {\n\t\t\t\tclean.call(this$1, element.node);\n\t\t\t}\n\t\t}, duration - elapsed)\n\t};\n}\n\nfunction sequence(element, pristine) {\n\tif ( pristine === void 0 ) pristine = this.pristine;\n\n\t/**\n\t * We first check if the element should reset.\n\t */\n\tif (!element.visible && element.revealed && element.config.reset) {\n\t\treturn animate.call(this, element, { reset: true })\n\t}\n\n\tvar seq = this.store.sequences[element.sequence.id];\n\tvar i = element.sequence.index;\n\n\tif (seq) {\n\t\tvar visible = new SequenceModel(seq, 'visible', this.store);\n\t\tvar revealed = new SequenceModel(seq, 'revealed', this.store);\n\n\t\tseq.models = { visible: visible, revealed: revealed };\n\n\t\t/**\n\t\t * If the sequence has no revealed members,\n\t\t * then we reveal the first visible element\n\t\t * within that sequence.\n\t\t *\n\t\t * The sequence then cues a recursive call\n\t\t * in both directions.\n\t\t */\n\t\tif (!revealed.body.length) {\n\t\t\tvar nextId = seq.members[visible.body[0]];\n\t\t\tvar nextElement = this.store.elements[nextId];\n\n\t\t\tif (nextElement) {\n\t\t\t\tcue.call(this, seq, visible.body[0], -1, pristine);\n\t\t\t\tcue.call(this, seq, visible.body[0], +1, pristine);\n\t\t\t\treturn animate.call(this, nextElement, { reveal: true, pristine: pristine })\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * If our element isn’t resetting, we check the\n\t\t * element sequence index against the head, and\n\t\t * then the foot of the sequence.\n\t\t */\n\t\tif (\n\t\t\t!seq.blocked.head &&\n\t\t\ti === [].concat( revealed.head ).pop() &&\n\t\t\ti >= [].concat( visible.body ).shift()\n\t\t) {\n\t\t\tcue.call(this, seq, i, -1, pristine);\n\t\t\treturn animate.call(this, element, { reveal: true, pristine: pristine })\n\t\t}\n\n\t\tif (\n\t\t\t!seq.blocked.foot &&\n\t\t\ti === [].concat( revealed.foot ).shift() &&\n\t\t\ti <= [].concat( visible.body ).pop()\n\t\t) {\n\t\t\tcue.call(this, seq, i, +1, pristine);\n\t\t\treturn animate.call(this, element, { reveal: true, pristine: pristine })\n\t\t}\n\t}\n}\n\nfunction Sequence(interval) {\n\tvar i = Math.abs(interval);\n\tif (!isNaN(i)) {\n\t\tthis.id = nextUniqueId();\n\t\tthis.interval = Math.max(i, 16);\n\t\tthis.members = [];\n\t\tthis.models = {};\n\t\tthis.blocked = {\n\t\t\thead: false,\n\t\t\tfoot: false\n\t\t};\n\t} else {\n\t\tthrow new RangeError('Invalid sequence interval.')\n\t}\n}\n\nfunction SequenceModel(seq, prop, store) {\n\tvar this$1 = this;\n\n\tthis.head = [];\n\tthis.body = [];\n\tthis.foot = [];\n\n\teach(seq.members, function (id, index) {\n\t\tvar element = store.elements[id];\n\t\tif (element && element[prop]) {\n\t\t\tthis$1.body.push(index);\n\t\t}\n\t});\n\n\tif (this.body.length) {\n\t\teach(seq.members, function (id, index) {\n\t\t\tvar element = store.elements[id];\n\t\t\tif (element && !element[prop]) {\n\t\t\t\tif (index < this$1.body[0]) {\n\t\t\t\t\tthis$1.head.push(index);\n\t\t\t\t} else {\n\t\t\t\t\tthis$1.foot.push(index);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction cue(seq, i, direction, pristine) {\n\tvar this$1 = this;\n\n\tvar blocked = ['head', null, 'foot'][1 + direction];\n\tvar nextId = seq.members[i + direction];\n\tvar nextElement = this.store.elements[nextId];\n\n\tseq.blocked[blocked] = true;\n\n\tsetTimeout(function () {\n\t\tseq.blocked[blocked] = false;\n\t\tif (nextElement) {\n\t\t\tsequence.call(this$1, nextElement, pristine);\n\t\t}\n\t}, seq.interval);\n}\n\nfunction reveal(target, options, syncing) {\n\tvar this$1 = this;\n\tif ( options === void 0 ) options = {};\n\tif ( syncing === void 0 ) syncing = false;\n\n\tvar containerBuffer = [];\n\tvar sequence$$1;\n\tvar interval = options.interval || scrollreveal_es_defaults.interval;\n\n\ttry {\n\t\tif (interval) {\n\t\t\tsequence$$1 = new Sequence(interval);\n\t\t}\n\n\t\tvar nodes = tealight_es(target);\n\t\tif (!nodes.length) {\n\t\t\tthrow new Error('Invalid reveal target.')\n\t\t}\n\n\t\tvar elements = nodes.reduce(function (elementBuffer, elementNode) {\n\t\t\tvar element = {};\n\t\t\tvar existingId = elementNode.getAttribute('data-sr-id');\n\n\t\t\tif (existingId) {\n\t\t\t\tdeepAssign(element, this$1.store.elements[existingId]);\n\n\t\t\t\t/**\n\t\t\t\t * In order to prevent previously generated styles\n\t\t\t\t * from throwing off the new styles, the style tag\n\t\t\t\t * has to be reverted to its pre-reveal state.\n\t\t\t\t */\n\t\t\t\tapplyStyle(element.node, element.styles.inline.computed);\n\t\t\t} else {\n\t\t\t\telement.id = nextUniqueId();\n\t\t\t\telement.node = elementNode;\n\t\t\t\telement.seen = false;\n\t\t\t\telement.revealed = false;\n\t\t\t\telement.visible = false;\n\t\t\t}\n\n\t\t\tvar config = deepAssign({}, element.config || this$1.defaults, options);\n\n\t\t\tif ((!config.mobile && isMobile()) || (!config.desktop && !isMobile())) {\n\t\t\t\tif (existingId) {\n\t\t\t\t\tclean.call(this$1, element);\n\t\t\t\t}\n\t\t\t\treturn elementBuffer // skip elements that are disabled\n\t\t\t}\n\n\t\t\tvar containerNode = tealight_es(config.container)[0];\n\t\t\tif (!containerNode) {\n\t\t\t\tthrow new Error('Invalid container.')\n\t\t\t}\n\t\t\tif (!containerNode.contains(elementNode)) {\n\t\t\t\treturn elementBuffer // skip elements found outside the container\n\t\t\t}\n\n\t\t\tvar containerId;\n\t\t\t{\n\t\t\t\tcontainerId = getContainerId(\n\t\t\t\t\tcontainerNode,\n\t\t\t\t\tcontainerBuffer,\n\t\t\t\t\tthis$1.store.containers\n\t\t\t\t);\n\t\t\t\tif (containerId === null) {\n\t\t\t\t\tcontainerId = nextUniqueId();\n\t\t\t\t\tcontainerBuffer.push({ id: containerId, node: containerNode });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telement.config = config;\n\t\t\telement.containerId = containerId;\n\t\t\telement.styles = style(element);\n\n\t\t\tif (sequence$$1) {\n\t\t\t\telement.sequence = {\n\t\t\t\t\tid: sequence$$1.id,\n\t\t\t\t\tindex: sequence$$1.members.length\n\t\t\t\t};\n\t\t\t\tsequence$$1.members.push(element.id);\n\t\t\t}\n\n\t\t\telementBuffer.push(element);\n\t\t\treturn elementBuffer\n\t\t}, []);\n\n\t\t/**\n\t\t * Modifying the DOM via setAttribute needs to be handled\n\t\t * separately from reading computed styles in the map above\n\t\t * for the browser to batch DOM changes (limiting reflows)\n\t\t */\n\t\teach(elements, function (element) {\n\t\t\tthis$1.store.elements[element.id] = element;\n\t\t\telement.node.setAttribute('data-sr-id', element.id);\n\t\t});\n\t} catch (e) {\n\t\treturn logger.call(this, 'Reveal failed.', e.message)\n\t}\n\n\t/**\n\t * Now that element set-up is complete...\n\t * Let’s commit any container and sequence data we have to the store.\n\t */\n\teach(containerBuffer, function (container) {\n\t\tthis$1.store.containers[container.id] = {\n\t\t\tid: container.id,\n\t\t\tnode: container.node\n\t\t};\n\t});\n\tif (sequence$$1) {\n\t\tthis.store.sequences[sequence$$1.id] = sequence$$1;\n\t}\n\n\t/**\n\t * If reveal wasn't invoked by sync, we want to\n\t * make sure to add this call to the history.\n\t */\n\tif (syncing !== true) {\n\t\tthis.store.history.push({ target: target, options: options });\n\n\t\t/**\n\t\t * Push initialization to the event queue, giving\n\t\t * multiple reveal calls time to be interpreted.\n\t\t */\n\t\tif (this.initTimeout) {\n\t\t\twindow.clearTimeout(this.initTimeout);\n\t\t}\n\t\tthis.initTimeout = window.setTimeout(initialize.bind(this), 0);\n\t}\n}\n\nfunction getContainerId(node) {\n\tvar collections = [], len = arguments.length - 1;\n\twhile ( len-- > 0 ) collections[ len ] = arguments[ len + 1 ];\n\n\tvar id = null;\n\teach(collections, function (collection) {\n\t\teach(collection, function (container) {\n\t\t\tif (id === null && container.node === node) {\n\t\t\t\tid = container.id;\n\t\t\t}\n\t\t});\n\t});\n\treturn id\n}\n\n/**\n * Re-runs the reveal method for each record stored in history,\n * for capturing new content asynchronously loaded into the DOM.\n */\nfunction sync() {\n\tvar this$1 = this;\n\n\teach(this.store.history, function (record) {\n\t\treveal.call(this$1, record.target, record.options, true);\n\t});\n\n\tinitialize.call(this);\n}\n\nvar scrollreveal_es_polyfill = function (x) { return (x > 0) - (x < 0) || +x; };\nvar mathSign = Math.sign || scrollreveal_es_polyfill;\n\nfunction getGeometry(target, isContainer) {\n\t/**\n\t * We want to ignore padding and scrollbars for container elements.\n\t * More information here: https://goo.gl/vOZpbz\n\t */\n\tvar height = isContainer ? target.node.clientHeight : target.node.offsetHeight;\n\tvar width = isContainer ? target.node.clientWidth : target.node.offsetWidth;\n\n\tvar offsetTop = 0;\n\tvar offsetLeft = 0;\n\tvar node = target.node;\n\n\tdo {\n\t\tif (!isNaN(node.offsetTop)) {\n\t\t\toffsetTop += node.offsetTop;\n\t\t}\n\t\tif (!isNaN(node.offsetLeft)) {\n\t\t\toffsetLeft += node.offsetLeft;\n\t\t}\n\t\tnode = node.offsetParent;\n\t} while (node)\n\n\treturn {\n\t\tbounds: {\n\t\t\ttop: offsetTop,\n\t\t\tright: offsetLeft + width,\n\t\t\tbottom: offsetTop + height,\n\t\t\tleft: offsetLeft\n\t\t},\n\t\theight: height,\n\t\twidth: width\n\t}\n}\n\nfunction getScrolled(container) {\n\tvar top, left;\n\tif (container.node === document.documentElement) {\n\t\ttop = window.pageYOffset;\n\t\tleft = window.pageXOffset;\n\t} else {\n\t\ttop = container.node.scrollTop;\n\t\tleft = container.node.scrollLeft;\n\t}\n\treturn { top: top, left: left }\n}\n\nfunction isElementVisible(element) {\n\tif ( element === void 0 ) element = {};\n\n\tvar container = this.store.containers[element.containerId];\n\tif (!container) { return }\n\n\tvar viewFactor = Math.max(0, Math.min(1, element.config.viewFactor));\n\tvar viewOffset = element.config.viewOffset;\n\n\tvar elementBounds = {\n\t\ttop: element.geometry.bounds.top + element.geometry.height * viewFactor,\n\t\tright: element.geometry.bounds.right - element.geometry.width * viewFactor,\n\t\tbottom: element.geometry.bounds.bottom - element.geometry.height * viewFactor,\n\t\tleft: element.geometry.bounds.left + element.geometry.width * viewFactor\n\t};\n\n\tvar containerBounds = {\n\t\ttop: container.geometry.bounds.top + container.scroll.top + viewOffset.top,\n\t\tright: container.geometry.bounds.right + container.scroll.left - viewOffset.right,\n\t\tbottom:\n\t\t\tcontainer.geometry.bounds.bottom + container.scroll.top - viewOffset.bottom,\n\t\tleft: container.geometry.bounds.left + container.scroll.left + viewOffset.left\n\t};\n\n\treturn (\n\t\t(elementBounds.top < containerBounds.bottom &&\n\t\t\telementBounds.right > containerBounds.left &&\n\t\t\telementBounds.bottom > containerBounds.top &&\n\t\t\telementBounds.left < containerBounds.right) ||\n\t\telement.styles.position === 'fixed'\n\t)\n}\n\nfunction delegate(\n\tevent,\n\telements\n) {\n\tvar this$1 = this;\n\tif ( event === void 0 ) event = { type: 'init' };\n\tif ( elements === void 0 ) elements = this.store.elements;\n\n\tminiraf_es(function () {\n\t\tvar stale = event.type === 'init' || event.type === 'resize';\n\n\t\teach(this$1.store.containers, function (container) {\n\t\t\tif (stale) {\n\t\t\t\tcontainer.geometry = getGeometry.call(this$1, container, true);\n\t\t\t}\n\t\t\tvar scroll = getScrolled.call(this$1, container);\n\t\t\tif (container.scroll) {\n\t\t\t\tcontainer.direction = {\n\t\t\t\t\tx: mathSign(scroll.left - container.scroll.left),\n\t\t\t\t\ty: mathSign(scroll.top - container.scroll.top)\n\t\t\t\t};\n\t\t\t}\n\t\t\tcontainer.scroll = scroll;\n\t\t});\n\n\t\t/**\n\t\t * Due to how the sequencer is implemented, it’s\n\t\t * important that we update the state of all\n\t\t * elements, before any animation logic is\n\t\t * evaluated (in the second loop below).\n\t\t */\n\t\teach(elements, function (element) {\n\t\t\tif (stale || element.geometry === undefined) {\n\t\t\t\telement.geometry = getGeometry.call(this$1, element);\n\t\t\t}\n\t\t\telement.visible = isElementVisible.call(this$1, element);\n\t\t});\n\n\t\teach(elements, function (element) {\n\t\t\tif (element.sequence) {\n\t\t\t\tsequence.call(this$1, element);\n\t\t\t} else {\n\t\t\t\tanimate.call(this$1, element);\n\t\t\t}\n\t\t});\n\n\t\tthis$1.pristine = false;\n\t});\n}\n\nfunction isTransformSupported() {\n\tvar style = document.documentElement.style;\n\treturn 'transform' in style || 'WebkitTransform' in style\n}\n\nfunction isTransitionSupported() {\n\tvar style = document.documentElement.style;\n\treturn 'transition' in style || 'WebkitTransition' in style\n}\n\nvar version = \"4.0.9\";\n\nvar boundDelegate;\nvar boundDestroy;\nvar boundReveal;\nvar boundClean;\nvar boundSync;\nvar config;\nvar debug;\nvar instance;\n\nfunction ScrollReveal(options) {\n\tif ( options === void 0 ) options = {};\n\n\tvar invokedWithoutNew =\n\t\ttypeof this === 'undefined' ||\n\t\tObject.getPrototypeOf(this) !== ScrollReveal.prototype;\n\n\tif (invokedWithoutNew) {\n\t\treturn new ScrollReveal(options)\n\t}\n\n\tif (!ScrollReveal.isSupported()) {\n\t\tlogger.call(this, 'Instantiation failed.', 'This browser is not supported.');\n\t\treturn mount.failure()\n\t}\n\n\tvar buffer;\n\ttry {\n\t\tbuffer = config\n\t\t\t? deepAssign({}, config, options)\n\t\t\t: deepAssign({}, scrollreveal_es_defaults, options);\n\t} catch (e) {\n\t\tlogger.call(this, 'Invalid configuration.', e.message);\n\t\treturn mount.failure()\n\t}\n\n\ttry {\n\t\tvar container = tealight_es(buffer.container)[0];\n\t\tif (!container) {\n\t\t\tthrow new Error('Invalid container.')\n\t\t}\n\t} catch (e) {\n\t\tlogger.call(this, e.message);\n\t\treturn mount.failure()\n\t}\n\n\tconfig = buffer;\n\n\tif ((!config.mobile && isMobile()) || (!config.desktop && !isMobile())) {\n\t\tlogger.call(\n\t\t\tthis,\n\t\t\t'This device is disabled.',\n\t\t\t(\"desktop: \" + (config.desktop)),\n\t\t\t(\"mobile: \" + (config.mobile))\n\t\t);\n\t\treturn mount.failure()\n\t}\n\n\tmount.success();\n\n\tthis.store = {\n\t\tcontainers: {},\n\t\telements: {},\n\t\thistory: [],\n\t\tsequences: {}\n\t};\n\n\tthis.pristine = true;\n\n\tboundDelegate = boundDelegate || delegate.bind(this);\n\tboundDestroy = boundDestroy || destroy.bind(this);\n\tboundReveal = boundReveal || reveal.bind(this);\n\tboundClean = boundClean || clean.bind(this);\n\tboundSync = boundSync || sync.bind(this);\n\n\tObject.defineProperty(this, 'delegate', { get: function () { return boundDelegate; } });\n\tObject.defineProperty(this, 'destroy', { get: function () { return boundDestroy; } });\n\tObject.defineProperty(this, 'reveal', { get: function () { return boundReveal; } });\n\tObject.defineProperty(this, 'clean', { get: function () { return boundClean; } });\n\tObject.defineProperty(this, 'sync', { get: function () { return boundSync; } });\n\n\tObject.defineProperty(this, 'defaults', { get: function () { return config; } });\n\tObject.defineProperty(this, 'version', { get: function () { return version; } });\n\tObject.defineProperty(this, 'noop', { get: function () { return false; } });\n\n\treturn instance ? instance : (instance = this)\n}\n\nScrollReveal.isSupported = function () { return isTransformSupported() && isTransitionSupported(); };\n\nObject.defineProperty(ScrollReveal, 'debug', {\n\tget: function () { return debug || false; },\n\tset: function (value) { return (debug = typeof value === 'boolean' ? value : debug); }\n});\n\nScrollReveal();\n\n/* harmony default export */ var scrollreveal_es = (ScrollReveal);\n\n;// CONCATENATED MODULE: ./src/js/reveal.js\n\nscrollreveal_es({\n  distance: \"60px\",\n  duration: 1000,\n  reset: true,\n  mobile: false\n});\nscrollreveal_es().reveal(\".header\", {\n  origin: \"top\"\n});\nscrollreveal_es().reveal(\".discover__desc\", {\n  origin: \"left\",\n  mobile: false\n});\nscrollreveal_es().reveal(\".discover__picture\", {\n  origin: \"right\",\n  mobile: false\n});\nscrollreveal_es().reveal(\".popular\", {\n  origin: \"right\",\n  mobile: false\n});\nscrollreveal_es().reveal(\".services\", {\n  origin: \"left\",\n  mobile: false\n});\nscrollreveal_es().reveal(\".explore\", {\n  origin: \"right\",\n  mobile: false\n});\n// EXTERNAL MODULE: ./src/js/mobile-menu.js\nvar mobile_menu = __webpack_require__(5579);\n;// CONCATENATED MODULE: ./src/main.js\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBTUEsU0FBUyxHQUFHLENBQ2hCLGFBQWEsRUFDYixTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxRQUFRLEVBQ1IscUJBQXFCLEVBQ3JCLFdBQVcsRUFDWCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFNBQVMsRUFDVCxZQUFZLEVBQ1osU0FBUyxFQUNULFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLFNBQVMsRUFDVCxTQUFTLEVBQ1QsUUFBUSxFQUNSLE9BQU8sRUFDUCxRQUFRLEVBQ1IsU0FBUyxFQUNULHdCQUF3QixFQUN4QixVQUFVLEVBQ1YsUUFBUSxFQUNSLFFBQVEsRUFDUixVQUFVLEVBQ1YsY0FBYyxFQUNkLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLFVBQVUsRUFDVixRQUFRLEVBQ1IsMEJBQTBCLEVBQzFCLE1BQU0sRUFDTixPQUFPLEVBQ1AsT0FBTyxFQUNQLFVBQVUsRUFDVixTQUFTLEVBQ1QsMkJBQTJCLEVBQzNCLFlBQVksRUFDWixlQUFlLEVBQ2YsU0FBUyxFQUNULE1BQU0sRUFDTixRQUFRLEVBQ1IsZ0JBQWdCLEVBQ2hCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsVUFBVSxFQUNWLG9CQUFvQixFQUNwQiwwQkFBMEIsRUFDMUIsU0FBUyxFQUNULE9BQU8sRUFDUCxhQUFhLEVBQ2IsbUJBQW1CLEVBQ25CLFNBQVMsRUFDVCxTQUFTLEVBQ1QsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsUUFBUSxFQUNSLE9BQU8sRUFDUCxRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxPQUFPLEVBQ1AsUUFBUSxFQUNSLFNBQVMsRUFDVCxXQUFXLEVBQ1gsUUFBUSxFQUNSLGVBQWUsRUFDZixRQUFRLEVBQ1IsT0FBTyxFQUNQLFVBQVUsRUFDVixTQUFTLEVBQ1QsU0FBUyxFQUNULE9BQU8sRUFDUCxXQUFXLEVBQ1gsTUFBTSxFQUNOLE1BQU0sRUFDTixvQkFBb0IsRUFDcEIsUUFBUSxFQUNSLE9BQU8sRUFDUCxTQUFTLEVBQ1QsT0FBTyxFQUNQLFFBQVEsRUFDUixZQUFZLEVBQ1osT0FBTyxFQUNQLFVBQVUsRUFDVixjQUFjLEVBQ2QsY0FBYyxFQUNkLFFBQVEsRUFDUixRQUFRLEVBQ1IsWUFBWSxFQUNaLE1BQU0sRUFDTixRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsT0FBTyxFQUNQLGVBQWUsRUFDZixXQUFXLEVBQ1gsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osUUFBUSxFQUNSLFVBQVUsRUFDVixVQUFVLEVBQ1YsTUFBTSxFQUNOLE9BQU8sRUFDUCxrQkFBa0IsRUFDbEIsWUFBWSxFQUNaLFdBQVcsRUFDWCxRQUFRLEVBQ1IsWUFBWSxFQUNaLFNBQVMsRUFDVCxRQUFRLEVBQ1IsVUFBVSxFQUNWLFlBQVksRUFDWixTQUFTLEVBQ1QsWUFBWSxFQUNaLFNBQVMsRUFDVCxTQUFTLEVBQ1QsT0FBTyxFQUNQLE9BQU8sRUFDUCxhQUFhLEVBQ2IsYUFBYSxFQUNiLFdBQVcsRUFDWCxPQUFPLEVBQ1AsU0FBUyxFQUNULFFBQVEsRUFDUixNQUFNLEVBQ04sVUFBVSxFQUNWLE9BQU8sRUFDUCxRQUFRLEVBQ1Isa0JBQWtCLEVBQ2xCLFVBQVUsRUFDVixNQUFNLEVBQ04sYUFBYSxFQUNiLFFBQVEsRUFDUixVQUFVLEVBQ1YsT0FBTyxFQUNQLFNBQVMsRUFDVCxRQUFRLEVBQ1IsUUFBUSxFQUNSLHVCQUF1QixFQUN2QixhQUFhLEVBQ2IsZUFBZSxFQUNmLE9BQU8sRUFDUCxZQUFZLEVBQ1osdUJBQXVCLEVBQ3ZCLGNBQWMsRUFDZCxTQUFTLEVBQ1QsUUFBUSxFQUNSLFlBQVksRUFDWixjQUFjLEVBQ2QsV0FBVyxFQUNYLFVBQVUsRUFDVixVQUFVLEVBQ1YsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxjQUFjLEVBQ2QsT0FBTyxFQUNQLFdBQVcsRUFDWCxPQUFPLEVBQ1AsVUFBVSxFQUNWLFdBQVcsRUFDWCxRQUFRLEVBQ1IsYUFBYSxFQUNiLE9BQU8sRUFDUCxRQUFRLEVBQ1IsWUFBWSxFQUNaLFVBQVUsRUFDVixVQUFVLEVBQ1YsTUFBTSxFQUNOLE9BQU8sRUFDUCxxQkFBcUIsRUFDckIsU0FBUyxFQUNULFFBQVEsRUFDUixjQUFjLEVBQ2QsUUFBUSxFQUNSLFFBQVEsRUFDUixTQUFTLEVBQ1Qsc0JBQXNCLEVBQ3RCLGdCQUFnQixFQUNoQixlQUFlLEVBQ2YsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsY0FBYyxFQUNkLFdBQVcsRUFDWCxTQUFTLEVBQ1QsT0FBTyxFQUNQLFFBQVEsRUFDUixVQUFVLEVBQ1YsV0FBVyxFQUNYLFNBQVMsRUFDVCxhQUFhLEVBQ2IsU0FBUyxFQUNULE9BQU8sRUFDUCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLFVBQVUsRUFDVixTQUFTLEVBQ1QsVUFBVSxFQUNWLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsU0FBUyxFQUNULFdBQVcsRUFDWCxTQUFTLEVBQ1QsT0FBTyxFQUNQLFVBQVUsRUFDVixRQUFRLEVBQ1IsUUFBUSxFQUNSLE9BQU8sRUFDUCxRQUFRLEVBQ1IsU0FBUyxFQUNULE9BQU8sRUFDUCxXQUFXLEVBQ1gsVUFBVSxFQUNWLE1BQU0sRUFDTixVQUFVLEVBQ1YsVUFBVSxFQUNWLFNBQVMsRUFDVCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFVBQVUsRUFDVixRQUFRLEVBQ1IsT0FBTyxFQUNQLE9BQU8sRUFDUCxNQUFNLEVBQ04sT0FBTyxFQUNQLFVBQVUsRUFDVixlQUFlLEVBQ2YsTUFBTSxFQUNOLFFBQVEsRUFDUixNQUFNLEVBQ04sUUFBUSxFQUNSLE9BQU8sRUFDUCxPQUFPLEVBQ1AsT0FBTyxFQUNQLFlBQVksRUFDWixXQUFXLEVBQ1gsVUFBVSxFQUNWLE1BQU0sRUFDTixRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxVQUFVLEVBQ1YsVUFBVSxFQUNWLFFBQVEsRUFDUixVQUFVLEVBQ1YsUUFBUSxFQUNSLFNBQVMsRUFDVCxPQUFPLEVBQ1AsT0FBTyxFQUNQLFNBQVMsRUFDVCxZQUFZLEVBQ1osV0FBVyxFQUNYLGdCQUFnQixFQUNoQixVQUFVLEVBQ1YsS0FBSyxFQUNMLE1BQU0sRUFDTixVQUFVLEVBQ1YsUUFBUSxFQUNSLFVBQVUsRUFDVixNQUFNLEVBQ04sUUFBUSxFQUNSLFlBQVksRUFDWixRQUFRLEVBQ1IsU0FBUyxFQUNULFdBQVcsRUFDWCxtQkFBbUIsRUFDbkIsU0FBUyxFQUNULFFBQVEsRUFDUixVQUFVLEVBQ1YsT0FBTyxFQUNQLFVBQVUsRUFDVixVQUFVLEVBQ1YsS0FBSyxFQUNMLGFBQWEsRUFDYixTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixPQUFPLEVBQ1AsY0FBYyxFQUNkLFFBQVEsRUFDUixRQUFRLEVBQ1IsWUFBWSxFQUNaLFNBQVMsRUFDVCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFdBQVcsRUFDWCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixPQUFPLEVBQ1AsTUFBTSxFQUNOLFdBQVcsRUFDWCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULEtBQUssRUFDTCxRQUFRLEVBQ1IsUUFBUSxDQUNUO0FBRUQsOENBQWVBLFNBQVMsRTs7QUN4VGdDO0FBQ2pCO0FBRXZDLElBQU1FLGNBQWMsR0FBRyxJQUFJRCw0QkFBWSxDQUFDO0VBQ3RDRSxRQUFRLEVBQUUsV0FBVztFQUNyQkMsV0FBVyxFQUFFLHFCQUFxQjtFQUNsQ0MsSUFBSSxFQUFFO0lBQ0pDLEdBQUcsRUFBRU4sU0FBUztJQUNkTyxLQUFLLEVBQUU7RUFDVCxDQUFDO0VBQ0RDLFVBQVUsRUFBRTtJQUNWQyxTQUFTLEVBQUU7RUFDYixDQUFDO0VBQ0RDLE1BQU0sRUFBRTtJQUNOQyxLQUFLLEVBQUU7TUFDTEMsU0FBUyxFQUFFLFNBQUFBLFVBQUNDLEtBQUssRUFBSztRQUNwQixJQUFNRCxTQUFTLEdBQUdDLEtBQUssQ0FBQ0MsTUFBTSxDQUFDRixTQUFTLENBQUNHLEtBQUs7UUFDOUNiLGNBQWMsQ0FBQ1MsS0FBSyxDQUFDSSxLQUFLLEdBQUdILFNBQVM7TUFDeEM7SUFDRjtFQUNGO0FBQ0YsQ0FBQyxDQUFDLEM7O0FDckJGLHFCQUFxQixpREFBaUQsb0RBQW9ELHNDQUFzQyw4QkFBOEIsVUFBVSxJQUFJLDhDQUE4Qyx1QkFBdUIsV0FBVyxXQUFXLEtBQUssMEJBQTBCLHdCQUF3QixhQUFhLFNBQVMsMEdBQTBHLCtCQUErQixvQ0FBb0MsbUJBQW1CLGtCQUFrQiwwQkFBMEIsbUNBQW1DLHVCQUF1QixRQUFRLElBQUksY0FBYyxzQ0FBc0MsV0FBVyxpSkFBaUosZ0RBQWdELDBCQUEwQiwwR0FBMEcsb0VBQW9FLDhDQUE4QyxzQkFBc0IsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxRQUFRLDRDQUE0QyxzQkFBc0IsNkRBQTZELGNBQWMsSUFBSSxxQkFBcUIsNkRBQTZELGFBQWEsSUFBSSwyQkFBMkIsVUFBVSwyQkFBMkIsMkJBQTJCLEVBQUUsVUFBVSxJQUFJLGVBQWUsNEJBQTRCLElBQUksSUFBSSxnQkFBZ0IsNEJBQTRCLEVBQUUsSUFBSSxpQkFBaUIsK0JBQStCLDJCQUEyQixJQUFJLGtCQUFrQiw4QkFBOEIsMEJBQTBCLElBQUksZUFBZSwwQkFBMEIsSUFBSSxJQUFJLGdCQUFnQiwwQkFBMEIsRUFBRSxJQUFJLHVCQUF1QiwyQkFBMkIsSUFBSSxJQUFJLHlCQUF5QiwyQkFBMkIsRUFBRSxJQUFJLGVBQWUsNkJBQTZCLElBQUksSUFBSSxnQkFBZ0IsNkJBQTZCLEVBQUUsSUFBSSxlQUFlLDZCQUE2QixJQUFJLElBQUksZ0JBQWdCLDZCQUE2QixFQUFFLElBQUksdUJBQXVCLHVDQUF1QyxLQUFLLDZDQUE2QywwQ0FBMEMsV0FBVyxtRUFBbUUseUJBQXlCLG9CQUFvQiw4R0FBOEcsUUFBUSxtQkFBbUIsV0FBVyxzQkFBc0Isa0JBQWtCLHdGQUF3RixzQkFBc0IsVUFBVSwrR0FBK0csd0dBQXdHLHdHQUF3RyxrR0FBa0cscUJBQXFCLFVBQVUsK0pBQStKLDRJQUE0SSxpRUFBaUUsMkNBQTJDLDJCQUEyQixVQUFVLGdLQUFnSyw2SUFBNkksaURBQWlELG9CQUFvQixVQUFVLCtKQUErSiw0SUFBNEksaUVBQWlFLDBDQUEwQywwQkFBMEIsVUFBVSxnS0FBZ0ssNklBQTZJLGdEQUFnRCxtQkFBbUIsVUFBVSxpS0FBaUssOElBQThJLHlDQUF5QyxnQkFBZ0IsVUFBVSxvREFBb0QsTUFBTSwwREFBMEQsWUFBWSxxQkFBcUIsVUFBVSxvREFBb0QsTUFBTSwwREFBMEQsWUFBWSxpQkFBaUIsVUFBVSwrRkFBK0YsdUVBQXVFLDZDQUE2QyxvQkFBb0IsU0FBUyxXQUFXLFdBQVcsS0FBSywwQkFBMEIsd0JBQXdCLGFBQWEsNkNBQTZDLG9DQUFvQyxrQkFBa0IsK0lBQStJLDJCQUEyQixlQUFlLDRKQUE0SixrQkFBa0IsVUFBVSxxREFBcUQsNkNBQTZDLHlDQUF5QyxtQkFBbUIsa0JBQWtCLFlBQVksbURBQW1ELG1EQUFtRCxzQ0FBc0MsbUJBQW1CLGVBQWUsWUFBWSx1Q0FBdUMsbUJBQW1CLGdCQUFnQixZQUFZLDhDQUE4QyxtQkFBbUIsdUJBQXVCLFlBQVkseUNBQXlDLG1CQUFtQixrQkFBa0IsWUFBWSx5Q0FBeUMsbUJBQW1CLGtCQUFrQixZQUFZLGtFQUFrRSxrRUFBa0UsbUJBQW1CLFFBQVEsT0FBTyxlQUFlLGNBQWMsWUFBWSw0RUFBNEUsRUFBRSxtQkFBbUIsRUFBRSxVQUFVLG9CQUFvQixnR0FBZ0csNkJBQTZCLGdDQUFnQywyQkFBMkIsK0RBQStELDZCQUE2QixFQUFFLGlCQUFpQix5Q0FBeUMsdVBBQXVQLHNDQUFzQyxFQUFFLGVBQWUsdUNBQXVDLHdDQUF3QyxzQ0FBc0MsOEJBQThCLHlCQUF5QixFQUFFLFlBQVksZ0NBQWdDLEtBQUssc0NBQXNDLHdDQUF3Qyw4Q0FBOEMsNkNBQTZDLHNEQUFzRCxFQUFFLHVDQUF1Qyw2Q0FBNkMsd0RBQXdELEVBQUUsNENBQTRDLDZDQUE2QyxvREFBb0QsRUFBRSx1RUFBdUUsNkNBQTZDLHNEQUFzRCw4QkFBOEIsb0RBQW9ELG1CQUFtQiw2Q0FBNkMseUNBQXlDLDhCQUE4QixvQ0FBb0MsRUFBRSxpQkFBaUIseUVBQXlFLDZCQUE2Qix5Q0FBeUMsZ0dBQWdHLHlDQUF5QyxpTUFBaU0sOEJBQThCLEVBQUUseUJBQXlCLHNDQUFzQyxxQkFBcUIsc0NBQXNDLDhDQUE4QywyQ0FBMkMsYUFBYSxFQUFFLFVBQVUsaUJBQWlCLG1CQUFtQix5Q0FBeUMseUdBQXlHLHlDQUF5QywwR0FBMEcsMEJBQTBCLHNDQUFzQywyQkFBMkIsWUFBWSxLQUFLLEtBQUsseUVBQXlFLHVHQUF1RyxnQkFBZ0IsK0VBQStFLGVBQWUsK0NBQStDLHlDQUF5QyxFQUFFLFNBQVMsdUJBQXVCLHNDQUFzQyx3QkFBd0IscUhBQXFILFlBQVksSUFBSSxLQUFLLHNDQUFzQyxzQ0FBc0MsWUFBWSxLQUFLLEtBQUssYUFBYSxtQ0FBbUMsNkNBQTZDLG1DQUFtQyxFQUFFLFNBQVMsc0JBQXNCLDhHQUE4RyxpWEFBaVgsbUNBQW1DLElBQUksMkJBQTJCLHNDQUFzQyw4QkFBOEIsb0JBQW9CLG1CQUFtQixzQkFBc0IsUUFBUSxPQUFPLGFBQWEsZUFBZSxjQUFjLGFBQWEsV0FBVyx5Q0FBeUMsd0xBQXdMLEdBQUcsYUFBYSxrTEFBa0wsb0RBQW9ELEdBQUcsZUFBZSx5QkFBeUIsZUFBZSxvRkFBb0YsR0FBRyxpQkFBaUIsS0FBSyxtRkFBbUYsd0JBQXdCLDZEQUE2RCxzQ0FBc0MsaUNBQWlDLDZEQUE2RCwwQkFBMEIsR0FBRyxhQUFhLFlBQVksa0JBQWtCLGdGQUFnRixrQkFBa0Isa0RBQWtELGVBQWUseUdBQXlHLFFBQVEscUJBQXFCLDBCQUEwQixhQUFhLGNBQWMsWUFBWSxPQUFPLGlFQUFpRSxTQUFTLCtLQUErSywrV0FBK1csaURBQWlELElBQUksNkNBQTZDLGdCQUFnQixlQUFlLFNBQVMsb0NBQW9DLGNBQWMscUJBQXFCLGdTQUFnUyxZQUFZLGl1QkFBaXVCLHNEQUFzRCxrQkFBa0IsV0FBVyxFQUFFLDBDQUEwQyxZQUFZLEVBQUUsNkNBQTZDLGNBQWMsRUFBRSwwREFBMEQsU0FBUyxHQUFHLFVBQVUsNE9BQTRPLHFDQUFxQyw0QkFBNEIsWUFBWSxNQUFNLGNBQWMsVUFBVSwwQkFBMEIsVUFBVSxNQUFNLGdCQUFnQixVQUFVLHFGQUFxRix1QkFBdUIsK0tBQStLLHNCQUFzQiwwQkFBMEIsOEJBQThCLCtEQUErRCxvQkFBb0IsK0RBQStELG9CQUFvQixxQkFBcUIsc0JBQXNCLDBCQUEwQixzQ0FBc0MsbUNBQW1DLGdCQUFnQixtQ0FBbUMsb0JBQW9CLEdBQUcsdUJBQXVCLG9DQUFvQyxXQUFXLGlCQUFpQiw2QkFBNkIsMkJBQTJCLHNDQUFzQywrR0FBK0csVUFBVSxvR0FBb0csUUFBUSx5QkFBeUIsdURBQXVELGFBQWEsd0JBQXdCLCtCQUErQixFQUFFLG9DQUFvQyxFQUFFLGlFQUFpRSxTQUFTLEVBQUUsT0FBTywwR0FBMEcsV0FBVyxxQ0FBcUMsd0ZBQXdGLFVBQVUscUVBQXFFLGNBQWMsNE9BQTRPLGVBQWUscUhBQXFILGtGQUFrRixjQUFjLHNCQUFzQix3SUFBd0ksYUFBYSx1QkFBdUIscURBQXFELEVBQUUsMEJBQTBCLDJFQUEyRSxpQkFBaUIsbUNBQW1DLGlCQUFpQiw0Q0FBNEMsa0JBQWtCLDZDQUE2QyxZQUFZLHFDQUFxQywwREFBMEQsUUFBUSwyR0FBMkcsZ0JBQWdCLDBiQUEwYixZQUFZLGlFQUFpRSx1Q0FBdUMsNEJBQTRCLGFBQWEsK0ZBQStGLHdGQUF3RixHQUFHLDJDQUEyQyxvRkFBb0YsK0VBQStFLDZHQUE2RyxrQkFBa0IsNEVBQTRFLHdDQUF3QyxrREFBa0QsMkNBQTJDLHdDQUF3Qyx5TEFBeUwsZUFBZSxxQkFBcUIsK0JBQStCLEVBQUUsUUFBUSxPQUFPLFFBQVEsV0FBVyxnQkFBZ0IsVUFBVSwwQkFBMEIsaUJBQWlCLGNBQWMscUNBQXFDLGtJQUFrSSxTQUFTLG9CQUFvQixpSUFBaUksYUFBYSxFQUFFLDhDQUE4QyxnRkFBZ0YsNEJBQTRCLGVBQWUsMkJBQTJCLGFBQWEsS0FBSyw4Q0FBOEMsMERBQTBELFNBQVMsOENBQThDLCtGQUErRix1QkFBdUIsd0dBQXdHLHVCQUF1QixzRkFBc0Ysb0JBQW9CLDhEQUE4RCxnQkFBZ0IsaURBQUMsR0FBQyxXQUFXLE9BQU8sK0JBQStCLFNBQVMsa0lBQWtJLFVBQVUsbUJBQW1CLFdBQVcsZ1lBQWdZLDZEQUE2RCx3QkFBd0IsZ0tBQWdLLCtEQUErRCxnQkFBZ0IsZUFBZSxZQUFZLGNBQWMsd0JBQXdCLHlDQUF5QyxXQUFXLDBDQUEwQyxVQUFVLE1BQU0sdUJBQXVCLFVBQVUseVJBQXlSLHFFQUFxRSw0REFBNEQsNkJBQTZCLHlCQUF5Qix1R0FBdUcsY0FBYyxLQUFLLG9CQUFvQixFQUFFLHVCQUF1QixLQUFLLE1BQU0sZUFBZSxLQUFLLG1CQUFtQixFQUFFLHVCQUF1QixLQUFLLE1BQU0sb0JBQW9CLHVDQUF1QyxnRUFBZ0UsK0RBQStELG1EQUFtRCxzTEFBc0wsa0tBQWtLLHdCQUF3QixxSkFBcUoseUJBQXlCLG1CQUFtQix5RkFBeUYsS0FBSywwQkFBMEIsRUFBRSwrQkFBK0IsZUFBZSxTQUFTLGVBQWUsaUZBQWlGLGVBQWUsZ0ZBQWdGLGlCQUFpQiw0QkFBNEIsdUdBQXVHLHdCQUF3QixTQUFTLGlCQUFpQiw0QkFBNEIsbUdBQW1HLHdCQUF3QixTQUFTLHFCQUFxQixrRUFBa0UsMENBQTBDLDJCQUEyQixTQUFTLHNCQUFzQixtRUFBbUUsMENBQTBDLDBCQUEwQixTQUFTLGNBQWMsNkZBQTZGLGdCQUFnQixpREFBQyxHQUFDLDZCQUE2QixPQUFPLCtEQUErRCxTQUFTLHlHQUF5RyxrQkFBa0IsVUFBVSxxQkFBcUIsV0FBVyxtREFBbUQscUJBQXFCLGtCQUFrQixhQUFhLG1EQUFtRCwwQkFBMEIsUUFBUSxrQkFBa0Isd0NBQXdDLGlEQUFpRCwwQkFBMEIsOEtBQThLLDBEQUEwRCxrQ0FBa0MsR0FBRyxvRkFBb0YsV0FBVyxzRkFBc0YsVUFBVSxNQUFNLGdCQUFnQixVQUFVLGVBQWUsc0NBQXNDLDBGQUEwRixzRUFBc0Usd0VBQXdFLHdKQUF3SixtQ0FBbUMsR0FBRyw4Q0FBOEMsc0JBQXNCLCtCQUErQixzQ0FBc0MsR0FBRyxXQUFXLGlCQUFpQiw2QkFBNkIsMkJBQTJCLHNDQUFzQywyQkFBMkIsc0VBQXNFLDJGQUEyRiw4REFBOEQsK0VBQStFLGtCQUFrQiw4Q0FBOEMsZ0JBQWdCLGlEQUFDLEdBQUMsZUFBZSxlQUFlLE9BQU8scWpCQUFxakIsU0FBUyxzSEFBc0gscURBQXFELDJDQUEyQyxVQUFVLG9CQUFvQixXQUFXLHloQkFBeWhCLGNBQWMsOENBQThDLGFBQWEsNENBQTRDLGVBQWUsOENBQThDLGVBQWUsOENBQThDLGFBQWEsNENBQTRDLGNBQWMsNkNBQTZDLGVBQWUsOENBQThDLFFBQVEsdUNBQXVDLHFCQUFxQixvREFBb0QscUJBQXFCLHFEQUFxRCx5N0JBQXk3QixXQUFXLHFDQUFxQyxjQUFjLCtDQUErQyxhQUFhLDZDQUE2QyxlQUFlLCtDQUErQyxlQUFlLCtDQUErQyxhQUFhLDZDQUE2QyxjQUFjLDhDQUE4QyxlQUFlLCtDQUErQyxRQUFRLHdDQUF3QyxxQkFBcUIscURBQXFELHFCQUFxQixzREFBc0Qsd01BQXdNLGNBQWMsd1dBQXdXLHltQkFBeW1CLDJHQUEyRywyRUFBMkUsa0dBQWtHLGVBQWUsZ1NBQWdTLHlLQUF5SyxLQUFLLFdBQVcsRUFBRSxFQUFFLCtCQUErQixFQUFFLEVBQUUsRUFBRSxtRkFBbUYsUUFBUSwrSkFBK0osVUFBVSxNQUFNLFNBQVMsVUFBVSw4SkFBOEosVUFBVSxNQUFNLGdCQUFnQixVQUFVLCtLQUErSyx1S0FBdUssK0lBQStJLGlCQUFpQixtR0FBbUcsOENBQThDLGNBQWMsc0JBQXNCLGlNQUFpTSxnQkFBZ0IsNENBQTRDLG9GQUFvRixjQUFjLDRDQUE0QyxrRkFBa0Ysa0JBQWtCLGtGQUFrRiwwSEFBMEgsZUFBZSxrRkFBa0YsYUFBYSw4RUFBOEUsZ0JBQWdCLGlCQUFpQiw2QkFBNkIsNkNBQTZDLDJCQUEyQixzQ0FBc0MsaUNBQWlDLDRDQUE0QyxxRUFBcUUsdUJBQXVCLGtCQUFrQiw2QkFBNkIsdUVBQXVFLDJFQUEyRSw0T0FBNE8seUJBQXlCLHNEQUFzRCxRQUFRLHNFQUFzRSxHQUFHLEVBQUUsdUJBQXVCLEVBQUUsc0JBQXNCLDJCQUEyQixnQkFBZ0Isb0RBQW9ELGdEQUFnRCxpRUFBaUUsc0JBQXNCLGlDQUFpQyxxRUFBcUUsOEJBQThCLDRKQUE0SiwwQ0FBMEMsZ0dBQWdHLG1HQUFtRywwS0FBMEssb1RBQW9ULDhEQUE4RCxvTUFBb00sOERBQThELHFFQUFxRSxzQkFBc0IscWRBQXFkLDhEQUE4RCxzQkFBc0IsaUJBQWlCLCtFQUErRSxtSUFBbUkscUJBQXFCLDBGQUEwRixFQUFFLHNDQUFzQyxFQUFFLElBQUksY0FBYyw4Q0FBOEMseUJBQXlCLGdDQUFnQyx5VkFBeVYsNkNBQTZDLGVBQWUscUJBQXFCLGFBQWEsOEJBQThCLG1CQUFtQiwrQkFBK0IsZ0RBQWdELG9LQUFvSyxlQUFlLHFDQUFxQyxnQkFBZ0IsaURBQUMsR0FBQyxTQUFTLDBFQUEwRSxZQUFZLFlBQVksZ0NBQWdDLGVBQWUsZ0NBQWdDLE9BQU8saVdBQWlXLFVBQVUsbUJBQW1CLFdBQVcsNktBQTZLLFNBQVMseUNBQXlDLGVBQWUsOENBQThDLGFBQWEsNENBQTRDLFVBQVUseUNBQXlDLGVBQWUsOENBQThDLGFBQWEsNkNBQTZDLHVRQUF1USxXQUFXLDhIQUE4SCxTQUFTLDBDQUEwQyxlQUFlLCtDQUErQyxhQUFhLDhDQUE4QyxrTEFBa0wsVUFBVSxNQUFNLGdCQUFnQixVQUFVLGVBQWUsc0VBQXNFLHNDQUFzQyx5REFBeUQsNkJBQTZCLDZDQUE2QyxnQ0FBZ0MsRUFBRSwyQkFBMkIsNkNBQTZDLGdDQUFnQyxFQUFFLEtBQUssOEJBQThCLDZDQUE2QyxnQ0FBZ0MsRUFBRSw2Q0FBNkMsb0NBQW9DLEdBQUcsV0FBVyxpQkFBaUIsNkVBQTZFLGdFQUFnRSw2SkFBNkosWUFBWSxpQkFBaUIscUZBQXFGLGtFQUFrRSxZQUFZLGlMQUFpTCxtQ0FBbUMsNkVBQTZFLEVBQUUsZ0RBQWdELHlEQUF5RCxtREFBbUQsTUFBTSxxREFBcUQsTUFBTSxxREFBcUQsTUFBTSx1Q0FBdUMsNkVBQTZFLEVBQUUsMERBQTBELDBEQUEwRCxpRkFBaUYsS0FBSyx3QkFBd0IsZ0VBQWdFLHFCQUFxQix1UUFBdVEsY0FBYyxzREFBc0QsV0FBVyxpQkFBaUIsNkJBQTZCLDJCQUEyQixzQ0FBc0MseUVBQXlFLHlGQUF5RixrREFBa0QsK0JBQStCLHNEQUFzRCwrQkFBK0IsMkJBQTJCLFdBQVcsaUNBQWlDLG1GQUFtRixnQkFBZ0IsaUNBQWlDLG1GQUFtRixjQUFjLGlDQUFpQyxpRkFBaUYsb0JBQW9CLHFJQUFxSSw2QkFBNkIsVUFBVSw2Q0FBNkMsbUVBQW1FLDBDQUEwQyw4QkFBOEIseURBQXlELFNBQVMsWUFBWSxlQUFlLHVEQUF1RCw2RUFBNkUsMENBQTBDLDhCQUE4Qix5REFBeUQsU0FBUyxZQUFZLGFBQWEscURBQXFELDJFQUEyRSx3Q0FBd0MsNEJBQTRCLHlEQUF5RCxTQUFTLFlBQVksaUJBQWlCLHFGQUFxRixnQkFBZ0IscUZBQXFGLGNBQWMsaUZBQWlGLGtCQUFrQix3Q0FBd0MsNERBQTRELDJCQUEyQixNQUFNLFlBQVksYUFBYSxrQkFBa0IsZUFBZSxZQUFZLFdBQVcsRUFBRSxHQUFHLEVBQUUsRUFBRSxTQUFTLGtCQUFrQixzQ0FBc0MsdUNBQXVDLHlDQUF5QyxzREFBc0QsRUFBRSxNQUFNLGdFQUFnRSxXQUFXLHVLQUF1SyxZQUFZLElBQUksMkJBQTJCLHlDQUF5QywyS0FBMkssaUJBQWlCLHlDQUF5QyxzREFBc0QsRUFBRSxNQUFNLFlBQVksS0FBSyw2QkFBNkIseUNBQXlDLFlBQVksVUFBVSx1QkFBdUIsVUFBVSxvRUFBb0UsMENBQTBDLHlDQUF5QyxzREFBc0QsRUFBRSxNQUFNLFdBQVcsWUFBWSxJQUFJLDZCQUE2Qix5Q0FBeUMsWUFBWSxVQUFVLHVCQUF1QixVQUFVLG9FQUFvRSxpQkFBaUIsMEJBQTBCLHlDQUF5QyxzREFBc0QsRUFBRSxtQ0FBbUMseUNBQXlDLG1GQUFtRixvQkFBb0IsU0FBUyxzQkFBc0Isa0JBQWtCLFVBQVUsNEdBQTRHLE1BQU0sK0dBQStHLFNBQVMsY0FBYyxxQkFBcUIsb0NBQW9DLHlFQUF5RSxrSkFBa0osK0RBQStELEtBQUssdUNBQXVDLDZFQUE2RSxnQ0FBZ0MscUNBQXFDLDJFQUEyRSwrQkFBK0IsMkVBQTJFLHlOQUF5TiwwSkFBMEosK0RBQStELEtBQUssc0dBQXNHLDRFQUE0RSxnQ0FBZ0Msc0hBQXNILG9GQUFvRixpQ0FBaUMsMkdBQTJHLHVGQUF1RixvQ0FBb0MsU0FBUyxrRkFBa0YsK0RBQStELEtBQUssTUFBTSw0Q0FBNEMsZ0NBQWdDLE1BQU0sNENBQTRDLG1DQUFtQyxLQUFLLDZCQUE2QixtRUFBbUUsZ0NBQWdDLHNHQUFzRyw0RUFBNEUsbUNBQW1DLGdCQUFnQixpREFBQyxHQUFDLGdCQUFnQixZQUFZLE9BQU8sbUVBQW1FLFNBQVMsd0JBQXdCLFVBQVUsa0JBQWtCLFdBQVcsZ0VBQWdFLHlIQUF5SCxZQUFZLDBGQUEwRixZQUFZLDJFQUEyRSxLQUFLLHdDQUF3Qyx1QkFBdUIsa0NBQWtDLHVCQUF1QiwrREFBK0QsU0FBUywyQ0FBMkMsbUJBQW1CLHVDQUF1QywyREFBMkQsb0NBQW9DLHFDQUFxQyxtQ0FBbUMsRUFBRSxHQUFHLFdBQVcsb0NBQW9DLHNDQUFzQyxHQUFHLFdBQVcsOElBQThJLFdBQVcsaUtBQWlLLFVBQVUsTUFBTSxnQkFBZ0IsVUFBVSx1T0FBdU8sYUFBYSxvQ0FBb0MsbURBQW1ELE1BQU0sd0RBQXdELE1BQU0sNENBQTRDLE1BQU0saUNBQWlDLCtCQUErQix3REFBd0Qsc0JBQXNCLHFCQUFxQix3RUFBd0UsZUFBZSxTQUFTLHVDQUF1Qyw4Q0FBOEMsVUFBVSxvQkFBb0IsdUJBQXVCLEtBQUssNkNBQTZDLFVBQVUsOENBQThDLFdBQVcsb0JBQW9CLFdBQVcsZUFBZSxvRkFBb0Ysc0JBQXNCLEtBQUssZ0JBQWdCLE1BQU0sNEVBQTRFLHNCQUFzQixLQUFLLGFBQWEsSUFBSSxnQkFBZ0IsaUJBQWlCLGdDQUFnQyxtQkFBbUIsMkdBQTJHLGNBQWMsa0JBQWtCLGlCQUFpQixnQ0FBZ0MsbUJBQW1CLDZHQUE2RyxpQ0FBaUMsZUFBZSxpQkFBaUIsb0ZBQW9GLFdBQVcsb0JBQW9CLDJIQUEySCxnRUFBZ0Usb0JBQW9CLFVBQVUsSUFBSSxJQUFJLGdCQUFnQixxREFBcUQsZ0RBQWdELDJDQUEyQyxXQUFXLEdBQUcsSUFBSSxnQkFBZ0IsaURBQUMsR0FBQyxZQUFZLFdBQVcsWUFBWSxPQUFPLDJFQUEyRSxTQUFTLFVBQVUsNkNBQTZDLHFCQUFxQixrVUFBa1UsV0FBVyxVQUFVLGtCQUFrQixXQUFXLGlZQUFpWSxXQUFXLHdSQUF3UixVQUFVLHFOQUFxTixpQkFBaUIsaUNBQWlDLHlDQUF5QyxrQkFBa0IsTUFBTSwrQkFBK0IsVUFBVSx5QkFBeUIsdUNBQXVDLGlDQUFpQyx5QkFBeUIseUNBQXlDLHNEQUFzRCxZQUFZLEtBQUssTUFBTSxtSUFBbUksb0VBQW9FLGFBQWEsZ1JBQWdSLGlDQUFpQyxpQkFBaUIsK0dBQStHLGdCQUFnQixnQ0FBZ0MseUJBQXlCLHlDQUF5QyxpQ0FBaUMsNkhBQTZILHNCQUFzQix5Q0FBeUMsNEdBQTRHLFlBQVksS0FBSyxNQUFNLHdFQUF3RSx1U0FBdVMsc0JBQXNCLHlDQUF5Qyw0R0FBNEcsd0NBQXdDLDJEQUEyRCw4QkFBOEIscUNBQXFDLEdBQUcsaUNBQWlDLGlCQUFpQiw4RUFBOEUsc0JBQXNCLHFCQUFxQixNQUFNLGdCQUFnQixVQUFVLG1EQUFtRCx5Q0FBeUMsNEdBQTRHLG1CQUFtQixTQUFTLDRHQUE0RyxxQkFBcUIscUJBQXFCLDZCQUE2QixNQUFNLGdCQUFnQixVQUFVLDJCQUEyQixzQ0FBc0Msd0RBQXdELHFEQUFxRCxrQkFBa0IsTUFBTSx1REFBdUQsS0FBSyxnQ0FBZ0Msd0JBQXdCLDhDQUE4QyxxQ0FBcUMsc0NBQXNDLG1FQUFtRSxLQUFzSjs7O0FDQXJ3MUQ7QUFFNUMsSUFBTUssTUFBTSxHQUFHLElBQUlELENBQVEsQ0FBQ0UsTUFBTSxDQUFDO0VBQ2pDQyxPQUFPLEVBQUUsT0FBTztFQUNoQkMsR0FBRyxFQUFFLENBQUMsb0VBQW9FLENBQUM7RUFDM0VDLE1BQU0sRUFBRSxFQUFFO0VBQ1ZDLE1BQU0sRUFBRTtBQUNWLENBQUMsQ0FBQyxDOztBQ1BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsV0FBVztBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWTtBQUNaLFdBQVc7QUFDWCxZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRDOzs7QUNoSjRCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBZ0I7QUFDekIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFNO0FBQ2Y7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQVEsaUJBQWlCLGNBQVE7QUFDL0M7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjLFlBQU07QUFDcEI7QUFDQSxZQUFZLFVBQVUsY0FBUSxpQkFBaUIsY0FBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYyxZQUFNO0FBQ3BCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1jOzs7QUNuUzNYO0FBQ3dROztBQUVoVjtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUIsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVksR0FBRyxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsWUFBWSwwQ0FBMEMsWUFBWTtBQUM3Riw2QkFBNkIsWUFBWSx5Q0FBeUMsWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZSxlQUFlLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUksY0FBYztBQUNsQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZLHlDQUF5Qzs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0IseUJBQXlCLGdCQUFnQjtBQUNyRyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQSw0REFBNEQsa0NBQWtDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOERBQThEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixhQUFhO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxjQUFjLGtEQUFrRCxhQUFhO0FBQ2pGLElBQUksY0FBYyxpREFBaUQsa0VBQWtFO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsVUFBVTtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsZUFBZSxrQkFBa0IsRUFBRSxTQUFTLGdCQUFnQixTQUFTO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFLE1BQU07QUFDTixrRUFBa0UsWUFBWTtBQUM5RTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxrQkFBa0Isa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjLGtCQUFrQixrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRSx5QkFBeUI7QUFDL0Y7QUFDQTtBQUNBLDJDQUEyQyxpQ0FBaUM7QUFDNUU7QUFDQTtBQUNBLHNEQUFzRCxpQ0FBaUM7QUFDdkYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpQ0FBaUM7QUFDM0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0NBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixvREFBb0QsdURBQXVEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxrRkFBa0Y7O0FBRWpLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0RBQWtELG1EQUFtRDtBQUNyRztBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSztBQUM5QztBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QyxNQUFNO0FBQ04sd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNEQUFzRDs7QUFFekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQSxRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0QkFBNEIsR0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUIsRUFBRSxRQUFRO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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QUFFRixNQUFNLEVBQUU7QUFBTSxDQUFDLENBQUM7QUFDL0VKLGVBQVksQ0FBQyxDQUFDLENBQUNLLE1BQU0sQ0FBQyxVQUFVLEVBQUU7RUFBRUMsTUFBTSxFQUFFLE9BQU87RUFBRUYsTUFBTSxFQUFFO0FBQU0sQ0FBQyxDQUFDO0FBQ3JFSixlQUFZLENBQUMsQ0FBQyxDQUFDSyxNQUFNLENBQUMsV0FBVyxFQUFFO0VBQUVDLE1BQU0sRUFBRSxNQUFNO0VBQUVGLE1BQU0sRUFBRTtBQUFNLENBQUMsQ0FBQztBQUNyRUosZUFBWSxDQUFDLENBQUMsQ0FBQ0ssTUFBTSxDQUFDLFVBQVUsRUFBRTtFQUFFQyxNQUFNLEVBQUUsT0FBTztFQUFFRixNQUFNLEVBQUU7QUFBTSxDQUFDLENBQUMsQzs7OztBQ1J6QztBQUNGO0FBRUk7QUFDRjtBQUNKO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9qcy9fY291bnRyZXMuanM/YTMzYiIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9qcy9hdXRvY29tcGxldGUuanM/NjQ3YiIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9AZWFzZXBpY2svYnVuZGxlL2Rpc3QvaW5kZXguZXNtLmpzP2EzYzkiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9zcmMvanMvZGF0ZVBpY2tlci5qcz8yZTdlIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9zaGFyZWQvc3NyLXdpbmRvdy5lc20ubWpzPzMxMWMiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91dGlscy5tanM/N2UyNyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3N3aXBlci1jb3JlLm1qcz83YzNkIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3ZpcnR1YWwubWpzPzJjMjUiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMva2V5Ym9hcmQubWpzP2E2YjEiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvbW91c2V3aGVlbC5tanM/MjYyMCIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL2NyZWF0ZS1lbGVtZW50LWlmLW5vdC1kZWZpbmVkLm1qcz8xN2EyIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL25hdmlnYXRpb24ubWpzP2QxZWQiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9jbGFzc2VzLXRvLXNlbGVjdG9yLm1qcz82ZmQyIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhZ2luYXRpb24ubWpzPzQ1NTgiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvc2Nyb2xsYmFyLm1qcz9hZWM4Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3BhcmFsbGF4Lm1qcz8zYzljIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3pvb20ubWpzP2MyNTUiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvY29udHJvbGxlci5tanM/M2ZhNyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9hMTF5Lm1qcz9hMmI5Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL2hpc3RvcnkubWpzPzhmMTMiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvaGFzaC1uYXZpZ2F0aW9uLm1qcz9hMTIwIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL2F1dG9wbGF5Lm1qcz84NmE0Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9tb2R1bGVzL3RodW1icy5tanM/MzhlNyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9mcmVlLW1vZGUubWpzPzJhNTQiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZ3JpZC5tanM/NGI2MyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9tYW5pcHVsYXRpb24ubWpzP2YxNTciLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9lZmZlY3QtaW5pdC5tanM/YWUzMiIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL2VmZmVjdC10YXJnZXQubWpzP2Y5OTAiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9lZmZlY3QtdmlydHVhbC10cmFuc2l0aW9uLWVuZC5tanM/MzFkMSIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9lZmZlY3QtZmFkZS5tanM/MWQyYyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9lZmZlY3QtY3ViZS5tanM/YWY0NCIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL2NyZWF0ZS1zaGFkb3cubWpzPzdmNDkiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWZsaXAubWpzPzNjMDQiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWNvdmVyZmxvdy5tanM/MjAwMCIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zd2lwZXIvbW9kdWxlcy9lZmZlY3QtY3JlYXRpdmUubWpzPzViMDkiLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvZWZmZWN0LWNhcmRzLm1qcz9iMzQ0Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9zd2lwZXItYnVuZGxlLm1qcz9mYzc3Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vc3JjL2pzL3N3aXBlci5qcz81MmNmIiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL2lzLWRvbS1ub2RlL2Rpc3QvaXMtZG9tLW5vZGUuZXMuanM/MDM0ZCIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9pcy1kb20tbm9kZS1saXN0L2Rpc3QvaXMtZG9tLW5vZGUtbGlzdC5lcy5qcz9lY2Y3Iiwid2VicGFjazovL3dlYnBhY2tfd2ViLy4vbm9kZV9tb2R1bGVzL3RlYWxpZ2h0L2Rpc3QvdGVhbGlnaHQuZXMuanM/ZjJhNyIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9yZW1hdHJpeC9kaXN0L3JlbWF0cml4LmVzLmpzPzZlMzciLCJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvbWluaXJhZi9kaXN0L21pbmlyYWYuZXMuanM/NWQzNSIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL25vZGVfbW9kdWxlcy9zY3JvbGxyZXZlYWwvZGlzdC9zY3JvbGxyZXZlYWwuZXMuanM/NmU1NSIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9qcy9yZXZlYWwuanM/ZDlhOSIsIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY291bnRyaWVzID0gW1xuICBcIkFmZ2hhbmlzdGFuXCIsXG4gIFwiQWxiYW5pYVwiLFxuICBcIkFsZ2VyaWFcIixcbiAgXCJBbmRvcnJhXCIsXG4gIFwiQW5nb2xhXCIsXG4gIFwiQW50aWd1YSBhbmQgQmFyYnVkYVwiLFxuICBcIkFyZ2VudGluYVwiLFxuICBcIkFybWVuaWFcIixcbiAgXCJBdXN0cmFsaWFcIixcbiAgXCJBdXN0cmlhXCIsXG4gIFwiQXplcmJhaWphblwiLFxuICBcIkJhaGFtYXNcIixcbiAgXCJCYWhyYWluXCIsXG4gIFwiQmFuZ2xhZGVzaFwiLFxuICBcIkJhcmJhZG9zXCIsXG4gIFwiQmVsYXJ1c1wiLFxuICBcIkJlbGdpdW1cIixcbiAgXCJCZWxpemVcIixcbiAgXCJCZW5pblwiLFxuICBcIkJodXRhblwiLFxuICBcIkJvbGl2aWFcIixcbiAgXCJCb3NuaWEgYW5kIEhlcnplZ292aW5hXCIsXG4gIFwiQm90c3dhbmFcIixcbiAgXCJCcmF6aWxcIixcbiAgXCJCcnVuZWlcIixcbiAgXCJCdWxnYXJpYVwiLFxuICBcIkJ1cmtpbmEgRmFzb1wiLFxuICBcIkJ1cnVuZGlcIixcbiAgXCJDYWJvIFZlcmRlXCIsXG4gIFwiQ2FtYm9kaWFcIixcbiAgXCJDYW1lcm9vblwiLFxuICBcIkNhbmFkYVwiLFxuICBcIkNlbnRyYWwgQWZyaWNhbiBSZXB1YmxpY1wiLFxuICBcIkNoYWRcIixcbiAgXCJDaGlsZVwiLFxuICBcIkNoaW5hXCIsXG4gIFwiQ29sb21iaWFcIixcbiAgXCJDb21vcm9zXCIsXG4gIFwiQ29uZ28gKENvbmdvLUJyYXp6YXZpbGxlKVwiLFxuICBcIkNvc3RhIFJpY2FcIixcbiAgXCJDb3RlIGQnSXZvaXJlXCIsXG4gIFwiQ3JvYXRpYVwiLFxuICBcIkN1YmFcIixcbiAgXCJDeXBydXNcIixcbiAgXCJDemVjaCBSZXB1YmxpY1wiLFxuICBcIkRlbm1hcmtcIixcbiAgXCJEamlib3V0aVwiLFxuICBcIkRvbWluaWNhXCIsXG4gIFwiRG9taW5pY2FuIFJlcHVibGljXCIsXG4gIFwiRWFzdCBUaW1vciAoVGltb3IgVGltdXIpXCIsXG4gIFwiRWN1YWRvclwiLFxuICBcIkVneXB0XCIsXG4gIFwiRWwgU2FsdmFkb3JcIixcbiAgXCJFcXVhdG9yaWFsIEd1aW5lYVwiLFxuICBcIkVyaXRyZWFcIixcbiAgXCJFc3RvbmlhXCIsXG4gIFwiRXRoaW9waWFcIixcbiAgXCJGaWppXCIsXG4gIFwiRmlubGFuZFwiLFxuICBcIkZyYW5jZVwiLFxuICBcIkdhYm9uXCIsXG4gIFwiR2FtYmlhXCIsXG4gIFwiR2VvcmdpYVwiLFxuICBcIkdlcm1hbnlcIixcbiAgXCJHaGFuYVwiLFxuICBcIkdyZWVjZVwiLFxuICBcIkdyZW5hZGFcIixcbiAgXCJHdWF0ZW1hbGFcIixcbiAgXCJHdWluZWFcIixcbiAgXCJHdWluZWEtQmlzc2F1XCIsXG4gIFwiR3V5YW5hXCIsXG4gIFwiSGFpdGlcIixcbiAgXCJIb25kdXJhc1wiLFxuICBcIkh1bmdhcnlcIixcbiAgXCJJY2VsYW5kXCIsXG4gIFwiSW5kaWFcIixcbiAgXCJJbmRvbmVzaWFcIixcbiAgXCJJcmFuXCIsXG4gIFwiSXJhcVwiLFxuICBcIklyZWxhbmQge1JlcHVibGljfVwiLFxuICBcIklzcmFlbFwiLFxuICBcIkl0YWx5XCIsXG4gIFwiSmFtYWljYVwiLFxuICBcIkphcGFuXCIsXG4gIFwiSm9yZGFuXCIsXG4gIFwiS2F6YWtoc3RhblwiLFxuICBcIktlbnlhXCIsXG4gIFwiS2lyaWJhdGlcIixcbiAgXCJLb3JlYSwgTm9ydGhcIixcbiAgXCJLb3JlYSwgU291dGhcIixcbiAgXCJLb3Nvdm9cIixcbiAgXCJLdXdhaXRcIixcbiAgXCJLeXJneXpzdGFuXCIsXG4gIFwiTGFvc1wiLFxuICBcIkxhdHZpYVwiLFxuICBcIkxlYmFub25cIixcbiAgXCJMZXNvdGhvXCIsXG4gIFwiTGliZXJpYVwiLFxuICBcIkxpYnlhXCIsXG4gIFwiTGllY2h0ZW5zdGVpblwiLFxuICBcIkxpdGh1YW5pYVwiLFxuICBcIkx1eGVtYm91cmdcIixcbiAgXCJNYWNlZG9uaWFcIixcbiAgXCJNYWRhZ2FzY2FyXCIsXG4gIFwiTWFsYXdpXCIsXG4gIFwiTWFsYXlzaWFcIixcbiAgXCJNYWxkaXZlc1wiLFxuICBcIk1hbGlcIixcbiAgXCJNYWx0YVwiLFxuICBcIk1hcnNoYWxsIElzbGFuZHNcIixcbiAgXCJNYXVyaXRhbmlhXCIsXG4gIFwiTWF1cml0aXVzXCIsXG4gIFwiTWV4aWNvXCIsXG4gIFwiTWljcm9uZXNpYVwiLFxuICBcIk1vbGRvdmFcIixcbiAgXCJNb25hY29cIixcbiAgXCJNb25nb2xpYVwiLFxuICBcIk1vbnRlbmVncm9cIixcbiAgXCJNb3JvY2NvXCIsXG4gIFwiTW96YW1iaXF1ZVwiLFxuICBcIk15YW5tYXJcIixcbiAgXCJOYW1pYmlhXCIsXG4gIFwiTmF1cnVcIixcbiAgXCJOZXBhbFwiLFxuICBcIk5ldGhlcmxhbmRzXCIsXG4gIFwiTmV3IFplYWxhbmRcIixcbiAgXCJOaWNhcmFndWFcIixcbiAgXCJOaWdlclwiLFxuICBcIk5pZ2VyaWFcIixcbiAgXCJOb3J3YXlcIixcbiAgXCJPbWFuXCIsXG4gIFwiUGFraXN0YW5cIixcbiAgXCJQYWxhdVwiLFxuICBcIlBhbmFtYVwiLFxuICBcIlBhcHVhIE5ldyBHdWluZWFcIixcbiAgXCJQYXJhZ3VheVwiLFxuICBcIlBlcnVcIixcbiAgXCJQaGlsaXBwaW5lc1wiLFxuICBcIlBvbGFuZFwiLFxuICBcIlBvcnR1Z2FsXCIsXG4gIFwiUWF0YXJcIixcbiAgXCJSb21hbmlhXCIsXG4gIFwiUnVzc2lhXCIsXG4gIFwiUndhbmRhXCIsXG4gIFwiU2FpbnQgS2l0dHMgYW5kIE5ldmlzXCIsXG4gIFwiU2FpbnQgTHVjaWFcIixcbiAgXCJTYWludCBWaW5jZW50XCIsXG4gIFwiU2Ftb2FcIixcbiAgXCJTYW4gTWFyaW5vXCIsXG4gIFwiU2FvIFRvbWUgYW5kIFByaW5jaXBlXCIsXG4gIFwiU2F1ZGkgQXJhYmlhXCIsXG4gIFwiU2VuZWdhbFwiLFxuICBcIlNlcmJpYVwiLFxuICBcIlNleWNoZWxsZXNcIixcbiAgXCJTaWVycmEgTGVvbmVcIixcbiAgXCJTaW5nYXBvcmVcIixcbiAgXCJTbG92YWtpYVwiLFxuICBcIlNsb3ZlbmlhXCIsXG4gIFwiU29sb21vbiBJc2xhbmRzXCIsXG4gIFwiU29tYWxpYVwiLFxuICBcIlNvdXRoIEFmcmljYVwiLFxuICBcIlNwYWluXCIsXG4gIFwiU3JpIExhbmthXCIsXG4gIFwiU3VkYW5cIixcbiAgXCJTdXJpbmFtZVwiLFxuICBcIlN3YXppbGFuZFwiLFxuICBcIlN3ZWRlblwiLFxuICBcIlN3aXR6ZXJsYW5kXCIsXG4gIFwiU3lyaWFcIixcbiAgXCJUYWl3YW5cIixcbiAgXCJUYWppa2lzdGFuXCIsXG4gIFwiVGFuemFuaWFcIixcbiAgXCJUaGFpbGFuZFwiLFxuICBcIlRvZ29cIixcbiAgXCJUb25nYVwiLFxuICBcIlRyaW5pZGFkIGFuZCBUb2JhZ29cIixcbiAgXCJUdW5pc2lhXCIsXG4gIFwiVHVya2V5XCIsXG4gIFwiVHVya21lbmlzdGFuXCIsXG4gIFwiVHV2YWx1XCIsXG4gIFwiVWdhbmRhXCIsXG4gIFwiVWtyYWluZVwiLFxuICBcIlVuaXRlZCBBcmFiIEVtaXJhdGVzXCIsXG4gIFwiVW5pdGVkIEtpbmdkb21cIixcbiAgXCJVbml0ZWQgU3RhdGVzXCIsXG4gIFwiVXJ1Z3VheVwiLFxuICBcIlV6YmVraXN0YW5cIixcbiAgXCJWYW51YXR1XCIsXG4gIFwiVmF0aWNhbiBDaXR5XCIsXG4gIFwiVmVuZXp1ZWxhXCIsXG4gIFwiVmlldG5hbVwiLFxuICBcIlllbWVuXCIsXG4gIFwiWmFtYmlhXCIsXG4gIFwiWmltYmFid2VcIixcbiAgXCLQkNCy0YHRgtGA0LDQu9C40Y9cIixcbiAgXCLQkNCy0YHRgtGA0LjRj1wiLFxuICBcItCQ0LfQtdGA0LHQsNC50LTQttCw0L1cIixcbiAgXCLQkNC70LHQsNC90LjRj1wiLFxuICBcItCQ0LvQttC40YBcIixcbiAgXCLQkNC90LPQvtC70LBcIixcbiAgXCLQkNGA0LPQtdC90YLQuNC90LBcIixcbiAgXCLQkNGA0LzQtdC90LjRj1wiLFxuICBcItCQ0YTQs9Cw0L3QuNGB0YLQsNC9XCIsXG4gIFwi0JHQsNC90LPQu9Cw0LTQtdGIXCIsXG4gIFwi0JHQtdC70LDRgNGD0YHRjFwiLFxuICBcItCR0LXQu9GM0LPQuNGPXCIsXG4gIFwi0JHQvtC70LPQsNGA0LjRj1wiLFxuICBcItCR0YDQsNC30LjQu9C40Y9cIixcbiAgXCLQktC10LvQuNC60L7QsdGA0LjRgtCw0L3QuNGPXCIsXG4gIFwi0JLQtdC90LPRgNC40Y9cIixcbiAgXCLQktC10L3QtdGB0YPRjdC70LBcIixcbiAgXCLQktGM0LXRgtC90LDQvFwiLFxuICBcItCT0LDQuNGC0LhcIixcbiAgXCLQk9C10YDQvNCw0L3QuNGPXCIsXG4gIFwi0JPRgNC10YbQuNGPXCIsXG4gIFwi0JPRgNGD0LfQuNGPXCIsXG4gIFwi0JTQsNC90LjRj1wiLFxuICBcItCV0LPQuNC/0LXRglwiLFxuICBcItCY0LfRgNCw0LjQu9GMXCIsXG4gIFwi0JjQvdC00LjRj1wiLFxuICBcItCY0L3QtNC+0L3QtdC30LjRj1wiLFxuICBcItCY0L7RgNC00LDQvdC40Y9cIixcbiAgXCLQmNGA0LDQvVwiLFxuICBcItCY0YDQu9Cw0L3QtNC40Y9cIixcbiAgXCLQmNGB0LvQsNC90LTQuNGPXCIsXG4gIFwi0JjRgdC/0LDQvdC40Y9cIixcbiAgXCLQmNGC0LDQu9C40Y9cIixcbiAgXCLQmtCw0LfQsNGF0YHRgtCw0L1cIixcbiAgXCLQmtCw0LzQsdC+0LTQttCwXCIsXG4gIFwi0JrQsNC90LDQtNCwXCIsXG4gIFwi0JrQsNGC0LDRgFwiLFxuICBcItCa0LXQvdC40Y9cIixcbiAgXCLQmtC40L/RgFwiLFxuICBcItCa0LjRgtCw0LlcIixcbiAgXCLQmtC+0LvRg9C80LHQuNGPXCIsXG4gIFwi0JrQvtGA0LXRjyAo0K7QttC90LDRjylcIixcbiAgXCLQmtGD0LHQsFwiLFxuICBcItCa0YPQstC10LnRglwiLFxuICBcItCb0LDQvtGBXCIsXG4gIFwi0JvQsNGC0LLQuNGPXCIsXG4gIFwi0JvQuNCy0LDQvVwiLFxuICBcItCb0LjQstC40Y9cIixcbiAgXCLQm9C40YLQstCwXCIsXG4gIFwi0JvRjtC60YHQtdC80LHRg9GA0LNcIixcbiAgXCLQnNCw0LrQtdC00L7QvdC40Y9cIixcbiAgXCLQnNCw0LvQsNC50LfQuNGPXCIsXG4gIFwi0JzQsNC70LhcIixcbiAgXCLQnNCw0LvRjNGC0LBcIixcbiAgXCLQnNCw0YDQvtC60LrQvlwiLFxuICBcItCc0LXQutGB0LjQutCwXCIsXG4gIFwi0JzQvtC30LDQvNCx0LjQulwiLFxuICBcItCc0L7Qu9C00LDQstC40Y9cIixcbiAgXCLQnNC+0L3QsNC60L5cIixcbiAgXCLQnNC+0L3Qs9C+0LvQuNGPXCIsXG4gIFwi0JzRjNGP0L3QvNCwXCIsXG4gIFwi0J3QsNC80LjQsdC40Y9cIixcbiAgXCLQndC10L/QsNC7XCIsXG4gIFwi0J3QuNCz0LXRgFwiLFxuICBcItCd0LjQs9C10YDQuNGPXCIsXG4gIFwi0J3QuNC00LXRgNC70LDQvdC00YtcIixcbiAgXCLQndC40LrQsNGA0LDQs9GD0LBcIixcbiAgXCLQndC+0LLQsNGPINCX0LXQu9Cw0L3QtNC40Y9cIixcbiAgXCLQndC+0YDQstC10LPQuNGPXCIsXG4gIFwi0J7QkNCtXCIsXG4gIFwi0J7QvNCw0L1cIixcbiAgXCLQn9Cw0LrQuNGB0YLQsNC9XCIsXG4gIFwi0J/QsNC90LDQvNCwXCIsXG4gIFwi0J/QsNGA0LDQs9Cy0LDQuVwiLFxuICBcItCf0LXRgNGDXCIsXG4gIFwi0J/QvtC70YzRiNCwXCIsXG4gIFwi0J/QvtGA0YLRg9Cz0LDQu9C40Y9cIixcbiAgXCLQoNC+0YHRgdC40Y9cIixcbiAgXCLQoNGD0LzRi9C90LjRj1wiLFxuICBcItCh0LDQu9GM0LLQsNC00L7RgFwiLFxuICBcItCh0LDRg9C00L7QstGB0LrQsNGPINCQ0YDQsNCy0LjRj1wiLFxuICBcItCh0LXQvdC10LPQsNC7XCIsXG4gIFwi0KHQtdGA0LHQuNGPXCIsXG4gIFwi0KHQuNC90LPQsNC/0YPRgFwiLFxuICBcItCh0LjRgNC40Y9cIixcbiAgXCLQodC70L7QstCw0LrQuNGPXCIsXG4gIFwi0KHQu9C+0LLQtdC90LjRj1wiLFxuICBcItCh0KjQkFwiLFxuICBcItCi0LDQtNC20LjQutC40YHRgtCw0L1cIixcbiAgXCLQotCw0LjQu9Cw0L3QtFwiLFxuICBcItCi0LDQudCy0LDQvdGMXCIsXG4gIFwi0KLQsNC90LfQsNC90LjRj1wiLFxuICBcItCi0YPQvdC40YFcIixcbiAgXCLQotGD0YDQutC80LXQvdC40YHRgtCw0L1cIixcbiAgXCLQotGD0YDRhtC40Y9cIixcbiAgXCLQo9Cz0LDQvdC00LBcIixcbiAgXCLQo9C30LHQtdC60LjRgdGC0LDQvVwiLFxuICBcItCj0LrRgNCw0LjQvdCwXCIsXG4gIFwi0KPRgNGD0LPQstCw0LlcIixcbiAgXCLQpNC40LvQuNC/0L/QuNC90YtcIixcbiAgXCLQpNC40L3Qu9GP0L3QtNC40Y9cIixcbiAgXCLQpNGA0LDQvdGG0LjRj1wiLFxuICBcItCl0L7RgNCy0LDRgtC40Y9cIixcbiAgXCLQp9C10YDQvdC+0LPQvtGA0LjRj1wiLFxuICBcItCn0LXRhdC40Y9cIixcbiAgXCLQp9C40LvQuFwiLFxuICBcItCo0LLQtdC50YbQsNGA0LjRj1wiLFxuICBcItCo0LLQtdGG0LjRj1wiLFxuICBcItCo0YDQuC3Qm9Cw0L3QutCwXCIsXG4gIFwi0K3QutCy0LDQtNC+0YBcIixcbiAgXCLQrdGB0YLQvtC90LjRj1wiLFxuICBcItCt0YTQuNC+0L/QuNGPXCIsXG4gIFwi0K7QkNCgXCIsXG4gIFwi0K/QvNCw0LnQutCwXCIsXG4gIFwi0K/Qv9C+0L3QuNGPXCIsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjb3VudHJpZXM7XG4iLCJpbXBvcnQgYXV0b0NvbXBsZXRlIGZyb20gXCJAdGFyZWtyYWFmYXQvYXV0b2NvbXBsZXRlLmpzXCI7XG5pbXBvcnQgY291bnRyaWVzIGZyb20gXCIuL19jb3VudHJlcy5qc1wiO1xuXG5jb25zdCBhdXRvQ29tcGxldGVKUyA9IG5ldyBhdXRvQ29tcGxldGUoe1xuICBzZWxlY3RvcjogXCIjbG9jYXRpb25cIixcbiAgcGxhY2VIb2xkZXI6IFwiZS5nIEJhbGksIEluZG9uZXNpYVwiLFxuICBkYXRhOiB7XG4gICAgc3JjOiBjb3VudHJpZXMsXG4gICAgY2FjaGU6IHRydWUsXG4gIH0sXG4gIHJlc3VsdEl0ZW06IHtcbiAgICBoaWdobGlnaHQ6IHRydWUsXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIGlucHV0OiB7XG4gICAgICBzZWxlY3Rpb246IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBldmVudC5kZXRhaWwuc2VsZWN0aW9uLnZhbHVlO1xuICAgICAgICBhdXRvQ29tcGxldGVKUy5pbnB1dC52YWx1ZSA9IHNlbGVjdGlvbjtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn0pO1xuIiwiY2xhc3MgdCBleHRlbmRzIERhdGV7c3RhdGljIHBhcnNlRGF0ZVRpbWUoZSxpPVwiWVlZWS1NTS1ERFwiLG49XCJlbi1VU1wiKXtpZighZSlyZXR1cm4gbmV3IERhdGUoKG5ldyBEYXRlKS5zZXRIb3VycygwLDAsMCwwKSk7aWYoZSBpbnN0YW5jZW9mIHQpcmV0dXJuIGUudG9KU0RhdGUoKTtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gZTtpZigvXi0/XFxkezEwLH0kLy50ZXN0KFN0cmluZyhlKSkpcmV0dXJuIG5ldyBEYXRlKE51bWJlcihlKSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2NvbnN0IHM9W107bGV0IG89bnVsbDtmb3IoO251bGwhPShvPXQucmVnZXguZXhlYyhpKSk7KVwiXFxcXFwiIT09b1sxXSYmcy5wdXNoKG8pO2lmKHMubGVuZ3RoKXtjb25zdCBpPXt5ZWFyOm51bGwsbW9udGg6bnVsbCxzaG9ydE1vbnRoOm51bGwsbG9uZ01vbnRoOm51bGwsZGF5Om51bGwsaG91cjowLG1pbnV0ZTowLHNlY29uZDowLGFtcG06bnVsbCx2YWx1ZTpcIlwifTtzWzBdLmluZGV4PjAmJihpLnZhbHVlKz1cIi4qP1wiKTtmb3IoY29uc3RbZSxvXW9mIE9iamVjdC5lbnRyaWVzKHMpKXtjb25zdCBzPU51bWJlcihlKSx7Z3JvdXA6YSxwYXR0ZXJuOnJ9PXQuZm9ybWF0UGF0dGVybnMob1swXSxuKTtpW2FdPXMrMSxpLnZhbHVlKz1yLGkudmFsdWUrPVwiLio/XCJ9Y29uc3Qgbz1uZXcgUmVnRXhwKGBeJHtpLnZhbHVlfSRgKTtpZihvLnRlc3QoZSkpe2NvbnN0IHM9by5leGVjKGUpLGE9TnVtYmVyKHNbaS55ZWFyXSk7bGV0IHI9bnVsbDtpLm1vbnRoP3I9TnVtYmVyKHNbaS5tb250aF0pLTE6aS5zaG9ydE1vbnRoP3I9dC5zaG9ydE1vbnRocyhuKS5pbmRleE9mKHNbaS5zaG9ydE1vbnRoXSk6aS5sb25nTW9udGgmJihyPXQubG9uZ01vbnRocyhuKS5pbmRleE9mKHNbaS5sb25nTW9udGhdKSk7Y29uc3QgYz1OdW1iZXIoc1tpLmRheV0pfHwxLGw9TnVtYmVyKHNbaS5ob3VyXSk7bGV0IGg9TnVtYmVyLmlzTmFOKGwpPzA6bDtjb25zdCBkPU51bWJlcihzW2kubWludXRlXSkscD1OdW1iZXIuaXNOYU4oZCk/MDpkLHU9TnVtYmVyKHNbaS5zZWNvbmRdKSxnPU51bWJlci5pc05hTih1KT8wOnUsbT1zW2kuYW1wbV07cmV0dXJuIG0mJlwiUE1cIj09PW0mJihoKz0xMiwyND09PWgmJihoPTApKSxuZXcgRGF0ZShhLHIsYyxoLHAsZywwKX19fXJldHVybiBuZXcgRGF0ZSgobmV3IERhdGUpLnNldEhvdXJzKDAsMCwwLDApKX1zdGF0aWMgcmVnZXg9LyhcXFxcKT8oWXsyLDR9fE17MSw0fXxEezEsMn18SHsxLDJ9fGh7MSwyfXxtezEsMn18c3sxLDJ9fEF8YSkvZztzdGF0aWMgTU9OVEhfSlM9WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTFdO3N0YXRpYyBzaG9ydE1vbnRocyhlKXtyZXR1cm4gdC5NT05USF9KUy5tYXAoKHQ9Pm5ldyBEYXRlKDIwMTksdCkudG9Mb2NhbGVTdHJpbmcoZSx7bW9udGg6XCJzaG9ydFwifSkpKX1zdGF0aWMgbG9uZ01vbnRocyhlKXtyZXR1cm4gdC5NT05USF9KUy5tYXAoKHQ9Pm5ldyBEYXRlKDIwMTksdCkudG9Mb2NhbGVTdHJpbmcoZSx7bW9udGg6XCJsb25nXCJ9KSkpfXN0YXRpYyBmb3JtYXRQYXR0ZXJucyhlLGkpe3N3aXRjaChlKXtjYXNlXCJZWVwiOmNhc2VcIllZWVlcIjpyZXR1cm57Z3JvdXA6XCJ5ZWFyXCIscGF0dGVybjpgKFxcXFxkeyR7ZS5sZW5ndGh9fSlgfTtjYXNlXCJNXCI6cmV0dXJue2dyb3VwOlwibW9udGhcIixwYXR0ZXJuOlwiKFxcXFxkezEsMn0pXCJ9O2Nhc2VcIk1NXCI6cmV0dXJue2dyb3VwOlwibW9udGhcIixwYXR0ZXJuOlwiKFxcXFxkezJ9KVwifTtjYXNlXCJNTU1cIjpyZXR1cm57Z3JvdXA6XCJzaG9ydE1vbnRoXCIscGF0dGVybjpgKCR7dC5zaG9ydE1vbnRocyhpKS5qb2luKFwifFwiKX0pYH07Y2FzZVwiTU1NTVwiOnJldHVybntncm91cDpcImxvbmdNb250aFwiLHBhdHRlcm46YCgke3QubG9uZ01vbnRocyhpKS5qb2luKFwifFwiKX0pYH07Y2FzZVwiRFwiOnJldHVybntncm91cDpcImRheVwiLHBhdHRlcm46XCIoXFxcXGR7MSwyfSlcIn07Y2FzZVwiRERcIjpyZXR1cm57Z3JvdXA6XCJkYXlcIixwYXR0ZXJuOlwiKFxcXFxkezJ9KVwifTtjYXNlXCJoXCI6Y2FzZVwiSFwiOnJldHVybntncm91cDpcImhvdXJcIixwYXR0ZXJuOlwiKFxcXFxkezEsMn0pXCJ9O2Nhc2VcImhoXCI6Y2FzZVwiSEhcIjpyZXR1cm57Z3JvdXA6XCJob3VyXCIscGF0dGVybjpcIihcXFxcZHsyfSlcIn07Y2FzZVwibVwiOnJldHVybntncm91cDpcIm1pbnV0ZVwiLHBhdHRlcm46XCIoXFxcXGR7MSwyfSlcIn07Y2FzZVwibW1cIjpyZXR1cm57Z3JvdXA6XCJtaW51dGVcIixwYXR0ZXJuOlwiKFxcXFxkezJ9KVwifTtjYXNlXCJzXCI6cmV0dXJue2dyb3VwOlwic2Vjb25kXCIscGF0dGVybjpcIihcXFxcZHsxLDJ9KVwifTtjYXNlXCJzc1wiOnJldHVybntncm91cDpcInNlY29uZFwiLHBhdHRlcm46XCIoXFxcXGR7Mn0pXCJ9O2Nhc2VcImFcIjpjYXNlXCJBXCI6cmV0dXJue2dyb3VwOlwiYW1wbVwiLHBhdHRlcm46XCIoQU18UE18YW18cG0pXCJ9fX1sYW5nO2NvbnN0cnVjdG9yKGU9bnVsbCxpPVwiWVlZWS1NTS1ERFwiLG49XCJlbi1VU1wiKXtzdXBlcih0LnBhcnNlRGF0ZVRpbWUoZSxpLG4pKSx0aGlzLmxhbmc9bn1nZXRXZWVrKHQpe2NvbnN0IGU9bmV3IERhdGUodGhpcy5taWRuaWdodF90cyh0aGlzKSksaT0odGhpcy5nZXREYXkoKSsoNy10KSklNztlLnNldERhdGUoZS5nZXREYXRlKCktaSk7Y29uc3Qgbj1lLmdldFRpbWUoKTtyZXR1cm4gZS5zZXRNb250aCgwLDEpLGUuZ2V0RGF5KCkhPT10JiZlLnNldE1vbnRoKDAsMSsoNC1lLmdldERheSgpKzcpJTcpLDErTWF0aC5jZWlsKChuLWUuZ2V0VGltZSgpKS82MDQ4ZTUpfWNsb25lKCl7cmV0dXJuIG5ldyB0KHRoaXMpfXRvSlNEYXRlKCl7cmV0dXJuIG5ldyBEYXRlKHRoaXMpfWluQXJyYXkodCxlPVwiW11cIil7cmV0dXJuIHQuc29tZSgodD0+dCBpbnN0YW5jZW9mIEFycmF5P3RoaXMuaXNCZXR3ZWVuKHRbMF0sdFsxXSxlKTp0aGlzLmlzU2FtZSh0LFwiZGF5XCIpKSl9aXNCZXR3ZWVuKHQsZSxpPVwiKClcIil7c3dpdGNoKGkpe2RlZmF1bHQ6Y2FzZVwiKClcIjpyZXR1cm4gdGhpcy5taWRuaWdodF90cyh0aGlzKT50aGlzLm1pZG5pZ2h0X3RzKHQpJiZ0aGlzLm1pZG5pZ2h0X3RzKHRoaXMpPHRoaXMubWlkbmlnaHRfdHMoZSk7Y2FzZVwiWylcIjpyZXR1cm4gdGhpcy5taWRuaWdodF90cyh0aGlzKT49dGhpcy5taWRuaWdodF90cyh0KSYmdGhpcy5taWRuaWdodF90cyh0aGlzKTx0aGlzLm1pZG5pZ2h0X3RzKGUpO2Nhc2VcIihdXCI6cmV0dXJuIHRoaXMubWlkbmlnaHRfdHModGhpcyk+dGhpcy5taWRuaWdodF90cyh0KSYmdGhpcy5taWRuaWdodF90cyh0aGlzKTw9dGhpcy5taWRuaWdodF90cyhlKTtjYXNlXCJbXVwiOnJldHVybiB0aGlzLm1pZG5pZ2h0X3RzKCk+PXRoaXMubWlkbmlnaHRfdHModCkmJnRoaXMubWlkbmlnaHRfdHMoKTw9dGhpcy5taWRuaWdodF90cyhlKX19aXNCZWZvcmUodCxlPVwiZGF5c1wiKXtzd2l0Y2goZSl7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLHQuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk+bmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLHRoaXMuZ2V0TW9udGgoKSx0aGlzLmdldERhdGUoKSkuZ2V0VGltZSgpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMSkuZ2V0VGltZSgpPm5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpO2Nhc2VcInllYXJcIjpjYXNlXCJ5ZWFyc1wiOnJldHVybiB0LmdldEZ1bGxZZWFyKCk+dGhpcy5nZXRGdWxsWWVhcigpfXRocm93IG5ldyBFcnJvcihcImlzQmVmb3JlOiBJbnZhbGlkIHVuaXQhXCIpfWlzU2FtZU9yQmVmb3JlKHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpPj1uZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSwxKS5nZXRUaW1lKCk+PW5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpfXRocm93IG5ldyBFcnJvcihcImlzU2FtZU9yQmVmb3JlOiBJbnZhbGlkIHVuaXQhXCIpfWlzQWZ0ZXIodCxlPVwiZGF5c1wiKXtzd2l0Y2goZSl7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk+bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpPm5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMSkuZ2V0VGltZSgpO2Nhc2VcInllYXJcIjpjYXNlXCJ5ZWFyc1wiOnJldHVybiB0aGlzLmdldEZ1bGxZZWFyKCk+dC5nZXRGdWxsWWVhcigpfXRocm93IG5ldyBFcnJvcihcImlzQWZ0ZXI6IEludmFsaWQgdW5pdCFcIil9aXNTYW1lT3JBZnRlcih0LGU9XCJkYXlzXCIpe3N3aXRjaChlKXtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKT49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSx0LmdldERhdGUoKSkuZ2V0VGltZSgpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksMSkuZ2V0VGltZSgpPj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLDEpLmdldFRpbWUoKX10aHJvdyBuZXcgRXJyb3IoXCJpc1NhbWVPckFmdGVyOiBJbnZhbGlkIHVuaXQhXCIpfWlzU2FtZSh0LGU9XCJkYXlzXCIpe3N3aXRjaChlKXtjYXNlXCJkYXlcIjpjYXNlXCJkYXlzXCI6cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkpLmdldFRpbWUoKT09PW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksdC5nZXREYXRlKCkpLmdldFRpbWUoKTtjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLDEpLmdldFRpbWUoKT09PW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSx0LmdldE1vbnRoKCksMSkuZ2V0VGltZSgpfXRocm93IG5ldyBFcnJvcihcImlzU2FtZTogSW52YWxpZCB1bml0IVwiKX1hZGQodCxlPVwiZGF5c1wiKXtzd2l0Y2goZSl7Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnRoaXMuc2V0RGF0ZSh0aGlzLmdldERhdGUoKSt0KTticmVhaztjYXNlXCJtb250aFwiOmNhc2VcIm1vbnRoc1wiOnRoaXMuc2V0TW9udGgodGhpcy5nZXRNb250aCgpK3QpfXJldHVybiB0aGlzfXN1YnRyYWN0KHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2Nhc2VcImRheVwiOmNhc2VcImRheXNcIjp0aGlzLnNldERhdGUodGhpcy5nZXREYXRlKCktdCk7YnJlYWs7Y2FzZVwibW9udGhcIjpjYXNlXCJtb250aHNcIjp0aGlzLnNldE1vbnRoKHRoaXMuZ2V0TW9udGgoKS10KX1yZXR1cm4gdGhpc31kaWZmKHQsZT1cImRheXNcIil7c3dpdGNoKGUpe2RlZmF1bHQ6Y2FzZVwiZGF5XCI6Y2FzZVwiZGF5c1wiOnJldHVybiBNYXRoLnJvdW5kKCh0aGlzLm1pZG5pZ2h0X3RzKCktdGhpcy5taWRuaWdodF90cyh0KSkvODY0ZTUpO2Nhc2VcIm1vbnRoXCI6Y2FzZVwibW9udGhzXCI6bGV0IGU9MTIqKHQuZ2V0RnVsbFllYXIoKS10aGlzLmdldEZ1bGxZZWFyKCkpO3JldHVybiBlLT10LmdldE1vbnRoKCksZSs9dGhpcy5nZXRNb250aCgpLGV9fWZvcm1hdChlLGk9XCJlbi1VU1wiKXtsZXQgbj1cIlwiO2NvbnN0IHM9W107bGV0IG89bnVsbDtmb3IoO251bGwhPShvPXQucmVnZXguZXhlYyhlKSk7KVwiXFxcXFwiIT09b1sxXSYmcy5wdXNoKG8pO2lmKHMubGVuZ3RoKXtzWzBdLmluZGV4PjAmJihuKz1lLnN1YnN0cmluZygwLHNbMF0uaW5kZXgpKTtmb3IoY29uc3RbdCxvXW9mIE9iamVjdC5lbnRyaWVzKHMpKXtjb25zdCBhPU51bWJlcih0KTtuKz10aGlzLmZvcm1hdFRva2VucyhvWzBdLGkpLHNbYSsxXSYmKG4rPWUuc3Vic3RyaW5nKG8uaW5kZXgrb1swXS5sZW5ndGgsc1thKzFdLmluZGV4KSksYT09PXMubGVuZ3RoLTEmJihuKz1lLnN1YnN0cmluZyhvLmluZGV4K29bMF0ubGVuZ3RoKSl9fXJldHVybiBuLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1taWRuaWdodF90cyh0KXtyZXR1cm4gdD9uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksdC5nZXRNb250aCgpLHQuZ2V0RGF0ZSgpLDAsMCwwLDApLmdldFRpbWUoKTpuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksdGhpcy5nZXRNb250aCgpLHRoaXMuZ2V0RGF0ZSgpLDAsMCwwLDApLmdldFRpbWUoKX1mb3JtYXRUb2tlbnMoZSxpKXtzd2l0Y2goZSl7Y2FzZVwiWVlcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0RnVsbFllYXIoKSkuc2xpY2UoLTIpO2Nhc2VcIllZWVlcIjpyZXR1cm4gU3RyaW5nKHRoaXMuZ2V0RnVsbFllYXIoKSk7Y2FzZVwiTVwiOnJldHVybiBTdHJpbmcodGhpcy5nZXRNb250aCgpKzEpO2Nhc2VcIk1NXCI6cmV0dXJuYDAke3RoaXMuZ2V0TW9udGgoKSsxfWAuc2xpY2UoLTIpO2Nhc2VcIk1NTVwiOnJldHVybiB0LnNob3J0TW9udGhzKGkpW3RoaXMuZ2V0TW9udGgoKV07Y2FzZVwiTU1NTVwiOnJldHVybiB0LmxvbmdNb250aHMoaSlbdGhpcy5nZXRNb250aCgpXTtjYXNlXCJEXCI6cmV0dXJuIFN0cmluZyh0aGlzLmdldERhdGUoKSk7Y2FzZVwiRERcIjpyZXR1cm5gMCR7dGhpcy5nZXREYXRlKCl9YC5zbGljZSgtMik7Y2FzZVwiSFwiOnJldHVybiBTdHJpbmcodGhpcy5nZXRIb3VycygpKTtjYXNlXCJISFwiOnJldHVybmAwJHt0aGlzLmdldEhvdXJzKCl9YC5zbGljZSgtMik7Y2FzZVwiaFwiOnJldHVybiBTdHJpbmcodGhpcy5nZXRIb3VycygpJTEyfHwxMik7Y2FzZVwiaGhcIjpyZXR1cm5gMCR7dGhpcy5nZXRIb3VycygpJTEyfHwxMn1gLnNsaWNlKC0yKTtjYXNlXCJtXCI6cmV0dXJuIFN0cmluZyh0aGlzLmdldE1pbnV0ZXMoKSk7Y2FzZVwibW1cIjpyZXR1cm5gMCR7dGhpcy5nZXRNaW51dGVzKCl9YC5zbGljZSgtMik7Y2FzZVwic1wiOnJldHVybiBTdHJpbmcodGhpcy5nZXRTZWNvbmRzKCkpO2Nhc2VcInNzXCI6cmV0dXJuYDAke3RoaXMuZ2V0U2Vjb25kcygpfWAuc2xpY2UoLTIpO2Nhc2VcImFcIjpyZXR1cm4gdGhpcy5nZXRIb3VycygpPDEyfHwyND09PXRoaXMuZ2V0SG91cnMoKT9cImFtXCI6XCJwbVwiO2Nhc2VcIkFcIjpyZXR1cm4gdGhpcy5nZXRIb3VycygpPDEyfHwyND09PXRoaXMuZ2V0SG91cnMoKT9cIkFNXCI6XCJQTVwiO2RlZmF1bHQ6cmV0dXJuXCJcIn19fWNsYXNzIGV7cGlja2VyO2NvbnN0cnVjdG9yKHQpe3RoaXMucGlja2VyPXR9cmVuZGVyKGUsaSl7ZXx8KGU9bmV3IHQpLGUuc2V0RGF0ZSgxKSxlLnNldEhvdXJzKDAsMCwwLDApLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXNbYGdldCR7aX1WaWV3YF0mJnRoaXNbYGdldCR7aX1WaWV3YF0oZSl9Z2V0Q29udGFpbmVyVmlldyh0KXt0aGlzLnBpY2tlci51aS5jb250YWluZXIuaW5uZXJIVE1MPVwiXCIsdGhpcy5waWNrZXIub3B0aW9ucy5oZWFkZXImJnRoaXMucGlja2VyLnRyaWdnZXIoXCJyZW5kZXJcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkhlYWRlclwifSksdGhpcy5waWNrZXIudHJpZ2dlcihcInJlbmRlclwiLHtkYXRlOnQuY2xvbmUoKSx2aWV3OlwiTWFpblwifSksdGhpcy5waWNrZXIub3B0aW9ucy5hdXRvQXBwbHl8fHRoaXMucGlja2VyLnRyaWdnZXIoXCJyZW5kZXJcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkZvb3RlclwifSl9Z2V0SGVhZGVyVmlldyh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoZWFkZXJcIik7dGhpcy5waWNrZXIub3B0aW9ucy5oZWFkZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmZS5hcHBlbmRDaGlsZCh0aGlzLnBpY2tlci5vcHRpb25zLmhlYWRlciksXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMucGlja2VyLm9wdGlvbnMuaGVhZGVyJiYoZS5pbm5lckhUTUw9dGhpcy5waWNrZXIub3B0aW9ucy5oZWFkZXIpLHRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt0YXJnZXQ6ZSxkYXRlOnQuY2xvbmUoKSx2aWV3OlwiSGVhZGVyXCJ9KX1nZXRNYWluVmlldyh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJtYWluXCIpO3RoaXMucGlja2VyLnVpLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5jbGFzc05hbWU9YGNhbGVuZGFycyBncmlkLSR7dGhpcy5waWNrZXIub3B0aW9ucy5ncmlkfWA7Zm9yKGxldCBlPTA7ZTx0aGlzLnBpY2tlci5vcHRpb25zLmNhbGVuZGFycztlKyspe2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtuLmNsYXNzTmFtZT1cImNhbGVuZGFyXCIsaS5hcHBlbmRDaGlsZChuKTtjb25zdCBzPXRoaXMuZ2V0Q2FsZW5kYXJIZWFkZXJWaWV3KHQuY2xvbmUoKSk7bi5hcHBlbmRDaGlsZChzKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHtkYXRlOnQuY2xvbmUoKSx2aWV3OlwiQ2FsZW5kYXJIZWFkZXJcIixpbmRleDplLHRhcmdldDpzfSk7Y29uc3Qgbz10aGlzLmdldENhbGVuZGFyRGF5TmFtZXNWaWV3KCk7bi5hcHBlbmRDaGlsZChvKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHtkYXRlOnQuY2xvbmUoKSx2aWV3OlwiQ2FsZW5kYXJEYXlOYW1lc1wiLGluZGV4OmUsdGFyZ2V0Om99KTtjb25zdCBhPXRoaXMuZ2V0Q2FsZW5kYXJEYXlzVmlldyh0LmNsb25lKCkpO24uYXBwZW5kQ2hpbGQoYSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkNhbGVuZGFyRGF5c1wiLGluZGV4OmUsdGFyZ2V0OmF9KTtjb25zdCByPXRoaXMuZ2V0Q2FsZW5kYXJGb290ZXJWaWV3KHRoaXMucGlja2VyLm9wdGlvbnMubGFuZyx0LmNsb25lKCkpO24uYXBwZW5kQ2hpbGQociksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkNhbGVuZGFyRm9vdGVyXCIsaW5kZXg6ZSx0YXJnZXQ6cn0pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6dC5jbG9uZSgpLHZpZXc6XCJDYWxlbmRhckl0ZW1cIixpbmRleDplLHRhcmdldDpufSksdC5hZGQoMSxcIm1vbnRoXCIpfWUuYXBwZW5kQ2hpbGQoaSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIkNhbGVuZGFyc1wiLHRhcmdldDppfSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LmNsb25lKCksdmlldzpcIk1haW5cIix0YXJnZXQ6ZX0pfWdldEZvb3RlclZpZXcodCl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIpLGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpLmNsYXNzTmFtZT1cImZvb3Rlci1idXR0b25zXCI7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO24uY2xhc3NOYW1lPVwiY2FuY2VsLWJ1dHRvbiB1bml0XCIsbi5pbm5lckhUTUw9dGhpcy5waWNrZXIub3B0aW9ucy5sb2NhbGUuY2FuY2VsLGkuYXBwZW5kQ2hpbGQobik7Y29uc3Qgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO3MuY2xhc3NOYW1lPVwiYXBwbHktYnV0dG9uIHVuaXRcIixzLmlubmVySFRNTD10aGlzLnBpY2tlci5vcHRpb25zLmxvY2FsZS5hcHBseSxzLmRpc2FibGVkPSEwLGkuYXBwZW5kQ2hpbGQocyksZS5hcHBlbmRDaGlsZChpKSx0aGlzLnBpY2tlci51aS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LHRhcmdldDplLHZpZXc6XCJGb290ZXJcIn0pfWdldENhbGVuZGFySGVhZGVyVmlldyh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9XCJoZWFkZXJcIjtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5jbGFzc05hbWU9XCJtb250aC1uYW1lXCIsaS5pbm5lckhUTUw9YDxzcGFuPiR7dC50b0xvY2FsZVN0cmluZyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcse21vbnRoOlwibG9uZ1wifSl9PC9zcGFuPiAke3QuZm9ybWF0KFwiWVlZWVwiKX1gLGUuYXBwZW5kQ2hpbGQoaSk7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO24uY2xhc3NOYW1lPVwicHJldmlvdXMtYnV0dG9uIHVuaXRcIixuLmlubmVySFRNTD10aGlzLnBpY2tlci5vcHRpb25zLmxvY2FsZS5wcmV2aW91c01vbnRoLGUuYXBwZW5kQ2hpbGQobik7Y29uc3Qgcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO3JldHVybiBzLmNsYXNzTmFtZT1cIm5leHQtYnV0dG9uIHVuaXRcIixzLmlubmVySFRNTD10aGlzLnBpY2tlci5vcHRpb25zLmxvY2FsZS5uZXh0TW9udGgsZS5hcHBlbmRDaGlsZChzKSxlfWdldENhbGVuZGFyRGF5TmFtZXNWaWV3KCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3QuY2xhc3NOYW1lPVwiZGF5bmFtZXMtcm93XCI7Zm9yKGxldCBlPTE7ZTw9NztlKyspe2NvbnN0IGk9Myt0aGlzLnBpY2tlci5vcHRpb25zLmZpcnN0RGF5K2Usbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO24uY2xhc3NOYW1lPVwiZGF5bmFtZVwiLG4uaW5uZXJIVE1MPW5ldyBEYXRlKDE5NzAsMCxpLDEyLDAsMCwwKS50b0xvY2FsZVN0cmluZyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcse3dlZWtkYXk6XCJzaG9ydFwifSksbi50aXRsZT1uZXcgRGF0ZSgxOTcwLDAsaSwxMiwwLDAsMCkudG9Mb2NhbGVTdHJpbmcodGhpcy5waWNrZXIub3B0aW9ucy5sYW5nLHt3ZWVrZGF5OlwibG9uZ1wifSksdC5hcHBlbmRDaGlsZChuKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHtkYXlJZHg6aSx2aWV3OlwiQ2FsZW5kYXJEYXlOYW1lXCIsdGFyZ2V0Om59KX1yZXR1cm4gdH1nZXRDYWxlbmRhckRheXNWaWV3KHQpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtlLmNsYXNzTmFtZT1cImRheXMtZ3JpZFwiO2NvbnN0IGk9dGhpcy5jYWxjT2Zmc2V0RGF5cyh0LHRoaXMucGlja2VyLm9wdGlvbnMuZmlyc3REYXkpLG49MzItbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLHQuZ2V0TW9udGgoKSwzMikuZ2V0RGF0ZSgpO2ZvcihsZXQgdD0wO3Q8aTt0Kyspe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cIm9mZnNldFwiLGUuYXBwZW5kQ2hpbGQodCl9Zm9yKGxldCBpPTE7aTw9bjtpKyspe3Quc2V0RGF0ZShpKTtjb25zdCBuPXRoaXMuZ2V0Q2FsZW5kYXJEYXlWaWV3KHQpO2UuYXBwZW5kQ2hpbGQobiksdGhpcy5waWNrZXIudHJpZ2dlcihcInZpZXdcIix7ZGF0ZTp0LHZpZXc6XCJDYWxlbmRhckRheVwiLHRhcmdldDpufSl9cmV0dXJuIGV9Z2V0Q2FsZW5kYXJEYXlWaWV3KGUpe2NvbnN0IGk9dGhpcy5waWNrZXIub3B0aW9ucy5kYXRlP25ldyB0KHRoaXMucGlja2VyLm9wdGlvbnMuZGF0ZSk6bnVsbCxuPW5ldyB0LHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gcy5jbGFzc05hbWU9XCJkYXkgdW5pdFwiLHMuaW5uZXJIVE1MPWUuZm9ybWF0KFwiRFwiKSxzLmRhdGFzZXQudGltZT1TdHJpbmcoZS5nZXRUaW1lKCkpLGUuaXNTYW1lKG4sXCJkYXlcIikmJnMuY2xhc3NMaXN0LmFkZChcInRvZGF5XCIpLFswLDZdLmluY2x1ZGVzKGUuZ2V0RGF5KCkpJiZzLmNsYXNzTGlzdC5hZGQoXCJ3ZWVrZW5kXCIpLHRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoP3RoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uaXNTYW1lKGUsXCJkYXlcIikmJnMuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpOmkmJmUuaXNTYW1lKGksXCJkYXlcIikmJnMuY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkXCIpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse2RhdGU6ZSx2aWV3OlwiQ2FsZW5kYXJEYXlcIix0YXJnZXQ6c30pLHN9Z2V0Q2FsZW5kYXJGb290ZXJWaWV3KHQsZSl7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiBpLmNsYXNzTmFtZT1cImZvb3RlclwiLGl9Y2FsY09mZnNldERheXModCxlKXtsZXQgaT10LmdldERheSgpLWU7cmV0dXJuIGk8MCYmKGkrPTcpLGl9fWNsYXNzIGl7cGlja2VyO2luc3RhbmNlcz17fTtjb25zdHJ1Y3Rvcih0KXt0aGlzLnBpY2tlcj10fWluaXRpYWxpemUoKXtjb25zdCB0PVtdO3RoaXMucGlja2VyLm9wdGlvbnMucGx1Z2lucy5mb3JFYWNoKChlPT57XCJmdW5jdGlvblwiPT10eXBlb2YgZT90LnB1c2gobmV3IGUpOlwic3RyaW5nXCI9PXR5cGVvZiBlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZWFzZXBpY2smJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlYXNlcGljayxlKT90LnB1c2gobmV3IGVhc2VwaWNrW2VdKTpjb25zb2xlLndhcm4oYGVhc2VwaWNrOiAke2V9IG5vdCBmb3VuZC5gKX0pKSx0LnNvcnQoKCh0LGUpPT50LnByaW9yaXR5PmUucHJpb3JpdHk/LTE6dC5wcmlvcml0eTxlLnByaW9yaXR5fHx0LmRlcGVuZGVuY2llcy5sZW5ndGg+ZS5kZXBlbmRlbmNpZXMubGVuZ3RoPzE6dC5kZXBlbmRlbmNpZXMubGVuZ3RoPGUuZGVwZW5kZW5jaWVzLmxlbmd0aD8tMTowKSksdC5mb3JFYWNoKCh0PT57dC5hdHRhY2godGhpcy5waWNrZXIpLHRoaXMuaW5zdGFuY2VzW3QuZ2V0TmFtZSgpXT10fSkpfWdldEluc3RhbmNlKHQpe3JldHVybiB0aGlzLmluc3RhbmNlc1t0XX1hZGRJbnN0YW5jZSh0KXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5pbnN0YW5jZXMsdCkpY29uc29sZS53YXJuKGBlYXNlcGljazogJHt0fSBhbHJlYWR5IGFkZGVkLmApO2Vsc2V7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGVhc2VwaWNrJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWFzZXBpY2ssdCkpe2NvbnN0IGU9bmV3IGVhc2VwaWNrW3RdO3JldHVybiBlLmF0dGFjaCh0aGlzLnBpY2tlciksdGhpcy5pbnN0YW5jZXNbZS5nZXROYW1lKCldPWUsZX1pZihcInVuZGVmaW5lZFwiIT09dGhpcy5nZXRQbHVnaW5Gbih0KSl7Y29uc3QgZT1uZXcodGhpcy5nZXRQbHVnaW5Gbih0KSk7cmV0dXJuIGUuYXR0YWNoKHRoaXMucGlja2VyKSx0aGlzLmluc3RhbmNlc1tlLmdldE5hbWUoKV09ZSxlfWNvbnNvbGUud2FybihgZWFzZXBpY2s6ICR7dH0gbm90IGZvdW5kLmApfXJldHVybiBudWxsfXJlbW92ZUluc3RhbmNlKHQpe3JldHVybiB0IGluIHRoaXMuaW5zdGFuY2VzJiZ0aGlzLmluc3RhbmNlc1t0XS5kZXRhY2goKSxkZWxldGUgdGhpcy5pbnN0YW5jZXNbdF19cmVsb2FkSW5zdGFuY2UodCl7cmV0dXJuIHRoaXMucmVtb3ZlSW5zdGFuY2UodCksdGhpcy5hZGRJbnN0YW5jZSh0KX1nZXRQbHVnaW5Gbih0KXtyZXR1cm5bLi4udGhpcy5waWNrZXIub3B0aW9ucy5wbHVnaW5zXS5maWx0ZXIoKGU9PlwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihuZXcgZSkuZ2V0TmFtZSgpPT09dCkpLnNoaWZ0KCl9fWNsYXNzIG57Q2FsZW5kYXI9bmV3IGUodGhpcyk7UGx1Z2luTWFuYWdlcj1uZXcgaSh0aGlzKTtjYWxlbmRhcnM9W107ZGF0ZVBpY2tlZD1bXTtjc3NMb2FkZWQ9MDtiaW5kcz17aGlkZVBpY2tlcjp0aGlzLmhpZGVQaWNrZXIuYmluZCh0aGlzKSxzaG93OnRoaXMuc2hvdy5iaW5kKHRoaXMpfTtvcHRpb25zPXtkb2M6ZG9jdW1lbnQsY3NzOltdLGVsZW1lbnQ6bnVsbCxmaXJzdERheToxLGdyaWQ6MSxjYWxlbmRhcnM6MSxsYW5nOlwiZW4tVVNcIixkYXRlOm51bGwsZm9ybWF0OlwiWVlZWS1NTS1ERFwiLHJlYWRvbmx5OiEwLGF1dG9BcHBseTohMCxoZWFkZXI6ITEsaW5saW5lOiExLHNjcm9sbFRvRGF0ZTohMCxsb2NhbGU6e25leHRNb250aDonPHN2ZyB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0yLjc0OCAxNkwwIDEzLjMzMyA1LjMzMyA4IDAgMi42NjcgMi43NDggMGw3LjkxOSA4elwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxwcmV2aW91c01vbnRoOic8c3ZnIHdpZHRoPVwiMTFcIiBoZWlnaHQ9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTcuOTE5IDBsMi43NDggMi42NjdMNS4zMzMgOGw1LjMzNCA1LjMzM0w3LjkxOSAxNiAwIDh6XCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLGNhbmNlbDpcIkNhbmNlbFwiLGFwcGx5OlwiQXBwbHlcIn0sZG9jdW1lbnRDbGljazp0aGlzLmJpbmRzLmhpZGVQaWNrZXIscGx1Z2luczpbXX07dWk9e2NvbnRhaW5lcjpudWxsLHNoYWRvd1Jvb3Q6bnVsbCx3cmFwcGVyOm51bGx9O3ZlcnNpb249XCIxLjIuMVwiO2NvbnN0cnVjdG9yKHQpe2NvbnN0IGU9ey4uLnRoaXMub3B0aW9ucy5sb2NhbGUsLi4udC5sb2NhbGV9O3RoaXMub3B0aW9ucz17Li4udGhpcy5vcHRpb25zLC4uLnR9LHRoaXMub3B0aW9ucy5sb2NhbGU9ZSx0aGlzLmhhbmRsZU9wdGlvbnMoKSx0aGlzLnVpLndyYXBwZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIiksdGhpcy51aS53cmFwcGVyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy51aS53cmFwcGVyLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLnVpLndyYXBwZXIuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIix0aGlzLnVpLndyYXBwZXIuY2xhc3NOYW1lPVwiZWFzZXBpY2std3JhcHBlclwiLHRoaXMudWkud3JhcHBlci5hdHRhY2hTaGFkb3coe21vZGU6XCJvcGVuXCJ9KSx0aGlzLnVpLnNoYWRvd1Jvb3Q9dGhpcy51aS53cmFwcGVyLnNoYWRvd1Jvb3QsdGhpcy51aS5jb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLnVpLmNvbnRhaW5lci5jbGFzc05hbWU9XCJjb250YWluZXJcIix0aGlzLm9wdGlvbnMuekluZGV4JiYodGhpcy51aS5jb250YWluZXIuc3R5bGUuekluZGV4PVN0cmluZyh0aGlzLm9wdGlvbnMuekluZGV4KSksdGhpcy5vcHRpb25zLmlubGluZSYmKHRoaXMudWkud3JhcHBlci5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsdGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImlubGluZVwiKSksdGhpcy51aS5zaGFkb3dSb290LmFwcGVuZENoaWxkKHRoaXMudWkuY29udGFpbmVyKSx0aGlzLm9wdGlvbnMuZWxlbWVudC5hZnRlcih0aGlzLnVpLndyYXBwZXIpLHRoaXMuaGFuZGxlQ1NTKCksdGhpcy5vcHRpb25zLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5iaW5kcy5zaG93KSx0aGlzLm9uKFwidmlld1wiLHRoaXMub25WaWV3LmJpbmQodGhpcykpLHRoaXMub24oXCJyZW5kZXJcIix0aGlzLm9uUmVuZGVyLmJpbmQodGhpcykpLHRoaXMuUGx1Z2luTWFuYWdlci5pbml0aWFsaXplKCksdGhpcy5wYXJzZVZhbHVlcygpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5zZXR1cCYmdGhpcy5vcHRpb25zLnNldHVwKHRoaXMpLHRoaXMub24oXCJjbGlja1wiLHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtjb25zdCBpPXRoaXMub3B0aW9ucy5zY3JvbGxUb0RhdGU/dGhpcy5nZXREYXRlKCk6bnVsbDt0aGlzLnJlbmRlckFsbChpKX1vbih0LGUsaT17fSl7dGhpcy51aS5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcih0LGUsaSl9b2ZmKHQsZSxpPXt9KXt0aGlzLnVpLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKHQsZSxpKX10cmlnZ2VyKHQsZT17fSl7cmV0dXJuIHRoaXMudWkuY29udGFpbmVyLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KHQse2RldGFpbDplfSkpfWRlc3Ryb3koKXt0aGlzLm9wdGlvbnMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmJpbmRzLnNob3cpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5kb2N1bWVudENsaWNrJiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljaywhMCksT2JqZWN0LmtleXModGhpcy5QbHVnaW5NYW5hZ2VyLmluc3RhbmNlcykuZm9yRWFjaCgodD0+e3RoaXMuUGx1Z2luTWFuYWdlci5yZW1vdmVJbnN0YW5jZSh0KX0pKSx0aGlzLnVpLndyYXBwZXIucmVtb3ZlKCl9b25SZW5kZXIodCl7Y29uc3R7dmlldzplLGRhdGU6aX09dC5kZXRhaWw7dGhpcy5DYWxlbmRhci5yZW5kZXIoaSxlKX1vblZpZXcodCl7Y29uc3R7dmlldzplLHRhcmdldDppfT10LmRldGFpbDtcIkZvb3RlclwiPT09ZSYmdGhpcy5kYXRlUGlja2VkLmxlbmd0aCYmKGkucXVlcnlTZWxlY3RvcihcIi5hcHBseS1idXR0b25cIikuZGlzYWJsZWQ9ITEpfW9uQ2xpY2tIZWFkZXJCdXR0b24odCl7dGhpcy5pc0NhbGVuZGFySGVhZGVyQnV0dG9uKHQpJiYodC5jbGFzc0xpc3QuY29udGFpbnMoXCJuZXh0LWJ1dHRvblwiKT90aGlzLmNhbGVuZGFyc1swXS5hZGQoMSxcIm1vbnRoXCIpOnRoaXMuY2FsZW5kYXJzWzBdLnN1YnRyYWN0KDEsXCJtb250aFwiKSx0aGlzLnJlbmRlckFsbCh0aGlzLmNhbGVuZGFyc1swXSkpfW9uQ2xpY2tDYWxlbmRhckRheShlKXtpZih0aGlzLmlzQ2FsZW5kYXJEYXkoZSkpe2NvbnN0IGk9bmV3IHQoZS5kYXRhc2V0LnRpbWUpO3RoaXMub3B0aW9ucy5hdXRvQXBwbHk/KHRoaXMuc2V0RGF0ZShpKSx0aGlzLnRyaWdnZXIoXCJzZWxlY3RcIix7ZGF0ZTp0aGlzLmdldERhdGUoKX0pLHRoaXMuaGlkZSgpKToodGhpcy5kYXRlUGlja2VkWzBdPWksdGhpcy50cmlnZ2VyKFwicHJlc2VsZWN0XCIse2RhdGU6dGhpcy5nZXREYXRlKCl9KSx0aGlzLnJlbmRlckFsbCgpKX19b25DbGlja0FwcGx5QnV0dG9uKHQpe2lmKHRoaXMuaXNBcHBseUJ1dHRvbih0KSl7aWYodGhpcy5kYXRlUGlja2VkWzBdaW5zdGFuY2VvZiBEYXRlKXtjb25zdCB0PXRoaXMuZGF0ZVBpY2tlZFswXS5jbG9uZSgpO3RoaXMuc2V0RGF0ZSh0KX10aGlzLmhpZGUoKSx0aGlzLnRyaWdnZXIoXCJzZWxlY3RcIix7ZGF0ZTp0aGlzLmdldERhdGUoKX0pfX1vbkNsaWNrQ2FuY2VsQnV0dG9uKHQpe3RoaXMuaXNDYW5jZWxCdXR0b24odCkmJnRoaXMuaGlkZSgpfW9uQ2xpY2sodCl7Y29uc3QgZT10LnRhcmdldDtpZihlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe2NvbnN0IHQ9ZS5jbG9zZXN0KFwiLnVuaXRcIik7aWYoISh0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKXJldHVybjt0aGlzLm9uQ2xpY2tIZWFkZXJCdXR0b24odCksdGhpcy5vbkNsaWNrQ2FsZW5kYXJEYXkodCksdGhpcy5vbkNsaWNrQXBwbHlCdXR0b24odCksdGhpcy5vbkNsaWNrQ2FuY2VsQnV0dG9uKHQpfX1pc1Nob3duKCl7cmV0dXJuIHRoaXMudWkuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcImlubGluZVwiKXx8dGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwic2hvd1wiKX1zaG93KHQpe2lmKHRoaXMuaXNTaG93bigpKXJldHVybjtjb25zdCBlPXQmJlwidGFyZ2V0XCJpbiB0P3QudGFyZ2V0OnRoaXMub3B0aW9ucy5lbGVtZW50LHt0b3A6aSxsZWZ0Om59PXRoaXMuYWRqdXN0UG9zaXRpb24oZSk7dGhpcy51aS5jb250YWluZXIuc3R5bGUudG9wPWAke2l9cHhgLHRoaXMudWkuY29udGFpbmVyLnN0eWxlLmxlZnQ9YCR7bn1weGAsdGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNob3dcIiksdGhpcy50cmlnZ2VyKFwic2hvd1wiLHt0YXJnZXQ6ZX0pfWhpZGUoKXt0aGlzLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKSx0aGlzLmRhdGVQaWNrZWQubGVuZ3RoPTAsdGhpcy5yZW5kZXJBbGwoKSx0aGlzLnRyaWdnZXIoXCJoaWRlXCIpfXNldERhdGUoZSl7Y29uc3QgaT1uZXcgdChlLHRoaXMub3B0aW9ucy5mb3JtYXQpO3RoaXMub3B0aW9ucy5kYXRlPWkuY2xvbmUoKSx0aGlzLnVwZGF0ZVZhbHVlcygpLHRoaXMuY2FsZW5kYXJzLmxlbmd0aCYmdGhpcy5yZW5kZXJBbGwoKX1nZXREYXRlKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5kYXRlIGluc3RhbmNlb2YgdD90aGlzLm9wdGlvbnMuZGF0ZS5jbG9uZSgpOm51bGx9cGFyc2VWYWx1ZXMoKXt0aGlzLm9wdGlvbnMuZGF0ZT90aGlzLnNldERhdGUodGhpcy5vcHRpb25zLmRhdGUpOnRoaXMub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoJiZ0aGlzLnNldERhdGUodGhpcy5vcHRpb25zLmVsZW1lbnQudmFsdWUpLHRoaXMub3B0aW9ucy5kYXRlIGluc3RhbmNlb2YgRGF0ZXx8KHRoaXMub3B0aW9ucy5kYXRlPW51bGwpfXVwZGF0ZVZhbHVlcygpe2NvbnN0IHQ9dGhpcy5nZXREYXRlKCksZT10IGluc3RhbmNlb2YgRGF0ZT90LmZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LHRoaXMub3B0aW9ucy5sYW5nKTpcIlwiLGk9dGhpcy5vcHRpb25zLmVsZW1lbnQ7aSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ/aS52YWx1ZT1lOmkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmKGkuaW5uZXJUZXh0PWUpfWhpZGVQaWNrZXIodCl7bGV0IGU9dC50YXJnZXQsaT1udWxsO2Uuc2hhZG93Um9vdCYmKGU9dC5jb21wb3NlZFBhdGgoKVswXSxpPWUuZ2V0Um9vdE5vZGUoKS5ob3N0KSx0aGlzLmlzU2hvd24oKSYmaSE9PXRoaXMudWkud3JhcHBlciYmZSE9PXRoaXMub3B0aW9ucy5lbGVtZW50JiZ0aGlzLmhpZGUoKX1yZW5kZXJBbGwodCl7dGhpcy50cmlnZ2VyKFwicmVuZGVyXCIse3ZpZXc6XCJDb250YWluZXJcIixkYXRlOih0fHx0aGlzLmNhbGVuZGFyc1swXSkuY2xvbmUoKX0pfWlzQ2FsZW5kYXJIZWFkZXJCdXR0b24odCl7cmV0dXJuW1wicHJldmlvdXMtYnV0dG9uXCIsXCJuZXh0LWJ1dHRvblwiXS5zb21lKChlPT50LmNsYXNzTGlzdC5jb250YWlucyhlKSkpfWlzQ2FsZW5kYXJEYXkodCl7cmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGF5XCIpfWlzQXBwbHlCdXR0b24odCl7cmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXBwbHktYnV0dG9uXCIpfWlzQ2FuY2VsQnV0dG9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcImNhbmNlbC1idXR0b25cIil9Z290b0RhdGUoZSl7Y29uc3QgaT1uZXcgdChlLHRoaXMub3B0aW9ucy5mb3JtYXQpO2kuc2V0RGF0ZSgxKSx0aGlzLmNhbGVuZGFyc1swXT1pLmNsb25lKCksdGhpcy5yZW5kZXJBbGwoKX1jbGVhcigpe3RoaXMub3B0aW9ucy5kYXRlPW51bGwsdGhpcy5kYXRlUGlja2VkLmxlbmd0aD0wLHRoaXMudXBkYXRlVmFsdWVzKCksdGhpcy5yZW5kZXJBbGwoKSx0aGlzLnRyaWdnZXIoXCJjbGVhclwiKX1oYW5kbGVPcHRpb25zKCl7dGhpcy5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudHx8KHRoaXMub3B0aW9ucy5lbGVtZW50PXRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuZWxlbWVudCkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5kb2N1bWVudENsaWNrJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljaywhMCksdGhpcy5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiYodGhpcy5vcHRpb25zLmVsZW1lbnQucmVhZE9ubHk9dGhpcy5vcHRpb25zLnJlYWRvbmx5KSx0aGlzLm9wdGlvbnMuZGF0ZT90aGlzLmNhbGVuZGFyc1swXT1uZXcgdCh0aGlzLm9wdGlvbnMuZGF0ZSx0aGlzLm9wdGlvbnMuZm9ybWF0KTp0aGlzLmNhbGVuZGFyc1swXT1uZXcgdH1oYW5kbGVDU1MoKXtpZihBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5jc3MpKXRoaXMub3B0aW9ucy5jc3MuZm9yRWFjaCgodD0+e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7ZS5ocmVmPXQsZS5yZWw9XCJzdHlsZXNoZWV0XCI7Y29uc3QgaT0oKT0+e3RoaXMuY3NzTG9hZGVkKyssdGhpcy5jc3NMb2FkZWQ9PT10aGlzLm9wdGlvbnMuY3NzLmxlbmd0aCYmKHRoaXMudWkud3JhcHBlci5zdHlsZS5kaXNwbGF5PVwiXCIpfTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsaSksZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixpKSx0aGlzLnVpLnNoYWRvd1Jvb3QuYXBwZW5kKGUpfSkpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMub3B0aW9ucy5jc3Mpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLGU9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5vcHRpb25zLmNzcyk7dC5hcHBlbmRDaGlsZChlKSx0aGlzLnVpLnNoYWRvd1Jvb3QuYXBwZW5kKHQpLHRoaXMudWkud3JhcHBlci5zdHlsZS5kaXNwbGF5PVwiXCJ9ZWxzZVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5jc3MmJih0aGlzLm9wdGlvbnMuY3NzLmNhbGwodGhpcyx0aGlzKSx0aGlzLnVpLndyYXBwZXIuc3R5bGUuZGlzcGxheT1cIlwiKX1hZGp1c3RQb3NpdGlvbih0KXtjb25zdCBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT10aGlzLnVpLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dGhpcy51aS5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhbGNcIik7Y29uc3Qgbj10aGlzLnVpLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0aGlzLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiY2FsY1wiKTtsZXQgcz1lLmJvdHRvbS1pLmJvdHRvbSxvPWUubGVmdC1pLmxlZnQ7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5pbm5lckhlaWdodDxzK24uaGVpZ2h0JiZzLW4uaGVpZ2h0Pj0wJiYocz1lLnRvcC1pLnRvcC1uLmhlaWdodCksd2luZG93LmlubmVyV2lkdGg8bytuLndpZHRoJiZlLnJpZ2h0LW4ud2lkdGg+PTAmJihvPWUucmlnaHQtaS5yaWdodC1uLndpZHRoKSkse2xlZnQ6byx0b3A6c319fXZhciBzPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLENvcmU6bixjcmVhdGU6bn0pO2NsYXNzIG97cGlja2VyO29wdGlvbnM7cHJpb3JpdHk9MDtkZXBlbmRlbmNpZXM9W107YXR0YWNoKHQpe2NvbnN0IGU9dGhpcy5nZXROYW1lKCksaT17Li4udGhpcy5vcHRpb25zfTt0aGlzLm9wdGlvbnM9ey4uLnRoaXMub3B0aW9ucywuLi50Lm9wdGlvbnNbZV18fHt9fTtmb3IoY29uc3QgbiBvZiBPYmplY3Qua2V5cyhpKSlpZihudWxsIT09aVtuXSYmXCJvYmplY3RcIj09dHlwZW9mIGlbbl0mJk9iamVjdC5rZXlzKGlbbl0pLmxlbmd0aCYmZSBpbiB0Lm9wdGlvbnMmJm4gaW4gdC5vcHRpb25zW2VdKXtjb25zdCBzPXsuLi50Lm9wdGlvbnNbZV1bbl19O251bGwhPT1zJiZcIm9iamVjdFwiPT10eXBlb2YgcyYmT2JqZWN0LmtleXMocykubGVuZ3RoJiZPYmplY3Qua2V5cyhzKS5ldmVyeSgodD0+T2JqZWN0LmtleXMoaVtuXSkuaW5jbHVkZXModCkpKSYmKHRoaXMub3B0aW9uc1tuXT17Li4uaVtuXSwuLi5zfSl9aWYodGhpcy5waWNrZXI9dCx0aGlzLmRlcGVuZGVuY2llc05vdEZvdW5kKCkpe2NvbnN0IHQ9dGhpcy5kZXBlbmRlbmNpZXMuZmlsdGVyKCh0PT4hdGhpcy5wbHVnaW5zQXNTdHJpbmdBcnJheSgpLmluY2x1ZGVzKHQpKSk7cmV0dXJuIHZvaWQgY29uc29sZS53YXJuKGAke3RoaXMuZ2V0TmFtZSgpfTogcmVxdWlyZWQgZGVwZW5kZW5jaWVzICgke3Quam9pbihcIiwgXCIpfSkuYCl9Y29uc3Qgbj10aGlzLmNhbWVsQ2FzZVRvS2ViYWIodGhpcy5nZXROYW1lKCkpO3RoaXMucGlja2VyLnVpLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKG4pLHRoaXMub25BdHRhY2goKX1kZXRhY2goKXtjb25zdCB0PXRoaXMuY2FtZWxDYXNlVG9LZWJhYih0aGlzLmdldE5hbWUoKSk7dGhpcy5waWNrZXIudWkuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodCksXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vbkRldGFjaCYmdGhpcy5vbkRldGFjaCgpfWRlcGVuZGVuY2llc05vdEZvdW5kKCl7cmV0dXJuIHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aCYmIXRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KCh0PT50aGlzLnBsdWdpbnNBc1N0cmluZ0FycmF5KCkuaW5jbHVkZXModCkpKX1wbHVnaW5zQXNTdHJpbmdBcnJheSgpe3JldHVybiB0aGlzLnBpY2tlci5vcHRpb25zLnBsdWdpbnMubWFwKCh0PT5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0PyhuZXcgdCkuZ2V0TmFtZSgpOnQpKX1jYW1lbENhc2VUb0tlYmFiKHQpe3JldHVybiB0LnJlcGxhY2UoLyhbYS16QS1aXSkoPz1bQS1aXSkvZyxcIiQxLVwiKS50b0xvd2VyQ2FzZSgpfX1jbGFzcyBhIGV4dGVuZHMgb3twcmlvcml0eT0xO2JpbmRzPXtvblZpZXc6dGhpcy5vblZpZXcuYmluZCh0aGlzKX07b3B0aW9ucz17bWluRGF0ZTpudWxsLG1heERhdGU6bnVsbCxtaW5EYXlzOm51bGwsbWF4RGF5czpudWxsLHNlbGVjdEZvcndhcmQ6bnVsbCxzZWxlY3RCYWNrd2FyZDpudWxsLHByZXNldHM6ITAsaW5zZXBhcmFibGU6ITEsZmlsdGVyOm51bGx9O2dldE5hbWUoKXtyZXR1cm5cIkxvY2tQbHVnaW5cIn1vbkF0dGFjaCgpe2lmKHRoaXMub3B0aW9ucy5taW5EYXRlJiYodGhpcy5vcHRpb25zLm1pbkRhdGU9bmV3IHQodGhpcy5vcHRpb25zLm1pbkRhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQsdGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKSksdGhpcy5vcHRpb25zLm1heERhdGUmJih0aGlzLm9wdGlvbnMubWF4RGF0ZT1uZXcgdCh0aGlzLm9wdGlvbnMubWF4RGF0ZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCx0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLHRoaXMub3B0aW9ucy5tYXhEYXRlIGluc3RhbmNlb2YgdCYmdGhpcy5waWNrZXIub3B0aW9ucy5jYWxlbmRhcnM+MSYmdGhpcy5waWNrZXIuY2FsZW5kYXJzWzBdLmlzU2FtZSh0aGlzLm9wdGlvbnMubWF4RGF0ZSxcIm1vbnRoXCIpKSl7Y29uc3QgdD10aGlzLnBpY2tlci5jYWxlbmRhcnNbMF0uY2xvbmUoKS5zdWJ0cmFjdCgxLFwibW9udGhcIik7dGhpcy5waWNrZXIuZ290b0RhdGUodCl9aWYoKHRoaXMub3B0aW9ucy5taW5EYXlzfHx0aGlzLm9wdGlvbnMubWF4RGF5c3x8dGhpcy5vcHRpb25zLnNlbGVjdEZvcndhcmR8fHRoaXMub3B0aW9ucy5zZWxlY3RCYWNrd2FyZCkmJiF0aGlzLnBpY2tlci5vcHRpb25zLnBsdWdpbnMuaW5jbHVkZXMoXCJSYW5nZVBsdWdpblwiKSl7Y29uc3QgdD1bXCJtaW5EYXlzXCIsXCJtYXhEYXlzXCIsXCJzZWxlY3RGb3J3YXJkXCIsXCJzZWxlY3RCYWNrd2FyZFwiXTtjb25zb2xlLndhcm4oYCR7dGhpcy5nZXROYW1lKCl9OiBvcHRpb25zICR7dC5qb2luKFwiLCBcIil9IHJlcXVpcmVkIFJhbmdlUGx1Z2luLmApfXRoaXMucGlja2VyLm9uKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KX1vbkRldGFjaCgpe3RoaXMucGlja2VyLm9mZihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyl9b25WaWV3KGUpe2NvbnN0e3ZpZXc6aSx0YXJnZXQ6bixkYXRlOnN9PWUuZGV0YWlsO2lmKFwiQ2FsZW5kYXJIZWFkZXJcIj09PWkmJih0aGlzLm9wdGlvbnMubWluRGF0ZSBpbnN0YW5jZW9mIHQmJnMuaXNTYW1lT3JCZWZvcmUodGhpcy5vcHRpb25zLm1pbkRhdGUsXCJtb250aFwiKSYmbi5jbGFzc0xpc3QuYWRkKFwibm8tcHJldmlvdXMtbW9udGhcIiksdGhpcy5vcHRpb25zLm1heERhdGUgaW5zdGFuY2VvZiB0JiZzLmlzU2FtZU9yQWZ0ZXIodGhpcy5vcHRpb25zLm1heERhdGUsXCJtb250aFwiKSYmbi5jbGFzc0xpc3QuYWRkKFwibm8tbmV4dC1tb250aFwiKSksXCJDYWxlbmRhckRheVwiPT09aSl7Y29uc3QgdD10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aD90aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdOm51bGw7aWYodGhpcy50ZXN0RmlsdGVyKHMpKXJldHVybiB2b2lkIG4uY2xhc3NMaXN0LmFkZChcImxvY2tlZFwiKTtpZih0aGlzLm9wdGlvbnMuaW5zZXBhcmFibGUpe2lmKHRoaXMub3B0aW9ucy5taW5EYXlzKXtjb25zdCB0PXMuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLm9wdGlvbnMubWluRGF5cy0xLFwiZGF5XCIpLGU9cy5jbG9uZSgpLmFkZCh0aGlzLm9wdGlvbnMubWluRGF5cy0xLFwiZGF5XCIpO2xldCBpPSExLG89ITE7Zm9yKDt0LmlzQmVmb3JlKHMsXCJkYXlcIik7KXtpZih0aGlzLnRlc3RGaWx0ZXIodCkpe2k9ITA7YnJlYWt9dC5hZGQoMSxcImRheVwiKX1mb3IoO2UuaXNBZnRlcihzLFwiZGF5XCIpOyl7aWYodGhpcy50ZXN0RmlsdGVyKGUpKXtvPSEwO2JyZWFrfWUuc3VidHJhY3QoMSxcImRheVwiKX1pJiZvJiZuLmNsYXNzTGlzdC5hZGQoXCJub3QtYXZhaWxhYmxlXCIpfXRoaXMucmFuZ2VJc05vdEF2YWlsYWJsZShzLHQpJiZuLmNsYXNzTGlzdC5hZGQoXCJub3QtYXZhaWxhYmxlXCIpfXRoaXMuZGF0ZUlzTm90QXZhaWxhYmxlKHMsdCkmJm4uY2xhc3NMaXN0LmFkZChcIm5vdC1hdmFpbGFibGVcIil9aWYodGhpcy5vcHRpb25zLnByZXNldHMmJlwiUHJlc2V0UGx1Z2luQnV0dG9uXCI9PT1pKXtjb25zdCBlPW5ldyB0KE51bWJlcihuLmRhdGFzZXQuc3RhcnQpKSxpPW5ldyB0KE51bWJlcihuLmRhdGFzZXQuZW5kKSkscz1pLmRpZmYoZSxcImRheVwiKSxvPXRoaXMub3B0aW9ucy5taW5EYXlzJiZzPHRoaXMub3B0aW9ucy5taW5EYXlzLGE9dGhpcy5vcHRpb25zLm1heERheXMmJnM+dGhpcy5vcHRpb25zLm1heERheXM7KG98fGF8fHRoaXMubG9ja01pbkRhdGUoZSl8fHRoaXMubG9ja01heERhdGUoZSl8fHRoaXMubG9ja01pbkRhdGUoaSl8fHRoaXMubG9ja01heERhdGUoaSl8fHRoaXMucmFuZ2VJc05vdEF2YWlsYWJsZShlLGkpKSYmbi5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIil9fWRhdGVJc05vdEF2YWlsYWJsZSh0LGUpe3JldHVybiB0aGlzLmxvY2tNaW5EYXRlKHQpfHx0aGlzLmxvY2tNYXhEYXRlKHQpfHx0aGlzLmxvY2tNaW5EYXlzKHQsZSl8fHRoaXMubG9ja01heERheXModCxlKXx8dGhpcy5sb2NrU2VsZWN0Rm9yd2FyZCh0KXx8dGhpcy5sb2NrU2VsZWN0QmFja3dhcmQodCl9cmFuZ2VJc05vdEF2YWlsYWJsZSh0LGUpe2lmKCF0fHwhZSlyZXR1cm4hMTtjb25zdCBpPSh0LmlzU2FtZU9yQmVmb3JlKGUsXCJkYXlcIik/dDplKS5jbG9uZSgpLG49KGUuaXNTYW1lT3JBZnRlcih0LFwiZGF5XCIpP2U6dCkuY2xvbmUoKTtmb3IoO2kuaXNTYW1lT3JCZWZvcmUobixcImRheVwiKTspe2lmKHRoaXMudGVzdEZpbHRlcihpKSlyZXR1cm4hMDtpLmFkZCgxLFwiZGF5XCIpfXJldHVybiExfWxvY2tNaW5EYXRlKGUpe3JldHVybiB0aGlzLm9wdGlvbnMubWluRGF0ZSBpbnN0YW5jZW9mIHQmJmUuaXNCZWZvcmUodGhpcy5vcHRpb25zLm1pbkRhdGUsXCJkYXlcIil9bG9ja01heERhdGUoZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhEYXRlIGluc3RhbmNlb2YgdCYmZS5pc0FmdGVyKHRoaXMub3B0aW9ucy5tYXhEYXRlLFwiZGF5XCIpfWxvY2tNaW5EYXlzKHQsZSl7aWYodGhpcy5vcHRpb25zLm1pbkRheXMmJmUpe2NvbnN0IGk9ZS5jbG9uZSgpLnN1YnRyYWN0KHRoaXMub3B0aW9ucy5taW5EYXlzLTEsXCJkYXlcIiksbj1lLmNsb25lKCkuYWRkKHRoaXMub3B0aW9ucy5taW5EYXlzLTEsXCJkYXlcIik7cmV0dXJuIHQuaXNCZXR3ZWVuKGksbil9cmV0dXJuITF9bG9ja01heERheXModCxlKXtpZih0aGlzLm9wdGlvbnMubWF4RGF5cyYmZSl7Y29uc3QgaT1lLmNsb25lKCkuc3VidHJhY3QodGhpcy5vcHRpb25zLm1heERheXMsXCJkYXlcIiksbj1lLmNsb25lKCkuYWRkKHRoaXMub3B0aW9ucy5tYXhEYXlzLFwiZGF5XCIpO3JldHVybiF0LmlzQmV0d2VlbihpLG4pfXJldHVybiExfWxvY2tTZWxlY3RGb3J3YXJkKHQpe2lmKDE9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmdGhpcy5vcHRpb25zLnNlbGVjdEZvcndhcmQpe2NvbnN0IGU9dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXS5jbG9uZSgpO3JldHVybiB0LmlzQmVmb3JlKGUsXCJkYXlcIil9cmV0dXJuITF9bG9ja1NlbGVjdEJhY2t3YXJkKHQpe2lmKDE9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmdGhpcy5vcHRpb25zLnNlbGVjdEJhY2t3YXJkKXtjb25zdCBlPXRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uY2xvbmUoKTtyZXR1cm4gdC5pc0FmdGVyKGUsXCJkYXlcIil9cmV0dXJuITF9dGVzdEZpbHRlcih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMuZmlsdGVyJiZ0aGlzLm9wdGlvbnMuZmlsdGVyKHQsdGhpcy5waWNrZXIuZGF0ZVBpY2tlZCl9fWNsYXNzIHIgZXh0ZW5kcyBve2RlcGVuZGVuY2llcz1bXCJSYW5nZVBsdWdpblwiXTtiaW5kcz17b25WaWV3OnRoaXMub25WaWV3LmJpbmQodGhpcyksb25DbGljazp0aGlzLm9uQ2xpY2suYmluZCh0aGlzKX07b3B0aW9ucz17Y3VzdG9tTGFiZWxzOltcIlRvZGF5XCIsXCJZZXN0ZXJkYXlcIixcIkxhc3QgNyBEYXlzXCIsXCJMYXN0IDMwIERheXNcIixcIlRoaXMgTW9udGhcIixcIkxhc3QgTW9udGhcIl0sY3VzdG9tUHJlc2V0Ont9LHBvc2l0aW9uOlwibGVmdFwifTtnZXROYW1lKCl7cmV0dXJuXCJQcmVzZXRQbHVnaW5cIn1vbkF0dGFjaCgpe2lmKCFPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuY3VzdG9tUHJlc2V0KS5sZW5ndGgpe2NvbnN0IGU9bmV3IHQsaT0oKT0+e2NvbnN0IGk9ZS5jbG9uZSgpO2kuc2V0RGF0ZSgxKTtjb25zdCBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSxlLmdldE1vbnRoKCkrMSwwKTtyZXR1cm5bbmV3IHQoaSksbmV3IHQobildfSxuPSgpPT57Y29uc3QgaT1lLmNsb25lKCk7aS5zZXRNb250aChpLmdldE1vbnRoKCktMSksaS5zZXREYXRlKDEpO2NvbnN0IG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLGUuZ2V0TW9udGgoKSwwKTtyZXR1cm5bbmV3IHQoaSksbmV3IHQobildfSxzPVtbZS5jbG9uZSgpLGUuY2xvbmUoKV0sW2UuY2xvbmUoKS5zdWJ0cmFjdCgxLFwiZGF5XCIpLGUuY2xvbmUoKS5zdWJ0cmFjdCgxLFwiZGF5XCIpXSxbZS5jbG9uZSgpLnN1YnRyYWN0KDYsXCJkYXlcIiksZS5jbG9uZSgpXSxbZS5jbG9uZSgpLnN1YnRyYWN0KDI5LFwiZGF5XCIpLGUuY2xvbmUoKV0saSgpLG4oKV07T2JqZWN0LnZhbHVlcyh0aGlzLm9wdGlvbnMuY3VzdG9tTGFiZWxzKS5mb3JFYWNoKCgodCxlKT0+e3RoaXMub3B0aW9ucy5jdXN0b21QcmVzZXRbdF09c1tlXX0pKX10aGlzLnBpY2tlci5vbihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyksdGhpcy5waWNrZXIub24oXCJjbGlja1wiLHRoaXMuYmluZHMub25DbGljayl9b25EZXRhY2goKXt0aGlzLnBpY2tlci5vZmYoXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9mZihcImNsaWNrXCIsdGhpcy5iaW5kcy5vbkNsaWNrKX1vblZpZXcodCl7Y29uc3R7dmlldzplLHRhcmdldDppfT10LmRldGFpbDtpZihcIk1haW5cIj09PWUpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cInByZXNldC1wbHVnaW4tY29udGFpbmVyXCIsT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmN1c3RvbVByZXNldCkuZm9yRWFjaCgoZT0+e2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9wdGlvbnMuY3VzdG9tUHJlc2V0LGUpKXtjb25zdCBpPXRoaXMub3B0aW9ucy5jdXN0b21QcmVzZXRbZV0sbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO24uY2xhc3NOYW1lPVwicHJlc2V0LWJ1dHRvbiB1bml0XCIsbi5pbm5lckhUTUw9ZSxuLmRhdGFzZXQuc3RhcnQ9aVswXS5nZXRUaW1lKCksbi5kYXRhc2V0LmVuZD1pWzFdLmdldFRpbWUoKSx0LmFwcGVuZENoaWxkKG4pLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse3ZpZXc6XCJQcmVzZXRQbHVnaW5CdXR0b25cIix0YXJnZXQ6bn0pfX0pKSxpLmFwcGVuZENoaWxkKHQpLGkuY2xhc3NMaXN0LmFkZChgcHJlc2V0LSR7dGhpcy5vcHRpb25zLnBvc2l0aW9ufWApLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse3ZpZXc6XCJQcmVzZXRQbHVnaW5Db250YWluZXJcIix0YXJnZXQ6dH0pfX1vbkNsaWNrKGUpe2NvbnN0IGk9ZS50YXJnZXQ7aWYoaSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXtjb25zdCBlPWkuY2xvc2VzdChcIi51bml0XCIpO2lmKCEoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm47aWYodGhpcy5pc1ByZXNldEJ1dHRvbihlKSl7Y29uc3QgaT1uZXcgdChOdW1iZXIoZS5kYXRhc2V0LnN0YXJ0KSksbj1uZXcgdChOdW1iZXIoZS5kYXRhc2V0LmVuZCkpO3RoaXMucGlja2VyLm9wdGlvbnMuYXV0b0FwcGx5Pyh0aGlzLnBpY2tlci5zZXREYXRlUmFuZ2UoaSxuKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwic2VsZWN0XCIse3N0YXJ0OnRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSgpLGVuZDp0aGlzLnBpY2tlci5nZXRFbmREYXRlKCl9KSx0aGlzLnBpY2tlci5oaWRlKCkpOih0aGlzLnBpY2tlci5kYXRlUGlja2VkPVtpLG5dLHRoaXMucGlja2VyLnJlbmRlckFsbCgpKX19fWlzUHJlc2V0QnV0dG9uKHQpe3JldHVybiB0LmNsYXNzTGlzdC5jb250YWlucyhcInByZXNldC1idXR0b25cIil9fWNsYXNzIGMgZXh0ZW5kcyBve3Rvb2x0aXBFbGVtZW50O3RyaWdnZXJFbGVtZW50O2JpbmRzPXtzZXRTdGFydERhdGU6dGhpcy5zZXRTdGFydERhdGUuYmluZCh0aGlzKSxzZXRFbmREYXRlOnRoaXMuc2V0RW5kRGF0ZS5iaW5kKHRoaXMpLHNldERhdGVSYW5nZTp0aGlzLnNldERhdGVSYW5nZS5iaW5kKHRoaXMpLGdldFN0YXJ0RGF0ZTp0aGlzLmdldFN0YXJ0RGF0ZS5iaW5kKHRoaXMpLGdldEVuZERhdGU6dGhpcy5nZXRFbmREYXRlLmJpbmQodGhpcyksb25WaWV3OnRoaXMub25WaWV3LmJpbmQodGhpcyksb25TaG93OnRoaXMub25TaG93LmJpbmQodGhpcyksb25Nb3VzZUVudGVyOnRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcyksb25Nb3VzZUxlYXZlOnRoaXMub25Nb3VzZUxlYXZlLmJpbmQodGhpcyksb25DbGlja0NhbGVuZGFyRGF5OnRoaXMub25DbGlja0NhbGVuZGFyRGF5LmJpbmQodGhpcyksb25DbGlja0FwcGx5QnV0dG9uOnRoaXMub25DbGlja0FwcGx5QnV0dG9uLmJpbmQodGhpcykscGFyc2VWYWx1ZXM6dGhpcy5wYXJzZVZhbHVlcy5iaW5kKHRoaXMpLHVwZGF0ZVZhbHVlczp0aGlzLnVwZGF0ZVZhbHVlcy5iaW5kKHRoaXMpLGNsZWFyOnRoaXMuY2xlYXIuYmluZCh0aGlzKX07b3B0aW9ucz17ZWxlbWVudEVuZDpudWxsLHN0YXJ0RGF0ZTpudWxsLGVuZERhdGU6bnVsbCxyZXBpY2s6ITEsc3RyaWN0OiEwLGRlbGltaXRlcjpcIiAtIFwiLHRvb2x0aXA6ITAsdG9vbHRpcE51bWJlcjp0PT50LGxvY2FsZTp7emVybzpcIlwiLG9uZTpcImRheVwiLHR3bzpcIlwiLGZldzpcIlwiLG1hbnk6XCJcIixvdGhlcjpcImRheXNcIn0sZG9jdW1lbnRDbGljazp0aGlzLmhpZGVQaWNrZXIuYmluZCh0aGlzKX07Z2V0TmFtZSgpe3JldHVyblwiUmFuZ2VQbHVnaW5cIn1vbkF0dGFjaCgpe3RoaXMuYmluZHMuX3NldFN0YXJ0RGF0ZT10aGlzLnBpY2tlci5zZXRTdGFydERhdGUsdGhpcy5iaW5kcy5fc2V0RW5kRGF0ZT10aGlzLnBpY2tlci5zZXRFbmREYXRlLHRoaXMuYmluZHMuX3NldERhdGVSYW5nZT10aGlzLnBpY2tlci5zZXREYXRlUmFuZ2UsdGhpcy5iaW5kcy5fZ2V0U3RhcnREYXRlPXRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSx0aGlzLmJpbmRzLl9nZXRFbmREYXRlPXRoaXMucGlja2VyLmdldEVuZERhdGUsdGhpcy5iaW5kcy5fcGFyc2VWYWx1ZXM9dGhpcy5waWNrZXIucGFyc2VWYWx1ZXMsdGhpcy5iaW5kcy5fdXBkYXRlVmFsdWVzPXRoaXMucGlja2VyLnVwZGF0ZVZhbHVlcyx0aGlzLmJpbmRzLl9jbGVhcj10aGlzLnBpY2tlci5jbGVhcix0aGlzLmJpbmRzLl9vbkNsaWNrQ2FsZW5kYXJEYXk9dGhpcy5waWNrZXIub25DbGlja0NhbGVuZGFyRGF5LHRoaXMuYmluZHMuX29uQ2xpY2tBcHBseUJ1dHRvbj10aGlzLnBpY2tlci5vbkNsaWNrQXBwbHlCdXR0b24sT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5waWNrZXIse3NldFN0YXJ0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuc2V0U3RhcnREYXRlfSxzZXRFbmREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5zZXRFbmREYXRlfSxzZXREYXRlUmFuZ2U6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLnNldERhdGVSYW5nZX0sZ2V0U3RhcnREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5nZXRTdGFydERhdGV9LGdldEVuZERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLmdldEVuZERhdGV9LHBhcnNlVmFsdWVzOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5wYXJzZVZhbHVlc30sdXBkYXRlVmFsdWVzOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy51cGRhdGVWYWx1ZXN9LGNsZWFyOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5jbGVhcn0sb25DbGlja0NhbGVuZGFyRGF5Ontjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5vbkNsaWNrQ2FsZW5kYXJEYXl9LG9uQ2xpY2tBcHBseUJ1dHRvbjp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMub25DbGlja0FwcGx5QnV0dG9ufX0pLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kJiYodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudHx8KHRoaXMub3B0aW9ucy5lbGVtZW50RW5kPXRoaXMucGlja2VyLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQpKSx0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJih0aGlzLm9wdGlvbnMuZWxlbWVudEVuZC5yZWFkT25seT10aGlzLnBpY2tlci5vcHRpb25zLnJlYWRvbmx5KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLnBpY2tlci5vcHRpb25zLmRvY3VtZW50Q2xpY2smJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLnBpY2tlci5vcHRpb25zLmRvY3VtZW50Q2xpY2ssITApLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5kb2N1bWVudENsaWNrJiZkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLm9wdGlvbnMuZG9jdW1lbnRDbGljaywhMCkpLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMucGlja2VyLnNob3cuYmluZCh0aGlzLnBpY2tlcikpKSx0aGlzLm9wdGlvbnMucmVwaWNrPXRoaXMub3B0aW9ucy5yZXBpY2smJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQsdGhpcy5waWNrZXIub3B0aW9ucy5kYXRlPW51bGwsdGhpcy5waWNrZXIub24oXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9uKFwic2hvd1wiLHRoaXMuYmluZHMub25TaG93KSx0aGlzLnBpY2tlci5vbihcIm1vdXNlZW50ZXJcIix0aGlzLmJpbmRzLm9uTW91c2VFbnRlciwhMCksdGhpcy5waWNrZXIub24oXCJtb3VzZWxlYXZlXCIsdGhpcy5iaW5kcy5vbk1vdXNlTGVhdmUsITApLHRoaXMuY2hlY2tJbnRsUGx1cmFsTG9jYWxlcygpfW9uRGV0YWNoKCl7T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5waWNrZXIse3NldFN0YXJ0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX3NldFN0YXJ0RGF0ZX0sc2V0RW5kRGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX3NldEVuZERhdGV9LHNldERhdGVSYW5nZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX3NldERhdGVSYW5nZX0sZ2V0U3RhcnREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fZ2V0U3RhcnREYXRlfSxnZXRFbmREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fZ2V0RW5kRGF0ZX0scGFyc2VWYWx1ZXM6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9wYXJzZVZhbHVlc30sdXBkYXRlVmFsdWVzOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5fdXBkYXRlVmFsdWVzfSxjbGVhcjp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX2NsZWFyfSxvbkNsaWNrQ2FsZW5kYXJEYXk6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9vbkNsaWNrQ2FsZW5kYXJEYXl9LG9uQ2xpY2tBcHBseUJ1dHRvbjp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuX29uQ2xpY2tBcHBseUJ1dHRvbn19KSx0aGlzLnBpY2tlci5vZmYoXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9mZihcInNob3dcIix0aGlzLmJpbmRzLm9uU2hvdyksdGhpcy5waWNrZXIub2ZmKFwibW91c2VlbnRlclwiLHRoaXMuYmluZHMub25Nb3VzZUVudGVyLCEwKSx0aGlzLnBpY2tlci5vZmYoXCJtb3VzZWxlYXZlXCIsdGhpcy5iaW5kcy5vbk1vdXNlTGVhdmUsITApfXBhcnNlVmFsdWVzKCl7aWYodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZXx8dGhpcy5vcHRpb25zLmVuZERhdGUpdGhpcy5vcHRpb25zLnN0cmljdD90aGlzLm9wdGlvbnMuc3RhcnREYXRlJiZ0aGlzLm9wdGlvbnMuZW5kRGF0ZT90aGlzLnNldERhdGVSYW5nZSh0aGlzLm9wdGlvbnMuc3RhcnREYXRlLHRoaXMub3B0aW9ucy5lbmREYXRlKToodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT1udWxsLHRoaXMub3B0aW9ucy5lbmREYXRlPW51bGwpOih0aGlzLm9wdGlvbnMuc3RhcnREYXRlJiZ0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLm9wdGlvbnMuc3RhcnREYXRlKSx0aGlzLm9wdGlvbnMuZW5kRGF0ZSYmdGhpcy5zZXRFbmREYXRlKHRoaXMub3B0aW9ucy5lbmREYXRlKSk7ZWxzZSBpZih0aGlzLm9wdGlvbnMuZWxlbWVudEVuZCl0aGlzLm9wdGlvbnMuc3RyaWN0P3RoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgmJnRoaXMub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUubGVuZ3RoJiZ0aGlzLnNldERhdGVSYW5nZSh0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUsdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUpOih0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUubGVuZ3RoJiZ0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQudmFsdWUpLHRoaXMub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUubGVuZ3RoJiZ0aGlzLnNldEVuZERhdGUodGhpcy5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUpKTtlbHNlIGlmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgpe2NvbnN0W3QsZV09dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLnNwbGl0KHRoaXMub3B0aW9ucy5kZWxpbWl0ZXIpO3RoaXMub3B0aW9ucy5zdHJpY3Q/dCYmZSYmdGhpcy5zZXREYXRlUmFuZ2UodCxlKToodCYmdGhpcy5zZXRTdGFydERhdGUodCksZSYmdGhpcy5zZXRFbmREYXRlKGUpKX19dXBkYXRlVmFsdWVzKCl7Y29uc3QgdD10aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQsZT10aGlzLm9wdGlvbnMuZWxlbWVudEVuZCxpPXRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSgpLG49dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSgpLHM9aSBpbnN0YW5jZW9mIERhdGU/aS5mb3JtYXQodGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQsdGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKTpcIlwiLG89biBpbnN0YW5jZW9mIERhdGU/bi5mb3JtYXQodGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQsdGhpcy5waWNrZXIub3B0aW9ucy5sYW5nKTpcIlwiO2lmKGUpdCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQ/dC52YWx1ZT1zOnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCYmKHQuaW5uZXJUZXh0PXMpLGUgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50P2UudmFsdWU9bzplIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJihlLmlubmVyVGV4dD1vKTtlbHNle2NvbnN0IGU9YCR7c30ke3N8fG8/dGhpcy5vcHRpb25zLmRlbGltaXRlcjpcIlwifSR7b31gO3QgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50P3QudmFsdWU9ZTp0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJih0LmlubmVyVGV4dD1lKX19Y2xlYXIoKXt0aGlzLm9wdGlvbnMuc3RhcnREYXRlPW51bGwsdGhpcy5vcHRpb25zLmVuZERhdGU9bnVsbCx0aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aD0wLHRoaXMudXBkYXRlVmFsdWVzKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCksdGhpcy5waWNrZXIudHJpZ2dlcihcImNsZWFyXCIpfW9uU2hvdyh0KXtjb25zdHt0YXJnZXQ6ZX09dC5kZXRhaWw7dGhpcy50cmlnZ2VyRWxlbWVudD1lLHRoaXMucGlja2VyLm9wdGlvbnMuc2Nyb2xsVG9EYXRlJiZ0aGlzLmdldFN0YXJ0RGF0ZSgpaW5zdGFuY2VvZiBEYXRlJiZ0aGlzLnBpY2tlci5nb3RvRGF0ZSh0aGlzLmdldFN0YXJ0RGF0ZSgpKSx0aGlzLmluaXRpYWxpemVSZXBpY2soKX1vblZpZXcoZSl7Y29uc3R7dmlldzppLHRhcmdldDpufT1lLmRldGFpbDtpZihcIk1haW5cIj09PWkmJih0aGlzLnRvb2x0aXBFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLHRoaXMudG9vbHRpcEVsZW1lbnQuY2xhc3NOYW1lPVwicmFuZ2UtcGx1Z2luLXRvb2x0aXBcIixuLmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcEVsZW1lbnQpKSxcIkNhbGVuZGFyRGF5XCI9PT1pKXtjb25zdCBlPW5ldyB0KG4uZGF0YXNldC50aW1lKSxpPXRoaXMucGlja2VyLmRhdGVQaWNrZWQscz1pLmxlbmd0aD90aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdOnRoaXMuZ2V0U3RhcnREYXRlKCksbz1pLmxlbmd0aD90aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdOnRoaXMuZ2V0RW5kRGF0ZSgpO3MmJnMuaXNTYW1lKGUsXCJkYXlcIikmJm4uY2xhc3NMaXN0LmFkZChcInN0YXJ0XCIpLHMmJm8mJihvLmlzU2FtZShlLFwiZGF5XCIpJiZuLmNsYXNzTGlzdC5hZGQoXCJlbmRcIiksZS5pc0JldHdlZW4ocyxvKSYmbi5jbGFzc0xpc3QuYWRkKFwiaW4tcmFuZ2VcIikpfWlmKFwiRm9vdGVyXCI9PT1pKXtjb25zdCB0PTE9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmIXRoaXMub3B0aW9ucy5zdHJpY3R8fDI9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aDtuLnF1ZXJ5U2VsZWN0b3IoXCIuYXBwbHktYnV0dG9uXCIpLmRpc2FibGVkPSF0fX1oaWRlUGlja2VyKHQpe2xldCBlPXQudGFyZ2V0LGk9bnVsbDtlLnNoYWRvd1Jvb3QmJihlPXQuY29tcG9zZWRQYXRoKClbMF0saT1lLmdldFJvb3ROb2RlKCkuaG9zdCksdGhpcy5waWNrZXIuaXNTaG93bigpJiZpIT09dGhpcy5waWNrZXIudWkud3JhcHBlciYmZSE9PXRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCYmZSE9PXRoaXMub3B0aW9ucy5lbGVtZW50RW5kJiZ0aGlzLnBpY2tlci5oaWRlKCl9c2V0U3RhcnREYXRlKGUpe2NvbnN0IGk9bmV3IHQoZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT1pP2kuY2xvbmUoKTpudWxsLHRoaXMudXBkYXRlVmFsdWVzKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCl9c2V0RW5kRGF0ZShlKXtjb25zdCBpPW5ldyB0KGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMub3B0aW9ucy5lbmREYXRlPWk/aS5jbG9uZSgpOm51bGwsdGhpcy51cGRhdGVWYWx1ZXMoKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKX1zZXREYXRlUmFuZ2UoZSxpKXtjb25zdCBuPW5ldyB0KGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpLHM9bmV3IHQoaSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT1uP24uY2xvbmUoKTpudWxsLHRoaXMub3B0aW9ucy5lbmREYXRlPXM/cy5jbG9uZSgpOm51bGwsdGhpcy51cGRhdGVWYWx1ZXMoKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKX1nZXRTdGFydERhdGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSBpbnN0YW5jZW9mIERhdGU/dGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5jbG9uZSgpOm51bGx9Z2V0RW5kRGF0ZSgpe3JldHVybiB0aGlzLm9wdGlvbnMuZW5kRGF0ZSBpbnN0YW5jZW9mIERhdGU/dGhpcy5vcHRpb25zLmVuZERhdGUuY2xvbmUoKTpudWxsfW9uTW91c2VFbnRlcihlKXtjb25zdCBpPWUudGFyZ2V0O2lmKGkgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7dGhpcy5pc0NvbnRhaW5lcihpKSYmdGhpcy5pbml0aWFsaXplUmVwaWNrKCk7Y29uc3QgZT1pLmNsb3Nlc3QoXCIudW5pdFwiKTtpZighKGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpcmV0dXJuO2lmKHRoaXMucGlja2VyLmlzQ2FsZW5kYXJEYXkoZSkpe2lmKDEhPT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aClyZXR1cm47bGV0IGk9dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXS5jbG9uZSgpLG49bmV3IHQoZS5kYXRhc2V0LnRpbWUpLHM9ITE7aWYoaS5pc0FmdGVyKG4sXCJkYXlcIikpe2NvbnN0IHQ9aS5jbG9uZSgpO2k9bi5jbG9uZSgpLG49dC5jbG9uZSgpLHM9ITB9aWYoWy4uLnRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmRheVwiKV0uZm9yRWFjaCgobz0+e2NvbnN0IGE9bmV3IHQoby5kYXRhc2V0LnRpbWUpLHI9dGhpcy5waWNrZXIuQ2FsZW5kYXIuZ2V0Q2FsZW5kYXJEYXlWaWV3KGEpO2EuaXNCZXR3ZWVuKGksbikmJnIuY2xhc3NMaXN0LmFkZChcImluLXJhbmdlXCIpLGEuaXNTYW1lKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0sXCJkYXlcIikmJihyLmNsYXNzTGlzdC5hZGQoXCJzdGFydFwiKSxyLmNsYXNzTGlzdC50b2dnbGUoXCJmbGlwcGVkXCIscykpLG89PT1lJiYoci5jbGFzc0xpc3QuYWRkKFwiZW5kXCIpLHIuY2xhc3NMaXN0LnRvZ2dsZShcImZsaXBwZWRcIixzKSksby5jbGFzc05hbWU9ci5jbGFzc05hbWV9KSksdGhpcy5vcHRpb25zLnRvb2x0aXApe2NvbnN0IHQ9dGhpcy5vcHRpb25zLnRvb2x0aXBOdW1iZXIobi5kaWZmKGksXCJkYXlcIikrMSk7aWYodD4wKXtjb25zdCBpPW5ldyBJbnRsLlBsdXJhbFJ1bGVzKHRoaXMucGlja2VyLm9wdGlvbnMubGFuZykuc2VsZWN0KHQpLG49YCR7dH0gJHt0aGlzLm9wdGlvbnMubG9jYWxlW2ldfWA7dGhpcy5zaG93VG9vbHRpcChlLG4pfWVsc2UgdGhpcy5oaWRlVG9vbHRpcCgpfX19fW9uTW91c2VMZWF2ZSh0KXtpZih0aGlzLmlzQ29udGFpbmVyKHQudGFyZ2V0KSYmdGhpcy5vcHRpb25zLnJlcGljayl7Y29uc3QgdD10aGlzLmdldFN0YXJ0RGF0ZSgpLGU9dGhpcy5nZXRFbmREYXRlKCk7dCYmZSYmKHRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoPTAsdGhpcy5waWNrZXIucmVuZGVyQWxsKCkpfX1vbkNsaWNrQ2FsZW5kYXJEYXkoZSl7aWYodGhpcy5waWNrZXIuaXNDYWxlbmRhckRheShlKSl7Mj09PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiYodGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGg9MCk7Y29uc3QgaT1uZXcgdChlLmRhdGFzZXQudGltZSk7aWYodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFt0aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aF09aSwyPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJnRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uaXNBZnRlcih0aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdKSl7Y29uc3QgdD10aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdLmNsb25lKCk7dGhpcy5waWNrZXIuZGF0ZVBpY2tlZFsxXT10aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdLmNsb25lKCksdGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXT10LmNsb25lKCl9MSE9PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiZ0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseXx8dGhpcy5waWNrZXIudHJpZ2dlcihcInByZXNlbGVjdFwiLHtzdGFydDp0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdaW5zdGFuY2VvZiBEYXRlP3RoaXMucGlja2VyLmRhdGVQaWNrZWRbMF0uY2xvbmUoKTpudWxsLGVuZDp0aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdaW5zdGFuY2VvZiBEYXRlP3RoaXMucGlja2VyLmRhdGVQaWNrZWRbMV0uY2xvbmUoKTpudWxsfSksMT09PXRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiYoIXRoaXMub3B0aW9ucy5zdHJpY3QmJnRoaXMucGlja2VyLm9wdGlvbnMuYXV0b0FwcGx5JiYodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50PT09dGhpcy50cmlnZ2VyRWxlbWVudCYmdGhpcy5zZXRTdGFydERhdGUodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSksdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQ9PT10aGlzLnRyaWdnZXJFbGVtZW50JiZ0aGlzLnNldEVuZERhdGUodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSksdGhpcy5waWNrZXIudHJpZ2dlcihcInNlbGVjdFwiLHtzdGFydDp0aGlzLnBpY2tlci5nZXRTdGFydERhdGUoKSxlbmQ6dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSgpfSkpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpKSwyPT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGgmJih0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseT8odGhpcy5zZXREYXRlUmFuZ2UodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSx0aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwic2VsZWN0XCIse3N0YXJ0OnRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSgpLGVuZDp0aGlzLnBpY2tlci5nZXRFbmREYXRlKCl9KSx0aGlzLnBpY2tlci5oaWRlKCkpOih0aGlzLmhpZGVUb29sdGlwKCksdGhpcy5waWNrZXIucmVuZGVyQWxsKCkpKX19b25DbGlja0FwcGx5QnV0dG9uKHQpe3RoaXMucGlja2VyLmlzQXBwbHlCdXR0b24odCkmJigxIT09dGhpcy5waWNrZXIuZGF0ZVBpY2tlZC5sZW5ndGh8fHRoaXMub3B0aW9ucy5zdHJpY3R8fCh0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQ9PT10aGlzLnRyaWdnZXJFbGVtZW50JiYodGhpcy5vcHRpb25zLmVuZERhdGU9bnVsbCx0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdKSksdGhpcy5vcHRpb25zLmVsZW1lbnRFbmQ9PT10aGlzLnRyaWdnZXJFbGVtZW50JiYodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZT1udWxsLHRoaXMuc2V0RW5kRGF0ZSh0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdKSkpLDI9PT10aGlzLnBpY2tlci5kYXRlUGlja2VkLmxlbmd0aCYmdGhpcy5zZXREYXRlUmFuZ2UodGhpcy5waWNrZXIuZGF0ZVBpY2tlZFswXSx0aGlzLnBpY2tlci5kYXRlUGlja2VkWzFdKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwic2VsZWN0XCIse3N0YXJ0OnRoaXMucGlja2VyLmdldFN0YXJ0RGF0ZSgpLGVuZDp0aGlzLnBpY2tlci5nZXRFbmREYXRlKCl9KSx0aGlzLnBpY2tlci5oaWRlKCkpfXNob3dUb29sdGlwKHQsZSl7dGhpcy50b29sdGlwRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiLHRoaXMudG9vbHRpcEVsZW1lbnQuaW5uZXJIVE1MPWU7Y29uc3QgaT10aGlzLnBpY2tlci51aS5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10aGlzLnRvb2x0aXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtsZXQgbz1zLnRvcCxhPXMubGVmdDtvLT1pLnRvcCxhLT1pLmxlZnQsby09bi5oZWlnaHQsYS09bi53aWR0aC8yLGErPXMud2lkdGgvMix0aGlzLnRvb2x0aXBFbGVtZW50LnN0eWxlLnRvcD1gJHtvfXB4YCx0aGlzLnRvb2x0aXBFbGVtZW50LnN0eWxlLmxlZnQ9YCR7YX1weGB9aGlkZVRvb2x0aXAoKXt0aGlzLnRvb2x0aXBFbGVtZW50LnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIn1jaGVja0ludGxQbHVyYWxMb2NhbGVzKCl7aWYoIXRoaXMub3B0aW9ucy50b29sdGlwKXJldHVybjtjb25zdCB0PVsuLi5uZXcgU2V0KFtuZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCgwKSxuZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCgxKSxuZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCgyKSxuZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCg2KSxuZXcgSW50bC5QbHVyYWxSdWxlcyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcpLnNlbGVjdCgxOCldKV0sZT1PYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubG9jYWxlKTt0LmV2ZXJ5KCh0PT5lLmluY2x1ZGVzKHQpKSl8fGNvbnNvbGUud2FybihgJHt0aGlzLmdldE5hbWUoKX06IHByb3ZpZGUgbG9jYWxlcyAoJHt0LmpvaW4oXCIsIFwiKX0pIGZvciBjb3JyZWN0IHRvb2x0aXAgdGV4dC5gKX1pbml0aWFsaXplUmVwaWNrKCl7aWYoIXRoaXMub3B0aW9ucy5yZXBpY2spcmV0dXJuO2NvbnN0IHQ9dGhpcy5nZXRTdGFydERhdGUoKSxlPXRoaXMuZ2V0RW5kRGF0ZSgpO2UmJnRoaXMudHJpZ2dlckVsZW1lbnQ9PT10aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQmJih0aGlzLnBpY2tlci5kYXRlUGlja2VkWzBdPWUpLHQmJnRoaXMudHJpZ2dlckVsZW1lbnQ9PT10aGlzLm9wdGlvbnMuZWxlbWVudEVuZCYmKHRoaXMucGlja2VyLmRhdGVQaWNrZWRbMF09dCl9aXNDb250YWluZXIodCl7cmV0dXJuIHQ9PT10aGlzLnBpY2tlci51aS5jb250YWluZXJ9fWNsYXNzIGwgZXh0ZW5kcyBve29wdGlvbnM9e25hdGl2ZTohMSxzZWNvbmRzOiExLHN0ZXBIb3VyczoxLHN0ZXBNaW51dGVzOjUsc3RlcFNlY29uZHM6NSxmb3JtYXQxMjohMX07cmFuZ2VQbHVnaW47dGltZVBpY2tlZD17aW5wdXQ6bnVsbCxzdGFydDpudWxsLGVuZDpudWxsfTt0aW1lUHJlUGlja2VkPXtpbnB1dDpudWxsLHN0YXJ0Om51bGwsZW5kOm51bGx9O2JpbmRzPXtnZXREYXRlOnRoaXMuZ2V0RGF0ZS5iaW5kKHRoaXMpLGdldFN0YXJ0RGF0ZTp0aGlzLmdldFN0YXJ0RGF0ZS5iaW5kKHRoaXMpLGdldEVuZERhdGU6dGhpcy5nZXRFbmREYXRlLmJpbmQodGhpcyksb25WaWV3OnRoaXMub25WaWV3LmJpbmQodGhpcyksb25JbnB1dDp0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSxvbkNoYW5nZTp0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyksb25DbGljazp0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSxzZXRUaW1lOnRoaXMuc2V0VGltZS5iaW5kKHRoaXMpLHNldFN0YXJ0VGltZTp0aGlzLnNldFN0YXJ0VGltZS5iaW5kKHRoaXMpLHNldEVuZFRpbWU6dGhpcy5zZXRFbmRUaW1lLmJpbmQodGhpcyl9O2dldE5hbWUoKXtyZXR1cm5cIlRpbWVQbHVnaW5cIn1vbkF0dGFjaCgpe3RoaXMuYmluZHMuX2dldERhdGU9dGhpcy5waWNrZXIuZ2V0RGF0ZSx0aGlzLmJpbmRzLl9nZXRTdGFydERhdGU9dGhpcy5waWNrZXIuZ2V0U3RhcnREYXRlLHRoaXMuYmluZHMuX2dldEVuZERhdGU9dGhpcy5waWNrZXIuZ2V0RW5kRGF0ZSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLnBpY2tlcix7Z2V0RGF0ZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuZ2V0RGF0ZX0sZ2V0U3RhcnREYXRlOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5nZXRTdGFydERhdGV9LGdldEVuZERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLmdldEVuZERhdGV9LHNldFRpbWU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLnNldFRpbWV9LHNldFN0YXJ0VGltZTp7Y29uZmlndXJhYmxlOiEwLHZhbHVlOnRoaXMuYmluZHMuc2V0U3RhcnRUaW1lfSxzZXRFbmRUaW1lOntjb25maWd1cmFibGU6ITAsdmFsdWU6dGhpcy5iaW5kcy5zZXRFbmRUaW1lfX0pLHRoaXMucmFuZ2VQbHVnaW49dGhpcy5waWNrZXIuUGx1Z2luTWFuYWdlci5nZXRJbnN0YW5jZShcIlJhbmdlUGx1Z2luXCIpLHRoaXMucGFyc2VWYWx1ZXMoKSx0aGlzLnBpY2tlci5vbihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyksdGhpcy5waWNrZXIub24oXCJpbnB1dFwiLHRoaXMuYmluZHMub25JbnB1dCksdGhpcy5waWNrZXIub24oXCJjaGFuZ2VcIix0aGlzLmJpbmRzLm9uQ2hhbmdlKSx0aGlzLnBpY2tlci5vbihcImNsaWNrXCIsdGhpcy5iaW5kcy5vbkNsaWNrKX1vbkRldGFjaCgpe2RlbGV0ZSB0aGlzLnBpY2tlci5zZXRUaW1lLGRlbGV0ZSB0aGlzLnBpY2tlci5zZXRTdGFydFRpbWUsZGVsZXRlIHRoaXMucGlja2VyLnNldEVuZFRpbWUsT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5waWNrZXIse2dldERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9nZXREYXRlfSxnZXRTdGFydERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9nZXRTdGFydERhdGV9LGdldEVuZERhdGU6e2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTp0aGlzLmJpbmRzLl9nZXRFbmREYXRlfX0pLHRoaXMucGlja2VyLm9mZihcInZpZXdcIix0aGlzLmJpbmRzLm9uVmlldyksdGhpcy5waWNrZXIub2ZmKFwiaW5wdXRcIix0aGlzLmJpbmRzLm9uSW5wdXQpLHRoaXMucGlja2VyLm9mZihcImNoYW5nZVwiLHRoaXMuYmluZHMub25DaGFuZ2UpLHRoaXMucGlja2VyLm9mZihcImNsaWNrXCIsdGhpcy5iaW5kcy5vbkNsaWNrKX1vblZpZXcodCl7Y29uc3R7dmlldzplLHRhcmdldDppfT10LmRldGFpbDtpZihcIk1haW5cIj09PWUpe3RoaXMucmFuZ2VQbHVnaW49dGhpcy5waWNrZXIuUGx1Z2luTWFuYWdlci5nZXRJbnN0YW5jZShcIlJhbmdlUGx1Z2luXCIpO2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZih0LmNsYXNzTmFtZT1cInRpbWUtcGx1Z2luLWNvbnRhaW5lclwiLHRoaXMucmFuZ2VQbHVnaW4pe2NvbnN0IGU9dGhpcy5nZXRTdGFydElucHV0KCk7dC5hcHBlbmRDaGlsZChlKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiVGltZVBsdWdpbklucHV0XCIsdGFyZ2V0OmV9KTtjb25zdCBpPXRoaXMuZ2V0RW5kSW5wdXQoKTt0LmFwcGVuZENoaWxkKGkpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse3ZpZXc6XCJUaW1lUGx1Z2luSW5wdXRcIix0YXJnZXQ6aX0pfWVsc2V7Y29uc3QgZT10aGlzLmdldFNpbmdsZUlucHV0KCk7dC5hcHBlbmRDaGlsZChlKSx0aGlzLnBpY2tlci50cmlnZ2VyKFwidmlld1wiLHt2aWV3OlwiVGltZVBsdWdpbklucHV0XCIsdGFyZ2V0OmV9KX1pLmFwcGVuZENoaWxkKHQpLHRoaXMucGlja2VyLnRyaWdnZXIoXCJ2aWV3XCIse3ZpZXc6XCJUaW1lUGx1Z2luQ29udGFpbmVyXCIsdGFyZ2V0OnR9KX19b25JbnB1dChlKXtjb25zdCBpPWUudGFyZ2V0O2lmKGkgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZpLmNsYXNzTGlzdC5jb250YWlucyhcInRpbWUtcGx1Z2luLWlucHV0XCIpKXtjb25zdCBlPXRoaXMudGltZVBpY2tlZFtpLm5hbWVdfHxuZXcgdCxbbixzXT1pLnZhbHVlLnNwbGl0KFwiOlwiKTtlLnNldEhvdXJzKE51bWJlcihuKXx8MCxOdW1iZXIocyl8fDAsMCwwKSx0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseT8odGhpcy50aW1lUGlja2VkW2kubmFtZV09ZSx0aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMoKSk6dGhpcy50aW1lUHJlUGlja2VkW2kubmFtZV09ZX19b25DaGFuZ2UoZSl7Y29uc3QgaT1lLnRhcmdldDtpZihpIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQmJmkuY2xhc3NMaXN0LmNvbnRhaW5zKFwidGltZS1wbHVnaW4tY3VzdG9tLWlucHV0XCIpKXtjb25zdCBlPS8oXFx3KylcXFsoXFx3KylcXF0vLFssbixzXT1pLm5hbWUubWF0Y2goZSksbz1OdW1iZXIoaS52YWx1ZSk7bGV0IGE9bmV3IHQ7c3dpdGNoKCF0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseSYmdGhpcy50aW1lUHJlUGlja2VkW25daW5zdGFuY2VvZiBEYXRlP2E9dGhpcy50aW1lUHJlUGlja2VkW25dLmNsb25lKCk6dGhpcy50aW1lUGlja2VkW25daW5zdGFuY2VvZiBEYXRlJiYoYT10aGlzLnRpbWVQaWNrZWRbbl0uY2xvbmUoKSkscyl7Y2FzZVwiSEhcIjppZih0aGlzLm9wdGlvbnMuZm9ybWF0MTIpe2NvbnN0IHQ9aS5jbG9zZXN0KFwiLnRpbWUtcGx1Z2luLWN1c3RvbS1ibG9ja1wiKS5xdWVyeVNlbGVjdG9yKGBzZWxlY3RbbmFtZT1cIiR7bn1bcGVyaW9kXVwiXWApLnZhbHVlLGU9dGhpcy5oYW5kbGVGb3JtYXQxMih0LGEsbyk7YS5zZXRIb3VycyhlLmdldEhvdXJzKCksZS5nZXRNaW51dGVzKCksZS5nZXRTZWNvbmRzKCksMCl9ZWxzZSBhLnNldEhvdXJzKG8sYS5nZXRNaW51dGVzKCksYS5nZXRTZWNvbmRzKCksMCk7YnJlYWs7Y2FzZVwibW1cIjphLnNldEhvdXJzKGEuZ2V0SG91cnMoKSxvLGEuZ2V0U2Vjb25kcygpLDApO2JyZWFrO2Nhc2VcInNzXCI6YS5zZXRIb3VycyhhLmdldEhvdXJzKCksYS5nZXRNaW51dGVzKCksbywwKTticmVhaztjYXNlXCJwZXJpb2RcIjppZih0aGlzLm9wdGlvbnMuZm9ybWF0MTIpe2NvbnN0IHQ9aS5jbG9zZXN0KFwiLnRpbWUtcGx1Z2luLWN1c3RvbS1ibG9ja1wiKS5xdWVyeVNlbGVjdG9yKGBzZWxlY3RbbmFtZT1cIiR7bn1bSEhdXCJdYCkudmFsdWUsZT10aGlzLmhhbmRsZUZvcm1hdDEyKGkudmFsdWUsYSxOdW1iZXIodCkpO2Euc2V0SG91cnMoZS5nZXRIb3VycygpLGUuZ2V0TWludXRlcygpLGUuZ2V0U2Vjb25kcygpLDApfX1pZih0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseSl0aGlzLnRpbWVQaWNrZWRbbl09YSx0aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMoKTtlbHNle3RoaXMudGltZVByZVBpY2tlZFtuXT1hO2NvbnN0IHQ9dGhpcy5waWNrZXIudWkuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuYXBwbHktYnV0dG9uXCIpO2lmKHRoaXMucmFuZ2VQbHVnaW4pe2NvbnN0IGU9dGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLGk9dGhpcy5waWNrZXIuZGF0ZVBpY2tlZCxuPWUuc3RyaWN0JiYyPT09aS5sZW5ndGh8fCFlLnN0cmljdCYmaS5sZW5ndGg+MHx8IWkubGVuZ3RoJiZlLnN0cmljdCYmZS5zdGFydERhdGUgaW5zdGFuY2VvZiBEYXRlJiZlLmVuZERhdGUgaW5zdGFuY2VvZiBEYXRlfHwhaS5sZW5ndGgmJiFlLnN0cmljdCYmKGUuc3RhcnREYXRlIGluc3RhbmNlb2YgRGF0ZXx8ZS5lbmREYXRlIGluc3RhbmNlb2YgRGF0ZSk7dC5kaXNhYmxlZD0hbn1lbHNlIHRoaXMucGlja2VyLmRhdGVQaWNrZWQubGVuZ3RoJiYodC5kaXNhYmxlZD0hMSl9fX1vbkNsaWNrKHQpe2NvbnN0IGU9dC50YXJnZXQ7aWYoZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXtjb25zdCB0PWUuY2xvc2VzdChcIi51bml0XCIpO2lmKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm47dGhpcy5waWNrZXIuaXNBcHBseUJ1dHRvbih0KSYmKE9iamVjdC5rZXlzKHRoaXMudGltZVBpY2tlZCkuZm9yRWFjaCgodD0+e3RoaXMudGltZVByZVBpY2tlZFt0XWluc3RhbmNlb2YgRGF0ZSYmKHRoaXMudGltZVBpY2tlZFt0XT10aGlzLnRpbWVQcmVQaWNrZWRbdF0uY2xvbmUoKSl9KSksdGhpcy5waWNrZXIudXBkYXRlVmFsdWVzKCksdGhpcy50aW1lUHJlUGlja2VkPXtpbnB1dDpudWxsLHN0YXJ0Om51bGwsZW5kOm51bGx9KSx0aGlzLnBpY2tlci5pc0NhbmNlbEJ1dHRvbih0KSYmKHRoaXMudGltZVByZVBpY2tlZD17aW5wdXQ6bnVsbCxzdGFydDpudWxsLGVuZDpudWxsfSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSl9fXNldFRpbWUodCl7Y29uc3QgZT10aGlzLmhhbmRsZVRpbWVTdHJpbmcodCk7dGhpcy50aW1lUGlja2VkLmlucHV0PWUuY2xvbmUoKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSx0aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMoKX1zZXRTdGFydFRpbWUodCl7Y29uc3QgZT10aGlzLmhhbmRsZVRpbWVTdHJpbmcodCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWUuY2xvbmUoKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKSx0aGlzLnBpY2tlci51cGRhdGVWYWx1ZXMoKX1zZXRFbmRUaW1lKHQpe2NvbnN0IGU9dGhpcy5oYW5kbGVUaW1lU3RyaW5nKHQpO3RoaXMudGltZVBpY2tlZC5lbmQ9ZS5jbG9uZSgpLHRoaXMucGlja2VyLnJlbmRlckFsbCgpLHRoaXMucGlja2VyLnVwZGF0ZVZhbHVlcygpfWhhbmRsZVRpbWVTdHJpbmcoZSl7Y29uc3QgaT1uZXcgdCxbbixzLG9dPWUuc3BsaXQoXCI6XCIpLm1hcCgodD0+TnVtYmVyKHQpKSksYT1uJiYhTnVtYmVyLmlzTmFOKG4pP246MCxyPXMmJiFOdW1iZXIuaXNOYU4ocyk/czowLGM9byYmIU51bWJlci5pc05hTihvKT9vOjA7cmV0dXJuIGkuc2V0SG91cnMoYSxyLGMsMCksaX1nZXREYXRlKCl7aWYodGhpcy5waWNrZXIub3B0aW9ucy5kYXRlIGluc3RhbmNlb2YgRGF0ZSl7Y29uc3QgZT1uZXcgdCh0aGlzLnBpY2tlci5vcHRpb25zLmRhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO2lmKHRoaXMudGltZVBpY2tlZC5pbnB1dCBpbnN0YW5jZW9mIERhdGUpe2NvbnN0IHQ9dGhpcy50aW1lUGlja2VkLmlucHV0O2Uuc2V0SG91cnModC5nZXRIb3VycygpLHQuZ2V0TWludXRlcygpLHQuZ2V0U2Vjb25kcygpLDApfXJldHVybiBlfXJldHVybiBudWxsfWdldFN0YXJ0RGF0ZSgpe2lmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdGFydERhdGUgaW5zdGFuY2VvZiBEYXRlKXtjb25zdCBlPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdGFydERhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO2lmKHRoaXMudGltZVBpY2tlZC5zdGFydCBpbnN0YW5jZW9mIERhdGUpe2NvbnN0IHQ9dGhpcy50aW1lUGlja2VkLnN0YXJ0O2Uuc2V0SG91cnModC5nZXRIb3VycygpLHQuZ2V0TWludXRlcygpLHQuZ2V0U2Vjb25kcygpLDApfXJldHVybiBlfXJldHVybiBudWxsfWdldEVuZERhdGUoKXtpZih0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZW5kRGF0ZSBpbnN0YW5jZW9mIERhdGUpe2NvbnN0IGU9bmV3IHQodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVuZERhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO2lmKHRoaXMudGltZVBpY2tlZC5lbmQgaW5zdGFuY2VvZiBEYXRlKXtjb25zdCB0PXRoaXMudGltZVBpY2tlZC5lbmQ7ZS5zZXRIb3Vycyh0LmdldEhvdXJzKCksdC5nZXRNaW51dGVzKCksdC5nZXRTZWNvbmRzKCksMCl9cmV0dXJuIGV9cmV0dXJuIG51bGx9Z2V0U2luZ2xlSW5wdXQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLm5hdGl2ZT90aGlzLmdldE5hdGl2ZUlucHV0KFwiaW5wdXRcIik6dGhpcy5nZXRDdXN0b21JbnB1dChcImlucHV0XCIpfWdldFN0YXJ0SW5wdXQoKXtyZXR1cm4gdGhpcy5vcHRpb25zLm5hdGl2ZT90aGlzLmdldE5hdGl2ZUlucHV0KFwic3RhcnRcIik6dGhpcy5nZXRDdXN0b21JbnB1dChcInN0YXJ0XCIpfWdldEVuZElucHV0KCl7cmV0dXJuIHRoaXMub3B0aW9ucy5uYXRpdmU/dGhpcy5nZXROYXRpdmVJbnB1dChcImVuZFwiKTp0aGlzLmdldEN1c3RvbUlucHV0KFwiZW5kXCIpfWdldE5hdGl2ZUlucHV0KHQpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2UudHlwZT1cInRpbWVcIixlLm5hbWU9dCxlLmNsYXNzTmFtZT1cInRpbWUtcGx1Z2luLWlucHV0IHVuaXRcIjtjb25zdCBpPXRoaXMudGltZVBpY2tlZFt0XTtpZihpKXtjb25zdCB0PWAwJHtpLmdldEhvdXJzKCl9YC5zbGljZSgtMiksbj1gMCR7aS5nZXRNaW51dGVzKCl9YC5zbGljZSgtMik7ZS52YWx1ZT1gJHt0fToke259YH1yZXR1cm4gZX1nZXRDdXN0b21JbnB1dCh0KXtjb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7ZS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jdXN0b20tYmxvY2tcIjtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7aS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jdXN0b20taW5wdXQgdW5pdFwiLGkubmFtZT1gJHt0fVtISF1gO2NvbnN0IG49dGhpcy5vcHRpb25zLmZvcm1hdDEyPzE6MCxzPXRoaXMub3B0aW9ucy5mb3JtYXQxMj8xMzoyNDtsZXQgbz1udWxsOyF0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseSYmdGhpcy50aW1lUHJlUGlja2VkW3RdaW5zdGFuY2VvZiBEYXRlP289dGhpcy50aW1lUHJlUGlja2VkW3RdLmNsb25lKCk6dGhpcy50aW1lUGlja2VkW3RdaW5zdGFuY2VvZiBEYXRlJiYobz10aGlzLnRpbWVQaWNrZWRbdF0uY2xvbmUoKSk7Zm9yKGxldCB0PW47dDxzO3QrPXRoaXMub3B0aW9ucy5zdGVwSG91cnMpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtlLnZhbHVlPVN0cmluZyh0KSxlLnRleHQ9U3RyaW5nKHQpLG8mJih0aGlzLm9wdGlvbnMuZm9ybWF0MTI/KG8uZ2V0SG91cnMoKSUxMj9vLmdldEhvdXJzKCklMTI6MTIpPT09dCYmKGUuc2VsZWN0ZWQ9ITApOm8uZ2V0SG91cnMoKT09PXQmJihlLnNlbGVjdGVkPSEwKSksaS5hcHBlbmRDaGlsZChlKX1lLmFwcGVuZENoaWxkKGkpO2NvbnN0IGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTthLmNsYXNzTmFtZT1cInRpbWUtcGx1Z2luLWN1c3RvbS1pbnB1dCB1bml0XCIsYS5uYW1lPWAke3R9W21tXWA7Zm9yKGxldCB0PTA7dDw2MDt0Kz10aGlzLm9wdGlvbnMuc3RlcE1pbnV0ZXMpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtlLnZhbHVlPWAwJHtTdHJpbmcodCl9YC5zbGljZSgtMiksZS50ZXh0PWAwJHtTdHJpbmcodCl9YC5zbGljZSgtMiksbyYmby5nZXRNaW51dGVzKCk9PT10JiYoZS5zZWxlY3RlZD0hMCksYS5hcHBlbmRDaGlsZChlKX1pZihlLmFwcGVuZENoaWxkKGEpLHRoaXMub3B0aW9ucy5zZWNvbmRzKXtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7aS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jdXN0b20taW5wdXQgdW5pdFwiLGkubmFtZT1gJHt0fVtzc11gO2NvbnN0IG49NjA7Zm9yKGxldCB0PTA7dDxuO3QrPXRoaXMub3B0aW9ucy5zdGVwU2Vjb25kcyl7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO2UudmFsdWU9YDAke1N0cmluZyh0KX1gLnNsaWNlKC0yKSxlLnRleHQ9YDAke1N0cmluZyh0KX1gLnNsaWNlKC0yKSxvJiZvLmdldFNlY29uZHMoKT09PXQmJihlLnNlbGVjdGVkPSEwKSxpLmFwcGVuZENoaWxkKGUpfWUuYXBwZW5kQ2hpbGQoaSl9aWYodGhpcy5vcHRpb25zLmZvcm1hdDEyKXtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7aS5jbGFzc05hbWU9XCJ0aW1lLXBsdWdpbi1jdXN0b20taW5wdXQgdW5pdFwiLGkubmFtZT1gJHt0fVtwZXJpb2RdYCxbXCJBTVwiLFwiUE1cIl0uZm9yRWFjaCgodD0+e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtlLnZhbHVlPXQsZS50ZXh0PXQsbyYmXCJQTVwiPT09dCYmby5nZXRIb3VycygpPj0xMiYmKGUuc2VsZWN0ZWQ9ITApLGkuYXBwZW5kQ2hpbGQoZSl9KSksZS5hcHBlbmRDaGlsZChpKX1yZXR1cm4gZX1oYW5kbGVGb3JtYXQxMih0LGUsaSl7Y29uc3Qgbj1lLmNsb25lKCk7c3dpdGNoKHQpe2Nhc2VcIkFNXCI6MTI9PT1pP24uc2V0SG91cnMoMCxuLmdldE1pbnV0ZXMoKSxuLmdldFNlY29uZHMoKSwwKTpuLnNldEhvdXJzKGksbi5nZXRNaW51dGVzKCksbi5nZXRTZWNvbmRzKCksMCk7YnJlYWs7Y2FzZVwiUE1cIjoxMiE9PWk/bi5zZXRIb3VycyhpKzEyLG4uZ2V0TWludXRlcygpLG4uZ2V0U2Vjb25kcygpLDApOm4uc2V0SG91cnMoaSxuLmdldE1pbnV0ZXMoKSxuLmdldFNlY29uZHMoKSwwKX1yZXR1cm4gbn1wYXJzZVZhbHVlcygpe2lmKHRoaXMucmFuZ2VQbHVnaW4pe2lmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdHJpY3Qpe2lmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdGFydERhdGUmJnRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbmREYXRlKXtjb25zdCBlPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdGFydERhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpLGk9bmV3IHQodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVuZERhdGUsdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMudGltZVBpY2tlZC5zdGFydD1lLmNsb25lKCksdGhpcy50aW1lUGlja2VkLmVuZD1pLmNsb25lKCl9fWVsc2V7aWYodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLnN0YXJ0RGF0ZSl7Y29uc3QgZT1uZXcgdCh0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuc3RhcnREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpfWlmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbmREYXRlKXtjb25zdCBlPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbmREYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuZW5kPWUuY2xvbmUoKX19aWYodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVsZW1lbnRFbmQpaWYodGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLnN0cmljdCl7aWYodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLmxlbmd0aCYmdGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVsZW1lbnRFbmQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50JiZ0aGlzLnJhbmdlUGx1Z2luLm9wdGlvbnMuZWxlbWVudEVuZC52YWx1ZS5sZW5ndGgpe2NvbnN0IGU9bmV3IHQodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KSxpPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpLHRoaXMudGltZVBpY2tlZC5lbmQ9aS5jbG9uZSgpfX1lbHNle2lmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgpe2NvbnN0IGU9bmV3IHQodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpfWlmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCYmdGhpcy5yYW5nZVBsdWdpbi5vcHRpb25zLmVsZW1lbnRFbmQudmFsdWUubGVuZ3RoKXtjb25zdCBlPW5ldyB0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5lbGVtZW50RW5kLnZhbHVlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9ZS5jbG9uZSgpfX1lbHNlIGlmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgpe2NvbnN0W2UsaV09dGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLnNwbGl0KHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5kZWxpbWl0ZXIpO2lmKHRoaXMucmFuZ2VQbHVnaW4ub3B0aW9ucy5zdHJpY3Qpe2lmKGUmJmkpe2NvbnN0IG49bmV3IHQoZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCkscz1uZXcgdChpLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuc3RhcnQ9bi5jbG9uZSgpLHRoaXMudGltZVBpY2tlZC5lbmQ9cy5jbG9uZSgpfX1lbHNle2lmKGUpe2NvbnN0IGk9bmV3IHQoZSx0aGlzLnBpY2tlci5vcHRpb25zLmZvcm1hdCk7dGhpcy50aW1lUGlja2VkLnN0YXJ0PWkuY2xvbmUoKX1pZihpKXtjb25zdCBlPW5ldyB0KGksdGhpcy5waWNrZXIub3B0aW9ucy5mb3JtYXQpO3RoaXMudGltZVBpY2tlZC5zdGFydD1lLmNsb25lKCl9fX19ZWxzZXtpZih0aGlzLnBpY2tlci5vcHRpb25zLmRhdGUpe2NvbnN0IGU9bmV3IHQodGhpcy5waWNrZXIub3B0aW9ucy5kYXRlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuaW5wdXQ9ZS5jbG9uZSgpfWlmKHRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJnRoaXMucGlja2VyLm9wdGlvbnMuZWxlbWVudC52YWx1ZS5sZW5ndGgpe2NvbnN0IGU9bmV3IHQodGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LnZhbHVlLHRoaXMucGlja2VyLm9wdGlvbnMuZm9ybWF0KTt0aGlzLnRpbWVQaWNrZWQuaW5wdXQ9ZS5jbG9uZSgpfX19fWNsYXNzIGggZXh0ZW5kcyBve2RvY0VsZW1lbnQ9bnVsbDtyYW5nZVBsdWdpbjtiaW5kcz17b25WaWV3OnRoaXMub25WaWV3LmJpbmQodGhpcyksb25LZXlkb3duOnRoaXMub25LZXlkb3duLmJpbmQodGhpcyl9O29wdGlvbnM9e3VuaXRJbmRleDoxLGRheUluZGV4OjJ9O2dldE5hbWUoKXtyZXR1cm5cIktiZFBsdWdpblwifW9uQXR0YWNoKCl7Y29uc3QgdD10aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQsZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKHRoaXMuZG9jRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSx0aGlzLmRvY0VsZW1lbnQuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuZG9jRWxlbWVudC5zdHlsZS50b3A9YCR7dC5vZmZzZXRUb3B9cHhgLHRoaXMuZG9jRWxlbWVudC5zdHlsZS5sZWZ0PXQub2Zmc2V0TGVmdCtlLndpZHRoLTI1K1wicHhcIix0aGlzLmRvY0VsZW1lbnQuYXR0YWNoU2hhZG93KHttb2RlOlwib3BlblwifSksdGhpcy5vcHRpb25zLmh0bWwpdGhpcy5kb2NFbGVtZW50LnNoYWRvd1Jvb3QuaW5uZXJIVE1MPXRoaXMub3B0aW9ucy5odG1sO2Vsc2V7Y29uc3QgdD1gXFxuICAgICAgPHN0eWxlPlxcbiAgICAgIGJ1dHRvbiB7XFxuICAgICAgICBib3JkZXI6IG5vbmU7XFxuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gICAgICAgIGZvbnQtc2l6ZTogJHt3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnQpLmZvbnRTaXplfTtcXG4gICAgICB9XFxuICAgICAgPC9zdHlsZT5cXG5cXG4gICAgICA8YnV0dG9uPiYjMTI4MTk3OzwvYnV0dG9uPlxcbiAgICAgIGA7dGhpcy5kb2NFbGVtZW50LnNoYWRvd1Jvb3QuaW5uZXJIVE1MPXR9Y29uc3QgaT10aGlzLmRvY0VsZW1lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uXCIpO2kmJihpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCh0PT57dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMucGlja2VyLnNob3coe3RhcmdldDp0aGlzLnBpY2tlci5vcHRpb25zLmVsZW1lbnR9KX0pLHtjYXB0dXJlOiEwfSksaS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCh0PT57XCJFc2NhcGVcIj09PXQuY29kZSYmdGhpcy5waWNrZXIuaGlkZSgpfSkse2NhcHR1cmU6ITB9KSksdGhpcy5waWNrZXIub3B0aW9ucy5lbGVtZW50LmFmdGVyKHRoaXMuZG9jRWxlbWVudCksdGhpcy5waWNrZXIub24oXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpLHRoaXMucGlja2VyLm9uKFwia2V5ZG93blwiLHRoaXMuYmluZHMub25LZXlkb3duKX1vbkRldGFjaCgpe3RoaXMuZG9jRWxlbWVudCYmdGhpcy5kb2NFbGVtZW50LmlzQ29ubmVjdGVkJiZ0aGlzLmRvY0VsZW1lbnQucmVtb3ZlKCksdGhpcy5waWNrZXIub2ZmKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KSx0aGlzLnBpY2tlci5vZmYoXCJrZXlkb3duXCIsdGhpcy5iaW5kcy5vbktleWRvd24pfW9uVmlldyh0KXtjb25zdHt2aWV3OmUsdGFyZ2V0Oml9PXQuZGV0YWlsO2kmJlwicXVlcnlTZWxlY3RvclwiaW4gaSYmKFwiQ2FsZW5kYXJEYXlcIiE9PWV8fFtcImxvY2tlZFwiLFwibm90LWF2YWlsYWJsZVwiXS5zb21lKCh0PT5pLmNsYXNzTGlzdC5jb250YWlucyh0KSkpP1suLi5pLnF1ZXJ5U2VsZWN0b3JBbGwoXCIudW5pdDpub3QoLmRheSlcIildLmZvckVhY2goKHQ9PnQudGFiSW5kZXg9dGhpcy5vcHRpb25zLnVuaXRJbmRleCkpOmkudGFiSW5kZXg9dGhpcy5vcHRpb25zLmRheUluZGV4KX1vbktleWRvd24odCl7c3dpdGNoKHRoaXMub25Nb3VzZUVudGVyKHQpLHQuY29kZSl7Y2FzZVwiQXJyb3dVcFwiOmNhc2VcIkFycm93RG93blwiOnRoaXMudmVydGljYWxNb3ZlKHQpO2JyZWFrO2Nhc2VcIkFycm93TGVmdFwiOmNhc2VcIkFycm93UmlnaHRcIjp0aGlzLmhvcml6b250YWxNb3ZlKHQpO2JyZWFrO2Nhc2VcIkVudGVyXCI6Y2FzZVwiU3BhY2VcIjp0aGlzLmhhbmRsZUVudGVyKHQpO2JyZWFrO2Nhc2VcIkVzY2FwZVwiOnRoaXMucGlja2VyLmhpZGUoKX19ZmluZEFsbG93YWJsZURheVNpYmxpbmcodCxlLGkpe2NvbnN0IG49QXJyYXkuZnJvbSh0LnF1ZXJ5U2VsZWN0b3JBbGwoYC5kYXlbdGFiaW5kZXg9XCIke3RoaXMub3B0aW9ucy5kYXlJbmRleH1cIl1gKSkscz1uLmluZGV4T2YoZSk7cmV0dXJuIG4uZmlsdGVyKCgodCxlKT0+aShlLHMpJiZ0LnRhYkluZGV4PT09dGhpcy5vcHRpb25zLmRheUluZGV4KSlbMF19Y2hhbmdlTW9udGgodCl7Y29uc3QgZT17QXJyb3dMZWZ0OlwicHJldmlvdXNcIixBcnJvd1JpZ2h0OlwibmV4dFwifSxpPXRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHtlW3QuY29kZV19LWJ1dHRvblt0YWJpbmRleD1cIiR7dGhpcy5vcHRpb25zLnVuaXRJbmRleH1cIl1gKTtpJiYhaS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhgbm8tJHtlW3QuY29kZV19LW1vbnRoYCkmJihpLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2xpY2tcIix7YnViYmxlczohMH0pKSxzZXRUaW1lb3V0KCgoKT0+e2xldCBlPW51bGw7c3dpdGNoKHQuY29kZSl7Y2FzZVwiQXJyb3dMZWZ0XCI6Y29uc3QgdD10aGlzLnBpY2tlci51aS5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChgLmRheVt0YWJpbmRleD1cIiR7dGhpcy5vcHRpb25zLmRheUluZGV4fVwiXWApO2U9dFt0Lmxlbmd0aC0xXTticmVhaztjYXNlXCJBcnJvd1JpZ2h0XCI6ZT10aGlzLnBpY2tlci51aS5jb250YWluZXIucXVlcnlTZWxlY3RvcihgLmRheVt0YWJpbmRleD1cIiR7dGhpcy5vcHRpb25zLmRheUluZGV4fVwiXWApfWUmJmUuZm9jdXMoKX0pKSl9dmVydGljYWxNb3ZlKHQpe2NvbnN0IGU9dC50YXJnZXQ7aWYoZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXlcIikpe3QucHJldmVudERlZmF1bHQoKTtjb25zdCBpPXRoaXMuZmluZEFsbG93YWJsZURheVNpYmxpbmcodGhpcy5waWNrZXIudWkuY29udGFpbmVyLGUsKChlLGkpPT5lPT09KFwiQXJyb3dVcFwiPT09dC5jb2RlP2ktNzppKzcpKSk7aSYmaS5mb2N1cygpfX1ob3Jpem9udGFsTW92ZSh0KXtjb25zdCBlPXQudGFyZ2V0O2lmKGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGF5XCIpKXt0LnByZXZlbnREZWZhdWx0KCk7Y29uc3QgaT10aGlzLmZpbmRBbGxvd2FibGVEYXlTaWJsaW5nKHRoaXMucGlja2VyLnVpLmNvbnRhaW5lcixlLCgoZSxpKT0+ZT09PShcIkFycm93TGVmdFwiPT09dC5jb2RlP2ktMTppKzEpKSk7aT9pLmZvY3VzKCk6dGhpcy5jaGFuZ2VNb250aCh0KX19aGFuZGxlRW50ZXIodCl7Y29uc3QgZT10LnRhcmdldDtlLmNsYXNzTGlzdC5jb250YWlucyhcImRheVwiKSYmKHQucHJldmVudERlZmF1bHQoKSxlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiY2xpY2tcIix7YnViYmxlczohMH0pKSxzZXRUaW1lb3V0KCgoKT0+e2lmKHRoaXMucmFuZ2VQbHVnaW49dGhpcy5waWNrZXIuUGx1Z2luTWFuYWdlci5nZXRJbnN0YW5jZShcIlJhbmdlUGx1Z2luXCIpLHRoaXMucmFuZ2VQbHVnaW58fCF0aGlzLnBpY2tlci5vcHRpb25zLmF1dG9BcHBseSl7Y29uc3QgdD10aGlzLnBpY2tlci51aS5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5kYXkuc2VsZWN0ZWRcIik7dCYmc2V0VGltZW91dCgoKCk9Pnt0LmZvY3VzKCl9KSl9fSkpKX1vbk1vdXNlRW50ZXIodCl7dC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGF5XCIpJiZzZXRUaW1lb3V0KCgoKT0+e2NvbnN0IHQ9dGhpcy5waWNrZXIudWkuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O3QmJnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJtb3VzZWVudGVyXCIse2J1YmJsZXM6ITB9KSl9KSl9fWNsYXNzIGQgZXh0ZW5kcyBve3JhbmdlUGx1Z2luO2xvY2tQbHVnaW47cHJpb3JpdHk9MTA7YmluZHM9e29uVmlldzp0aGlzLm9uVmlldy5iaW5kKHRoaXMpLG9uQ29sb3JTY2hlbWU6dGhpcy5vbkNvbG9yU2NoZW1lLmJpbmQodGhpcyl9O29wdGlvbnM9e2Ryb3Bkb3duOnttb250aHM6ITEseWVhcnM6ITEsbWluWWVhcjoxOTUwLG1heFllYXI6bnVsbH0sZGFya01vZGU6ITAsbG9jYWxlOntyZXNldEJ1dHRvbjonPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgaGVpZ2h0PVwiMjRcIiB3aWR0aD1cIjI0XCI+PHBhdGggZD1cIk0xMyAzYy00Ljk3IDAtOSA0LjAzLTkgOUgxbDMuODkgMy44OS4wNy4xNEw5IDEySDZjMC0zLjg3IDMuMTMtNyA3LTdzNyAzLjEzIDcgNy0zLjEzIDctNyA3Yy0xLjkzIDAtMy42OC0uNzktNC45NC0yLjA2bC0xLjQyIDEuNDJDOC4yNyAxOS45OSAxMC41MSAyMSAxMyAyMWM0Ljk3IDAgOS00LjAzIDktOXMtNC4wMy05LTktOXptLTEgNXY1bDQuMjggMi41NC43Mi0xLjIxLTMuNS0yLjA4VjhIMTJ6XCIvPjwvc3ZnPid9fTttYXRjaE1lZGlhO2dldE5hbWUoKXtyZXR1cm5cIkFtcFBsdWdpblwifW9uQXR0YWNoKCl7dGhpcy5vcHRpb25zLmRhcmtNb2RlJiZ3aW5kb3cmJlwibWF0Y2hNZWRpYVwiaW4gd2luZG93JiYodGhpcy5tYXRjaE1lZGlhPXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKSx0aGlzLm1hdGNoTWVkaWEubWF0Y2hlcyYmKHRoaXMucGlja2VyLnVpLmNvbnRhaW5lci5kYXRhc2V0LnRoZW1lPVwiZGFya1wiKSx0aGlzLm1hdGNoTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHRoaXMuYmluZHMub25Db2xvclNjaGVtZSkpLHRoaXMub3B0aW9ucy53ZWVrTnVtYmVycyYmdGhpcy5waWNrZXIudWkuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ3ZWVrLW51bWJlcnNcIiksdGhpcy5waWNrZXIub24oXCJ2aWV3XCIsdGhpcy5iaW5kcy5vblZpZXcpfW9uRGV0YWNoKCl7dGhpcy5vcHRpb25zLmRhcmtNb2RlJiZ3aW5kb3cmJlwibWF0Y2hNZWRpYVwiaW4gd2luZG93JiZ0aGlzLm1hdGNoTWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHRoaXMuYmluZHMub25Db2xvclNjaGVtZSksdGhpcy5waWNrZXIudWkuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGhlbWVcIiksdGhpcy5waWNrZXIudWkuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJ3ZWVrLW51bWJlcnNcIiksdGhpcy5waWNrZXIub2ZmKFwidmlld1wiLHRoaXMuYmluZHMub25WaWV3KX1vblZpZXcodCl7dGhpcy5sb2NrUGx1Z2luPXRoaXMucGlja2VyLlBsdWdpbk1hbmFnZXIuZ2V0SW5zdGFuY2UoXCJMb2NrUGx1Z2luXCIpLHRoaXMucmFuZ2VQbHVnaW49dGhpcy5waWNrZXIuUGx1Z2luTWFuYWdlci5nZXRJbnN0YW5jZShcIlJhbmdlUGx1Z2luXCIpLHRoaXMuaGFuZGxlRHJvcGRvd24odCksdGhpcy5oYW5kbGVSZXNldEJ1dHRvbih0KSx0aGlzLmhhbmRsZVdlZWtOdW1iZXJzKHQpfW9uQ29sb3JTY2hlbWUodCl7Y29uc3QgZT10Lm1hdGNoZXM/XCJkYXJrXCI6XCJsaWdodFwiO3RoaXMucGlja2VyLnVpLmNvbnRhaW5lci5kYXRhc2V0LnRoZW1lPWV9aGFuZGxlRHJvcGRvd24oZSl7Y29uc3R7dmlldzppLHRhcmdldDpuLGRhdGU6cyxpbmRleDpvfT1lLmRldGFpbDtpZihcIkNhbGVuZGFySGVhZGVyXCI9PT1pKXtjb25zdCBlPW4ucXVlcnlTZWxlY3RvcihcIi5tb250aC1uYW1lXCIpO2lmKHRoaXMub3B0aW9ucy5kcm9wZG93bi5tb250aHMpe2UuY2hpbGROb2Rlc1swXS5yZW1vdmUoKTtjb25zdCBpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7aS5jbGFzc05hbWU9XCJtb250aC1uYW1lLS1zZWxlY3QgbW9udGgtbmFtZS0tZHJvcGRvd25cIjtmb3IobGV0IGU9MDtlPDEyO2UrPTEpe2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSxvPW5ldyB0KG5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSxlLDIsMCwwLDApKSxhPW5ldyB0KG5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSxlLDEsMCwwLDApKTtuLnZhbHVlPVN0cmluZyhlKSxuLnRleHQ9by50b0xvY2FsZVN0cmluZyh0aGlzLnBpY2tlci5vcHRpb25zLmxhbmcse21vbnRoOlwibG9uZ1wifSksdGhpcy5sb2NrUGx1Z2luJiYobi5kaXNhYmxlZD10aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5taW5EYXRlJiZhLmlzQmVmb3JlKG5ldyB0KHRoaXMubG9ja1BsdWdpbi5vcHRpb25zLm1pbkRhdGUpLFwibW9udGhcIil8fHRoaXMubG9ja1BsdWdpbi5vcHRpb25zLm1heERhdGUmJmEuaXNBZnRlcihuZXcgdCh0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5tYXhEYXRlKSxcIm1vbnRoXCIpKSxuLnNlbGVjdGVkPWEuZ2V0TW9udGgoKT09PXMuZ2V0TW9udGgoKSxpLmFwcGVuZENoaWxkKG4pfWkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCh0PT57Y29uc3QgZT10LnRhcmdldDt0aGlzLnBpY2tlci5jYWxlbmRhcnNbMF0uc2V0RGF0ZSgxKSx0aGlzLnBpY2tlci5jYWxlbmRhcnNbMF0uc2V0TW9udGgoTnVtYmVyKGUudmFsdWUpKSx0aGlzLnBpY2tlci5yZW5kZXJBbGwoKX0pKSxlLnByZXBlbmQoaSl9aWYodGhpcy5vcHRpb25zLmRyb3Bkb3duLnllYXJzKXtlLmNoaWxkTm9kZXNbMV0ucmVtb3ZlKCk7Y29uc3QgaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO2kuY2xhc3NOYW1lPVwibW9udGgtbmFtZS0tc2VsZWN0XCI7Y29uc3Qgbj10aGlzLm9wdGlvbnMuZHJvcGRvd24ubWluWWVhcixvPXRoaXMub3B0aW9ucy5kcm9wZG93bi5tYXhZZWFyP3RoaXMub3B0aW9ucy5kcm9wZG93bi5tYXhZZWFyOihuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKTtpZihzLmdldEZ1bGxZZWFyKCk+byl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO3QudmFsdWU9U3RyaW5nKHMuZ2V0RnVsbFllYXIoKSksdC50ZXh0PVN0cmluZyhzLmdldEZ1bGxZZWFyKCkpLHQuc2VsZWN0ZWQ9ITAsdC5kaXNhYmxlZD0hMCxpLmFwcGVuZENoaWxkKHQpfWZvcihsZXQgZT1vO2U+PW47ZS09MSl7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpLG89bmV3IHQobmV3IERhdGUoZSwwLDEsMCwwLDApKTtuLnZhbHVlPVN0cmluZyhlKSxuLnRleHQ9U3RyaW5nKGUpLHRoaXMubG9ja1BsdWdpbiYmKG4uZGlzYWJsZWQ9dGhpcy5sb2NrUGx1Z2luLm9wdGlvbnMubWluRGF0ZSYmby5pc0JlZm9yZShuZXcgdCh0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5taW5EYXRlKSxcInllYXJcIil8fHRoaXMubG9ja1BsdWdpbi5vcHRpb25zLm1heERhdGUmJm8uaXNBZnRlcihuZXcgdCh0aGlzLmxvY2tQbHVnaW4ub3B0aW9ucy5tYXhEYXRlKSxcInllYXJcIikpLG4uc2VsZWN0ZWQ9cy5nZXRGdWxsWWVhcigpPT09ZSxpLmFwcGVuZENoaWxkKG4pfWlmKHMuZ2V0RnVsbFllYXIoKTxuKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7dC52YWx1ZT1TdHJpbmcocy5nZXRGdWxsWWVhcigpKSx0LnRleHQ9U3RyaW5nKHMuZ2V0RnVsbFllYXIoKSksdC5zZWxlY3RlZD0hMCx0LmRpc2FibGVkPSEwLGkuYXBwZW5kQ2hpbGQodCl9aWYoXCJhc2NcIj09PXRoaXMub3B0aW9ucy5kcm9wZG93bi55ZWFycyl7Y29uc3QgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpLmNoaWxkTm9kZXMpLnJldmVyc2UoKTtpLmlubmVySFRNTD1cIlwiLHQuZm9yRWFjaCgodD0+e3QuaW5uZXJIVE1MPXQudmFsdWUsaS5hcHBlbmRDaGlsZCh0KX0pKX1pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwodD0+e2NvbnN0IGU9dC50YXJnZXQ7dGhpcy5waWNrZXIuY2FsZW5kYXJzWzBdLnNldEZ1bGxZZWFyKE51bWJlcihlLnZhbHVlKSksdGhpcy5waWNrZXIucmVuZGVyQWxsKCl9KSksZS5hcHBlbmRDaGlsZChpKX19fWhhbmRsZVJlc2V0QnV0dG9uKHQpe2NvbnN0e3ZpZXc6ZSx0YXJnZXQ6aX09dC5kZXRhaWw7aWYoXCJDYWxlbmRhckhlYWRlclwiPT09ZSYmdGhpcy5vcHRpb25zLnJlc2V0QnV0dG9uKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7dC5jbGFzc05hbWU9XCJyZXNldC1idXR0b24gdW5pdFwiLHQuaW5uZXJIVE1MPXRoaXMub3B0aW9ucy5sb2NhbGUucmVzZXRCdXR0b24sdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwodD0+e3QucHJldmVudERlZmF1bHQoKTtsZXQgZT0hMDtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucmVzZXRCdXR0b24mJihlPXRoaXMub3B0aW9ucy5yZXNldEJ1dHRvbi5jYWxsKHRoaXMpKSxlJiZ0aGlzLnBpY2tlci5jbGVhcigpfSkpLGkuYXBwZW5kQ2hpbGQodCl9fWhhbmRsZVdlZWtOdW1iZXJzKGUpe2lmKHRoaXMub3B0aW9ucy53ZWVrTnVtYmVycyl7Y29uc3R7dmlldzppLHRhcmdldDpufT1lLmRldGFpbDtpZihcIkNhbGVuZGFyRGF5TmFtZXNcIj09PWkpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT1cIndudW0taGVhZGVyXCIsdC5pbm5lckhUTUw9XCJXa1wiLG4ucHJlcGVuZCh0KX1cIkNhbGVuZGFyRGF5c1wiPT09aSYmWy4uLm4uY2hpbGRyZW5dLmZvckVhY2goKChlLGkpPT57aWYoMD09PWl8fGklNz09MCl7bGV0IGk7aWYoZS5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXlcIikpaT1uZXcgdChlLmRhdGFzZXQudGltZSk7ZWxzZXtjb25zdCBlPW4ucXVlcnlTZWxlY3RvcihcIi5kYXlcIik7aT1uZXcgdChlLmRhdGFzZXQudGltZSl9bGV0IHM9aS5nZXRXZWVrKHRoaXMucGlja2VyLm9wdGlvbnMuZmlyc3REYXkpOzUzPT09cyYmMD09PWkuZ2V0TW9udGgoKSYmKHM9XCI1My8xXCIpO2NvbnN0IG89ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtvLmNsYXNzTmFtZT1cIndudW0taXRlbVwiLG8uaW5uZXJIVE1MPVN0cmluZyhzKSxuLmluc2VydEJlZm9yZShvLGUpfX0pKX19fWV4cG9ydHtkIGFzIEFtcFBsdWdpbix0IGFzIERhdGVUaW1lLGggYXMgS2JkUGx1Z2luLGEgYXMgTG9ja1BsdWdpbixyIGFzIFByZXNldFBsdWdpbixjIGFzIFJhbmdlUGx1Z2luLGwgYXMgVGltZVBsdWdpbixuIGFzIGNyZWF0ZSxzIGFzIGVhc2VwaWNrfTtcbiIsImltcG9ydCB7IGVhc2VwaWNrIH0gZnJvbSBcIkBlYXNlcGljay9idW5kbGVcIjtcblxuY29uc3QgcGlja2VyID0gbmV3IGVhc2VwaWNrLmNyZWF0ZSh7XG4gIGVsZW1lbnQ6IFwiI2RhdGVcIixcbiAgY3NzOiBbXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BlYXNlcGljay9idW5kbGVAMS4yLjEvZGlzdC9pbmRleC5jc3NcIl0sXG4gIHpJbmRleDogMTAsXG4gIGZvcm1hdDogXCJERCBNTU1NIFlZWVlcIixcbn0pO1xuIiwiLyoqXG4gKiBTU1IgV2luZG93IDQuMC4yXG4gKiBCZXR0ZXIgaGFuZGxpbmcgZm9yIHdpbmRvdyBvYmplY3QgaW4gU1NSIGVudmlyb25tZW50XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9saW1pdHM0d2ViL3Nzci13aW5kb3dcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMSwgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqXG4gKiBSZWxlYXNlZCBvbjogRGVjZW1iZXIgMTMsIDIwMjFcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICdjb25zdHJ1Y3RvcicgaW4gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc3JjKSB7XG4gIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgIHRhcmdldCA9IHt9O1xuICB9XG4gIGlmIChzcmMgPT09IHZvaWQgMCkge1xuICAgIHNyYyA9IHt9O1xuICB9XG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgaWYgKGlzT2JqZWN0KHNyY1trZXldKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkgJiYgT2JqZWN0LmtleXMoc3JjW2tleV0pLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBzc3JEb2N1bWVudCA9IHtcbiAgYm9keToge30sXG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuICBhY3RpdmVFbGVtZW50OiB7XG4gICAgYmx1cigpIHt9LFxuICAgIG5vZGVOYW1lOiAnJ1xuICB9LFxuICBxdWVyeVNlbGVjdG9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgZ2V0RWxlbWVudEJ5SWQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGNyZWF0ZUV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbml0RXZlbnQoKSB7fVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgc3R5bGU6IHt9LFxuICAgICAgc2V0QXR0cmlidXRlKCkge30sXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnROUygpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGltcG9ydE5vZGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGxvY2F0aW9uOiB7XG4gICAgaGFzaDogJycsXG4gICAgaG9zdDogJycsXG4gICAgaG9zdG5hbWU6ICcnLFxuICAgIGhyZWY6ICcnLFxuICAgIG9yaWdpbjogJycsXG4gICAgcGF0aG5hbWU6ICcnLFxuICAgIHByb3RvY29sOiAnJyxcbiAgICBzZWFyY2g6ICcnXG4gIH1cbn07XG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDoge307XG4gIGV4dGVuZChkb2MsIHNzckRvY3VtZW50KTtcbiAgcmV0dXJuIGRvYztcbn1cbmNvbnN0IHNzcldpbmRvdyA9IHtcbiAgZG9jdW1lbnQ6IHNzckRvY3VtZW50LFxuICBuYXZpZ2F0b3I6IHtcbiAgICB1c2VyQWdlbnQ6ICcnXG4gIH0sXG4gIGxvY2F0aW9uOiB7XG4gICAgaGFzaDogJycsXG4gICAgaG9zdDogJycsXG4gICAgaG9zdG5hbWU6ICcnLFxuICAgIGhyZWY6ICcnLFxuICAgIG9yaWdpbjogJycsXG4gICAgcGF0aG5hbWU6ICcnLFxuICAgIHByb3RvY29sOiAnJyxcbiAgICBzZWFyY2g6ICcnXG4gIH0sXG4gIGhpc3Rvcnk6IHtcbiAgICByZXBsYWNlU3RhdGUoKSB7fSxcbiAgICBwdXNoU3RhdGUoKSB7fSxcbiAgICBnbygpIHt9LFxuICAgIGJhY2soKSB7fVxuICB9LFxuICBDdXN0b21FdmVudDogZnVuY3Rpb24gQ3VzdG9tRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9LFxuICBnZXRDb21wdXRlZFN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQcm9wZXJ0eVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgSW1hZ2UoKSB7fSxcbiAgRGF0ZSgpIHt9LFxuICBzY3JlZW46IHt9LFxuICBzZXRUaW1lb3V0KCkge30sXG4gIGNsZWFyVGltZW91dCgpIHt9LFxuICBtYXRjaE1lZGlhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH0sXG4gIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoaWQpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xuICBleHRlbmQod2luLCBzc3JXaW5kb3cpO1xuICByZXR1cm4gd2luO1xufVxuXG5leHBvcnQgeyBnZXRXaW5kb3cgYXMgYSwgZ2V0RG9jdW1lbnQgYXMgZyB9O1xuIiwiaW1wb3J0IHsgYSBhcyBnZXRXaW5kb3csIGcgYXMgZ2V0RG9jdW1lbnQgfSBmcm9tICcuL3Nzci13aW5kb3cuZXNtLm1qcyc7XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb1Rva2VucyhjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gJyc7XG4gIH1cbiAgcmV0dXJuIGNsYXNzZXMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKGMgPT4gISFjLnRyaW0oKSk7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVByb3BzKG9iaikge1xuICBjb25zdCBvYmplY3QgPSBvYmo7XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBvYmplY3Rba2V5XSA9IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbm8gZ2V0dGVyIGZvciBvYmplY3RcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzb21ldGhpbmcgZ290IHdyb25nXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrLCBkZWxheSkge1xuICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgIGRlbGF5ID0gMDtcbiAgfVxuICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXkpO1xufVxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGxldCBzdHlsZTtcbiAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCk7XG4gIH1cbiAgaWYgKCFzdHlsZSAmJiBlbC5jdXJyZW50U3R5bGUpIHtcbiAgICBzdHlsZSA9IGVsLmN1cnJlbnRTdHlsZTtcbiAgfVxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBlbC5zdHlsZTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoZWwsIGF4aXMpIHtcbiAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuICAgIGF4aXMgPSAneCc7XG4gIH1cbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGxldCBtYXRyaXg7XG4gIGxldCBjdXJUcmFuc2Zvcm07XG4gIGxldCB0cmFuc2Zvcm1NYXRyaXg7XG4gIGNvbnN0IGN1clN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSB7XG4gICAgY3VyVHJhbnNmb3JtID0gY3VyU3R5bGUudHJhbnNmb3JtIHx8IGN1clN0eWxlLndlYmtpdFRyYW5zZm9ybTtcbiAgICBpZiAoY3VyVHJhbnNmb3JtLnNwbGl0KCcsJykubGVuZ3RoID4gNikge1xuICAgICAgY3VyVHJhbnNmb3JtID0gY3VyVHJhbnNmb3JtLnNwbGl0KCcsICcpLm1hcChhID0+IGEucmVwbGFjZSgnLCcsICcuJykpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIFdlYmtpdCBjaG9rZSB3aGVuICdub25lJyBpcyBwYXNzZWQ7IHBhc3NcbiAgICAvLyBlbXB0eSBzdHJpbmcgaW5zdGVhZCBpbiB0aGlzIGNhc2VcbiAgICB0cmFuc2Zvcm1NYXRyaXggPSBuZXcgd2luZG93LldlYktpdENTU01hdHJpeChjdXJUcmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogY3VyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm1NYXRyaXggPSBjdXJTdHlsZS5Nb3pUcmFuc2Zvcm0gfHwgY3VyU3R5bGUuT1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5Nc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS5tc1RyYW5zZm9ybSB8fCBjdXJTdHlsZS50cmFuc2Zvcm0gfHwgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgndHJhbnNmb3JtJykucmVwbGFjZSgndHJhbnNsYXRlKCcsICdtYXRyaXgoMSwgMCwgMCwgMSwnKTtcbiAgICBtYXRyaXggPSB0cmFuc2Zvcm1NYXRyaXgudG9TdHJpbmcoKS5zcGxpdCgnLCcpO1xuICB9XG4gIGlmIChheGlzID09PSAneCcpIHtcbiAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQxO1xuICAgIC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEyXSk7XG4gICAgLy8gTm9ybWFsIEJyb3dzZXJzXG4gICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs0XSk7XG4gIH1cbiAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgIC8vIExhdGVzdCBDaHJvbWUgYW5kIHdlYmtpdHMgRml4XG4gICAgaWYgKHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgpIGN1clRyYW5zZm9ybSA9IHRyYW5zZm9ybU1hdHJpeC5tNDI7XG4gICAgLy8gQ3JhenkgSUUxMCBNYXRyaXhcbiAgICBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID09PSAxNikgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbMTNdKTtcbiAgICAvLyBOb3JtYWwgQnJvd3NlcnNcbiAgICBlbHNlIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzVdKTtcbiAgfVxuICByZXR1cm4gY3VyVHJhbnNmb3JtIHx8IDA7XG59XG5mdW5jdGlvbiBpc09iamVjdChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLmNvbnN0cnVjdG9yICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkgPT09ICdPYmplY3QnO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IDEgfHwgbm9kZS5ub2RlVHlwZSA9PT0gMTEpO1xufVxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICBjb25zdCB0byA9IE9iamVjdChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pO1xuICBjb25zdCBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IG5leHRTb3VyY2UgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07XG4gICAgaWYgKG5leHRTb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBuZXh0U291cmNlICE9PSBudWxsICYmICFpc05vZGUobmV4dFNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IGtleXNBcnJheSA9IE9iamVjdC5rZXlzKE9iamVjdChuZXh0U291cmNlKSkuZmlsdGVyKGtleSA9PiBub0V4dGVuZC5pbmRleE9mKGtleSkgPCAwKTtcbiAgICAgIGZvciAobGV0IG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3QgbmV4dEtleSA9IGtleXNBcnJheVtuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuZXh0U291cmNlLCBuZXh0S2V5KTtcbiAgICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCAmJiBkZXNjLmVudW1lcmFibGUpIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZVtuZXh0S2V5XS5fX3N3aXBlcl9fKSB7XG4gICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4dGVuZCh0b1tuZXh0S2V5XSwgbmV4dFNvdXJjZVtuZXh0S2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNPYmplY3QodG9bbmV4dEtleV0pICYmIGlzT2JqZWN0KG5leHRTb3VyY2VbbmV4dEtleV0pKSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IHt9O1xuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cbmZ1bmN0aW9uIHNldENTU1Byb3BlcnR5KGVsLCB2YXJOYW1lLCB2YXJWYWx1ZSkge1xuICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YXJWYWx1ZSk7XG59XG5mdW5jdGlvbiBhbmltYXRlQ1NTTW9kZVNjcm9sbChfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIHNpZGVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBzdGFydFBvc2l0aW9uID0gLXN3aXBlci50cmFuc2xhdGU7XG4gIGxldCBzdGFydFRpbWUgPSBudWxsO1xuICBsZXQgdGltZTtcbiAgY29uc3QgZHVyYXRpb24gPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJ25vbmUnO1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3dpcGVyLmNzc01vZGVGcmFtZUlEKTtcbiAgY29uc3QgZGlyID0gdGFyZ2V0UG9zaXRpb24gPiBzdGFydFBvc2l0aW9uID8gJ25leHQnIDogJ3ByZXYnO1xuICBjb25zdCBpc091dE9mQm91bmQgPSAoY3VycmVudCwgdGFyZ2V0KSA9PiB7XG4gICAgcmV0dXJuIGRpciA9PT0gJ25leHQnICYmIGN1cnJlbnQgPj0gdGFyZ2V0IHx8IGRpciA9PT0gJ3ByZXYnICYmIGN1cnJlbnQgPD0gdGFyZ2V0O1xuICB9O1xuICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKCh0aW1lIC0gc3RhcnRUaW1lKSAvIGR1cmF0aW9uLCAxKSwgMCk7XG4gICAgY29uc3QgZWFzZVByb2dyZXNzID0gMC41IC0gTWF0aC5jb3MocHJvZ3Jlc3MgKiBNYXRoLlBJKSAvIDI7XG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gKyBlYXNlUHJvZ3Jlc3MgKiAodGFyZ2V0UG9zaXRpb24gLSBzdGFydFBvc2l0aW9uKTtcbiAgICBpZiAoaXNPdXRPZkJvdW5kKGN1cnJlbnRQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvbjtcbiAgICB9XG4gICAgc3dpcGVyLndyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICBbc2lkZV06IGN1cnJlbnRQb3NpdGlvblxuICAgIH0pO1xuICAgIGlmIChpc091dE9mQm91bmQoY3VycmVudFBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbikpIHtcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSAnJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICAgIFtzaWRlXTogY3VycmVudFBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoc3dpcGVyLmNzc01vZGVGcmFtZUlEKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpcGVyLmNzc01vZGVGcmFtZUlEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgfTtcbiAgYW5pbWF0ZSgpO1xufVxuZnVuY3Rpb24gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKSB7XG4gIHJldHVybiBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtdHJhbnNmb3JtJykgfHwgc2xpZGVFbC5zaGFkb3dSb290ICYmIHNsaWRlRWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXRyYW5zZm9ybScpIHx8IHNsaWRlRWw7XG59XG5mdW5jdGlvbiBlbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RvciA9ICcnO1xuICB9XG4gIHJldHVybiBbLi4uZWxlbWVudC5jaGlsZHJlbl0uZmlsdGVyKGVsID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpKTtcbn1cbmZ1bmN0aW9uIHNob3dXYXJuaW5nKHRleHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLndhcm4odGV4dCk7XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBlcnJcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzZXMpIHtcbiAgaWYgKGNsYXNzZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzZXMgPSBbXTtcbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi4oQXJyYXkuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzVG9Ub2tlbnMoY2xhc3NlcykpKTtcbiAgcmV0dXJuIGVsO1xufVxuZnVuY3Rpb24gZWxlbWVudE9mZnNldChlbCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGNsaWVudFRvcCA9IGVsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICBjb25zdCBjbGllbnRMZWZ0ID0gZWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxZIDogZWwuc2Nyb2xsVG9wO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gZWwgPT09IHdpbmRvdyA/IHdpbmRvdy5zY3JvbGxYIDogZWwuc2Nyb2xsTGVmdDtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3AsXG4gICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdFxuICB9O1xufVxuZnVuY3Rpb24gZWxlbWVudFByZXZBbGwoZWwsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IHByZXZFbHMgPSBbXTtcbiAgd2hpbGUgKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHByZXYubWF0Y2hlcyhzZWxlY3RvcikpIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICB9IGVsc2UgcHJldkVscy5wdXNoKHByZXYpO1xuICAgIGVsID0gcHJldjtcbiAgfVxuICByZXR1cm4gcHJldkVscztcbn1cbmZ1bmN0aW9uIGVsZW1lbnROZXh0QWxsKGVsLCBzZWxlY3Rvcikge1xuICBjb25zdCBuZXh0RWxzID0gW107XG4gIHdoaWxlIChlbC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBjb25zdCBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkgbmV4dEVscy5wdXNoKG5leHQpO1xuICAgIH0gZWxzZSBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgZWwgPSBuZXh0O1xuICB9XG4gIHJldHVybiBuZXh0RWxzO1xufVxuZnVuY3Rpb24gZWxlbWVudFN0eWxlKGVsLCBwcm9wKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG59XG5mdW5jdGlvbiBlbGVtZW50SW5kZXgoZWwpIHtcbiAgbGV0IGNoaWxkID0gZWw7XG4gIGxldCBpO1xuICBpZiAoY2hpbGQpIHtcbiAgICBpID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB3aGlsZSAoKGNoaWxkID0gY2hpbGQucHJldmlvdXNTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBlbGVtZW50UGFyZW50cyhlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgcGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChwYXJlbnQubWF0Y2hlcyhzZWxlY3RvcikpIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5mdW5jdGlvbiBlbGVtZW50VHJhbnNpdGlvbkVuZChlbCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZmlyZUNhbGxCYWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgIT09IGVsKSByZXR1cm47XG4gICAgY2FsbGJhY2suY2FsbChlbCwgZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZpcmVDYWxsQmFjayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnRPdXRlclNpemUoZWwsIHNpemUsIGluY2x1ZGVNYXJnaW5zKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBpZiAoaW5jbHVkZU1hcmdpbnMpIHtcbiAgICByZXR1cm4gZWxbc2l6ZSA9PT0gJ3dpZHRoJyA/ICdvZmZzZXRXaWR0aCcgOiAnb2Zmc2V0SGVpZ2h0J10gKyBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHNpemUgPT09ICd3aWR0aCcgPyAnbWFyZ2luLXJpZ2h0JyA6ICdtYXJnaW4tdG9wJykpICsgcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShzaXplID09PSAnd2lkdGgnID8gJ21hcmdpbi1sZWZ0JyA6ICdtYXJnaW4tYm90dG9tJykpO1xuICB9XG4gIHJldHVybiBlbC5vZmZzZXRXaWR0aDtcbn1cbmZ1bmN0aW9uIG1ha2VFbGVtZW50c0FycmF5KGVsKSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShlbCkgPyBlbCA6IFtlbF0pLmZpbHRlcihlID0+ICEhZSk7XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRQYXJlbnRzIGFzIGEsIGVsZW1lbnRPZmZzZXQgYXMgYiwgY3JlYXRlRWxlbWVudCBhcyBjLCBub3cgYXMgZCwgZWxlbWVudENoaWxkcmVuIGFzIGUsIGVsZW1lbnRPdXRlclNpemUgYXMgZiwgZ2V0U2xpZGVUcmFuc2Zvcm1FbCBhcyBnLCBlbGVtZW50SW5kZXggYXMgaCwgY2xhc3Nlc1RvVG9rZW5zIGFzIGksIGdldFRyYW5zbGF0ZSBhcyBqLCBlbGVtZW50VHJhbnNpdGlvbkVuZCBhcyBrLCBpc09iamVjdCBhcyBsLCBtYWtlRWxlbWVudHNBcnJheSBhcyBtLCBuZXh0VGljayBhcyBuLCBlbGVtZW50U3R5bGUgYXMgbywgZWxlbWVudE5leHRBbGwgYXMgcCwgZWxlbWVudFByZXZBbGwgYXMgcSwgYW5pbWF0ZUNTU01vZGVTY3JvbGwgYXMgciwgc2V0Q1NTUHJvcGVydHkgYXMgcywgc2hvd1dhcm5pbmcgYXMgdCwgZXh0ZW5kIGFzIHUsIGRlbGV0ZVByb3BzIGFzIHYgfTtcbiIsImltcG9ydCB7IGEgYXMgZ2V0V2luZG93LCBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgYSBhcyBlbGVtZW50UGFyZW50cywgbyBhcyBlbGVtZW50U3R5bGUsIGUgYXMgZWxlbWVudENoaWxkcmVuLCBzIGFzIHNldENTU1Byb3BlcnR5LCBmIGFzIGVsZW1lbnRPdXRlclNpemUsIHAgYXMgZWxlbWVudE5leHRBbGwsIHEgYXMgZWxlbWVudFByZXZBbGwsIGogYXMgZ2V0VHJhbnNsYXRlLCByIGFzIGFuaW1hdGVDU1NNb2RlU2Nyb2xsLCBuIGFzIG5leHRUaWNrLCB0IGFzIHNob3dXYXJuaW5nLCBjIGFzIGNyZWF0ZUVsZW1lbnQsIGQgYXMgbm93LCB1IGFzIGV4dGVuZCwgaCBhcyBlbGVtZW50SW5kZXgsIHYgYXMgZGVsZXRlUHJvcHMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmxldCBzdXBwb3J0O1xuZnVuY3Rpb24gY2FsY1N1cHBvcnQoKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIHJldHVybiB7XG4gICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmICdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XG4gIGlmICghc3VwcG9ydCkge1xuICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0O1xufVxuXG5sZXQgZGV2aWNlQ2FjaGVkO1xuZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICBsZXQge1xuICAgIHVzZXJBZ2VudFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHN1cHBvcnQgPSBnZXRTdXBwb3J0KCk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gIGNvbnN0IHVhID0gdXNlckFnZW50IHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgaW9zOiBmYWxzZSxcbiAgICBhbmRyb2lkOiBmYWxzZVxuICB9O1xuICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIGNvbnN0IGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xuICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XG4gIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnO1xuXG4gIC8vIGlQYWRPcyAxMyBmaXhcbiAgY29uc3QgaVBhZFNjcmVlbnMgPSBbJzEwMjR4MTM2NicsICcxMzY2eDEwMjQnLCAnODM0eDExOTQnLCAnMTE5NHg4MzQnLCAnODM0eDExMTInLCAnMTExMng4MzQnLCAnNzY4eDEwMjQnLCAnMTAyNHg3NjgnLCAnODIweDExODAnLCAnMTE4MHg4MjAnLCAnODEweDEwODAnLCAnMTA4MHg4MTAnXTtcbiAgaWYgKCFpcGFkICYmIG1hY29zICYmIHN1cHBvcnQudG91Y2ggJiYgaVBhZFNjcmVlbnMuaW5kZXhPZihgJHtzY3JlZW5XaWR0aH14JHtzY3JlZW5IZWlnaHR9YCkgPj0gMCkge1xuICAgIGlwYWQgPSB1YS5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyk7XG4gICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICBtYWNvcyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQW5kcm9pZFxuICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBvYmplY3RcbiAgcmV0dXJuIGRldmljZTtcbn1cbmZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnJpZGVzID0ge307XG4gIH1cbiAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICBkZXZpY2VDYWNoZWQgPSBjYWxjRGV2aWNlKG92ZXJyaWRlcyk7XG4gIH1cbiAgcmV0dXJuIGRldmljZUNhY2hlZDtcbn1cblxubGV0IGJyb3dzZXI7XG5mdW5jdGlvbiBjYWxjQnJvd3NlcigpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IGRldmljZSA9IGdldERldmljZSgpO1xuICBsZXQgbmVlZFBlcnNwZWN0aXZlRml4ID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICAgIGNvbnN0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gdWEuaW5kZXhPZignc2FmYXJpJykgPj0gMCAmJiB1YS5pbmRleE9mKCdjaHJvbWUnKSA8IDAgJiYgdWEuaW5kZXhPZignYW5kcm9pZCcpIDwgMDtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IHVhID0gU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAodWEuaW5jbHVkZXMoJ1ZlcnNpb24vJykpIHtcbiAgICAgIGNvbnN0IFttYWpvciwgbWlub3JdID0gdWEuc3BsaXQoJ1ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpLm1hcChudW0gPT4gTnVtYmVyKG51bSkpO1xuICAgICAgbmVlZFBlcnNwZWN0aXZlRml4ID0gbWFqb3IgPCAxNiB8fCBtYWpvciA9PT0gMTYgJiYgbWlub3IgPCAyO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc1dlYlZpZXcgPSAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBpc1NhZmFyaUJyb3dzZXIgPSBpc1NhZmFyaSgpO1xuICBjb25zdCBuZWVkM2RGaXggPSBpc1NhZmFyaUJyb3dzZXIgfHwgaXNXZWJWaWV3ICYmIGRldmljZS5pb3M7XG4gIHJldHVybiB7XG4gICAgaXNTYWZhcmk6IG5lZWRQZXJzcGVjdGl2ZUZpeCB8fCBpc1NhZmFyaUJyb3dzZXIsXG4gICAgbmVlZFBlcnNwZWN0aXZlRml4LFxuICAgIG5lZWQzZEZpeCxcbiAgICBpc1dlYlZpZXdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gIGlmICghYnJvd3Nlcikge1xuICAgIGJyb3dzZXIgPSBjYWxjQnJvd3NlcigpO1xuICB9XG4gIHJldHVybiBicm93c2VyO1xufVxuXG5mdW5jdGlvbiBSZXNpemUoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBlbWl0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBlbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICBlbWl0KCdyZXNpemUnKTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBhbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb250ZW50Qm94U2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gY29udGVudFJlY3QgPyBjb250ZW50UmVjdC5oZWlnaHQgOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmJsb2NrU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoc3dpcGVyLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIudW5vYnNlcnZlICYmIHN3aXBlci5lbCkge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgZW1pdCgnb3JpZW50YXRpb25jaGFuZ2UnKTtcbiAgfTtcbiAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucmVzaXplT2JzZXJ2ZXIgJiYgdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNyZWF0ZU9ic2VydmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKG11dGF0aW9ucyA9PiB7XG4gICAgICAvLyBUaGUgb2JzZXJ2ZXJVcGRhdGUgZXZlbnQgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkXG4gICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAvLyB0cmlnZ2VycyBhcmUgcmVkdW5kYW50IGFuZCBhcmUgdmVyeSBjb3N0bHlcbiAgICAgIGlmIChzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXykgcmV0dXJuO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICBlbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XG4gICAgICB9O1xuICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkTGlzdDogdHlwZW9mIG9wdGlvbnMuY2hpbGRMaXN0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmNoaWxkTGlzdCxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHR5cGVvZiBvcHRpb25zLmNoYXJhY3RlckRhdGEgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hhcmFjdGVyRGF0YVxuICAgIH0pO1xuICAgIG9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgY29uc3QgY29udGFpbmVyUGFyZW50cyA9IGVsZW1lbnRQYXJlbnRzKHN3aXBlci5ob3N0RWwpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJQYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcbiAgICBhdHRhY2goc3dpcGVyLmhvc3RFbCwge1xuICAgICAgY2hpbGRMaXN0OiBzd2lwZXIucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVuXG4gICAgfSk7XG5cbiAgICAvLyBPYnNlcnZlIHdyYXBwZXJcbiAgICBhdHRhY2goc3dpcGVyLndyYXBwZXJFbCwge1xuICAgICAgYXR0cmlidXRlczogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJzLnNwbGljZSgwLCBvYnNlcnZlcnMubGVuZ3RoKTtcbiAgfTtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgb2JzZXJ2ZVBhcmVudHM6IGZhbHNlLFxuICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiBmYWxzZVxuICB9KTtcbiAgb24oJ2luaXQnLCBpbml0KTtcbiAgb24oJ2Rlc3Ryb3knLCBkZXN0cm95KTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9uY2UoZXZlbnRzLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcbiAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5ID0gaGFuZGxlcjtcbiAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gIH0sXG4gIG9uQW55KGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICBpZiAoc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKSA8IDApIHtcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBvZmZBbnkoaGFuZGxlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICghc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgZW1pdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBsZXQgZXZlbnRzO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XG4gICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gYXJnc1swXS5ldmVudHM7XG4gICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgY29udGV4dCA9IGFyZ3NbMF0uY29udGV4dCB8fCBzZWxmO1xuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XG4gICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICBldmVudHNBcnJheS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5hcHBseShjb250ZXh0LCBbZXZlbnQsIC4uLmRhdGFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGV2ZW50SGFuZGxlciA9PiB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBjb25zdCBlbCA9IHN3aXBlci5lbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSBudWxsKSB7XG4gICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN1YnRyYWN0IHBhZGRpbmdzXG4gIHdpZHRoID0gd2lkdGggLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGVsZW1lbnRTdHlsZShlbCwgJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkgd2lkdGggPSAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUobm9kZSwgbGFiZWwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKGxhYmVsKSkgfHwgMCk7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHdyYXBwZXJFbCxcbiAgICBzbGlkZXNFbCxcbiAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHdyb25nUlRMXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICBjb25zdCBzbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gIGxldCBzbmFwR3JpZCA9IFtdO1xuICBjb25zdCBzbGlkZXNHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcbiAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoc3dpcGVyKTtcbiAgfVxuICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aDtcbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjtcblxuICAvLyByZXNldCBtYXJnaW5zXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGlmIChydGwpIHtcbiAgICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luTGVmdCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZUVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJyc7XG4gICAgfVxuICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJyc7XG4gICAgc2xpZGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgfSk7XG5cbiAgLy8gcmVzZXQgY3NzTW9kZSBvZmZzZXRzXG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgJycpO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgfVxuICBjb25zdCBncmlkRW5hYmxlZCA9IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHN3aXBlci5ncmlkO1xuICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICBzd2lwZXIuZ3JpZC5pbml0U2xpZGVzKHNsaWRlcyk7XG4gIH0gZWxzZSBpZiAoc3dpcGVyLmdyaWQpIHtcbiAgICBzd2lwZXIuZ3JpZC51bnNldFNsaWRlcygpO1xuICB9XG5cbiAgLy8gQ2FsYyBzbGlkZXNcbiAgbGV0IHNsaWRlU2l6ZTtcbiAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW1zLmJyZWFrcG9pbnRzW2tleV0uc2xpZGVzUGVyVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZVNpemUgPSAwO1xuICAgIGxldCBzbGlkZTtcbiAgICBpZiAoc2xpZGVzW2ldKSBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKGksIHNsaWRlLCBzbGlkZXMpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldICYmIGVsZW1lbnRTdHlsZShzbGlkZSwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNsaWRlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZWxlbWVudE91dGVyU2l6ZShzbGlkZSwgJ3dpZHRoJywgdHJ1ZSkgOiBlbGVtZW50T3V0ZXJTaXplKHNsaWRlLCAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAncGFkZGluZy1sZWZ0Jyk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgY29uc3QgbWFyZ2luUmlnaHQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcbiAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgb2Zmc2V0V2lkdGhcbiAgICAgICAgICB9ID0gc2xpZGU7XG4gICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50V2ViS2l0VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgc2xpZGVzW2ldLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgIH1cbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplIC8gMiArIHByZXZTbGlkZVNpemUgLyAyICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgIGlmIChpID09PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIHN3aXBlclNpemUgLyAyIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgaWYgKGluZGV4ICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVQb3NpdGlvbiA9IE1hdGguZmxvb3Ioc2xpZGVQb3NpdGlvbik7XG4gICAgICBpZiAoKGluZGV4IC0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KSkgJSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcbiAgaWYgKHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGUud2lkdGggPSBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBzcGFjZUJldHdlZW59cHhgO1xuICB9XG4gIGlmIChwYXJhbXMuc2V0V3JhcHBlclNpemUpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHNwYWNlQmV0d2Vlbn1weGA7XG4gIH1cbiAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgc3dpcGVyLmdyaWQudXBkYXRlV3JhcHBlclNpemUoc2xpZGVTaXplLCBzbmFwR3JpZCk7XG4gIH1cblxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxuICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgIGNvbnN0IG5ld1NsaWRlc0dyaWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNsaWRlc1NpemVzR3JpZFswXSArIHNwYWNlQmV0d2VlbjtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gTWF0aC5jZWlsKChzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNBZnRlcikgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgZ3JvdXBTaXplID0gc2l6ZSAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpICs9IDEpIHtcbiAgICAgICAgc25hcEdyaWQucHVzaChzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSArIGdyb3VwU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQWZ0ZXI7IGkgKz0gMSkge1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgICBzbmFwR3JpZC5wdXNoKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICB9XG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICBzd2lwZXIudmlydHVhbFNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG4gIGlmIChzcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICBjb25zdCBrZXkgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgcnRsID8gJ21hcmdpbkxlZnQnIDogc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgIHNsaWRlcy5maWx0ZXIoKF8sIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGlmICghcGFyYW1zLmNzc01vZGUgfHwgcGFyYW1zLmxvb3ApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlW2tleV0gPSBgJHtzcGFjZUJldHdlZW59cHhgO1xuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKHNsaWRlU2l6ZVZhbHVlID0+IHtcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAoc3BhY2VCZXR3ZWVuIHx8IDApO1xuICAgIH0pO1xuICAgIGFsbFNsaWRlc1NpemUgLT0gc3BhY2VCZXR3ZWVuO1xuICAgIGNvbnN0IG1heFNuYXAgPSBhbGxTbGlkZXNTaXplIC0gc3dpcGVyU2l6ZTtcbiAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcChzbmFwID0+IHtcbiAgICAgIGlmIChzbmFwIDw9IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xuICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChzcGFjZUJldHdlZW4gfHwgMCk7XG4gICAgfSk7XG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBzcGFjZUJldHdlZW47XG4gICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IChwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIHx8IDApICsgKHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlciB8fCAwKTtcbiAgICBpZiAoYWxsU2xpZGVzU2l6ZSArIG9mZnNldFNpemUgPCBzd2lwZXJTaXplKSB7XG4gICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUgLSBvZmZzZXRTaXplKSAvIDI7XG4gICAgICBzbmFwR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgc25hcEdyaWRbc25hcEluZGV4XSA9IHNuYXAgLSBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICAgIHNsaWRlc0dyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XG4gICAgICAgIHNsaWRlc0dyaWRbc25hcEluZGV4XSA9IHNuYXAgKyBhbGxTbGlkZXNPZmZzZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBzbGlkZXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBzbGlkZXNTaXplc0dyaWRcbiAgfSk7XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUgJiYgIXBhcmFtcy5jZW50ZXJlZFNsaWRlc0JvdW5kcykge1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmUnLCBgJHstc25hcEdyaWRbMF19cHhgKTtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYWZ0ZXInLCBgJHtzd2lwZXIuc2l6ZSAvIDIgLSBzbGlkZXNTaXplc0dyaWRbc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIC8gMn1weGApO1xuICAgIGNvbnN0IGFkZFRvU25hcEdyaWQgPSAtc3dpcGVyLnNuYXBHcmlkWzBdO1xuICAgIGNvbnN0IGFkZFRvU2xpZGVzR3JpZCA9IC1zd2lwZXIuc2xpZGVzR3JpZFswXTtcbiAgICBzd2lwZXIuc25hcEdyaWQgPSBzd2lwZXIuc25hcEdyaWQubWFwKHYgPT4gdiArIGFkZFRvU25hcEdyaWQpO1xuICAgIHN3aXBlci5zbGlkZXNHcmlkID0gc3dpcGVyLnNsaWRlc0dyaWQubWFwKHYgPT4gdiArIGFkZFRvU2xpZGVzR3JpZCk7XG4gIH1cbiAgaWYgKHNsaWRlc0xlbmd0aCAhPT0gcHJldmlvdXNTbGlkZXNMZW5ndGgpIHtcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVzTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCAhPT0gcHJldmlvdXNTbmFwR3JpZExlbmd0aCkge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgc3dpcGVyLmVtaXQoJ3NuYXBHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHNsaWRlc0dyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGgpIHtcbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVzR3JpZExlbmd0aENoYW5nZScpO1xuICB9XG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVzVXBkYXRlZCcpO1xuICBpZiAoIWlzVmlydHVhbCAmJiAhcGFyYW1zLmNzc01vZGUgJiYgKHBhcmFtcy5lZmZlY3QgPT09ICdzbGlkZScgfHwgcGFyYW1zLmVmZmVjdCA9PT0gJ2ZhZGUnKSkge1xuICAgIGNvbnN0IGJhY2tGYWNlSGlkZGVuQ2xhc3MgPSBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31iYWNrZmFjZS1oaWRkZW5gO1xuICAgIGNvbnN0IGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkID0gc3dpcGVyLmVsLmNsYXNzTGlzdC5jb250YWlucyhiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICBpZiAoc2xpZGVzTGVuZ3RoIDw9IHBhcmFtcy5tYXhCYWNrZmFjZUhpZGRlblNsaWRlcykge1xuICAgICAgaWYgKCFoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCkgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG4gICAgfSBlbHNlIGlmIChoYXNDbGFzc0JhY2tmYWNlQ2xhc3NBZGRlZCkge1xuICAgICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5yZW1vdmUoYmFja0ZhY2VIaWRkZW5DbGFzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUF1dG9IZWlnaHQoc3BlZWQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgYWN0aXZlU2xpZGVzID0gW107XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBsZXQgbmV3SGVpZ2h0ID0gMDtcbiAgbGV0IGk7XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICdudW1iZXInKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3BlZWQpO1xuICB9IGVsc2UgaWYgKHNwZWVkID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oc3dpcGVyLnBhcmFtcy5zcGVlZCk7XG4gIH1cbiAgY29uc3QgZ2V0U2xpZGVCeUluZGV4ID0gaW5kZXggPT4ge1xuICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgIHJldHVybiBzd2lwZXIuc2xpZGVzW3N3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKGluZGV4KV07XG4gICAgfVxuICAgIHJldHVybiBzd2lwZXIuc2xpZGVzW2luZGV4XTtcbiAgfTtcbiAgLy8gRmluZCBzbGlkZXMgY3VycmVudGx5IGluIHZpZXdcbiAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgKHN3aXBlci52aXNpYmxlU2xpZGVzIHx8IFtdKS5mb3JFYWNoKHNsaWRlID0+IHtcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goc2xpZGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4ICsgaTtcbiAgICAgICAgaWYgKGluZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggJiYgIWlzVmlydHVhbCkgYnJlYWs7XG4gICAgICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChpbmRleCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVTbGlkZXMucHVzaChnZXRTbGlkZUJ5SW5kZXgoc3dpcGVyLmFjdGl2ZUluZGV4KSk7XG4gIH1cblxuICAvLyBGaW5kIG5ldyBoZWlnaHQgZnJvbSBoaWdoZXN0IHNsaWRlIGluIHZpZXdcbiAgZm9yIChpID0gMDsgaSA8IGFjdGl2ZVNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVzW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYWN0aXZlU2xpZGVzW2ldLm9mZnNldEhlaWdodDtcbiAgICAgIG5ld0hlaWdodCA9IGhlaWdodCA+IG5ld0hlaWdodCA/IGhlaWdodCA6IG5ld0hlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgSGVpZ2h0XG4gIGlmIChuZXdIZWlnaHQgfHwgbmV3SGVpZ2h0ID09PSAwKSBzd2lwZXIud3JhcHBlckVsLnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc09mZnNldCgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qgc2xpZGVzID0gc3dpcGVyLnNsaWRlcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGNvbnN0IG1pbnVzT2Zmc2V0ID0gc3dpcGVyLmlzRWxlbWVudCA/IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHN3aXBlci53cmFwcGVyRWwub2Zmc2V0TGVmdCA6IHN3aXBlci53cmFwcGVyRWwub2Zmc2V0VG9wIDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVPZmZzZXQgPSAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc2xpZGVzW2ldLm9mZnNldExlZnQgOiBzbGlkZXNbaV0ub2Zmc2V0VG9wKSAtIG1pbnVzT2Zmc2V0IC0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICB9XG59XG5cbmNvbnN0IHRvZ2dsZVNsaWRlQ2xhc3NlcyQxID0gKHNsaWRlRWwsIGNvbmRpdGlvbiwgY2xhc3NOYW1lKSA9PiB7XG4gIGlmIChjb25kaXRpb24gJiYgIXNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICBzbGlkZUVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmICghY29uZGl0aW9uICYmIHNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICBzbGlkZUVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSkge1xuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2xhdGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDA7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBzbmFwR3JpZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHN3aXBlci51cGRhdGVTbGlkZXNPZmZzZXQoKTtcbiAgbGV0IG9mZnNldENlbnRlciA9IC10cmFuc2xhdGU7XG4gIGlmIChydGwpIG9mZnNldENlbnRlciA9IHRyYW5zbGF0ZTtcbiAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzID0gW107XG4gIHN3aXBlci52aXNpYmxlU2xpZGVzID0gW107XG4gIGxldCBzcGFjZUJldHdlZW4gPSBwYXJhbXMuc3BhY2VCZXR3ZWVuO1xuICBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycgJiYgc3BhY2VCZXR3ZWVuLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgc3BhY2VCZXR3ZWVuID0gcGFyc2VGbG9hdChzcGFjZUJldHdlZW4ucmVwbGFjZSgnJScsICcnKSkgLyAxMDAgKiBzd2lwZXIuc2l6ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJykge1xuICAgIHNwYWNlQmV0d2VlbiA9IHBhcnNlRmxvYXQoc3BhY2VCZXR3ZWVuKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNsaWRlID0gc2xpZGVzW2ldO1xuICAgIGxldCBzbGlkZU9mZnNldCA9IHNsaWRlLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgIGlmIChwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlT2Zmc2V0IC09IHNsaWRlc1swXS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGVQcm9ncmVzcyA9IChvZmZzZXRDZW50ZXIgKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzbGlkZU9mZnNldCkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuKTtcbiAgICBjb25zdCBvcmlnaW5hbFNsaWRlUHJvZ3Jlc3MgPSAob2Zmc2V0Q2VudGVyIC0gc25hcEdyaWRbMF0gKyAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIDogMCkgLSBzbGlkZU9mZnNldCkgLyAoc2xpZGUuc3dpcGVyU2xpZGVTaXplICsgc3BhY2VCZXR3ZWVuKTtcbiAgICBjb25zdCBzbGlkZUJlZm9yZSA9IC0ob2Zmc2V0Q2VudGVyIC0gc2xpZGVPZmZzZXQpO1xuICAgIGNvbnN0IHNsaWRlQWZ0ZXIgPSBzbGlkZUJlZm9yZSArIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbaV07XG4gICAgY29uc3QgaXNGdWxseVZpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDw9IHN3aXBlci5zaXplIC0gc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtpXTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSBzbGlkZUJlZm9yZSA+PSAwICYmIHNsaWRlQmVmb3JlIDwgc3dpcGVyLnNpemUgLSAxIHx8IHNsaWRlQWZ0ZXIgPiAxICYmIHNsaWRlQWZ0ZXIgPD0gc3dpcGVyLnNpemUgfHwgc2xpZGVCZWZvcmUgPD0gMCAmJiBzbGlkZUFmdGVyID49IHN3aXBlci5zaXplO1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzLnB1c2goc2xpZGUpO1xuICAgICAgc3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzLnB1c2goaSk7XG4gICAgfVxuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyQxKHNsaWRlLCBpc1Zpc2libGUsIHBhcmFtcy5zbGlkZVZpc2libGVDbGFzcyk7XG4gICAgdG9nZ2xlU2xpZGVDbGFzc2VzJDEoc2xpZGUsIGlzRnVsbHlWaXNpYmxlLCBwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcyk7XG4gICAgc2xpZGUucHJvZ3Jlc3MgPSBydGwgPyAtc2xpZGVQcm9ncmVzcyA6IHNsaWRlUHJvZ3Jlc3M7XG4gICAgc2xpZGUub3JpZ2luYWxQcm9ncmVzcyA9IHJ0bCA/IC1vcmlnaW5hbFNsaWRlUHJvZ3Jlc3MgOiBvcmlnaW5hbFNsaWRlUHJvZ3Jlc3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmICh0eXBlb2YgdHJhbnNsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHRyYW5zbGF0ZSA9IHN3aXBlciAmJiBzd2lwZXIudHJhbnNsYXRlICYmIHN3aXBlci50cmFuc2xhdGUgKiBtdWx0aXBsaWVyIHx8IDA7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGxldCB7XG4gICAgcHJvZ3Jlc3MsXG4gICAgaXNCZWdpbm5pbmcsXG4gICAgaXNFbmQsXG4gICAgcHJvZ3Jlc3NMb29wXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHdhc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nO1xuICBjb25zdCB3YXNFbmQgPSBpc0VuZDtcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgcHJvZ3Jlc3MgPSAwO1xuICAgIGlzQmVnaW5uaW5nID0gdHJ1ZTtcbiAgICBpc0VuZCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICAgIGNvbnN0IGlzQmVnaW5uaW5nUm91bmRlZCA9IE1hdGguYWJzKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgPCAxO1xuICAgIGNvbnN0IGlzRW5kUm91bmRlZCA9IE1hdGguYWJzKHRyYW5zbGF0ZSAtIHN3aXBlci5tYXhUcmFuc2xhdGUoKSkgPCAxO1xuICAgIGlzQmVnaW5uaW5nID0gaXNCZWdpbm5pbmdSb3VuZGVkIHx8IHByb2dyZXNzIDw9IDA7XG4gICAgaXNFbmQgPSBpc0VuZFJvdW5kZWQgfHwgcHJvZ3Jlc3MgPj0gMTtcbiAgICBpZiAoaXNCZWdpbm5pbmdSb3VuZGVkKSBwcm9ncmVzcyA9IDA7XG4gICAgaWYgKGlzRW5kUm91bmRlZCkgcHJvZ3Jlc3MgPSAxO1xuICB9XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGNvbnN0IGZpcnN0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKDApO1xuICAgIGNvbnN0IGxhc3RTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEoc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBmaXJzdFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbZmlyc3RTbGlkZUluZGV4XTtcbiAgICBjb25zdCBsYXN0U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFtsYXN0U2xpZGVJbmRleF07XG4gICAgY29uc3QgdHJhbnNsYXRlTWF4ID0gc3dpcGVyLnNsaWRlc0dyaWRbc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdHJhbnNsYXRlQWJzID0gTWF0aC5hYnModHJhbnNsYXRlKTtcbiAgICBpZiAodHJhbnNsYXRlQWJzID49IGZpcnN0U2xpZGVUcmFuc2xhdGUpIHtcbiAgICAgIHByb2dyZXNzTG9vcCA9ICh0cmFuc2xhdGVBYnMgLSBmaXJzdFNsaWRlVHJhbnNsYXRlKSAvIHRyYW5zbGF0ZU1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3Jlc3NMb29wID0gKHRyYW5zbGF0ZUFicyArIHRyYW5zbGF0ZU1heCAtIGxhc3RTbGlkZVRyYW5zbGF0ZSkgLyB0cmFuc2xhdGVNYXg7XG4gICAgfVxuICAgIGlmIChwcm9ncmVzc0xvb3AgPiAxKSBwcm9ncmVzc0xvb3AgLT0gMTtcbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIHByb2dyZXNzLFxuICAgIHByb2dyZXNzTG9vcCxcbiAgICBpc0JlZ2lubmluZyxcbiAgICBpc0VuZFxuICB9KTtcbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzIHx8IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuYXV0b0hlaWdodCkgc3dpcGVyLnVwZGF0ZVNsaWRlc1Byb2dyZXNzKHRyYW5zbGF0ZSk7XG4gIGlmIChpc0JlZ2lubmluZyAmJiAhd2FzQmVnaW5uaW5nKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoQmVnaW5uaW5nIHRvRWRnZScpO1xuICB9XG4gIGlmIChpc0VuZCAmJiAhd2FzRW5kKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3JlYWNoRW5kIHRvRWRnZScpO1xuICB9XG4gIGlmICh3YXNCZWdpbm5pbmcgJiYgIWlzQmVnaW5uaW5nIHx8IHdhc0VuZCAmJiAhaXNFbmQpIHtcbiAgICBzd2lwZXIuZW1pdCgnZnJvbUVkZ2UnKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgncHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG59XG5cbmNvbnN0IHRvZ2dsZVNsaWRlQ2xhc3NlcyA9IChzbGlkZUVsLCBjb25kaXRpb24sIGNsYXNzTmFtZSkgPT4ge1xuICBpZiAoY29uZGl0aW9uICYmICFzbGlkZUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgc2xpZGVFbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH0gZWxzZSBpZiAoIWNvbmRpdGlvbiAmJiBzbGlkZUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH1cbn07XG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbCxcbiAgICBhY3RpdmVJbmRleFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBjb25zdCBnZXRGaWx0ZXJlZFNsaWRlID0gc2VsZWN0b3IgPT4ge1xuICAgIHJldHVybiBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30ke3NlbGVjdG9yfSwgc3dpcGVyLXNsaWRlJHtzZWxlY3Rvcn1gKVswXTtcbiAgfTtcbiAgbGV0IGFjdGl2ZVNsaWRlO1xuICBsZXQgcHJldlNsaWRlO1xuICBsZXQgbmV4dFNsaWRlO1xuICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICBsZXQgc2xpZGVJbmRleCA9IGFjdGl2ZUluZGV4IC0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPCAwKSBzbGlkZUluZGV4ID0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCArIHNsaWRlSW5kZXg7XG4gICAgICBpZiAoc2xpZGVJbmRleCA+PSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoKSBzbGlkZUluZGV4IC09IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGg7XG4gICAgICBhY3RpdmVTbGlkZSA9IGdldEZpbHRlcmVkU2xpZGUoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVJbmRleH1cIl1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlU2xpZGUgPSBnZXRGaWx0ZXJlZFNsaWRlKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2FjdGl2ZUluZGV4fVwiXWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIGFjdGl2ZVNsaWRlID0gc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY29sdW1uID09PSBhY3RpdmVJbmRleClbMF07XG4gICAgICBuZXh0U2xpZGUgPSBzbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4ICsgMSlbMF07XG4gICAgICBwcmV2U2xpZGUgPSBzbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4IC0gMSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZVNsaWRlID0gc2xpZGVzW2FjdGl2ZUluZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKGFjdGl2ZVNsaWRlKSB7XG4gICAgaWYgKCFncmlkRW5hYmxlZCkge1xuICAgICAgLy8gTmV4dCBTbGlkZVxuICAgICAgbmV4dFNsaWRlID0gZWxlbWVudE5leHRBbGwoYWN0aXZlU2xpZGUsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApWzBdO1xuICAgICAgaWYgKHBhcmFtcy5sb29wICYmICFuZXh0U2xpZGUpIHtcbiAgICAgICAgbmV4dFNsaWRlID0gc2xpZGVzWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmV2IFNsaWRlXG4gICAgICBwcmV2U2xpZGUgPSBlbGVtZW50UHJldkFsbChhY3RpdmVTbGlkZSwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYClbMF07XG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgIXByZXZTbGlkZSA9PT0gMCkge1xuICAgICAgICBwcmV2U2xpZGUgPSBzbGlkZXNbc2xpZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICB0b2dnbGVTbGlkZUNsYXNzZXMoc2xpZGVFbCwgc2xpZGVFbCA9PT0gYWN0aXZlU2xpZGUsIHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKTtcbiAgICB0b2dnbGVTbGlkZUNsYXNzZXMoc2xpZGVFbCwgc2xpZGVFbCA9PT0gbmV4dFNsaWRlLCBwYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xuICAgIHRvZ2dsZVNsaWRlQ2xhc3NlcyhzbGlkZUVsLCBzbGlkZUVsID09PSBwcmV2U2xpZGUsIHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gIH0pO1xuICBzd2lwZXIuZW1pdFNsaWRlc0NsYXNzZXMoKTtcbn1cblxuY29uc3QgcHJvY2Vzc0xhenlQcmVsb2FkZXIgPSAoc3dpcGVyLCBpbWFnZUVsKSA9PiB7XG4gIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5wYXJhbXMpIHJldHVybjtcbiAgY29uc3Qgc2xpZGVTZWxlY3RvciA9ICgpID0+IHN3aXBlci5pc0VsZW1lbnQgPyBgc3dpcGVyLXNsaWRlYCA6IGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9YDtcbiAgY29uc3Qgc2xpZGVFbCA9IGltYWdlRWwuY2xvc2VzdChzbGlkZVNlbGVjdG9yKCkpO1xuICBpZiAoc2xpZGVFbCkge1xuICAgIGxldCBsYXp5RWwgPSBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3aXBlci5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzfWApO1xuICAgIGlmICghbGF6eUVsICYmIHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGlmIChzbGlkZUVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgbGF6eUVsID0gc2xpZGVFbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoYC4ke3N3aXBlci5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5pdCBsYXRlclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmIChzbGlkZUVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGxhenlFbCA9IHNsaWRlRWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKGAuJHtzd2lwZXIucGFyYW1zLmxhenlQcmVsb2FkZXJDbGFzc31gKTtcbiAgICAgICAgICAgIGlmIChsYXp5RWwpIGxhenlFbC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGF6eUVsKSBsYXp5RWwucmVtb3ZlKCk7XG4gIH1cbn07XG5jb25zdCB1bmxhenkgPSAoc3dpcGVyLCBpbmRleCkgPT4ge1xuICBpZiAoIXN3aXBlci5zbGlkZXNbaW5kZXhdKSByZXR1cm47XG4gIGNvbnN0IGltYWdlRWwgPSBzd2lwZXIuc2xpZGVzW2luZGV4XS5xdWVyeVNlbGVjdG9yKCdbbG9hZGluZz1cImxhenlcIl0nKTtcbiAgaWYgKGltYWdlRWwpIGltYWdlRWwucmVtb3ZlQXR0cmlidXRlKCdsb2FkaW5nJyk7XG59O1xuY29uc3QgcHJlbG9hZCA9IHN3aXBlciA9PiB7XG4gIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5wYXJhbXMpIHJldHVybjtcbiAgbGV0IGFtb3VudCA9IHN3aXBlci5wYXJhbXMubGF6eVByZWxvYWRQcmV2TmV4dDtcbiAgY29uc3QgbGVuID0gc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gIGlmICghbGVuIHx8ICFhbW91bnQgfHwgYW1vdW50IDwgMCkgcmV0dXJuO1xuICBhbW91bnQgPSBNYXRoLm1pbihhbW91bnQsIGxlbik7XG4gIGNvbnN0IHNsaWRlc1BlclZpZXcgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogTWF0aC5jZWlsKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBpZiAoc3dpcGVyLnBhcmFtcy5ncmlkICYmIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzID4gMSkge1xuICAgIGNvbnN0IGFjdGl2ZUNvbHVtbiA9IGFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IHByZWxvYWRDb2x1bW5zID0gW2FjdGl2ZUNvbHVtbiAtIGFtb3VudF07XG4gICAgcHJlbG9hZENvbHVtbnMucHVzaCguLi5BcnJheS5mcm9tKHtcbiAgICAgIGxlbmd0aDogYW1vdW50XG4gICAgfSkubWFwKChfLCBpKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aXZlQ29sdW1uICsgc2xpZGVzUGVyVmlldyArIGk7XG4gICAgfSkpO1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaCgoc2xpZGVFbCwgaSkgPT4ge1xuICAgICAgaWYgKHByZWxvYWRDb2x1bW5zLmluY2x1ZGVzKHNsaWRlRWwuY29sdW1uKSkgdW5sYXp5KHN3aXBlciwgaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNsaWRlSW5kZXhMYXN0SW5WaWV3ID0gYWN0aXZlSW5kZXggKyBzbGlkZXNQZXJWaWV3IC0gMTtcbiAgaWYgKHN3aXBlci5wYXJhbXMucmV3aW5kIHx8IHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIGFtb3VudDsgaSA8PSBzbGlkZUluZGV4TGFzdEluVmlldyArIGFtb3VudDsgaSArPSAxKSB7XG4gICAgICBjb25zdCByZWFsSW5kZXggPSAoaSAlIGxlbiArIGxlbikgJSBsZW47XG4gICAgICBpZiAocmVhbEluZGV4IDwgYWN0aXZlSW5kZXggfHwgcmVhbEluZGV4ID4gc2xpZGVJbmRleExhc3RJblZpZXcpIHVubGF6eShzd2lwZXIsIHJlYWxJbmRleCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSBNYXRoLm1heChhY3RpdmVJbmRleCAtIGFtb3VudCwgMCk7IGkgPD0gTWF0aC5taW4oc2xpZGVJbmRleExhc3RJblZpZXcgKyBhbW91bnQsIGxlbiAtIDEpOyBpICs9IDEpIHtcbiAgICAgIGlmIChpICE9PSBhY3RpdmVJbmRleCAmJiAoaSA+IHNsaWRlSW5kZXhMYXN0SW5WaWV3IHx8IGkgPCBhY3RpdmVJbmRleCkpIHtcbiAgICAgICAgdW5sYXp5KHN3aXBlciwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVJbmRleEJ5VHJhbnNsYXRlKHN3aXBlcikge1xuICBjb25zdCB7XG4gICAgc2xpZGVzR3JpZCxcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgbGV0IGFjdGl2ZUluZGV4O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0dyaWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIDFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldICYmIHRyYW5zbGF0ZSA8IHNsaWRlc0dyaWRbaSArIDFdIC0gKHNsaWRlc0dyaWRbaSArIDFdIC0gc2xpZGVzR3JpZFtpXSkgLyAyKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0gJiYgdHJhbnNsYXRlIDwgc2xpZGVzR3JpZFtpICsgMV0pIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZSA+PSBzbGlkZXNHcmlkW2ldKSB7XG4gICAgICBhY3RpdmVJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgIGlmIChhY3RpdmVJbmRleCA8IDAgfHwgdHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykgYWN0aXZlSW5kZXggPSAwO1xuICB9XG4gIHJldHVybiBhY3RpdmVJbmRleDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZUluZGV4KG5ld0FjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGNvbnN0IHtcbiAgICBzbmFwR3JpZCxcbiAgICBwYXJhbXMsXG4gICAgYWN0aXZlSW5kZXg6IHByZXZpb3VzSW5kZXgsXG4gICAgcmVhbEluZGV4OiBwcmV2aW91c1JlYWxJbmRleCxcbiAgICBzbmFwSW5kZXg6IHByZXZpb3VzU25hcEluZGV4XG4gIH0gPSBzd2lwZXI7XG4gIGxldCBhY3RpdmVJbmRleCA9IG5ld0FjdGl2ZUluZGV4O1xuICBsZXQgc25hcEluZGV4O1xuICBjb25zdCBnZXRWaXJ0dWFsUmVhbEluZGV4ID0gYUluZGV4ID0+IHtcbiAgICBsZXQgcmVhbEluZGV4ID0gYUluZGV4IC0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgIGlmIChyZWFsSW5kZXggPCAwKSB7XG4gICAgICByZWFsSW5kZXggPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoICsgcmVhbEluZGV4O1xuICAgIH1cbiAgICBpZiAocmVhbEluZGV4ID49IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgIHJlYWxJbmRleCAtPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVhbEluZGV4O1xuICB9O1xuICBpZiAodHlwZW9mIGFjdGl2ZUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgIGFjdGl2ZUluZGV4ID0gZ2V0QWN0aXZlSW5kZXhCeVRyYW5zbGF0ZShzd2lwZXIpO1xuICB9XG4gIGlmIChzbmFwR3JpZC5pbmRleE9mKHRyYW5zbGF0ZSkgPj0gMCkge1xuICAgIHNuYXBJbmRleCA9IHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBza2lwID0gTWF0aC5taW4ocGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgYWN0aXZlSW5kZXgpO1xuICAgIHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChhY3RpdmVJbmRleCAtIHNraXApIC8gcGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgfVxuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgaWYgKGFjdGl2ZUluZGV4ID09PSBwcmV2aW91c0luZGV4ICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc25hcEluZGV4ICE9PSBwcmV2aW91c1NuYXBJbmRleCkge1xuICAgICAgc3dpcGVyLnNuYXBJbmRleCA9IHNuYXBJbmRleDtcbiAgICAgIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhY3RpdmVJbmRleCA9PT0gcHJldmlvdXNJbmRleCAmJiBzd2lwZXIucGFyYW1zLmxvb3AgJiYgc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICBzd2lwZXIucmVhbEluZGV4ID0gZ2V0VmlydHVhbFJlYWxJbmRleChhY3RpdmVJbmRleCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG5cbiAgLy8gR2V0IHJlYWwgaW5kZXhcbiAgbGV0IHJlYWxJbmRleDtcbiAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgcGFyYW1zLmxvb3ApIHtcbiAgICByZWFsSW5kZXggPSBnZXRWaXJ0dWFsUmVhbEluZGV4KGFjdGl2ZUluZGV4KTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCkge1xuICAgIGNvbnN0IGZpcnN0U2xpZGVJbkNvbHVtbiA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4KVswXTtcbiAgICBsZXQgYWN0aXZlU2xpZGVJbmRleCA9IHBhcnNlSW50KGZpcnN0U2xpZGVJbkNvbHVtbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGFjdGl2ZVNsaWRlSW5kZXgpKSB7XG4gICAgICBhY3RpdmVTbGlkZUluZGV4ID0gTWF0aC5tYXgoc3dpcGVyLnNsaWRlcy5pbmRleE9mKGZpcnN0U2xpZGVJbkNvbHVtbiksIDApO1xuICAgIH1cbiAgICByZWFsSW5kZXggPSBNYXRoLmZsb29yKGFjdGl2ZVNsaWRlSW5kZXggLyBwYXJhbXMuZ3JpZC5yb3dzKTtcbiAgfSBlbHNlIGlmIChzd2lwZXIuc2xpZGVzW2FjdGl2ZUluZGV4XSkge1xuICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzW2FjdGl2ZUluZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIHJlYWxJbmRleCA9IHBhcnNlSW50KHNsaWRlSW5kZXgsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhbEluZGV4ID0gYWN0aXZlSW5kZXg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlYWxJbmRleCA9IGFjdGl2ZUluZGV4O1xuICB9XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgcHJldmlvdXNTbmFwSW5kZXgsXG4gICAgc25hcEluZGV4LFxuICAgIHByZXZpb3VzUmVhbEluZGV4LFxuICAgIHJlYWxJbmRleCxcbiAgICBwcmV2aW91c0luZGV4LFxuICAgIGFjdGl2ZUluZGV4XG4gIH0pO1xuICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgcHJlbG9hZChzd2lwZXIpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdhY3RpdmVJbmRleENoYW5nZScpO1xuICBzd2lwZXIuZW1pdCgnc25hcEluZGV4Q2hhbmdlJyk7XG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgfHwgc3dpcGVyLnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpIHtcbiAgICBpZiAocHJldmlvdXNSZWFsSW5kZXggIT09IHJlYWxJbmRleCkge1xuICAgICAgc3dpcGVyLmVtaXQoJ3JlYWxJbmRleENoYW5nZScpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVDaGFuZ2UnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGlja2VkU2xpZGUoZWwsIHBhdGgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgbGV0IHNsaWRlID0gZWwuY2xvc2VzdChgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgaWYgKCFzbGlkZSAmJiBzd2lwZXIuaXNFbGVtZW50ICYmIHBhdGggJiYgcGF0aC5sZW5ndGggPiAxICYmIHBhdGguaW5jbHVkZXMoZWwpKSB7XG4gICAgWy4uLnBhdGguc2xpY2UocGF0aC5pbmRleE9mKGVsKSArIDEsIHBhdGgubGVuZ3RoKV0uZm9yRWFjaChwYXRoRWwgPT4ge1xuICAgICAgaWYgKCFzbGlkZSAmJiBwYXRoRWwubWF0Y2hlcyAmJiBwYXRoRWwubWF0Y2hlcyhgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKSkge1xuICAgICAgICBzbGlkZSA9IHBhdGhFbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgc2xpZGVGb3VuZCA9IGZhbHNlO1xuICBsZXQgc2xpZGVJbmRleDtcbiAgaWYgKHNsaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc1tpXSA9PT0gc2xpZGUpIHtcbiAgICAgICAgc2xpZGVGb3VuZCA9IHRydWU7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNsaWRlICYmIHNsaWRlRm91bmQpIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gc2xpZGU7XG4gICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBzd2lwZXIuY2xpY2tlZEluZGV4ID0gcGFyc2VJbnQoc2xpZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBzbGlkZUluZGV4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuY2xpY2tlZFNsaWRlID0gdW5kZWZpbmVkO1xuICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuc2xpZGVUb0NsaWNrZWRTbGlkZSAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgc3dpcGVyLmNsaWNrZWRJbmRleCAhPT0gc3dpcGVyLmFjdGl2ZUluZGV4KSB7XG4gICAgc3dpcGVyLnNsaWRlVG9DbGlja2VkU2xpZGUoKTtcbiAgfVxufVxuXG52YXIgdXBkYXRlID0ge1xuICB1cGRhdGVTaXplLFxuICB1cGRhdGVTbGlkZXMsXG4gIHVwZGF0ZUF1dG9IZWlnaHQsXG4gIHVwZGF0ZVNsaWRlc09mZnNldCxcbiAgdXBkYXRlU2xpZGVzUHJvZ3Jlc3MsXG4gIHVwZGF0ZVByb2dyZXNzLFxuICB1cGRhdGVTbGlkZXNDbGFzc2VzLFxuICB1cGRhdGVBY3RpdmVJbmRleCxcbiAgdXBkYXRlQ2xpY2tlZFNsaWRlXG59O1xuXG5mdW5jdGlvbiBnZXRTd2lwZXJUcmFuc2xhdGUoYXhpcykge1xuICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG4gICAgYXhpcyA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyAneCcgOiAneSc7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICB0cmFuc2xhdGUsXG4gICAgd3JhcHBlckVsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIHJldHVybiBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHJldHVybiB0cmFuc2xhdGU7XG4gIH1cbiAgbGV0IGN1cnJlbnRUcmFuc2xhdGUgPSBnZXRUcmFuc2xhdGUod3JhcHBlckVsLCBheGlzKTtcbiAgY3VycmVudFRyYW5zbGF0ZSArPSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gIGlmIChydGwpIGN1cnJlbnRUcmFuc2xhdGUgPSAtY3VycmVudFRyYW5zbGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRUcmFuc2xhdGUgfHwgMDtcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBwYXJhbXMsXG4gICAgd3JhcHBlckVsLFxuICAgIHByb2dyZXNzXG4gIH0gPSBzd2lwZXI7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBjb25zdCB6ID0gMDtcbiAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgIHggPSBydGwgPyAtdHJhbnNsYXRlIDogdHJhbnNsYXRlO1xuICB9IGVsc2Uge1xuICAgIHkgPSB0cmFuc2xhdGU7XG4gIH1cbiAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICB4ID0gTWF0aC5mbG9vcih4KTtcbiAgICB5ID0gTWF0aC5mbG9vcih5KTtcbiAgfVxuICBzd2lwZXIucHJldmlvdXNUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xuICBzd2lwZXIudHJhbnNsYXRlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8geCA6IHk7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHdyYXBwZXJFbFtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAteCA6IC15O1xuICB9IGVsc2UgaWYgKCFwYXJhbXMudmlydHVhbFRyYW5zbGF0ZSkge1xuICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHggLT0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB5IC09IHN3aXBlci5jc3NPdmVyZmxvd0FkanVzdG1lbnQoKTtcbiAgICB9XG4gICAgd3JhcHBlckVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgJHt6fXB4KWA7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBwcm9ncmVzc1xuICBsZXQgbmV3UHJvZ3Jlc3M7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBuZXdQcm9ncmVzcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAodHJhbnNsYXRlIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSAvIHRyYW5zbGF0ZXNEaWZmO1xuICB9XG4gIGlmIChuZXdQcm9ncmVzcyAhPT0gcHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgYnlDb250cm9sbGVyKTtcbn1cblxuZnVuY3Rpb24gbWluVHJhbnNsYXRlKCkge1xuICByZXR1cm4gLXRoaXMuc25hcEdyaWRbMF07XG59XG5cbmZ1bmN0aW9uIG1heFRyYW5zbGF0ZSgpIHtcbiAgcmV0dXJuIC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVRvKHRyYW5zbGF0ZSwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgdHJhbnNsYXRlQm91bmRzLCBpbnRlcm5hbCkge1xuICBpZiAodHJhbnNsYXRlID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2xhdGUgPSAwO1xuICB9XG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGlmICh0cmFuc2xhdGVCb3VuZHMgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZUJvdW5kcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICB3cmFwcGVyRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtaW5UcmFuc2xhdGUgPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGNvbnN0IG1heFRyYW5zbGF0ZSA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKTtcbiAgbGV0IG5ld1RyYW5zbGF0ZTtcbiAgaWYgKHRyYW5zbGF0ZUJvdW5kcyAmJiB0cmFuc2xhdGUgPiBtaW5UcmFuc2xhdGUpIG5ld1RyYW5zbGF0ZSA9IG1pblRyYW5zbGF0ZTtlbHNlIGlmICh0cmFuc2xhdGVCb3VuZHMgJiYgdHJhbnNsYXRlIDwgbWF4VHJhbnNsYXRlKSBuZXdUcmFuc2xhdGUgPSBtYXhUcmFuc2xhdGU7ZWxzZSBuZXdUcmFuc2xhdGUgPSB0cmFuc2xhdGU7XG5cbiAgLy8gVXBkYXRlIHByb2dyZXNzXG4gIHN3aXBlci51cGRhdGVQcm9ncmVzcyhuZXdUcmFuc2xhdGUpO1xuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICB3cmFwcGVyRWxbaXNIID8gJ3Njcm9sbExlZnQnIDogJ3Njcm9sbFRvcCddID0gLW5ld1RyYW5zbGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogLW5ld1RyYW5zbGF0ZSxcbiAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiAtbmV3VHJhbnNsYXRlLFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG4gICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdUcmFuc2xhdGUpO1xuICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgIHN3aXBlci5lbWl0KCdiZWZvcmVUcmFuc2l0aW9uU3RhcnQnLCBzcGVlZCwgaW50ZXJuYWwpO1xuICAgICAgc3dpcGVyLmVtaXQoJ3RyYW5zaXRpb25TdGFydCcpO1xuICAgIH1cbiAgICBpZiAoIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgaWYgKCFzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICAgIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgZGVsZXRlIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChydW5DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgdHJhbnNsYXRlID0ge1xuICBnZXRUcmFuc2xhdGU6IGdldFN3aXBlclRyYW5zbGF0ZSxcbiAgc2V0VHJhbnNsYXRlLFxuICBtaW5UcmFuc2xhdGUsXG4gIG1heFRyYW5zbGF0ZSxcbiAgdHJhbnNsYXRlVG9cbn07XG5cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb24oZHVyYXRpb24sIGJ5Q29udHJvbGxlcikge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7ZHVyYXRpb259bXNgO1xuICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gZHVyYXRpb24gPT09IDAgPyBgMG1zYCA6ICcnO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2l0aW9uJywgZHVyYXRpb24sIGJ5Q29udHJvbGxlcik7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbWl0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgcnVuQ2FsbGJhY2tzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGVwXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgcHJldmlvdXNJbmRleFxuICB9ID0gc3dpcGVyO1xuICBsZXQgZGlyID0gZGlyZWN0aW9uO1xuICBpZiAoIWRpcikge1xuICAgIGlmIChhY3RpdmVJbmRleCA+IHByZXZpb3VzSW5kZXgpIGRpciA9ICduZXh0JztlbHNlIGlmIChhY3RpdmVJbmRleCA8IHByZXZpb3VzSW5kZXgpIGRpciA9ICdwcmV2JztlbHNlIGRpciA9ICdyZXNldCc7XG4gIH1cbiAgc3dpcGVyLmVtaXQoYHRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gIGlmIChydW5DYWxsYmFja3MgJiYgYWN0aXZlSW5kZXggIT09IHByZXZpb3VzSW5kZXgpIHtcbiAgICBpZiAoZGlyID09PSAncmVzZXQnKSB7XG4gICAgICBzd2lwZXIuZW1pdChgc2xpZGVSZXNldFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KGBzbGlkZUNoYW5nZVRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgaWYgKGRpciA9PT0gJ25leHQnKSB7XG4gICAgICBzd2lwZXIuZW1pdChgc2xpZGVOZXh0VHJhbnNpdGlvbiR7c3RlcH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlUHJldlRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbikge1xuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gIH1cbiAgdHJhbnNpdGlvbkVtaXQoe1xuICAgIHN3aXBlcixcbiAgICBydW5DYWxsYmFja3MsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0ZXA6ICdTdGFydCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICB0cmFuc2l0aW9uRW1pdCh7XG4gICAgc3dpcGVyLFxuICAgIHJ1bkNhbGxiYWNrcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RlcDogJ0VuZCdcbiAgfSk7XG59XG5cbnZhciB0cmFuc2l0aW9uID0ge1xuICBzZXRUcmFuc2l0aW9uLFxuICB0cmFuc2l0aW9uU3RhcnQsXG4gIHRyYW5zaXRpb25FbmRcbn07XG5cbmZ1bmN0aW9uIHNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCBpbml0aWFsKSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHNsaWRlSW5kZXggPSBpbmRleDtcbiAgaWYgKHNsaWRlSW5kZXggPCAwKSBzbGlkZUluZGV4ID0gMDtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbmFwR3JpZCxcbiAgICBzbGlkZXNHcmlkLFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgd3JhcHBlckVsLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkICYmICFpbnRlcm5hbCAmJiAhaW5pdGlhbCB8fCBzd2lwZXIuZGVzdHJveWVkIHx8IHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJykge1xuICAgIHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHNsaWRlSW5kZXgpO1xuICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgY29uc3QgdHJhbnNsYXRlID0gLXNuYXBHcmlkW3NuYXBJbmRleF07XG4gIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IC1NYXRoLmZsb29yKHRyYW5zbGF0ZSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpXSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZE5leHQgPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaSArIDFdICogMTAwKTtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQgLSAobm9ybWFsaXplZEdyaWROZXh0IC0gbm9ybWFsaXplZEdyaWQpIC8gMikge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQgJiYgbm9ybWFsaXplZFRyYW5zbGF0ZSA8IG5vcm1hbGl6ZWRHcmlkTmV4dCkge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiAocnRsID8gdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGlmICgoYWN0aXZlSW5kZXggfHwgMCkgIT09IHNsaWRlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2xpZGVJbmRleCAhPT0gKHByZXZpb3VzSW5kZXggfHwgMCkgJiYgcnVuQ2FsbGJhY2tzKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVNsaWRlQ2hhbmdlU3RhcnQnKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgbGV0IGRpcmVjdGlvbjtcbiAgaWYgKHNsaWRlSW5kZXggPiBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ25leHQnO2Vsc2UgaWYgKHNsaWRlSW5kZXggPCBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ3ByZXYnO2Vsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcblxuICAvLyBVcGRhdGUgSW5kZXhcbiAgaWYgKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlIHx8ICFydGwgJiYgdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIC8vIFVwZGF0ZSBIZWlnaHRcbiAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdCA9IHJ0bCA/IHRyYW5zbGF0ZSA6IC10cmFuc2xhdGU7XG4gICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgICAgICAgc3dpcGVyLl9pbW1lZGlhdGVWaXJ0dWFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZpcnR1YWwgJiYgIXN3aXBlci5fY3NzTW9kZVZpcnR1YWxJbml0aWFsU2V0ICYmIHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlID4gMCkge1xuICAgICAgICBzd2lwZXIuX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgICAgIHN3aXBlci5faW1tZWRpYXRlVmlydHVhbCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogdCxcbiAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiB0LFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gIGlmIChzcGVlZCA9PT0gMCkge1xuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgfSBlbHNlIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgIGlmICghc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0xvb3AoaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBpbmRleEFzTnVtYmVyID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICBpbmRleCA9IGluZGV4QXNOdW1iZXI7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBzd2lwZXIucGFyYW1zLmdyaWQgJiYgc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcbiAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0U2xpZGVJbmRleDtcbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gbmV3SW5kZXggKiBzd2lwZXIucGFyYW1zLmdyaWQucm93cztcbiAgICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxID09PSBzbGlkZUluZGV4KVswXS5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEobmV3SW5kZXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29scyA9IGdyaWRFbmFibGVkID8gTWF0aC5jZWlsKHN3aXBlci5zbGlkZXMubGVuZ3RoIC8gc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3MpIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbnRlcmVkU2xpZGVzXG4gICAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICAgIGxldCBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgICAgICBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZXNQZXJWaWV3ID0gTWF0aC5jZWlsKHBhcnNlRmxvYXQoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpO1xuICAgICAgICBpZiAoY2VudGVyZWRTbGlkZXMgJiYgc2xpZGVzUGVyVmlldyAlIDIgPT09IDApIHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3ID0gc2xpZGVzUGVyVmlldyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBuZWVkTG9vcEZpeCA9IGNvbHMgLSB0YXJnZXRTbGlkZUluZGV4IDwgc2xpZGVzUGVyVmlldztcbiAgICAgIGlmIChjZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBuZWVkTG9vcEZpeCA9IG5lZWRMb29wRml4IHx8IHRhcmdldFNsaWRlSW5kZXggPCBNYXRoLmNlaWwoc2xpZGVzUGVyVmlldyAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKGludGVybmFsICYmIGNlbnRlcmVkU2xpZGVzICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmICFncmlkRW5hYmxlZCkge1xuICAgICAgICBuZWVkTG9vcEZpeCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMb29wRml4KSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNlbnRlcmVkU2xpZGVzID8gdGFyZ2V0U2xpZGVJbmRleCA8IHN3aXBlci5hY3RpdmVJbmRleCA/ICdwcmV2JyA6ICduZXh0JyA6IHRhcmdldFNsaWRlSW5kZXggLSBzd2lwZXIuYWN0aXZlSW5kZXggLSAxIDwgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gJ25leHQnIDogJ3ByZXYnO1xuICAgICAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgIHNsaWRlVG86IHRydWUsXG4gICAgICAgICAgYWN0aXZlU2xpZGVJbmRleDogZGlyZWN0aW9uID09PSAnbmV4dCcgPyB0YXJnZXRTbGlkZUluZGV4ICsgMSA6IHRhcmdldFNsaWRlSW5kZXggLSBjb2xzICsgMSxcbiAgICAgICAgICBzbGlkZVJlYWxJbmRleDogZGlyZWN0aW9uID09PSAnbmV4dCcgPyBzd2lwZXIucmVhbEluZGV4IDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBuZXdJbmRleCAqIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzO1xuICAgICAgICBuZXdJbmRleCA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JykgKiAxID09PSBzbGlkZUluZGV4KVswXS5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICB9KTtcbiAgcmV0dXJuIHN3aXBlcjtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZU5leHQoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCxcbiAgICBwYXJhbXMsXG4gICAgYW5pbWF0aW5nXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm4gc3dpcGVyO1xuICBpZiAodHlwZW9mIHNwZWVkID09PSAndW5kZWZpbmVkJykge1xuICAgIHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBsZXQgcGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgcGVyR3JvdXAgPSBNYXRoLm1heChzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoJ2N1cnJlbnQnLCB0cnVlKSwgMSk7XG4gIH1cbiAgY29uc3QgaW5jcmVtZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwZXJHcm91cDtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKGFuaW1hdGluZyAmJiAhaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wUHJldmVudHNTbGlkaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgZGlyZWN0aW9uOiAnbmV4dCdcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIud3JhcHBlckVsLmNsaWVudExlZnQ7XG4gICAgaWYgKHN3aXBlci5hY3RpdmVJbmRleCA9PT0gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0VuZCkge1xuICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIGluY3JlbWVudCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlUHJldihzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc25hcEdyaWQsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBydGxUcmFuc2xhdGUsXG4gICAgZW5hYmxlZCxcbiAgICBhbmltYXRpbmdcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybiBzd2lwZXI7XG4gIGlmICh0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3BlZWQgPSBzd2lwZXIucGFyYW1zLnNwZWVkO1xuICB9XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChhbmltYXRpbmcgJiYgIWlzVmlydHVhbCAmJiBwYXJhbXMubG9vcFByZXZlbnRzU2xpZGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgIGRpcmVjdGlvbjogJ3ByZXYnXG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgc3dpcGVyLl9jbGllbnRMZWZ0ID0gc3dpcGVyLndyYXBwZXJFbC5jbGllbnRMZWZ0O1xuICB9XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHZhbCkge1xuICAgIGlmICh2YWwgPCAwKSByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5hYnModmFsKSk7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodmFsKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkVHJhbnNsYXRlID0gbm9ybWFsaXplKHRyYW5zbGF0ZSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRTbmFwR3JpZCA9IHNuYXBHcmlkLm1hcCh2YWwgPT4gbm9ybWFsaXplKHZhbCkpO1xuICBsZXQgcHJldlNuYXAgPSBzbmFwR3JpZFtub3JtYWxpemVkU25hcEdyaWQuaW5kZXhPZihub3JtYWxpemVkVHJhbnNsYXRlKSAtIDFdO1xuICBpZiAodHlwZW9mIHByZXZTbmFwID09PSAndW5kZWZpbmVkJyAmJiBwYXJhbXMuY3NzTW9kZSkge1xuICAgIGxldCBwcmV2U25hcEluZGV4O1xuICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gc25hcCkge1xuICAgICAgICAvLyBwcmV2U25hcCA9IHNuYXA7XG4gICAgICAgIHByZXZTbmFwSW5kZXggPSBzbmFwSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBwcmV2U25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcHJldlNuYXAgPSBzbmFwR3JpZFtwcmV2U25hcEluZGV4ID4gMCA/IHByZXZTbmFwSW5kZXggLSAxIDogcHJldlNuYXBJbmRleF07XG4gICAgfVxuICB9XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHByZXZTbmFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIHByZXZJbmRleCA9IHNsaWRlc0dyaWQuaW5kZXhPZihwcmV2U25hcCk7XG4gICAgaWYgKHByZXZJbmRleCA8IDApIHByZXZJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleCAtIDE7XG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAxICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cEF1dG8pIHtcbiAgICAgIHByZXZJbmRleCA9IHByZXZJbmRleCAtIHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygncHJldmlvdXMnLCB0cnVlKSArIDE7XG4gICAgICBwcmV2SW5kZXggPSBNYXRoLm1heChwcmV2SW5kZXgsIDApO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLnJld2luZCAmJiBzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzd2lwZXIucGFyYW1zLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIC0gMSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gc3dpcGVyLnNsaWRlVG8obGFzdEluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gIH0gZWxzZSBpZiAocGFyYW1zLmxvb3AgJiYgc3dpcGVyLmFjdGl2ZUluZGV4ID09PSAwICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhwcmV2SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBcIm9mZlwiICovXG5mdW5jdGlvbiBzbGlkZVJlc2V0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCB0aHJlc2hvbGQpIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICB0aHJlc2hvbGQgPSAwLjU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzcGVlZCA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgbGV0IGluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KTtcbiAgY29uc3Qgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKGluZGV4IC0gc2tpcCkgLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKTtcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgaWYgKHRyYW5zbGF0ZSA+PSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XSkge1xuICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBvbiBvciBhZnRlciB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBhZnRlciBpdC5cbiAgICBjb25zdCBjdXJyZW50U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXhdO1xuICAgIGNvbnN0IG5leHRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCArIDFdO1xuICAgIGlmICh0cmFuc2xhdGUgLSBjdXJyZW50U25hcCA+IChuZXh0U25hcCAtIGN1cnJlbnRTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgaW5kZXggKz0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgdHJhbnNsYXRlIGlzIGJlZm9yZSB0aGUgY3VycmVudCBzbmFwIGluZGV4LCBzbyB0aGUgY2hvaWNlXG4gICAgLy8gaXMgYmV0d2VlbiB0aGUgY3VycmVudCBpbmRleCBhbmQgdGhlIG9uZSBiZWZvcmUgaXQuXG4gICAgY29uc3QgcHJldlNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4IC0gMV07XG4gICAgY29uc3QgY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcbiAgICBpZiAodHJhbnNsYXRlIC0gcHJldlNuYXAgPD0gKGN1cnJlbnRTbmFwIC0gcHJldlNuYXApICogdGhyZXNob2xkKSB7XG4gICAgICBpbmRleCAtPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgIH1cbiAgfVxuICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgc3dpcGVyLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG5mdW5jdGlvbiBzbGlkZVRvQ2xpY2tlZFNsaWRlKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNsaWRlc0VsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IHNsaWRlc1BlclZpZXcgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBwYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgbGV0IHNsaWRlVG9JbmRleCA9IHN3aXBlci5jbGlja2VkSW5kZXg7XG4gIGxldCByZWFsSW5kZXg7XG4gIGNvbnN0IHNsaWRlU2VsZWN0b3IgPSBzd2lwZXIuaXNFbGVtZW50ID8gYHN3aXBlci1zbGlkZWAgOiBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9YDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHJldHVybjtcbiAgICByZWFsSW5kZXggPSBwYXJzZUludChzd2lwZXIuY2xpY2tlZFNsaWRlLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIGlmIChzbGlkZVRvSW5kZXggPCBzd2lwZXIubG9vcGVkU2xpZGVzIC0gc2xpZGVzUGVyVmlldyAvIDIgfHwgc2xpZGVUb0luZGV4ID4gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSBzd2lwZXIubG9vcGVkU2xpZGVzICsgc2xpZGVzUGVyVmlldyAvIDIpIHtcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgc2xpZGVUb0luZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXgoZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgJHtzbGlkZVNlbGVjdG9yfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cmVhbEluZGV4fVwiXWApWzBdKTtcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc2xpZGVzUGVyVmlldykge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgIHNsaWRlVG9JbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYCR7c2xpZGVTZWxlY3Rvcn1bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKVswXSk7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnNsaWRlVG8oc2xpZGVUb0luZGV4KTtcbiAgfVxufVxuXG52YXIgc2xpZGUgPSB7XG4gIHNsaWRlVG8sXG4gIHNsaWRlVG9Mb29wLFxuICBzbGlkZU5leHQsXG4gIHNsaWRlUHJldixcbiAgc2xpZGVSZXNldCxcbiAgc2xpZGVUb0Nsb3Nlc3QsXG4gIHNsaWRlVG9DbGlja2VkU2xpZGVcbn07XG5cbmZ1bmN0aW9uIGxvb3BDcmVhdGUoc2xpZGVSZWFsSW5kZXgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIXBhcmFtcy5sb29wIHx8IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gIGNvbnN0IGluaXRTbGlkZXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JywgaW5kZXgpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBjb25zdCBzbGlkZXNQZXJHcm91cCA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cCAqIChncmlkRW5hYmxlZCA/IHBhcmFtcy5ncmlkLnJvd3MgOiAxKTtcbiAgY29uc3Qgc2hvdWxkRmlsbEdyb3VwID0gc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBzbGlkZXNQZXJHcm91cCAhPT0gMDtcbiAgY29uc3Qgc2hvdWxkRmlsbEdyaWQgPSBncmlkRW5hYmxlZCAmJiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5ncmlkLnJvd3MgIT09IDA7XG4gIGNvbnN0IGFkZEJsYW5rU2xpZGVzID0gYW1vdW50T2ZTbGlkZXMgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50T2ZTbGlkZXM7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2xpZGVFbCA9IHN3aXBlci5pc0VsZW1lbnQgPyBjcmVhdGVFbGVtZW50KCdzd2lwZXItc2xpZGUnLCBbcGFyYW1zLnNsaWRlQmxhbmtDbGFzc10pIDogY3JlYXRlRWxlbWVudCgnZGl2JywgW3BhcmFtcy5zbGlkZUNsYXNzLCBwYXJhbXMuc2xpZGVCbGFua0NsYXNzXSk7XG4gICAgICBzd2lwZXIuc2xpZGVzRWwuYXBwZW5kKHNsaWRlRWwpO1xuICAgIH1cbiAgfTtcbiAgaWYgKHNob3VsZEZpbGxHcm91cCkge1xuICAgIGlmIChwYXJhbXMubG9vcEFkZEJsYW5rU2xpZGVzKSB7XG4gICAgICBjb25zdCBzbGlkZXNUb0FkZCA9IHNsaWRlc1Blckdyb3VwIC0gc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBzbGlkZXNQZXJHcm91cDtcbiAgICAgIGFkZEJsYW5rU2xpZGVzKHNsaWRlc1RvQWRkKTtcbiAgICAgIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IFRoZSBudW1iZXIgb2Ygc2xpZGVzIGlzIG5vdCBldmVuIHRvIHNsaWRlc1Blckdyb3VwLCBsb29wIG1vZGUgbWF5IG5vdCBmdW5jdGlvbiBwcm9wZXJseS4gWW91IG5lZWQgdG8gYWRkIG1vcmUgc2xpZGVzIChvciBtYWtlIGR1cGxpY2F0ZXMsIG9yIGVtcHR5IHNsaWRlcyknKTtcbiAgICB9XG4gICAgaW5pdFNsaWRlcygpO1xuICB9IGVsc2UgaWYgKHNob3VsZEZpbGxHcmlkKSB7XG4gICAgaWYgKHBhcmFtcy5sb29wQWRkQmxhbmtTbGlkZXMpIHtcbiAgICAgIGNvbnN0IHNsaWRlc1RvQWRkID0gcGFyYW1zLmdyaWQucm93cyAtIHN3aXBlci5zbGlkZXMubGVuZ3RoICUgcGFyYW1zLmdyaWQucm93cztcbiAgICAgIGFkZEJsYW5rU2xpZGVzKHNsaWRlc1RvQWRkKTtcbiAgICAgIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IFRoZSBudW1iZXIgb2Ygc2xpZGVzIGlzIG5vdCBldmVuIHRvIGdyaWQucm93cywgbG9vcCBtb2RlIG1heSBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzLCBvciBlbXB0eSBzbGlkZXMpJyk7XG4gICAgfVxuICAgIGluaXRTbGlkZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0U2xpZGVzKCk7XG4gIH1cbiAgc3dpcGVyLmxvb3BGaXgoe1xuICAgIHNsaWRlUmVhbEluZGV4LFxuICAgIGRpcmVjdGlvbjogcGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gdW5kZWZpbmVkIDogJ25leHQnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb29wRml4KF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc2xpZGVSZWFsSW5kZXgsXG4gICAgc2xpZGVUbyA9IHRydWUsXG4gICAgZGlyZWN0aW9uLFxuICAgIHNldFRyYW5zbGF0ZSxcbiAgICBhY3RpdmVTbGlkZUluZGV4LFxuICAgIGJ5Q29udHJvbGxlcixcbiAgICBieU1vdXNld2hlZWxcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMubG9vcCkgcmV0dXJuO1xuICBzd2lwZXIuZW1pdCgnYmVmb3JlTG9vcEZpeCcpO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIGFsbG93U2xpZGVQcmV2LFxuICAgIGFsbG93U2xpZGVOZXh0LFxuICAgIHNsaWRlc0VsLFxuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCB7XG4gICAgY2VudGVyZWRTbGlkZXNcbiAgfSA9IHBhcmFtcztcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICBpZiAoc2xpZGVUbykge1xuICAgICAgaWYgKCFwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgc3dpcGVyLnNuYXBJbmRleCA9PT0gMCkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBzd2lwZXIuc25hcEluZGV4IDwgcGFyYW1zLnNsaWRlc1BlclZpZXcpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCArIHN3aXBlci5zbmFwSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3dpcGVyLnNuYXBJbmRleCA9PT0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICAgIHN3aXBlci5lbWl0KCdsb29wRml4Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICBzbGlkZXNQZXJWaWV3ID0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCk7XG4gIH0gZWxzZSB7XG4gICAgc2xpZGVzUGVyVmlldyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpO1xuICAgIGlmIChjZW50ZXJlZFNsaWRlcyAmJiBzbGlkZXNQZXJWaWV3ICUgMiA9PT0gMCkge1xuICAgICAgc2xpZGVzUGVyVmlldyA9IHNsaWRlc1BlclZpZXcgKyAxO1xuICAgIH1cbiAgfVxuICBjb25zdCBzbGlkZXNQZXJHcm91cCA9IHBhcmFtcy5zbGlkZXNQZXJHcm91cEF1dG8gPyBzbGlkZXNQZXJWaWV3IDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICBsZXQgbG9vcGVkU2xpZGVzID0gc2xpZGVzUGVyR3JvdXA7XG4gIGlmIChsb29wZWRTbGlkZXMgJSBzbGlkZXNQZXJHcm91cCAhPT0gMCkge1xuICAgIGxvb3BlZFNsaWRlcyArPSBzbGlkZXNQZXJHcm91cCAtIGxvb3BlZFNsaWRlcyAlIHNsaWRlc1Blckdyb3VwO1xuICB9XG4gIGxvb3BlZFNsaWRlcyArPSBwYXJhbXMubG9vcEFkZGl0aW9uYWxTbGlkZXM7XG4gIHN3aXBlci5sb29wZWRTbGlkZXMgPSBsb29wZWRTbGlkZXM7XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG4gIGlmIChzbGlkZXMubGVuZ3RoIDwgc2xpZGVzUGVyVmlldyArIGxvb3BlZFNsaWRlcykge1xuICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZW5vdWdoIGZvciBsb29wIG1vZGUsIGl0IHdpbGwgYmUgZGlzYWJsZWQgYW5kIG5vdCBmdW5jdGlvbiBwcm9wZXJseS4gWW91IG5lZWQgdG8gYWRkIG1vcmUgc2xpZGVzIChvciBtYWtlIGR1cGxpY2F0ZXMpIG9yIGxvd2VyIHRoZSB2YWx1ZXMgb2Ygc2xpZGVzUGVyVmlldyBhbmQgc2xpZGVzUGVyR3JvdXAgcGFyYW1ldGVycycpO1xuICB9IGVsc2UgaWYgKGdyaWRFbmFibGVkICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdyb3cnKSB7XG4gICAgc2hvd1dhcm5pbmcoJ1N3aXBlciBMb29wIFdhcm5pbmc6IExvb3AgbW9kZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGdyaWQuZmlsbCA9IGByb3dgJyk7XG4gIH1cbiAgY29uc3QgcHJlcGVuZFNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgY29uc3QgYXBwZW5kU2xpZGVzSW5kZXhlcyA9IFtdO1xuICBsZXQgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gIGlmICh0eXBlb2YgYWN0aXZlU2xpZGVJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhY3RpdmVTbGlkZUluZGV4ID0gc3dpcGVyLmdldFNsaWRlSW5kZXgoc2xpZGVzLmZpbHRlcihlbCA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpKVswXSk7XG4gIH0gZWxzZSB7XG4gICAgYWN0aXZlSW5kZXggPSBhY3RpdmVTbGlkZUluZGV4O1xuICB9XG4gIGNvbnN0IGlzTmV4dCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnIHx8ICFkaXJlY3Rpb247XG4gIGNvbnN0IGlzUHJldiA9IGRpcmVjdGlvbiA9PT0gJ3ByZXYnIHx8ICFkaXJlY3Rpb247XG4gIGxldCBzbGlkZXNQcmVwZW5kZWQgPSAwO1xuICBsZXQgc2xpZGVzQXBwZW5kZWQgPSAwO1xuICBjb25zdCBjb2xzID0gZ3JpZEVuYWJsZWQgPyBNYXRoLmNlaWwoc2xpZGVzLmxlbmd0aCAvIHBhcmFtcy5ncmlkLnJvd3MpIDogc2xpZGVzLmxlbmd0aDtcbiAgY29uc3QgYWN0aXZlQ29sSW5kZXggPSBncmlkRW5hYmxlZCA/IHNsaWRlc1thY3RpdmVTbGlkZUluZGV4XS5jb2x1bW4gOiBhY3RpdmVTbGlkZUluZGV4O1xuICBjb25zdCBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCA9IGFjdGl2ZUNvbEluZGV4ICsgKGNlbnRlcmVkU2xpZGVzICYmIHR5cGVvZiBzZXRUcmFuc2xhdGUgPT09ICd1bmRlZmluZWQnID8gLXNsaWRlc1BlclZpZXcgLyAyICsgMC41IDogMCk7XG4gIC8vIHByZXBlbmQgbGFzdCBzbGlkZXMgYmVmb3JlIHN0YXJ0XG4gIGlmIChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCA8IGxvb3BlZFNsaWRlcykge1xuICAgIHNsaWRlc1ByZXBlbmRlZCA9IE1hdGgubWF4KGxvb3BlZFNsaWRlcyAtIGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0LCBzbGlkZXNQZXJHcm91cCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29wZWRTbGlkZXMgLSBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgLSBNYXRoLmZsb29yKGkgLyBjb2xzKSAqIGNvbHM7XG4gICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgY29uc3QgY29sSW5kZXhUb1ByZXBlbmQgPSBjb2xzIC0gaW5kZXggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gc2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgaWYgKHNsaWRlc1tpXS5jb2x1bW4gPT09IGNvbEluZGV4VG9QcmVwZW5kKSBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNsaWRlcy5mb3JFYWNoKChzbGlkZSwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAvLyAgIGlmIChzbGlkZS5jb2x1bW4gPT09IGNvbEluZGV4VG9QcmVwZW5kKSBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgICAgICAvLyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXBlbmRTbGlkZXNJbmRleGVzLnB1c2goY29scyAtIGluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0ICsgc2xpZGVzUGVyVmlldyA+IGNvbHMgLSBsb29wZWRTbGlkZXMpIHtcbiAgICBzbGlkZXNBcHBlbmRlZCA9IE1hdGgubWF4KGFjdGl2ZUNvbEluZGV4V2l0aFNoaWZ0IC0gKGNvbHMgLSBsb29wZWRTbGlkZXMgKiAyKSwgc2xpZGVzUGVyR3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzQXBwZW5kZWQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpIC0gTWF0aC5mbG9vcihpIC8gY29scykgKiBjb2xzO1xuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIHNsaWRlcy5mb3JFYWNoKChzbGlkZSwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChzbGlkZS5jb2x1bW4gPT09IGluZGV4KSBhcHBlbmRTbGlkZXNJbmRleGVzLnB1c2goc2xpZGVJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSB0cnVlO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gZmFsc2U7XG4gIH0pO1xuICBpZiAoaXNQcmV2KSB7XG4gICAgcHJlcGVuZFNsaWRlc0luZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gdHJ1ZTtcbiAgICAgIHNsaWRlc0VsLnByZXBlbmQoc2xpZGVzW2luZGV4XSk7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzTmV4dCkge1xuICAgIGFwcGVuZFNsaWRlc0luZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gdHJ1ZTtcbiAgICAgIHNsaWRlc0VsLmFwcGVuZChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIHNsaWRlc1tpbmRleF0uc3dpcGVyTG9vcE1vdmVET00gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICB9IGVsc2UgaWYgKGdyaWRFbmFibGVkICYmIChwcmVwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzUHJldiB8fCBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCA+IDAgJiYgaXNOZXh0KSkge1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKHNsaWRlSW5kZXgsIHNsaWRlLCBzd2lwZXIuc2xpZGVzKTtcbiAgICB9KTtcbiAgfVxuICBpZiAocGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzT2Zmc2V0KCk7XG4gIH1cbiAgaWYgKHNsaWRlVG8pIHtcbiAgICBpZiAocHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoID4gMCAmJiBpc1ByZXYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVSZWFsSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2FjdGl2ZUluZGV4XTtcbiAgICAgICAgY29uc3QgbmV3U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleCArIHNsaWRlc1ByZXBlbmRlZF07XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTbGlkZVRyYW5zbGF0ZSAtIGN1cnJlbnRTbGlkZVRyYW5zbGF0ZTtcbiAgICAgICAgaWYgKGJ5TW91c2V3aGVlbCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoc3dpcGVyLnRyYW5zbGF0ZSAtIGRpZmYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGFjdGl2ZUluZGV4ICsgTWF0aC5jZWlsKHNsaWRlc1ByZXBlbmRlZCksIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoc2V0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmY7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNldFRyYW5zbGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gZ3JpZEVuYWJsZWQgPyBwcmVwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggLyBwYXJhbXMuZ3JpZC5yb3dzIDogcHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIHNoaWZ0LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzTmV4dCkge1xuICAgICAgaWYgKHR5cGVvZiBzbGlkZVJlYWxJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdO1xuICAgICAgICBjb25zdCBuZXdTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2FjdGl2ZUluZGV4IC0gc2xpZGVzQXBwZW5kZWRdO1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3U2xpZGVUcmFuc2xhdGUgLSBjdXJyZW50U2xpZGVUcmFuc2xhdGU7XG4gICAgICAgIGlmIChieU1vdXNld2hlZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHN3aXBlci50cmFuc2xhdGUgLSBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCAtIHNsaWRlc0FwcGVuZGVkLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHNldFRyYW5zbGF0ZSkge1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGEuc3RhcnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5jdXJyZW50VHJhbnNsYXRlIC0gZGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gZ3JpZEVuYWJsZWQgPyBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCAvIHBhcmFtcy5ncmlkLnJvd3MgOiBhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aDtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4IC0gc2hpZnQsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gYWxsb3dTbGlkZVByZXY7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICBpZiAoc3dpcGVyLmNvbnRyb2xsZXIgJiYgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCAmJiAhYnlDb250cm9sbGVyKSB7XG4gICAgY29uc3QgbG9vcFBhcmFtcyA9IHtcbiAgICAgIHNsaWRlUmVhbEluZGV4LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgc2V0VHJhbnNsYXRlLFxuICAgICAgYWN0aXZlU2xpZGVJbmRleCxcbiAgICAgIGJ5Q29udHJvbGxlcjogdHJ1ZVxuICAgIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCkpIHtcbiAgICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wuZm9yRWFjaChjID0+IHtcbiAgICAgICAgaWYgKCFjLmRlc3Ryb3llZCAmJiBjLnBhcmFtcy5sb29wKSBjLmxvb3BGaXgoe1xuICAgICAgICAgIC4uLmxvb3BQYXJhbXMsXG4gICAgICAgICAgc2xpZGVUbzogYy5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPyBzbGlkZVRvIDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgaW5zdGFuY2VvZiBzd2lwZXIuY29uc3RydWN0b3IgJiYgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5sb29wRml4KHtcbiAgICAgICAgLi4ubG9vcFBhcmFtcyxcbiAgICAgICAgc2xpZGVUbzogc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPyBzbGlkZVRvIDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xufVxuXG5mdW5jdGlvbiBsb29wRGVzdHJveSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIXBhcmFtcy5sb29wIHx8IHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgY29uc3QgbmV3U2xpZGVzT3JkZXIgPSBbXTtcbiAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIHNsaWRlRWwuc3dpcGVyU2xpZGVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyBzbGlkZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSAqIDEgOiBzbGlkZUVsLnN3aXBlclNsaWRlSW5kZXg7XG4gICAgbmV3U2xpZGVzT3JkZXJbaW5kZXhdID0gc2xpZGVFbDtcbiAgfSk7XG4gIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgfSk7XG4gIG5ld1NsaWRlc09yZGVyLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgc2xpZGVzRWwuYXBwZW5kKHNsaWRlRWwpO1xuICB9KTtcbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIucmVhbEluZGV4LCAwKTtcbn1cblxudmFyIGxvb3AgPSB7XG4gIGxvb3BDcmVhdGUsXG4gIGxvb3BGaXgsXG4gIGxvb3BEZXN0cm95XG59O1xuXG5mdW5jdGlvbiBzZXRHcmFiQ3Vyc29yKG1vdmluZykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fCBzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmlzTG9ja2VkIHx8IHN3aXBlci5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBjb25zdCBlbCA9IHN3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gc3dpcGVyLmVsIDogc3dpcGVyLndyYXBwZXJFbDtcbiAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IHRydWU7XG4gIH1cbiAgZWwuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICBlbC5zdHlsZS5jdXJzb3IgPSBtb3ZpbmcgPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xuICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc2V0R3JhYkN1cnNvcigpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSB0cnVlO1xuICB9XG4gIHN3aXBlcltzd2lwZXIucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnY29udGFpbmVyJyA/ICdlbCcgOiAnd3JhcHBlckVsJ10uc3R5bGUuY3Vyc29yID0gJyc7XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGdyYWJDdXJzb3IgPSB7XG4gIHNldEdyYWJDdXJzb3IsXG4gIHVuc2V0R3JhYkN1cnNvclxufTtcblxuLy8gTW9kaWZpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDUyMDU1NC9jdXN0b20tZWxlbWVudC1nZXRyb290bm9kZS1jbG9zZXN0LWZ1bmN0aW9uLWNyb3NzaW5nLW11bHRpcGxlLXBhcmVudC1zaGFkb3dkXG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudChzZWxlY3RvciwgYmFzZSkge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZSA9IHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gX19jbG9zZXN0RnJvbShlbCkge1xuICAgIGlmICghZWwgfHwgZWwgPT09IGdldERvY3VtZW50KCkgfHwgZWwgPT09IGdldFdpbmRvdygpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoZWwuYXNzaWduZWRTbG90KSBlbCA9IGVsLmFzc2lnbmVkU2xvdDtcbiAgICBjb25zdCBmb3VuZCA9IGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIGlmICghZm91bmQgJiYgIWVsLmdldFJvb3ROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kIHx8IF9fY2xvc2VzdEZyb20oZWwuZ2V0Um9vdE5vZGUoKS5ob3N0KTtcbiAgfVxuICByZXR1cm4gX19jbG9zZXN0RnJvbShiYXNlKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBldmVudCwgc3RhcnRYKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGVkZ2VTd2lwZURldGVjdGlvbiA9IHBhcmFtcy5lZGdlU3dpcGVEZXRlY3Rpb247XG4gIGNvbnN0IGVkZ2VTd2lwZVRocmVzaG9sZCA9IHBhcmFtcy5lZGdlU3dpcGVUaHJlc2hvbGQ7XG4gIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gJiYgKHN0YXJ0WCA8PSBlZGdlU3dpcGVUaHJlc2hvbGQgfHwgc3RhcnRYID49IHdpbmRvdy5pbm5lcldpZHRoIC0gZWRnZVN3aXBlVGhyZXNob2xkKSkge1xuICAgIGlmIChlZGdlU3dpcGVEZXRlY3Rpb24gPT09ICdwcmV2ZW50Jykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgaWYgKGUudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykge1xuICAgIGlmIChkYXRhLnBvaW50ZXJJZCAhPT0gbnVsbCAmJiBkYXRhLnBvaW50ZXJJZCAhPT0gZS5wb2ludGVySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5wb2ludGVySWQgPSBlLnBvaW50ZXJJZDtcbiAgfSBlbHNlIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgZGF0YS50b3VjaElkID0gZS50YXJnZXRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIH1cbiAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgLy8gZG9uJ3QgcHJvY2VlZCB0b3VjaCBldmVudFxuICAgIHByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBlLCBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHRvdWNoZXMsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgaWYgKCFwYXJhbXMuc2ltdWxhdGVUb3VjaCAmJiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSByZXR1cm47XG4gIGlmIChzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5wcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nICYmIHBhcmFtcy5jc3NNb2RlICYmIHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgfVxuICBsZXQgdGFyZ2V0RWwgPSBlLnRhcmdldDtcbiAgaWYgKHBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ3dyYXBwZXInKSB7XG4gICAgaWYgKCFzd2lwZXIud3JhcHBlckVsLmNvbnRhaW5zKHRhcmdldEVsKSkgcmV0dXJuO1xuICB9XG4gIGlmICgnd2hpY2gnIGluIGUgJiYgZS53aGljaCA9PT0gMykgcmV0dXJuO1xuICBpZiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiA+IDApIHJldHVybjtcbiAgaWYgKGRhdGEuaXNUb3VjaGVkICYmIGRhdGEuaXNNb3ZlZCkgcmV0dXJuO1xuXG4gIC8vIGNoYW5nZSB0YXJnZXQgZWwgZm9yIHNoYWRvdyByb290IGNvbXBvbmVudFxuICBjb25zdCBzd2lwaW5nQ2xhc3NIYXNWYWx1ZSA9ICEhcGFyYW1zLm5vU3dpcGluZ0NsYXNzICYmIHBhcmFtcy5ub1N3aXBpbmdDbGFzcyAhPT0gJyc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBjb25zdCBldmVudFBhdGggPSBlLmNvbXBvc2VkUGF0aCA/IGUuY29tcG9zZWRQYXRoKCkgOiBlLnBhdGg7XG4gIGlmIChzd2lwaW5nQ2xhc3NIYXNWYWx1ZSAmJiBlLnRhcmdldCAmJiBlLnRhcmdldC5zaGFkb3dSb290ICYmIGV2ZW50UGF0aCkge1xuICAgIHRhcmdldEVsID0gZXZlbnRQYXRoWzBdO1xuICB9XG4gIGNvbnN0IG5vU3dpcGluZ1NlbGVjdG9yID0gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yID8gcGFyYW1zLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke3BhcmFtcy5ub1N3aXBpbmdDbGFzc31gO1xuICBjb25zdCBpc1RhcmdldFNoYWRvdyA9ICEhKGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QpO1xuXG4gIC8vIHVzZSBjbG9zZXN0RWxlbWVudCBmb3Igc2hhZG93IHJvb3QgZWxlbWVudCB0byBnZXQgdGhlIGFjdHVhbCBjbG9zZXN0IGZvciBuZXN0ZWQgc2hhZG93IHJvb3QgZWxlbWVudFxuICBpZiAocGFyYW1zLm5vU3dpcGluZyAmJiAoaXNUYXJnZXRTaGFkb3cgPyBjbG9zZXN0RWxlbWVudChub1N3aXBpbmdTZWxlY3RvciwgdGFyZ2V0RWwpIDogdGFyZ2V0RWwuY2xvc2VzdChub1N3aXBpbmdTZWxlY3RvcikpKSB7XG4gICAgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLnN3aXBlSGFuZGxlcikge1xuICAgIGlmICghdGFyZ2V0RWwuY2xvc2VzdChwYXJhbXMuc3dpcGVIYW5kbGVyKSkgcmV0dXJuO1xuICB9XG4gIHRvdWNoZXMuY3VycmVudFggPSBlLnBhZ2VYO1xuICB0b3VjaGVzLmN1cnJlbnRZID0gZS5wYWdlWTtcbiAgY29uc3Qgc3RhcnRYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgY29uc3Qgc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcblxuICAvLyBEbyBOT1Qgc3RhcnQgaWYgaU9TIGVkZ2Ugc3dpcGUgaXMgZGV0ZWN0ZWQuIE90aGVyd2lzZSBpT1MgYXBwIGNhbm5vdCBzd2lwZS10by1nby1iYWNrIGFueW1vcmVcblxuICBpZiAoIXByZXZlbnRFZGdlU3dpcGUoc3dpcGVyLCBlLCBzdGFydFgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgIGlzVG91Y2hlZDogdHJ1ZSxcbiAgICBpc01vdmVkOiBmYWxzZSxcbiAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiB0cnVlLFxuICAgIGlzU2Nyb2xsaW5nOiB1bmRlZmluZWQsXG4gICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZFxuICB9KTtcbiAgdG91Y2hlcy5zdGFydFggPSBzdGFydFg7XG4gIHRvdWNoZXMuc3RhcnRZID0gc3RhcnRZO1xuICBkYXRhLnRvdWNoU3RhcnRUaW1lID0gbm93KCk7XG4gIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gZmFsc2U7XG4gIGxldCBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gIGlmICh0YXJnZXRFbC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICBpZiAodGFyZ2V0RWwubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGFyZ2V0RWwpIHtcbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgfVxuICBjb25zdCBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0ICYmIHN3aXBlci5hbGxvd1RvdWNoTW92ZSAmJiBwYXJhbXMudG91Y2hTdGFydFByZXZlbnREZWZhdWx0O1xuICBpZiAoKHBhcmFtcy50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCB8fCBzaG91bGRQcmV2ZW50RGVmYXVsdCkgJiYgIXRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlICYmIHN3aXBlci5hbmltYXRpbmcgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hTdGFydCgpO1xuICB9XG4gIHN3aXBlci5lbWl0KCd0b3VjaFN0YXJ0JywgZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgdG91Y2hlcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXBhcmFtcy5zaW11bGF0ZVRvdWNoICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSByZXR1cm47XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGlmIChlLnR5cGUgPT09ICdwb2ludGVybW92ZScpIHtcbiAgICBpZiAoZGF0YS50b3VjaElkICE9PSBudWxsKSByZXR1cm47IC8vIHJldHVybiBmcm9tIHBvaW50ZXIgaWYgd2UgdXNlIHRvdWNoXG4gICAgY29uc3QgaWQgPSBlLnBvaW50ZXJJZDtcbiAgICBpZiAoaWQgIT09IGRhdGEucG9pbnRlcklkKSByZXR1cm47XG4gIH1cbiAgbGV0IHRhcmdldFRvdWNoO1xuICBpZiAoZS50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgIHRhcmdldFRvdWNoID0gWy4uLmUuY2hhbmdlZFRvdWNoZXNdLmZpbHRlcih0ID0+IHQuaWRlbnRpZmllciA9PT0gZGF0YS50b3VjaElkKVswXTtcbiAgICBpZiAoIXRhcmdldFRvdWNoIHx8IHRhcmdldFRvdWNoLmlkZW50aWZpZXIgIT09IGRhdGEudG91Y2hJZCkgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFRvdWNoID0gZTtcbiAgfVxuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuc3RhcnRNb3ZpbmcgJiYgZGF0YS5pc1Njcm9sbGluZykge1xuICAgICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZU9wcG9zaXRlJywgZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYWdlWCA9IHRhcmdldFRvdWNoLnBhZ2VYO1xuICBjb25zdCBwYWdlWSA9IHRhcmdldFRvdWNoLnBhZ2VZO1xuICBpZiAoZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikge1xuICAgIHRvdWNoZXMuc3RhcnRYID0gcGFnZVg7XG4gICAgdG91Y2hlcy5zdGFydFkgPSBwYWdlWTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFzd2lwZXIuYWxsb3dUb3VjaE1vdmUpIHtcbiAgICBpZiAoIWUudGFyZ2V0Lm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICAgIHN3aXBlci5hbGxvd0NsaWNrID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkYXRhLmlzVG91Y2hlZCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0b3VjaGVzLCB7XG4gICAgICAgIHN0YXJ0WDogcGFnZVgsXG4gICAgICAgIHN0YXJ0WTogcGFnZVksXG4gICAgICAgIGN1cnJlbnRYOiBwYWdlWCxcbiAgICAgICAgY3VycmVudFk6IHBhZ2VZXG4gICAgICB9KTtcbiAgICAgIGRhdGEudG91Y2hTdGFydFRpbWUgPSBub3coKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcyAmJiAhcGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgICAgLy8gVmVydGljYWxcbiAgICAgIGlmIChwYWdlWSA8IHRvdWNoZXMuc3RhcnRZICYmIHN3aXBlci50cmFuc2xhdGUgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIHx8IHBhZ2VZID4gdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA+PSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhZ2VYIDwgdG91Y2hlcy5zdGFydFggJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVggPiB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBlLnRhcmdldC5tYXRjaGVzKGRhdGEuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmUnLCBlKTtcbiAgfVxuICB0b3VjaGVzLnByZXZpb3VzWCA9IHRvdWNoZXMuY3VycmVudFg7XG4gIHRvdWNoZXMucHJldmlvdXNZID0gdG91Y2hlcy5jdXJyZW50WTtcbiAgdG91Y2hlcy5jdXJyZW50WCA9IHBhZ2VYO1xuICB0b3VjaGVzLmN1cnJlbnRZID0gcGFnZVk7XG4gIGNvbnN0IGRpZmZYID0gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYO1xuICBjb25zdCBkaWZmWSA9IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgaWYgKHN3aXBlci5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydChkaWZmWCAqKiAyICsgZGlmZlkgKiogMikgPCBzd2lwZXIucGFyYW1zLnRocmVzaG9sZCkgcmV0dXJuO1xuICBpZiAodHlwZW9mIGRhdGEuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHRvdWNoQW5nbGU7XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiB0b3VjaGVzLmN1cnJlbnRZID09PSB0b3VjaGVzLnN0YXJ0WSB8fCBzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIHRvdWNoZXMuY3VycmVudFggPT09IHRvdWNoZXMuc3RhcnRYKSB7XG4gICAgICBkYXRhLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKGRpZmZYICogZGlmZlggKyBkaWZmWSAqIGRpZmZZID49IDI1KSB7XG4gICAgICAgIHRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKE1hdGguYWJzKGRpZmZZKSwgTWF0aC5hYnMoZGlmZlgpKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaEFuZ2xlID4gcGFyYW1zLnRvdWNoQW5nbGUgOiA5MCAtIHRvdWNoQW5nbGUgPiBwYXJhbXMudG91Y2hBbmdsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcpIHtcbiAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEuc3RhcnRNb3ZpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHRvdWNoZXMuY3VycmVudFggIT09IHRvdWNoZXMuc3RhcnRYIHx8IHRvdWNoZXMuY3VycmVudFkgIT09IHRvdWNoZXMuc3RhcnRZKSB7XG4gICAgICBkYXRhLnN0YXJ0TW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEuaXNTY3JvbGxpbmcgfHwgZS50eXBlID09PSAndG91Y2htb3ZlJyAmJiBkYXRhLnByZXZlbnRUb3VjaE1vdmVGcm9tUG9pbnRlck1vdmUpIHtcbiAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRhdGEuc3RhcnRNb3ZpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgaWYgKCFwYXJhbXMuY3NzTW9kZSAmJiBlLmNhbmNlbGFibGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKHBhcmFtcy50b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24gJiYgIXBhcmFtcy5uZXN0ZWQpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIGxldCBkaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZGlmZlggOiBkaWZmWTtcbiAgbGV0IHRvdWNoZXNEaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMucHJldmlvdXNYIDogdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMucHJldmlvdXNZO1xuICBpZiAocGFyYW1zLm9uZVdheU1vdmVtZW50KSB7XG4gICAgZGlmZiA9IE1hdGguYWJzKGRpZmYpICogKHJ0bCA/IDEgOiAtMSk7XG4gICAgdG91Y2hlc0RpZmYgPSBNYXRoLmFicyh0b3VjaGVzRGlmZikgKiAocnRsID8gMSA6IC0xKTtcbiAgfVxuICB0b3VjaGVzLmRpZmYgPSBkaWZmO1xuICBkaWZmICo9IHBhcmFtcy50b3VjaFJhdGlvO1xuICBpZiAocnRsKSB7XG4gICAgZGlmZiA9IC1kaWZmO1xuICAgIHRvdWNoZXNEaWZmID0gLXRvdWNoZXNEaWZmO1xuICB9XG4gIGNvbnN0IHByZXZUb3VjaGVzRGlyZWN0aW9uID0gc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb247XG4gIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9IGRpZmYgPiAwID8gJ3ByZXYnIDogJ25leHQnO1xuICBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbiA9IHRvdWNoZXNEaWZmID4gMCA/ICdwcmV2JyA6ICduZXh0JztcbiAgY29uc3QgaXNMb29wID0gc3dpcGVyLnBhcmFtcy5sb29wICYmICFwYXJhbXMuY3NzTW9kZTtcbiAgY29uc3QgYWxsb3dMb29wRml4ID0gc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBzd2lwZXIuYWxsb3dTbGlkZU5leHQgfHwgc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gPT09ICdwcmV2JyAmJiBzd2lwZXIuYWxsb3dTbGlkZVByZXY7XG4gIGlmICghZGF0YS5pc01vdmVkKSB7XG4gICAgaWYgKGlzTG9vcCAmJiBhbGxvd0xvb3BGaXgpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KHtcbiAgICAgICAgZGlyZWN0aW9uOiBzd2lwZXIuc3dpcGVEaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLmdldFRyYW5zbGF0ZSgpO1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICBjb25zdCBldnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KCd0cmFuc2l0aW9uZW5kJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBieVN3aXBlclRvdWNoTW92ZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cbiAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSBmYWxzZTtcbiAgICAvLyBHcmFiIEN1cnNvclxuICAgIGlmIChwYXJhbXMuZ3JhYkN1cnNvciAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKHRydWUpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnc2xpZGVyRmlyc3RNb3ZlJywgZSk7XG4gIH1cbiAgbGV0IGxvb3BGaXhlZDtcbiAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChkYXRhLmlzTW92ZWQgJiYgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgJiYgcHJldlRvdWNoZXNEaXJlY3Rpb24gIT09IHN3aXBlci50b3VjaGVzRGlyZWN0aW9uICYmIGlzTG9vcCAmJiBhbGxvd0xvb3BGaXggJiYgTWF0aC5hYnMoZGlmZikgPj0gMSkge1xuICAgIE9iamVjdC5hc3NpZ24odG91Y2hlcywge1xuICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgIHN0YXJ0WTogcGFnZVksXG4gICAgICBjdXJyZW50WDogcGFnZVgsXG4gICAgICBjdXJyZW50WTogcGFnZVksXG4gICAgICBzdGFydFRyYW5zbGF0ZTogZGF0YS5jdXJyZW50VHJhbnNsYXRlXG4gICAgfSk7XG4gICAgZGF0YS5sb29wU3dhcFJlc2V0ID0gdHJ1ZTtcbiAgICBkYXRhLnN0YXJ0VHJhbnNsYXRlID0gZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICAgIHJldHVybjtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2xpZGVyTW92ZScsIGUpO1xuICBkYXRhLmlzTW92ZWQgPSB0cnVlO1xuICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkaWZmICsgZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgbGV0IGRpc2FibGVQYXJlbnRTd2lwZXIgPSB0cnVlO1xuICBsZXQgcmVzaXN0YW5jZVJhdGlvID0gcGFyYW1zLnJlc2lzdGFuY2VSYXRpbztcbiAgaWYgKHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgcmVzaXN0YW5jZVJhdGlvID0gMDtcbiAgfVxuICBpZiAoZGlmZiA+IDApIHtcbiAgICBpZiAoaXNMb29wICYmIGFsbG93TG9vcEZpeCAmJiAhbG9vcEZpeGVkICYmIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWluVHJhbnNsYXRlKCkgLSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleCArIDFdIDogc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICBkaXJlY3Rpb246ICdwcmV2JyxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiB0cnVlLFxuICAgICAgICBhY3RpdmVTbGlkZUluZGV4OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IGZhbHNlO1xuICAgICAgaWYgKHBhcmFtcy5yZXNpc3RhbmNlKSB7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIDEgKyAoLXN3aXBlci5taW5UcmFuc2xhdGUoKSArIGRhdGEuc3RhcnRUcmFuc2xhdGUgKyBkaWZmKSAqKiByZXNpc3RhbmNlUmF0aW87XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgaWYgKGlzTG9vcCAmJiBhbGxvd0xvb3BGaXggJiYgIWxvb3BGaXhlZCAmJiBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCAocGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgc3dpcGVyLnNsaWRlc1NpemVzR3JpZFtzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkLmxlbmd0aCAtIDFdIDogc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICBkaXJlY3Rpb246ICduZXh0JyxcbiAgICAgICAgc2V0VHJhbnNsYXRlOiB0cnVlLFxuICAgICAgICBhY3RpdmVTbGlkZUluZGV4OiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBNYXRoLmNlaWwocGFyc2VGbG9hdChwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jdXJyZW50VHJhbnNsYXRlIDwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSB7XG4gICAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XG4gICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpICsgMSAtIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBkYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZikgKiogcmVzaXN0YW5jZVJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGlzYWJsZVBhcmVudFN3aXBlcikge1xuICAgIGUucHJldmVudGVkQnlOZXN0ZWRTd2lwZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gRGlyZWN0aW9ucyBsb2Nrc1xuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2JyAmJiBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPiBkYXRhLnN0YXJ0VHJhbnNsYXRlKSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlUHJldiAmJiAhc3dpcGVyLmFsbG93U2xpZGVOZXh0KSB7XG4gICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgfVxuXG4gIC8vIFRocmVzaG9sZFxuICBpZiAocGFyYW1zLnRocmVzaG9sZCA+IDApIHtcbiAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiBwYXJhbXMudGhyZXNob2xkIHx8IGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlKSB7XG4gICAgICBpZiAoIWRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlKSB7XG4gICAgICAgIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgdG91Y2hlcy5zdGFydFggPSB0b3VjaGVzLmN1cnJlbnRYO1xuICAgICAgICB0b3VjaGVzLnN0YXJ0WSA9IHRvdWNoZXMuY3VycmVudFk7XG4gICAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICAgIHRvdWNoZXMuZGlmZiA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHRvdWNoZXMuY3VycmVudFggLSB0b3VjaGVzLnN0YXJ0WCA6IHRvdWNoZXMuY3VycmVudFkgLSB0b3VjaGVzLnN0YXJ0WTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhcmFtcy5mb2xsb3dGaW5nZXIgfHwgcGFyYW1zLmNzc01vZGUpIHJldHVybjtcblxuICAvLyBVcGRhdGUgYWN0aXZlIGluZGV4IGluIGZyZWUgbW9kZVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSB8fCBwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiBzd2lwZXIuZnJlZU1vZGUpIHtcbiAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaE1vdmUoKTtcbiAgfVxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG4gIC8vIFVwZGF0ZSB0cmFuc2xhdGVcbiAgc3dpcGVyLnNldFRyYW5zbGF0ZShkYXRhLmN1cnJlbnRUcmFuc2xhdGUpO1xufVxuXG5mdW5jdGlvbiBvblRvdWNoRW5kKGV2ZW50KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICBsZXQgZSA9IGV2ZW50O1xuICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICBsZXQgdGFyZ2V0VG91Y2g7XG4gIGNvbnN0IGlzVG91Y2hFdmVudCA9IGUudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBlLnR5cGUgPT09ICd0b3VjaGNhbmNlbCc7XG4gIGlmICghaXNUb3VjaEV2ZW50KSB7XG4gICAgaWYgKGRhdGEudG91Y2hJZCAhPT0gbnVsbCkgcmV0dXJuOyAvLyByZXR1cm4gZnJvbSBwb2ludGVyIGlmIHdlIHVzZSB0b3VjaFxuICAgIGlmIChlLnBvaW50ZXJJZCAhPT0gZGF0YS5wb2ludGVySWQpIHJldHVybjtcbiAgICB0YXJnZXRUb3VjaCA9IGU7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0VG91Y2ggPSBbLi4uZS5jaGFuZ2VkVG91Y2hlc10uZmlsdGVyKHQgPT4gdC5pZGVudGlmaWVyID09PSBkYXRhLnRvdWNoSWQpWzBdO1xuICAgIGlmICghdGFyZ2V0VG91Y2ggfHwgdGFyZ2V0VG91Y2guaWRlbnRpZmllciAhPT0gZGF0YS50b3VjaElkKSByZXR1cm47XG4gIH1cbiAgaWYgKFsncG9pbnRlcmNhbmNlbCcsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJsZWF2ZScsICdjb250ZXh0bWVudSddLmluY2x1ZGVzKGUudHlwZSkpIHtcbiAgICBjb25zdCBwcm9jZWVkID0gWydwb2ludGVyY2FuY2VsJywgJ2NvbnRleHRtZW51J10uaW5jbHVkZXMoZS50eXBlKSAmJiAoc3dpcGVyLmJyb3dzZXIuaXNTYWZhcmkgfHwgc3dpcGVyLmJyb3dzZXIuaXNXZWJWaWV3KTtcbiAgICBpZiAoIXByb2NlZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGF0YS5wb2ludGVySWQgPSBudWxsO1xuICBkYXRhLnRvdWNoSWQgPSBudWxsO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHRvdWNoZXMsXG4gICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgc2xpZGVzR3JpZCxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXBhcmFtcy5zaW11bGF0ZVRvdWNoICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHJldHVybjtcbiAgaWYgKGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaEVuZCcsIGUpO1xuICB9XG4gIGRhdGEuYWxsb3dUb3VjaENhbGxiYWNrcyA9IGZhbHNlO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkKSB7XG4gICAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBwYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICAgIH1cbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUmV0dXJuIEdyYWIgQ3Vyc29yXG4gIGlmIChwYXJhbXMuZ3JhYkN1cnNvciAmJiBkYXRhLmlzTW92ZWQgJiYgZGF0YS5pc1RvdWNoZWQgJiYgKHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9PT0gdHJ1ZSB8fCBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPT09IHRydWUpKSB7XG4gICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoZmFsc2UpO1xuICB9XG5cbiAgLy8gVGltZSBkaWZmXG4gIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICBjb25zdCB0aW1lRGlmZiA9IHRvdWNoRW5kVGltZSAtIGRhdGEudG91Y2hTdGFydFRpbWU7XG5cbiAgLy8gVGFwLCBkb3VibGVUYXAsIENsaWNrXG4gIGlmIChzd2lwZXIuYWxsb3dDbGljaykge1xuICAgIGNvbnN0IHBhdGhUcmVlID0gZS5wYXRoIHx8IGUuY29tcG9zZWRQYXRoICYmIGUuY29tcG9zZWRQYXRoKCk7XG4gICAgc3dpcGVyLnVwZGF0ZUNsaWNrZWRTbGlkZShwYXRoVHJlZSAmJiBwYXRoVHJlZVswXSB8fCBlLnRhcmdldCwgcGF0aFRyZWUpO1xuICAgIHN3aXBlci5lbWl0KCd0YXAgY2xpY2snLCBlKTtcbiAgICBpZiAodGltZURpZmYgPCAzMDAgJiYgdG91Y2hFbmRUaW1lIC0gZGF0YS5sYXN0Q2xpY2tUaW1lIDwgMzAwKSB7XG4gICAgICBzd2lwZXIuZW1pdCgnZG91YmxlVGFwIGRvdWJsZUNsaWNrJywgZSk7XG4gICAgfVxuICB9XG4gIGRhdGEubGFzdENsaWNrVGltZSA9IG5vdygpO1xuICBuZXh0VGljaygoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIuZGVzdHJveWVkKSBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XG4gIH0pO1xuICBpZiAoIWRhdGEuaXNUb3VjaGVkIHx8ICFkYXRhLmlzTW92ZWQgfHwgIXN3aXBlci5zd2lwZURpcmVjdGlvbiB8fCB0b3VjaGVzLmRpZmYgPT09IDAgJiYgIWRhdGEubG9vcFN3YXBSZXNldCB8fCBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPT09IGRhdGEuc3RhcnRUcmFuc2xhdGUgJiYgIWRhdGEubG9vcFN3YXBSZXNldCkge1xuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgZGF0YS5pc01vdmVkID0gZmFsc2U7XG4gICAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgZGF0YS5zdGFydE1vdmluZyA9IGZhbHNlO1xuICBsZXQgY3VycmVudFBvcztcbiAgaWYgKHBhcmFtcy5mb2xsb3dGaW5nZXIpIHtcbiAgICBjdXJyZW50UG9zID0gcnRsID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRQb3MgPSAtZGF0YS5jdXJyZW50VHJhbnNsYXRlO1xuICB9XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkKSB7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgY3VycmVudFBvc1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpbmQgY3VycmVudCBzbGlkZVxuICBjb25zdCBzd2lwZVRvTGFzdCA9IGN1cnJlbnRQb3MgPj0gLXN3aXBlci5tYXhUcmFuc2xhdGUoKSAmJiAhc3dpcGVyLnBhcmFtcy5sb29wO1xuICBsZXQgc3RvcEluZGV4ID0gMDtcbiAgbGV0IGdyb3VwU2l6ZSA9IHN3aXBlci5zbGlkZXNTaXplc0dyaWRbMF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gaSA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwKSB7XG4gICAgY29uc3QgaW5jcmVtZW50ID0gaSA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICBpZiAodHlwZW9mIHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoc3dpcGVUb0xhc3QgfHwgY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldICYmIGN1cnJlbnRQb3MgPCBzbGlkZXNHcmlkW2kgKyBpbmNyZW1lbnRdKSB7XG4gICAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICAgIGdyb3VwU2l6ZSA9IHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0gLSBzbGlkZXNHcmlkW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3dpcGVUb0xhc3QgfHwgY3VycmVudFBvcyA+PSBzbGlkZXNHcmlkW2ldKSB7XG4gICAgICBzdG9wSW5kZXggPSBpO1xuICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdIC0gc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDJdO1xuICAgIH1cbiAgfVxuICBsZXQgcmV3aW5kRmlyc3RJbmRleCA9IG51bGw7XG4gIGxldCByZXdpbmRMYXN0SW5kZXggPSBudWxsO1xuICBpZiAocGFyYW1zLnJld2luZCkge1xuICAgIGlmIChzd2lwZXIuaXNCZWdpbm5pbmcpIHtcbiAgICAgIHJld2luZExhc3RJbmRleCA9IHBhcmFtcy52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIC0gMSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgcmV3aW5kRmlyc3RJbmRleCA9IDA7XG4gICAgfVxuICB9XG4gIC8vIEZpbmQgY3VycmVudCBzbGlkZSBzaXplXG4gIGNvbnN0IHJhdGlvID0gKGN1cnJlbnRQb3MgLSBzbGlkZXNHcmlkW3N0b3BJbmRleF0pIC8gZ3JvdXBTaXplO1xuICBjb25zdCBpbmNyZW1lbnQgPSBzdG9wSW5kZXggPCBwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gIGlmICh0aW1lRGlmZiA+IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcbiAgICAvLyBMb25nIHRvdWNoZXNcbiAgICBpZiAoIXBhcmFtcy5sb25nU3dpcGVzKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAnbmV4dCcpIHtcbiAgICAgIGlmIChyYXRpbyA+PSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSBzd2lwZXIuc2xpZGVUbyhwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0VuZCA/IHJld2luZEZpcnN0SW5kZXggOiBzdG9wSW5kZXggKyBpbmNyZW1lbnQpO2Vsc2Ugc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICBpZiAocmF0aW8gPiAxIC0gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXggKyBpbmNyZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChyZXdpbmRMYXN0SW5kZXggIT09IG51bGwgJiYgcmF0aW8gPCAwICYmIE1hdGguYWJzKHJhdGlvKSA+IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNob3J0IHN3aXBlc1xuICAgIGlmICghcGFyYW1zLnNob3J0U3dpcGVzKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc05hdkJ1dHRvblRhcmdldCA9IHN3aXBlci5uYXZpZ2F0aW9uICYmIChlLnRhcmdldCA9PT0gc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsIHx8IGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwpO1xuICAgIGlmICghaXNOYXZCdXR0b25UYXJnZXQpIHtcbiAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhyZXdpbmRGaXJzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kRmlyc3RJbmRleCA6IHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8ocmV3aW5kTGFzdEluZGV4ICE9PSBudWxsID8gcmV3aW5kTGFzdEluZGV4IDogc3RvcEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVzaXplKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGVsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChlbCAmJiBlbC5vZmZzZXRXaWR0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIC8vIEJyZWFrcG9pbnRzXG4gIGlmIChwYXJhbXMuYnJlYWtwb2ludHMpIHtcbiAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICB9XG5cbiAgLy8gU2F2ZSBsb2Nrc1xuICBjb25zdCB7XG4gICAgYWxsb3dTbGlkZU5leHQsXG4gICAgYWxsb3dTbGlkZVByZXYsXG4gICAgc25hcEdyaWRcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG5cbiAgLy8gRGlzYWJsZSBsb2NrcyBvbiByZXNpemVcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gdHJ1ZTtcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gdHJ1ZTtcbiAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBjb25zdCBpc1ZpcnR1YWxMb29wID0gaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wO1xuICBpZiAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiAhaXNWaXJ0dWFsTG9vcCkge1xuICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgZmFsc2UsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3AgJiYgIWlzVmlydHVhbCkge1xuICAgICAgc3dpcGVyLnNsaWRlVG9Mb29wKHN3aXBlci5yZWFsSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgIGNsZWFyVGltZW91dChzd2lwZXIuYXV0b3BsYXkucmVzaXplVGltZW91dCk7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChzd2lwZXIuYXV0b3BsYXkgJiYgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgJiYgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCkge1xuICAgICAgICBzd2lwZXIuYXV0b3BsYXkucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgfVxuICAvLyBSZXR1cm4gbG9ja3MgYWZ0ZXIgcmVzaXplXG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IGFsbG93U2xpZGVQcmV2O1xuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbiAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXN3aXBlci5hbGxvd0NsaWNrKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrcykgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbiAmJiBzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICB3cmFwcGVyRWwsXG4gICAgcnRsVHJhbnNsYXRlLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gIHN3aXBlci5wcmV2aW91c1RyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG4gIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICBzd2lwZXIudHJhbnNsYXRlID0gLXdyYXBwZXJFbC5zY3JvbGxMZWZ0O1xuICB9IGVsc2Uge1xuICAgIHN3aXBlci50cmFuc2xhdGUgPSAtd3JhcHBlckVsLnNjcm9sbFRvcDtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgaWYgKHN3aXBlci50cmFuc2xhdGUgPT09IDApIHN3aXBlci50cmFuc2xhdGUgPSAwO1xuICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgbGV0IG5ld1Byb2dyZXNzO1xuICBjb25zdCB0cmFuc2xhdGVzRGlmZiA9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgaWYgKHRyYW5zbGF0ZXNEaWZmID09PSAwKSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAwO1xuICB9IGVsc2Uge1xuICAgIG5ld1Byb2dyZXNzID0gKHN3aXBlci50cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gIH1cbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBzd2lwZXIucHJvZ3Jlc3MpIHtcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocnRsVHJhbnNsYXRlID8gLXN3aXBlci50cmFuc2xhdGUgOiBzd2lwZXIudHJhbnNsYXRlKTtcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNsYXRlJywgc3dpcGVyLnRyYW5zbGF0ZSwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBvbkxvYWQoZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGUudGFyZ2V0KTtcbiAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSB8fCBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgIT09ICdhdXRvJyAmJiAhc3dpcGVyLnBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXBlci51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gb25Eb2N1bWVudFRvdWNoU3RhcnQoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmIChzd2lwZXIuZG9jdW1lbnRUb3VjaEhhbmRsZXJQcm9jZWVkZWQpIHJldHVybjtcbiAgc3dpcGVyLmRvY3VtZW50VG91Y2hIYW5kbGVyUHJvY2VlZGVkID0gdHJ1ZTtcbiAgaWYgKHN3aXBlci5wYXJhbXMudG91Y2hSZWxlYXNlT25FZGdlcykge1xuICAgIHN3aXBlci5lbC5zdHlsZS50b3VjaEFjdGlvbiA9ICdhdXRvJztcbiAgfVxufVxuXG5jb25zdCBldmVudHMgPSAoc3dpcGVyLCBtZXRob2QpID0+IHtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGVsLFxuICAgIHdyYXBwZXJFbCxcbiAgICBkZXZpY2VcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgY2FwdHVyZSA9ICEhcGFyYW1zLm5lc3RlZDtcbiAgY29uc3QgZG9tTWV0aG9kID0gbWV0aG9kID09PSAnb24nID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICBjb25zdCBzd2lwZXJNZXRob2QgPSBtZXRob2Q7XG4gIGlmICghZWwgfHwgdHlwZW9mIGVsID09PSAnc3RyaW5nJykgcmV0dXJuO1xuXG4gIC8vIFRvdWNoIEV2ZW50c1xuICBkb2N1bWVudFtkb21NZXRob2RdKCd0b3VjaHN0YXJ0Jywgc3dpcGVyLm9uRG9jdW1lbnRUb3VjaFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgY2FwdHVyZVxuICB9KTtcbiAgZWxbZG9tTWV0aG9kXSgndG91Y2hzdGFydCcsIHN3aXBlci5vblRvdWNoU3RhcnQsIHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9KTtcbiAgZWxbZG9tTWV0aG9kXSgncG9pbnRlcmRvd24nLCBzd2lwZXIub25Ub3VjaFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3RvdWNobW92ZScsIHN3aXBlci5vblRvdWNoTW92ZSwge1xuICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgIGNhcHR1cmVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJtb3ZlJywgc3dpcGVyLm9uVG91Y2hNb3ZlLCB7XG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgY2FwdHVyZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2hlbmQnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJ1cCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgncG9pbnRlcmNhbmNlbCcsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2hjYW5jZWwnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJvdXQnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJsZWF2ZScsIHN3aXBlci5vblRvdWNoRW5kLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgnY29udGV4dG1lbnUnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG5cbiAgLy8gUHJldmVudCBMaW5rcyBDbGlja3NcbiAgaWYgKHBhcmFtcy5wcmV2ZW50Q2xpY2tzIHx8IHBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pIHtcbiAgICBlbFtkb21NZXRob2RdKCdjbGljaycsIHN3aXBlci5vbkNsaWNrLCB0cnVlKTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICB3cmFwcGVyRWxbZG9tTWV0aG9kXSgnc2Nyb2xsJywgc3dpcGVyLm9uU2Nyb2xsKTtcbiAgfVxuXG4gIC8vIFJlc2l6ZSBoYW5kbGVyXG4gIGlmIChwYXJhbXMudXBkYXRlT25XaW5kb3dSZXNpemUpIHtcbiAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXShkZXZpY2UuaW9zIHx8IGRldmljZS5hbmRyb2lkID8gJ3Jlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZSBvYnNlcnZlclVwZGF0ZScgOiAncmVzaXplIG9ic2VydmVyVXBkYXRlJywgb25SZXNpemUsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN3aXBlcltzd2lwZXJNZXRob2RdKCdvYnNlcnZlclVwZGF0ZScsIG9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEltYWdlcyBsb2FkZXJcbiAgZWxbZG9tTWV0aG9kXSgnbG9hZCcsIHN3aXBlci5vbkxvYWQsIHtcbiAgICBjYXB0dXJlOiB0cnVlXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBzd2lwZXIub25Ub3VjaFN0YXJ0ID0gb25Ub3VjaFN0YXJ0LmJpbmQoc3dpcGVyKTtcbiAgc3dpcGVyLm9uVG91Y2hNb3ZlID0gb25Ub3VjaE1vdmUuYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Ub3VjaEVuZCA9IG9uVG91Y2hFbmQuYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Eb2N1bWVudFRvdWNoU3RhcnQgPSBvbkRvY3VtZW50VG91Y2hTdGFydC5iaW5kKHN3aXBlcik7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIHN3aXBlci5vblNjcm9sbCA9IG9uU2Nyb2xsLmJpbmQoc3dpcGVyKTtcbiAgfVxuICBzd2lwZXIub25DbGljayA9IG9uQ2xpY2suYmluZChzd2lwZXIpO1xuICBzd2lwZXIub25Mb2FkID0gb25Mb2FkLmJpbmQoc3dpcGVyKTtcbiAgZXZlbnRzKHN3aXBlciwgJ29uJyk7XG59XG5mdW5jdGlvbiBkZXRhY2hFdmVudHMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGV2ZW50cyhzd2lwZXIsICdvZmYnKTtcbn1cbnZhciBldmVudHMkMSA9IHtcbiAgYXR0YWNoRXZlbnRzLFxuICBkZXRhY2hFdmVudHNcbn07XG5cbmNvbnN0IGlzR3JpZEVuYWJsZWQgPSAoc3dpcGVyLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xufTtcbmZ1bmN0aW9uIHNldEJyZWFrcG9pbnQoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICByZWFsSW5kZXgsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgcGFyYW1zLFxuICAgIGVsXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGJyZWFrcG9pbnRzID0gcGFyYW1zLmJyZWFrcG9pbnRzO1xuICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJyZWFrcG9pbnRzICYmIE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAvLyBHZXQgYnJlYWtwb2ludCBmb3Igd2luZG93IHdpZHRoIGFuZCB1cGRhdGUgcGFyYW1ldGVyc1xuICBjb25zdCBicmVha3BvaW50ID0gc3dpcGVyLmdldEJyZWFrcG9pbnQoYnJlYWtwb2ludHMsIHN3aXBlci5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBzd2lwZXIuZWwpO1xuICBpZiAoIWJyZWFrcG9pbnQgfHwgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID09PSBicmVha3BvaW50KSByZXR1cm47XG4gIGNvbnN0IGJyZWFrcG9pbnRPbmx5UGFyYW1zID0gYnJlYWtwb2ludCBpbiBicmVha3BvaW50cyA/IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBicmVha3BvaW50UGFyYW1zID0gYnJlYWtwb2ludE9ubHlQYXJhbXMgfHwgc3dpcGVyLm9yaWdpbmFsUGFyYW1zO1xuICBjb25zdCB3YXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBwYXJhbXMpO1xuICBjb25zdCBpc011bHRpUm93ID0gaXNHcmlkRW5hYmxlZChzd2lwZXIsIGJyZWFrcG9pbnRQYXJhbXMpO1xuICBjb25zdCB3YXNHcmFiQ3Vyc29yID0gc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yO1xuICBjb25zdCBpc0dyYWJDdXJzb3IgPSBicmVha3BvaW50UGFyYW1zLmdyYWJDdXJzb3I7XG4gIGNvbnN0IHdhc0VuYWJsZWQgPSBwYXJhbXMuZW5hYmxlZDtcbiAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCwgYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbiAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZGApO1xuICAgIGlmIChicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCAmJiBicmVha3BvaW50UGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicgfHwgIWJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQtY29sdW1uYCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICB9XG4gIGlmICh3YXNHcmFiQ3Vyc29yICYmICFpc0dyYWJDdXJzb3IpIHtcbiAgICBzd2lwZXIudW5zZXRHcmFiQ3Vyc29yKCk7XG4gIH0gZWxzZSBpZiAoIXdhc0dyYWJDdXJzb3IgJiYgaXNHcmFiQ3Vyc29yKSB7XG4gICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgfVxuXG4gIC8vIFRvZ2dsZSBuYXZpZ2F0aW9uLCBwYWdpbmF0aW9uLCBzY3JvbGxiYXJcbiAgWyduYXZpZ2F0aW9uJywgJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgICBpZiAodHlwZW9mIGJyZWFrcG9pbnRQYXJhbXNbcHJvcF0gPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgY29uc3Qgd2FzTW9kdWxlRW5hYmxlZCA9IHBhcmFtc1twcm9wXSAmJiBwYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICBjb25zdCBpc01vZHVsZUVuYWJsZWQgPSBicmVha3BvaW50UGFyYW1zW3Byb3BdICYmIGJyZWFrcG9pbnRQYXJhbXNbcHJvcF0uZW5hYmxlZDtcbiAgICBpZiAod2FzTW9kdWxlRW5hYmxlZCAmJiAhaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICBzd2lwZXJbcHJvcF0uZGlzYWJsZSgpO1xuICAgIH1cbiAgICBpZiAoIXdhc01vZHVsZUVuYWJsZWQgJiYgaXNNb2R1bGVFbmFibGVkKSB7XG4gICAgICBzd2lwZXJbcHJvcF0uZW5hYmxlKCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZGlyZWN0aW9uQ2hhbmdlZCA9IGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICYmIGJyZWFrcG9pbnRQYXJhbXMuZGlyZWN0aW9uICE9PSBwYXJhbXMuZGlyZWN0aW9uO1xuICBjb25zdCBuZWVkc1JlTG9vcCA9IHBhcmFtcy5sb29wICYmIChicmVha3BvaW50UGFyYW1zLnNsaWRlc1BlclZpZXcgIT09IHBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IGRpcmVjdGlvbkNoYW5nZWQpO1xuICBjb25zdCB3YXNMb29wID0gcGFyYW1zLmxvb3A7XG4gIGlmIChkaXJlY3Rpb25DaGFuZ2VkICYmIGluaXRpYWxpemVkKSB7XG4gICAgc3dpcGVyLmNoYW5nZURpcmVjdGlvbigpO1xuICB9XG4gIGV4dGVuZChzd2lwZXIucGFyYW1zLCBicmVha3BvaW50UGFyYW1zKTtcbiAgY29uc3QgaXNFbmFibGVkID0gc3dpcGVyLnBhcmFtcy5lbmFibGVkO1xuICBjb25zdCBoYXNMb29wID0gc3dpcGVyLnBhcmFtcy5sb29wO1xuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIGFsbG93VG91Y2hNb3ZlOiBzd2lwZXIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxuICAgIGFsbG93U2xpZGVOZXh0OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxuICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2XG4gIH0pO1xuICBpZiAod2FzRW5hYmxlZCAmJiAhaXNFbmFibGVkKSB7XG4gICAgc3dpcGVyLmRpc2FibGUoKTtcbiAgfSBlbHNlIGlmICghd2FzRW5hYmxlZCAmJiBpc0VuYWJsZWQpIHtcbiAgICBzd2lwZXIuZW5hYmxlKCk7XG4gIH1cbiAgc3dpcGVyLmN1cnJlbnRCcmVha3BvaW50ID0gYnJlYWtwb2ludDtcbiAgc3dpcGVyLmVtaXQoJ19iZWZvcmVCcmVha3BvaW50JywgYnJlYWtwb2ludFBhcmFtcyk7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIGlmIChuZWVkc1JlTG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgICBzd2lwZXIubG9vcENyZWF0ZShyZWFsSW5kZXgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIH0gZWxzZSBpZiAoIXdhc0xvb3AgJiYgaGFzTG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUocmVhbEluZGV4KTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2UgaWYgKHdhc0xvb3AgJiYgIWhhc0xvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBzd2lwZXIuZW1pdCgnYnJlYWtwb2ludCcsIGJyZWFrcG9pbnRQYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBiYXNlLCBjb250YWluZXJFbCkge1xuICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgYmFzZSA9ICd3aW5kb3cnO1xuICB9XG4gIGlmICghYnJlYWtwb2ludHMgfHwgYmFzZSA9PT0gJ2NvbnRhaW5lcicgJiYgIWNvbnRhaW5lckVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICBsZXQgYnJlYWtwb2ludCA9IGZhbHNlO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgY3VycmVudEhlaWdodCA9IGJhc2UgPT09ICd3aW5kb3cnID8gd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICBjb25zdCBwb2ludHMgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykubWFwKHBvaW50ID0+IHtcbiAgICBpZiAodHlwZW9mIHBvaW50ID09PSAnc3RyaW5nJyAmJiBwb2ludC5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgIGNvbnN0IG1pblJhdGlvID0gcGFyc2VGbG9hdChwb2ludC5zdWJzdHIoMSkpO1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50SGVpZ2h0ICogbWluUmF0aW87XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcG9pbnRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogcG9pbnQsXG4gICAgICBwb2ludFxuICAgIH07XG4gIH0pO1xuICBwb2ludHMuc29ydCgoYSwgYikgPT4gcGFyc2VJbnQoYS52YWx1ZSwgMTApIC0gcGFyc2VJbnQoYi52YWx1ZSwgMTApKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb2ludCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHBvaW50c1tpXTtcbiAgICBpZiAoYmFzZSA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYShgKG1pbi13aWR0aDogJHt2YWx1ZX1weClgKS5tYXRjaGVzKSB7XG4gICAgICAgIGJyZWFrcG9pbnQgPSBwb2ludDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IGNvbnRhaW5lckVsLmNsaWVudFdpZHRoKSB7XG4gICAgICBicmVha3BvaW50ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBicmVha3BvaW50IHx8ICdtYXgnO1xufVxuXG52YXIgYnJlYWtwb2ludHMgPSB7XG4gIHNldEJyZWFrcG9pbnQsXG4gIGdldEJyZWFrcG9pbnRcbn07XG5cbmZ1bmN0aW9uIHByZXBhcmVDbGFzc2VzKGVudHJpZXMsIHByZWZpeCkge1xuICBjb25zdCByZXN1bHRDbGFzc2VzID0gW107XG4gIGVudHJpZXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhpdGVtKS5mb3JFYWNoKGNsYXNzTmFtZXMgPT4ge1xuICAgICAgICBpZiAoaXRlbVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBjbGFzc05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlc3VsdENsYXNzZXMucHVzaChwcmVmaXggKyBpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0Q2xhc3Nlcztcbn1cbmZ1bmN0aW9uIGFkZENsYXNzZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBjbGFzc05hbWVzLFxuICAgIHBhcmFtcyxcbiAgICBydGwsXG4gICAgZWwsXG4gICAgZGV2aWNlXG4gIH0gPSBzd2lwZXI7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBjb25zdCBzdWZmaXhlcyA9IHByZXBhcmVDbGFzc2VzKFsnaW5pdGlhbGl6ZWQnLCBwYXJhbXMuZGlyZWN0aW9uLCB7XG4gICAgJ2ZyZWUtbW9kZSc6IHN3aXBlci5wYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWRcbiAgfSwge1xuICAgICdhdXRvaGVpZ2h0JzogcGFyYW1zLmF1dG9IZWlnaHRcbiAgfSwge1xuICAgICdydGwnOiBydGxcbiAgfSwge1xuICAgICdncmlkJzogcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDFcbiAgfSwge1xuICAgICdncmlkLWNvbHVtbic6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHBhcmFtcy5ncmlkLmZpbGwgPT09ICdjb2x1bW4nXG4gIH0sIHtcbiAgICAnYW5kcm9pZCc6IGRldmljZS5hbmRyb2lkXG4gIH0sIHtcbiAgICAnaW9zJzogZGV2aWNlLmlvc1xuICB9LCB7XG4gICAgJ2Nzcy1tb2RlJzogcGFyYW1zLmNzc01vZGVcbiAgfSwge1xuICAgICdjZW50ZXJlZCc6IHBhcmFtcy5jc3NNb2RlICYmIHBhcmFtcy5jZW50ZXJlZFNsaWRlc1xuICB9LCB7XG4gICAgJ3dhdGNoLXByb2dyZXNzJzogcGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3NcbiAgfV0sIHBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzKTtcbiAgY2xhc3NOYW1lcy5wdXNoKC4uLnN1ZmZpeGVzKTtcbiAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBlbCxcbiAgICBjbGFzc05hbWVzXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZWwgfHwgdHlwZW9mIGVsID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbn1cblxudmFyIGNsYXNzZXMgPSB7XG4gIGFkZENsYXNzZXMsXG4gIHJlbW92ZUNsYXNzZXNcbn07XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBpc0xvY2tlZDogd2FzTG9ja2VkLFxuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCB7XG4gICAgc2xpZGVzT2Zmc2V0QmVmb3JlXG4gIH0gPSBwYXJhbXM7XG4gIGlmIChzbGlkZXNPZmZzZXRCZWZvcmUpIHtcbiAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBsYXN0U2xpZGVSaWdodEVkZ2UgPSBzd2lwZXIuc2xpZGVzR3JpZFtsYXN0U2xpZGVJbmRleF0gKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2xhc3RTbGlkZUluZGV4XSArIHNsaWRlc09mZnNldEJlZm9yZSAqIDI7XG4gICAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNpemUgPiBsYXN0U2xpZGVSaWdodEVkZ2U7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCA9PT0gMTtcbiAgfVxuICBpZiAocGFyYW1zLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgfVxuICBpZiAocGFyYW1zLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgfVxuICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgc3dpcGVyLmlzRW5kID0gZmFsc2U7XG4gIH1cbiAgaWYgKHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgc3dpcGVyLmVtaXQoc3dpcGVyLmlzTG9ja2VkID8gJ2xvY2snIDogJ3VubG9jaycpO1xuICB9XG59XG52YXIgY2hlY2tPdmVyZmxvdyQxID0ge1xuICBjaGVja092ZXJmbG93XG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXQ6IHRydWUsXG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICBvbmVXYXlNb3ZlbWVudDogZmFsc2UsXG4gIHN3aXBlckVsZW1lbnROb2RlTmFtZTogJ1NXSVBFUi1DT05UQUlORVInLFxuICB0b3VjaEV2ZW50c1RhcmdldDogJ3dyYXBwZXInLFxuICBpbml0aWFsU2xpZGU6IDAsXG4gIHNwZWVkOiAzMDAsXG4gIGNzc01vZGU6IGZhbHNlLFxuICB1cGRhdGVPbldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgcmVzaXplT2JzZXJ2ZXI6IHRydWUsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGNyZWF0ZUVsZW1lbnRzOiBmYWxzZSxcbiAgZXZlbnRzUHJlZml4OiAnc3dpcGVyJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgZm9jdXNhYmxlRWxlbWVudHM6ICdpbnB1dCwgc2VsZWN0LCBvcHRpb24sIHRleHRhcmVhLCBidXR0b24sIHZpZGVvLCBsYWJlbCcsXG4gIC8vIE92ZXJyaWRlc1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICAvL1xuICBwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb246IGZhbHNlLFxuICAvLyBzc3JcbiAgdXNlckFnZW50OiBudWxsLFxuICB1cmw6IG51bGwsXG4gIC8vIFRvIHN1cHBvcnQgaU9TJ3Mgc3dpcGUtdG8tZ28tYmFjayBnZXN0dXJlICh3aGVuIGJlaW5nIHVzZWQgaW4tYXBwKS5cbiAgZWRnZVN3aXBlRGV0ZWN0aW9uOiBmYWxzZSxcbiAgZWRnZVN3aXBlVGhyZXNob2xkOiAyMCxcbiAgLy8gQXV0b2hlaWdodFxuICBhdXRvSGVpZ2h0OiBmYWxzZSxcbiAgLy8gU2V0IHdyYXBwZXIgd2lkdGhcbiAgc2V0V3JhcHBlclNpemU6IGZhbHNlLFxuICAvLyBWaXJ0dWFsIFRyYW5zbGF0ZVxuICB2aXJ0dWFsVHJhbnNsYXRlOiBmYWxzZSxcbiAgLy8gRWZmZWN0c1xuICBlZmZlY3Q6ICdzbGlkZScsXG4gIC8vICdzbGlkZScgb3IgJ2ZhZGUnIG9yICdjdWJlJyBvciAnY292ZXJmbG93JyBvciAnZmxpcCdcblxuICAvLyBCcmVha3BvaW50c1xuICBicmVha3BvaW50czogdW5kZWZpbmVkLFxuICBicmVha3BvaW50c0Jhc2U6ICd3aW5kb3cnLFxuICAvLyBTbGlkZXMgZ3JpZFxuICBzcGFjZUJldHdlZW46IDAsXG4gIHNsaWRlc1BlclZpZXc6IDEsXG4gIHNsaWRlc1Blckdyb3VwOiAxLFxuICBzbGlkZXNQZXJHcm91cFNraXA6IDAsXG4gIHNsaWRlc1Blckdyb3VwQXV0bzogZmFsc2UsXG4gIGNlbnRlcmVkU2xpZGVzOiBmYWxzZSxcbiAgY2VudGVyZWRTbGlkZXNCb3VuZHM6IGZhbHNlLFxuICBzbGlkZXNPZmZzZXRCZWZvcmU6IDAsXG4gIC8vIGluIHB4XG4gIHNsaWRlc09mZnNldEFmdGVyOiAwLFxuICAvLyBpbiBweFxuICBub3JtYWxpemVTbGlkZUluZGV4OiB0cnVlLFxuICBjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXM6IGZhbHNlLFxuICAvLyBEaXNhYmxlIHN3aXBlciBhbmQgaGlkZSBuYXZpZ2F0aW9uIHdoZW4gY29udGFpbmVyIG5vdCBvdmVyZmxvd1xuICB3YXRjaE92ZXJmbG93OiB0cnVlLFxuICAvLyBSb3VuZCBsZW5ndGhcbiAgcm91bmRMZW5ndGhzOiBmYWxzZSxcbiAgLy8gVG91Y2hlc1xuICB0b3VjaFJhdGlvOiAxLFxuICB0b3VjaEFuZ2xlOiA0NSxcbiAgc2ltdWxhdGVUb3VjaDogdHJ1ZSxcbiAgc2hvcnRTd2lwZXM6IHRydWUsXG4gIGxvbmdTd2lwZXM6IHRydWUsXG4gIGxvbmdTd2lwZXNSYXRpbzogMC41LFxuICBsb25nU3dpcGVzTXM6IDMwMCxcbiAgZm9sbG93RmluZ2VyOiB0cnVlLFxuICBhbGxvd1RvdWNoTW92ZTogdHJ1ZSxcbiAgdGhyZXNob2xkOiA1LFxuICB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICB0b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ6IHRydWUsXG4gIHRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgdG91Y2hSZWxlYXNlT25FZGdlczogZmFsc2UsXG4gIC8vIFVuaXF1ZSBOYXZpZ2F0aW9uIEVsZW1lbnRzXG4gIHVuaXF1ZU5hdkVsZW1lbnRzOiB0cnVlLFxuICAvLyBSZXNpc3RhbmNlXG4gIHJlc2lzdGFuY2U6IHRydWUsXG4gIHJlc2lzdGFuY2VSYXRpbzogMC44NSxcbiAgLy8gUHJvZ3Jlc3NcbiAgd2F0Y2hTbGlkZXNQcm9ncmVzczogZmFsc2UsXG4gIC8vIEN1cnNvclxuICBncmFiQ3Vyc29yOiBmYWxzZSxcbiAgLy8gQ2xpY2tzXG4gIHByZXZlbnRDbGlja3M6IHRydWUsXG4gIHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2UsXG4gIC8vIGxvb3BcbiAgbG9vcDogZmFsc2UsXG4gIGxvb3BBZGRCbGFua1NsaWRlczogdHJ1ZSxcbiAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXG4gIGxvb3BQcmV2ZW50c1NsaWRpbmc6IHRydWUsXG4gIC8vIHJld2luZFxuICByZXdpbmQ6IGZhbHNlLFxuICAvLyBTd2lwaW5nL25vIHN3aXBpbmdcbiAgYWxsb3dTbGlkZVByZXY6IHRydWUsXG4gIGFsbG93U2xpZGVOZXh0OiB0cnVlLFxuICBzd2lwZUhhbmRsZXI6IG51bGwsXG4gIC8vICcuc3dpcGUtaGFuZGxlcicsXG4gIG5vU3dpcGluZzogdHJ1ZSxcbiAgbm9Td2lwaW5nQ2xhc3M6ICdzd2lwZXItbm8tc3dpcGluZycsXG4gIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxuICAvLyBQYXNzaXZlIExpc3RlbmVyc1xuICBwYXNzaXZlTGlzdGVuZXJzOiB0cnVlLFxuICBtYXhCYWNrZmFjZUhpZGRlblNsaWRlczogMTAsXG4gIC8vIE5TXG4gIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6ICdzd2lwZXItJyxcbiAgLy8gTkVXXG4gIHNsaWRlQ2xhc3M6ICdzd2lwZXItc2xpZGUnLFxuICBzbGlkZUJsYW5rQ2xhc3M6ICdzd2lwZXItc2xpZGUtYmxhbmsnLFxuICBzbGlkZUFjdGl2ZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWFjdGl2ZScsXG4gIHNsaWRlVmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLXZpc2libGUnLFxuICBzbGlkZUZ1bGx5VmlzaWJsZUNsYXNzOiAnc3dpcGVyLXNsaWRlLWZ1bGx5LXZpc2libGUnLFxuICBzbGlkZU5leHRDbGFzczogJ3N3aXBlci1zbGlkZS1uZXh0JyxcbiAgc2xpZGVQcmV2Q2xhc3M6ICdzd2lwZXItc2xpZGUtcHJldicsXG4gIHdyYXBwZXJDbGFzczogJ3N3aXBlci13cmFwcGVyJyxcbiAgbGF6eVByZWxvYWRlckNsYXNzOiAnc3dpcGVyLWxhenktcHJlbG9hZGVyJyxcbiAgbGF6eVByZWxvYWRQcmV2TmV4dDogMCxcbiAgLy8gQ2FsbGJhY2tzXG4gIHJ1bkNhbGxiYWNrc09uSW5pdDogdHJ1ZSxcbiAgLy8gSW50ZXJuYWxzXG4gIF9lbWl0Q2xhc3NlczogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIG1vZHVsZUV4dGVuZFBhcmFtcyhwYXJhbXMsIGFsbE1vZHVsZXNQYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZFBhcmFtcyhvYmopIHtcbiAgICBpZiAob2JqID09PSB2b2lkIDApIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVQYXJhbU5hbWUgPSBPYmplY3Qua2V5cyhvYmopWzBdO1xuICAgIGNvbnN0IG1vZHVsZVBhcmFtcyA9IG9ialttb2R1bGVQYXJhbU5hbWVdO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlUGFyYW1zICE9PSAnb2JqZWN0JyB8fCBtb2R1bGVQYXJhbXMgPT09IG51bGwpIHtcbiAgICAgIGV4dGVuZChhbGxNb2R1bGVzUGFyYW1zLCBvYmopO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPT09IHRydWUpIHtcbiAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobW9kdWxlUGFyYW1OYW1lID09PSAnbmF2aWdhdGlvbicgJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZW5hYmxlZCAmJiAhcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0ucHJldkVsICYmICFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5uZXh0RWwpIHtcbiAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmF1dG8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoWydwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmluZGV4T2YobW9kdWxlUGFyYW1OYW1lKSA+PSAwICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdICYmIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVuYWJsZWQgJiYgIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmVsKSB7XG4gICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5hdXRvID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEobW9kdWxlUGFyYW1OYW1lIGluIHBhcmFtcyAmJiAnZW5hYmxlZCcgaW4gbW9kdWxlUGFyYW1zKSkge1xuICAgICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPT09ICdvYmplY3QnICYmICEoJ2VuYWJsZWQnIGluIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICghcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9O1xuICAgIGV4dGVuZChhbGxNb2R1bGVzUGFyYW1zLCBvYmopO1xuICB9O1xufVxuXG4vKiBlc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246IFwib2ZmXCIgKi9cbmNvbnN0IHByb3RvdHlwZXMgPSB7XG4gIGV2ZW50c0VtaXR0ZXIsXG4gIHVwZGF0ZSxcbiAgdHJhbnNsYXRlLFxuICB0cmFuc2l0aW9uLFxuICBzbGlkZSxcbiAgbG9vcCxcbiAgZ3JhYkN1cnNvcixcbiAgZXZlbnRzOiBldmVudHMkMSxcbiAgYnJlYWtwb2ludHMsXG4gIGNoZWNrT3ZlcmZsb3c6IGNoZWNrT3ZlcmZsb3ckMSxcbiAgY2xhc3Nlc1xufTtcbmNvbnN0IGV4dGVuZGVkRGVmYXVsdHMgPSB7fTtcbmNsYXNzIFN3aXBlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBlbDtcbiAgICBsZXQgcGFyYW1zO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3NbMF0pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIFtlbCwgcGFyYW1zXSA9IGFyZ3M7XG4gICAgfVxuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtcyk7XG4gICAgaWYgKGVsICYmICFwYXJhbXMuZWwpIHBhcmFtcy5lbCA9IGVsO1xuICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBpZiAocGFyYW1zLmVsICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFyYW1zLmVsKS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzd2lwZXJzID0gW107XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtcy5lbCkuZm9yRWFjaChjb250YWluZXJFbCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IGV4dGVuZCh7fSwgcGFyYW1zLCB7XG4gICAgICAgICAgZWw6IGNvbnRhaW5lckVsXG4gICAgICAgIH0pO1xuICAgICAgICBzd2lwZXJzLnB1c2gobmV3IFN3aXBlcihuZXdQYXJhbXMpKTtcbiAgICAgIH0pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgcmV0dXJuIHN3aXBlcnM7XG4gICAgfVxuXG4gICAgLy8gU3dpcGVyIEluc3RhbmNlXG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBzd2lwZXIuX19zd2lwZXJfXyA9IHRydWU7XG4gICAgc3dpcGVyLnN1cHBvcnQgPSBnZXRTdXBwb3J0KCk7XG4gICAgc3dpcGVyLmRldmljZSA9IGdldERldmljZSh7XG4gICAgICB1c2VyQWdlbnQ6IHBhcmFtcy51c2VyQWdlbnRcbiAgICB9KTtcbiAgICBzd2lwZXIuYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBzd2lwZXIuZXZlbnRzTGlzdGVuZXJzID0ge307XG4gICAgc3dpcGVyLmV2ZW50c0FueUxpc3RlbmVycyA9IFtdO1xuICAgIHN3aXBlci5tb2R1bGVzID0gWy4uLnN3aXBlci5fX21vZHVsZXNfX107XG4gICAgaWYgKHBhcmFtcy5tb2R1bGVzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLm1vZHVsZXMpKSB7XG4gICAgICBzd2lwZXIubW9kdWxlcy5wdXNoKC4uLnBhcmFtcy5tb2R1bGVzKTtcbiAgICB9XG4gICAgY29uc3QgYWxsTW9kdWxlc1BhcmFtcyA9IHt9O1xuICAgIHN3aXBlci5tb2R1bGVzLmZvckVhY2gobW9kID0+IHtcbiAgICAgIG1vZCh7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc3dpcGVyLFxuICAgICAgICBleHRlbmRQYXJhbXM6IG1vZHVsZUV4dGVuZFBhcmFtcyhwYXJhbXMsIGFsbE1vZHVsZXNQYXJhbXMpLFxuICAgICAgICBvbjogc3dpcGVyLm9uLmJpbmQoc3dpcGVyKSxcbiAgICAgICAgb25jZTogc3dpcGVyLm9uY2UuYmluZChzd2lwZXIpLFxuICAgICAgICBvZmY6IHN3aXBlci5vZmYuYmluZChzd2lwZXIpLFxuICAgICAgICBlbWl0OiBzd2lwZXIuZW1pdC5iaW5kKHN3aXBlcilcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggbW9kdWxlcyBwYXJhbXNcbiAgICBjb25zdCBzd2lwZXJQYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBhbGxNb2R1bGVzUGFyYW1zKTtcblxuICAgIC8vIEV4dGVuZCBkZWZhdWx0cyB3aXRoIHBhc3NlZCBwYXJhbXNcbiAgICBzd2lwZXIucGFyYW1zID0gZXh0ZW5kKHt9LCBzd2lwZXJQYXJhbXMsIGV4dGVuZGVkRGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zID0gZXh0ZW5kKHt9LCBzd2lwZXIucGFyYW1zKTtcbiAgICBzd2lwZXIucGFzc2VkUGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMpO1xuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChzd2lwZXIucGFyYW1zICYmIHN3aXBlci5wYXJhbXMub24pIHtcbiAgICAgIE9iamVjdC5rZXlzKHN3aXBlci5wYXJhbXMub24pLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgc3dpcGVyLm9uKGV2ZW50TmFtZSwgc3dpcGVyLnBhcmFtcy5vbltldmVudE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcyAmJiBzd2lwZXIucGFyYW1zLm9uQW55KSB7XG4gICAgICBzd2lwZXIub25Bbnkoc3dpcGVyLnBhcmFtcy5vbkFueSk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIFN3aXBlclxuICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgICBlbmFibGVkOiBzd2lwZXIucGFyYW1zLmVuYWJsZWQsXG4gICAgICBlbCxcbiAgICAgIC8vIENsYXNzZXNcbiAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgLy8gU2xpZGVzXG4gICAgICBzbGlkZXM6IFtdLFxuICAgICAgc2xpZGVzR3JpZDogW10sXG4gICAgICBzbmFwR3JpZDogW10sXG4gICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxuICAgICAgLy8gaXNEaXJlY3Rpb25cbiAgICAgIGlzSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICB9LFxuICAgICAgaXNWZXJ0aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnO1xuICAgICAgfSxcbiAgICAgIC8vIEluZGV4ZXNcbiAgICAgIGFjdGl2ZUluZGV4OiAwLFxuICAgICAgcmVhbEluZGV4OiAwLFxuICAgICAgLy9cbiAgICAgIGlzQmVnaW5uaW5nOiB0cnVlLFxuICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgLy8gUHJvcHNcbiAgICAgIHRyYW5zbGF0ZTogMCxcbiAgICAgIHByZXZpb3VzVHJhbnNsYXRlOiAwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB2ZWxvY2l0eTogMCxcbiAgICAgIGFuaW1hdGluZzogZmFsc2UsXG4gICAgICBjc3NPdmVyZmxvd0FkanVzdG1lbnQoKSB7XG4gICAgICAgIC8vIFJldHVybnMgMCB1bmxlc3MgYHRyYW5zbGF0ZWAgaXMgPiAyKioyM1xuICAgICAgICAvLyBTaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIGNzcyB2YWx1ZXMgdG8gcHJldmVudCBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyh0aGlzLnRyYW5zbGF0ZSAvIDIgKiogMjMpICogMiAqKiAyMztcbiAgICAgIH0sXG4gICAgICAvLyBMb2Nrc1xuICAgICAgYWxsb3dTbGlkZU5leHQ6IHN3aXBlci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXG4gICAgICBhbGxvd1NsaWRlUHJldjogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlUHJldixcbiAgICAgIC8vIFRvdWNoIEV2ZW50c1xuICAgICAgdG91Y2hFdmVudHNEYXRhOiB7XG4gICAgICAgIGlzVG91Y2hlZDogdW5kZWZpbmVkLFxuICAgICAgICBpc01vdmVkOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6IHVuZGVmaW5lZCxcbiAgICAgICAgdG91Y2hTdGFydFRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgY3VycmVudFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydFRyYW5zbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBhbGxvd1RocmVzaG9sZE1vdmU6IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gRm9ybSBlbGVtZW50cyB0byBtYXRjaFxuICAgICAgICBmb2N1c2FibGVFbGVtZW50czogc3dpcGVyLnBhcmFtcy5mb2N1c2FibGVFbGVtZW50cyxcbiAgICAgICAgLy8gTGFzdCBjbGljayB0aW1lXG4gICAgICAgIGxhc3RDbGlja1RpbWU6IDAsXG4gICAgICAgIGNsaWNrVGltZW91dDogdW5kZWZpbmVkLFxuICAgICAgICAvLyBWZWxvY2l0aWVzXG4gICAgICAgIHZlbG9jaXRpZXM6IFtdLFxuICAgICAgICBhbGxvd01vbWVudHVtQm91bmNlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0TW92aW5nOiB1bmRlZmluZWQsXG4gICAgICAgIHBvaW50ZXJJZDogbnVsbCxcbiAgICAgICAgdG91Y2hJZDogbnVsbFxuICAgICAgfSxcbiAgICAgIC8vIENsaWNrc1xuICAgICAgYWxsb3dDbGljazogdHJ1ZSxcbiAgICAgIC8vIFRvdWNoZXNcbiAgICAgIGFsbG93VG91Y2hNb3ZlOiBzd2lwZXIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxuICAgICAgdG91Y2hlczoge1xuICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgIHN0YXJ0WTogMCxcbiAgICAgICAgY3VycmVudFg6IDAsXG4gICAgICAgIGN1cnJlbnRZOiAwLFxuICAgICAgICBkaWZmOiAwXG4gICAgICB9LFxuICAgICAgLy8gSW1hZ2VzXG4gICAgICBpbWFnZXNUb0xvYWQ6IFtdLFxuICAgICAgaW1hZ2VzTG9hZGVkOiAwXG4gICAgfSk7XG4gICAgc3dpcGVyLmVtaXQoJ19zd2lwZXInKTtcblxuICAgIC8vIEluaXRcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5pbml0KSB7XG4gICAgICBzd2lwZXIuaW5pdCgpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhcHAgaW5zdGFuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgcmV0dXJuIHN3aXBlcjtcbiAgfVxuICBnZXREaXJlY3Rpb25MYWJlbChwcm9wZXJ0eSkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHJldHVybiB7XG4gICAgICAnd2lkdGgnOiAnaGVpZ2h0JyxcbiAgICAgICdtYXJnaW4tdG9wJzogJ21hcmdpbi1sZWZ0JyxcbiAgICAgICdtYXJnaW4tYm90dG9tICc6ICdtYXJnaW4tcmlnaHQnLFxuICAgICAgJ21hcmdpbi1sZWZ0JzogJ21hcmdpbi10b3AnLFxuICAgICAgJ21hcmdpbi1yaWdodCc6ICdtYXJnaW4tYm90dG9tJyxcbiAgICAgICdwYWRkaW5nLWxlZnQnOiAncGFkZGluZy10b3AnLFxuICAgICAgJ3BhZGRpbmctcmlnaHQnOiAncGFkZGluZy1ib3R0b20nLFxuICAgICAgJ21hcmdpblJpZ2h0JzogJ21hcmdpbkJvdHRvbSdcbiAgICB9W3Byb3BlcnR5XTtcbiAgfVxuICBnZXRTbGlkZUluZGV4KHNsaWRlRWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXNFbCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNsaWRlcyA9IGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gICAgY29uc3QgZmlyc3RTbGlkZUluZGV4ID0gZWxlbWVudEluZGV4KHNsaWRlc1swXSk7XG4gICAgcmV0dXJuIGVsZW1lbnRJbmRleChzbGlkZUVsKSAtIGZpcnN0U2xpZGVJbmRleDtcbiAgfVxuICBnZXRTbGlkZUluZGV4QnlEYXRhKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2xpZGVJbmRleCh0aGlzLnNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSAqIDEgPT09IGluZGV4KVswXSk7XG4gIH1cbiAgcmVjYWxjU2xpZGVzKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVzRWwsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gc3dpcGVyO1xuICAgIHN3aXBlci5zbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHN3aXBlci5lbmFibGVkID0gdHJ1ZTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnZW5hYmxlJyk7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICBzd2lwZXIuZW5hYmxlZCA9IGZhbHNlO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3IpIHtcbiAgICAgIHN3aXBlci51bnNldEdyYWJDdXJzb3IoKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXQoJ2Rpc2FibGUnKTtcbiAgfVxuICBzZXRQcm9ncmVzcyhwcm9ncmVzcywgc3BlZWQpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgocHJvZ3Jlc3MsIDApLCAxKTtcbiAgICBjb25zdCBtaW4gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gICAgY29uc3QgbWF4ID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSAobWF4IC0gbWluKSAqIHByb2dyZXNzICsgbWluO1xuICAgIHN3aXBlci50cmFuc2xhdGVUbyhjdXJyZW50LCB0eXBlb2Ygc3BlZWQgPT09ICd1bmRlZmluZWQnID8gMCA6IHNwZWVkKTtcbiAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICB9XG4gIGVtaXRDb250YWluZXJDbGFzc2VzKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgY29uc3QgY2xzID0gc3dpcGVyLmVsLmNsYXNzTmFtZS5zcGxpdCgnICcpLmZpbHRlcihjbGFzc05hbWUgPT4ge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdzd2lwZXInKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpID09PSAwO1xuICAgIH0pO1xuICAgIHN3aXBlci5lbWl0KCdfY29udGFpbmVyQ2xhc3NlcycsIGNscy5qb2luKCcgJykpO1xuICB9XG4gIGdldFNsaWRlQ2xhc3NlcyhzbGlkZUVsKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuICcnO1xuICAgIHJldHVybiBzbGlkZUVsLmNsYXNzTmFtZS5zcGxpdCgnICcpLmZpbHRlcihjbGFzc05hbWUgPT4ge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKCdzd2lwZXItc2xpZGUnKSA9PT0gMCB8fCBjbGFzc05hbWUuaW5kZXhPZihzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3MpID09PSAwO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuICBlbWl0U2xpZGVzQ2xhc3NlcygpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5fZW1pdENsYXNzZXMgfHwgIXN3aXBlci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gc3dpcGVyLmdldFNsaWRlQ2xhc3NlcyhzbGlkZUVsKTtcbiAgICAgIHVwZGF0ZXMucHVzaCh7XG4gICAgICAgIHNsaWRlRWwsXG4gICAgICAgIGNsYXNzTmFtZXNcbiAgICAgIH0pO1xuICAgICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzJywgc2xpZGVFbCwgY2xhc3NOYW1lcyk7XG4gICAgfSk7XG4gICAgc3dpcGVyLmVtaXQoJ19zbGlkZUNsYXNzZXMnLCB1cGRhdGVzKTtcbiAgfVxuICBzbGlkZXNQZXJWaWV3RHluYW1pYyh2aWV3LCBleGFjdCkge1xuICAgIGlmICh2aWV3ID09PSB2b2lkIDApIHtcbiAgICAgIHZpZXcgPSAnY3VycmVudCc7XG4gICAgfVxuICAgIGlmIChleGFjdCA9PT0gdm9pZCAwKSB7XG4gICAgICBleGFjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHNsaWRlcyxcbiAgICAgIHNsaWRlc0dyaWQsXG4gICAgICBzbGlkZXNTaXplc0dyaWQsXG4gICAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgICAgYWN0aXZlSW5kZXhcbiAgICB9ID0gc3dpcGVyO1xuICAgIGxldCBzcHYgPSAxO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdudW1iZXInKSByZXR1cm4gcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgbGV0IHNsaWRlU2l6ZSA9IHNsaWRlc1thY3RpdmVJbmRleF0gPyBNYXRoLmNlaWwoc2xpZGVzW2FjdGl2ZUluZGV4XS5zd2lwZXJTbGlkZVNpemUpIDogMDtcbiAgICAgIGxldCBicmVha0xvb3A7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgIHNsaWRlU2l6ZSArPSBNYXRoLmNlaWwoc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZSk7XG4gICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgaWYgKHNsaWRlU2l6ZSA+IHN3aXBlclNpemUpIGJyZWFrTG9vcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBhY3RpdmVJbmRleCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKHZpZXcgPT09ICdjdXJyZW50Jykge1xuICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVJblZpZXcgPSBleGFjdCA/IHNsaWRlc0dyaWRbaV0gKyBzbGlkZXNTaXplc0dyaWRbaV0gLSBzbGlkZXNHcmlkW2FjdGl2ZUluZGV4XSA8IHN3aXBlclNpemUgOiBzbGlkZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplO1xuICAgICAgICAgIGlmIChzbGlkZUluVmlldykge1xuICAgICAgICAgICAgc3B2ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcmV2aW91c1xuICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gLSBzbGlkZXNHcmlkW2ldIDwgc3dpcGVyU2l6ZTtcbiAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3B2O1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzbmFwR3JpZCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgLy8gQnJlYWtwb2ludHNcbiAgICBpZiAocGFyYW1zLmJyZWFrcG9pbnRzKSB7XG4gICAgICBzd2lwZXIuc2V0QnJlYWtwb2ludCgpO1xuICAgIH1cbiAgICBbLi4uc3dpcGVyLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsb2FkaW5nPVwibGF6eVwiXScpXS5mb3JFYWNoKGltYWdlRWwgPT4ge1xuICAgICAgaWYgKGltYWdlRWwuY29tcGxldGUpIHtcbiAgICAgICAgcHJvY2Vzc0xhenlQcmVsb2FkZXIoc3dpcGVyLCBpbWFnZUVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zbGF0ZSgpIHtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVZhbHVlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgKiAtMSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBjb25zdCBuZXdUcmFuc2xhdGUgPSBNYXRoLm1pbihNYXRoLm1heCh0cmFuc2xhdGVWYWx1ZSwgc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSwgc3dpcGVyLm1pblRyYW5zbGF0ZSgpKTtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0ZWQ7XG4gICAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiAhcGFyYW1zLmNzc01vZGUpIHtcbiAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgaWYgKHBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlcyA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMgOiBzd2lwZXIuc2xpZGVzO1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc2xpZGVzLmxlbmd0aCAtIDEsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zbGF0ZWQgPSBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNsYXRlZCkge1xuICAgICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCd1cGRhdGUnKTtcbiAgfVxuICBjaGFuZ2VEaXJlY3Rpb24obmV3RGlyZWN0aW9uLCBuZWVkVXBkYXRlKSB7XG4gICAgaWYgKG5lZWRVcGRhdGUgPT09IHZvaWQgMCkge1xuICAgICAgbmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudERpcmVjdGlvbiA9IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uO1xuICAgIGlmICghbmV3RGlyZWN0aW9uKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5ld0RpcmVjdGlvbiA9IGN1cnJlbnREaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGlmIChuZXdEaXJlY3Rpb24gPT09IGN1cnJlbnREaXJlY3Rpb24gfHwgbmV3RGlyZWN0aW9uICE9PSAnaG9yaXpvbnRhbCcgJiYgbmV3RGlyZWN0aW9uICE9PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gc3dpcGVyO1xuICAgIH1cbiAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LnJlbW92ZShgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtjdXJyZW50RGlyZWN0aW9ufWApO1xuICAgIHN3aXBlci5lbC5jbGFzc0xpc3QuYWRkKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke25ld0RpcmVjdGlvbn1gKTtcbiAgICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbiAgICBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9IG5ld0RpcmVjdGlvbjtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBpZiAobmV3RGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHNsaWRlRWwuc3R5bGUud2lkdGggPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRlRWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3dpcGVyLmVtaXQoJ2NoYW5nZURpcmVjdGlvbicpO1xuICAgIGlmIChuZWVkVXBkYXRlKSBzd2lwZXIudXBkYXRlKCk7XG4gICAgcmV0dXJuIHN3aXBlcjtcbiAgfVxuICBjaGFuZ2VMYW5ndWFnZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIucnRsICYmIGRpcmVjdGlvbiA9PT0gJ3J0bCcgfHwgIXN3aXBlci5ydGwgJiYgZGlyZWN0aW9uID09PSAnbHRyJykgcmV0dXJuO1xuICAgIHN3aXBlci5ydGwgPSBkaXJlY3Rpb24gPT09ICdydGwnO1xuICAgIHN3aXBlci5ydGxUcmFuc2xhdGUgPSBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHN3aXBlci5ydGw7XG4gICAgaWYgKHN3aXBlci5ydGwpIHtcbiAgICAgIHN3aXBlci5lbC5jbGFzc0xpc3QuYWRkKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKTtcbiAgICAgIHN3aXBlci5lbC5kaXIgPSAncnRsJztcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5yZW1vdmUoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApO1xuICAgICAgc3dpcGVyLmVsLmRpciA9ICdsdHInO1xuICAgIH1cbiAgICBzd2lwZXIudXBkYXRlKCk7XG4gIH1cbiAgbW91bnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5tb3VudGVkKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEZpbmQgZWxcbiAgICBsZXQgZWwgPSBlbGVtZW50IHx8IHN3aXBlci5wYXJhbXMuZWw7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgfVxuICAgIGlmICghZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWwuc3dpcGVyID0gc3dpcGVyO1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuaG9zdCAmJiBlbC5wYXJlbnROb2RlLmhvc3Qubm9kZU5hbWUgPT09IHN3aXBlci5wYXJhbXMuc3dpcGVyRWxlbWVudE5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIHN3aXBlci5pc0VsZW1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBnZXRXcmFwcGVyU2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gYC4keyhzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyB8fCAnJykudHJpbSgpLnNwbGl0KCcgJykuam9pbignLicpfWA7XG4gICAgfTtcbiAgICBjb25zdCBnZXRXcmFwcGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGVsICYmIGVsLnNoYWRvd1Jvb3QgJiYgZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihnZXRXcmFwcGVyU2VsZWN0b3IoKSk7XG4gICAgICAgIC8vIENoaWxkcmVuIG5lZWRzIHRvIHJldHVybiBzbG90IGl0ZW1zXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudENoaWxkcmVuKGVsLCBnZXRXcmFwcGVyU2VsZWN0b3IoKSlbMF07XG4gICAgfTtcbiAgICAvLyBGaW5kIFdyYXBwZXJcbiAgICBsZXQgd3JhcHBlckVsID0gZ2V0V3JhcHBlcigpO1xuICAgIGlmICghd3JhcHBlckVsICYmIHN3aXBlci5wYXJhbXMuY3JlYXRlRWxlbWVudHMpIHtcbiAgICAgIHdyYXBwZXJFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHN3aXBlci5wYXJhbXMud3JhcHBlckNsYXNzKTtcbiAgICAgIGVsLmFwcGVuZCh3cmFwcGVyRWwpO1xuICAgICAgZWxlbWVudENoaWxkcmVuKGVsLCBgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgIHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVFbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgIGVsLFxuICAgICAgd3JhcHBlckVsLFxuICAgICAgc2xpZGVzRWw6IHN3aXBlci5pc0VsZW1lbnQgJiYgIWVsLnBhcmVudE5vZGUuaG9zdC5zbGlkZVNsb3RzID8gZWwucGFyZW50Tm9kZS5ob3N0IDogd3JhcHBlckVsLFxuICAgICAgaG9zdEVsOiBzd2lwZXIuaXNFbGVtZW50ID8gZWwucGFyZW50Tm9kZS5ob3N0IDogZWwsXG4gICAgICBtb3VudGVkOiB0cnVlLFxuICAgICAgLy8gUlRMXG4gICAgICBydGw6IGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCBlbGVtZW50U3R5bGUoZWwsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICBydGxUcmFuc2xhdGU6IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgKGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCBlbGVtZW50U3R5bGUoZWwsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcpLFxuICAgICAgd3JvbmdSVEw6IGVsZW1lbnRTdHlsZSh3cmFwcGVyRWwsICdkaXNwbGF5JykgPT09ICctd2Via2l0LWJveCdcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbml0KGVsKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm4gc3dpcGVyO1xuICAgIGNvbnN0IG1vdW50ZWQgPSBzd2lwZXIubW91bnQoZWwpO1xuICAgIGlmIChtb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIHN3aXBlcjtcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlSW5pdCcpO1xuXG4gICAgLy8gU2V0IGJyZWFrcG9pbnRcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQ2xhc3Nlc1xuICAgIHN3aXBlci5hZGRDbGFzc2VzKCk7XG5cbiAgICAvLyBVcGRhdGUgc2l6ZVxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG5cbiAgICAvLyBVcGRhdGUgc2xpZGVzXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHtcbiAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IEdyYWIgQ3Vyc29yXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvciAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgICB9XG5cbiAgICAvLyBTbGlkZSBUbyBJbml0aWFsIFNsaWRlXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCAmJiBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUsIDAsIHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb29wXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggZXZlbnRzXG4gICAgc3dpcGVyLmF0dGFjaEV2ZW50cygpO1xuICAgIGNvbnN0IGxhenlFbGVtZW50cyA9IFsuLi5zd2lwZXIuZWwucXVlcnlTZWxlY3RvckFsbCgnW2xvYWRpbmc9XCJsYXp5XCJdJyldO1xuICAgIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgICBsYXp5RWxlbWVudHMucHVzaCguLi5zd2lwZXIuaG9zdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsb2FkaW5nPVwibGF6eVwiXScpKTtcbiAgICB9XG4gICAgbGF6eUVsZW1lbnRzLmZvckVhY2goaW1hZ2VFbCA9PiB7XG4gICAgICBpZiAoaW1hZ2VFbC5jb21wbGV0ZSkge1xuICAgICAgICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGltYWdlRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZSA9PiB7XG4gICAgICAgICAgcHJvY2Vzc0xhenlQcmVsb2FkZXIoc3dpcGVyLCBlLnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHByZWxvYWQoc3dpcGVyKTtcblxuICAgIC8vIEluaXQgRmxhZ1xuICAgIHN3aXBlci5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgcHJlbG9hZChzd2lwZXIpO1xuXG4gICAgLy8gRW1pdFxuICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gICAgc3dpcGVyLmVtaXQoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgZGVzdHJveShkZWxldGVJbnN0YW5jZSwgY2xlYW5TdHlsZXMpIHtcbiAgICBpZiAoZGVsZXRlSW5zdGFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlSW5zdGFuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2xlYW5TdHlsZXMgPT09IHZvaWQgMCkge1xuICAgICAgY2xlYW5TdHlsZXMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIGVsLFxuICAgICAgd3JhcHBlckVsLFxuICAgICAgc2xpZGVzXG4gICAgfSA9IHN3aXBlcjtcbiAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlci5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpO1xuXG4gICAgLy8gSW5pdCBGbGFnXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAvLyBEZXRhY2ggZXZlbnRzXG4gICAgc3dpcGVyLmRldGFjaEV2ZW50cygpO1xuXG4gICAgLy8gRGVzdHJveSBsb29wXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIHN0eWxlc1xuICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgc3dpcGVyLnJlbW92ZUNsYXNzZXMoKTtcbiAgICAgIGlmIChlbCAmJiB0eXBlb2YgZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICh3cmFwcGVyRWwpIHtcbiAgICAgICAgd3JhcHBlckVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbGlkZXMgJiYgc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICBzbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICBzbGlkZUVsLmNsYXNzTGlzdC5yZW1vdmUocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzLCBwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MsIHBhcmFtcy5zbGlkZU5leHRDbGFzcywgcGFyYW1zLnNsaWRlUHJldkNsYXNzKTtcbiAgICAgICAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICBzbGlkZUVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdkZXN0cm95Jyk7XG5cbiAgICAvLyBEZXRhY2ggZW1pdHRlciBldmVudHNcbiAgICBPYmplY3Qua2V5cyhzd2lwZXIuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXIub2ZmKGV2ZW50TmFtZSk7XG4gICAgfSk7XG4gICAgaWYgKGRlbGV0ZUluc3RhbmNlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHN3aXBlci5lbCAmJiB0eXBlb2Ygc3dpcGVyLmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzd2lwZXIuZWwuc3dpcGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZVByb3BzKHN3aXBlcik7XG4gICAgfVxuICAgIHN3aXBlci5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBleHRlbmREZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIGV4dGVuZChleHRlbmRlZERlZmF1bHRzLCBuZXdEZWZhdWx0cyk7XG4gIH1cbiAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkge1xuICAgIHJldHVybiBleHRlbmRlZERlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG4gIHN0YXRpYyBpbnN0YWxsTW9kdWxlKG1vZCkge1xuICAgIGlmICghU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXykgU3dpcGVyLnByb3RvdHlwZS5fX21vZHVsZXNfXyA9IFtdO1xuICAgIGNvbnN0IG1vZHVsZXMgPSBTd2lwZXIucHJvdG90eXBlLl9fbW9kdWxlc19fO1xuICAgIGlmICh0eXBlb2YgbW9kID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZXMuaW5kZXhPZihtb2QpIDwgMCkge1xuICAgICAgbW9kdWxlcy5wdXNoKG1vZCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB1c2UobW9kdWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlKSkge1xuICAgICAgbW9kdWxlLmZvckVhY2gobSA9PiBTd2lwZXIuaW5zdGFsbE1vZHVsZShtKSk7XG4gICAgICByZXR1cm4gU3dpcGVyO1xuICAgIH1cbiAgICBTd2lwZXIuaW5zdGFsbE1vZHVsZShtb2R1bGUpO1xuICAgIHJldHVybiBTd2lwZXI7XG4gIH1cbn1cbk9iamVjdC5rZXlzKHByb3RvdHlwZXMpLmZvckVhY2gocHJvdG90eXBlR3JvdXAgPT4ge1xuICBPYmplY3Qua2V5cyhwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXSkuZm9yRWFjaChwcm90b01ldGhvZCA9PiB7XG4gICAgU3dpcGVyLnByb3RvdHlwZVtwcm90b01ldGhvZF0gPSBwcm90b3R5cGVzW3Byb3RvdHlwZUdyb3VwXVtwcm90b01ldGhvZF07XG4gIH0pO1xufSk7XG5Td2lwZXIudXNlKFtSZXNpemUsIE9ic2VydmVyXSk7XG5cbmV4cG9ydCB7IFN3aXBlciBhcyBTLCBkZWZhdWx0cyBhcyBkIH07XG4iLCJpbXBvcnQgeyBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi4vc2hhcmVkL3Nzci13aW5kb3cuZXNtLm1qcyc7XG5pbXBvcnQgeyBzIGFzIHNldENTU1Byb3BlcnR5LCBlIGFzIGVsZW1lbnRDaGlsZHJlbiwgYyBhcyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIFZpcnR1YWwoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb24sXG4gICAgZW1pdFxuICB9ID0gX3JlZjtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICB2aXJ0dWFsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHNsaWRlczogW10sXG4gICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgIHJlbmRlclNsaWRlOiBudWxsLFxuICAgICAgcmVuZGVyRXh0ZXJuYWw6IG51bGwsXG4gICAgICByZW5kZXJFeHRlcm5hbFVwZGF0ZTogdHJ1ZSxcbiAgICAgIGFkZFNsaWRlc0JlZm9yZTogMCxcbiAgICAgIGFkZFNsaWRlc0FmdGVyOiAwXG4gICAgfVxuICB9KTtcbiAgbGV0IGNzc01vZGVUaW1lb3V0O1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIHN3aXBlci52aXJ0dWFsID0ge1xuICAgIGNhY2hlOiB7fSxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgdG86IHVuZGVmaW5lZCxcbiAgICBzbGlkZXM6IFtdLFxuICAgIG9mZnNldDogMCxcbiAgICBzbGlkZXNHcmlkOiBbXVxuICB9O1xuICBjb25zdCB0ZW1wRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGZ1bmN0aW9uIHJlbmRlclNsaWRlKHNsaWRlLCBpbmRleCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMudmlydHVhbDtcbiAgICBpZiAocGFyYW1zLmNhY2hlICYmIHN3aXBlci52aXJ0dWFsLmNhY2hlW2luZGV4XSkge1xuICAgICAgcmV0dXJuIHN3aXBlci52aXJ0dWFsLmNhY2hlW2luZGV4XTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgbGV0IHNsaWRlRWw7XG4gICAgaWYgKHBhcmFtcy5yZW5kZXJTbGlkZSkge1xuICAgICAgc2xpZGVFbCA9IHBhcmFtcy5yZW5kZXJTbGlkZS5jYWxsKHN3aXBlciwgc2xpZGUsIGluZGV4KTtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGVtcERPTS5pbm5lckhUTUwgPSBzbGlkZUVsO1xuICAgICAgICBzbGlkZUVsID0gdGVtcERPTS5jaGlsZHJlblswXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIHNsaWRlRWwgPSBjcmVhdGVFbGVtZW50KCdzd2lwZXItc2xpZGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHN3aXBlci5wYXJhbXMuc2xpZGVDbGFzcyk7XG4gICAgfVxuICAgIHNsaWRlRWwuc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgICBpZiAoIXBhcmFtcy5yZW5kZXJTbGlkZSkge1xuICAgICAgc2xpZGVFbC5pbm5lckhUTUwgPSBzbGlkZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jYWNoZSkge1xuICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGVbaW5kZXhdID0gc2xpZGVFbDtcbiAgICB9XG4gICAgcmV0dXJuIHNsaWRlRWw7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGZvcmNlLCBiZWZvcmVJbml0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVzUGVyVmlldyxcbiAgICAgIHNsaWRlc1Blckdyb3VwLFxuICAgICAgY2VudGVyZWRTbGlkZXMsXG4gICAgICBsb29wOiBpc0xvb3AsXG4gICAgICBpbml0aWFsU2xpZGVcbiAgICB9ID0gc3dpcGVyLnBhcmFtcztcbiAgICBpZiAoYmVmb3JlSW5pdCAmJiAhaXNMb29wICYmIGluaXRpYWxTbGlkZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkU2xpZGVzQmVmb3JlLFxuICAgICAgYWRkU2xpZGVzQWZ0ZXJcbiAgICB9ID0gc3dpcGVyLnBhcmFtcy52aXJ0dWFsO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyb206IHByZXZpb3VzRnJvbSxcbiAgICAgIHRvOiBwcmV2aW91c1RvLFxuICAgICAgc2xpZGVzLFxuICAgICAgc2xpZGVzR3JpZDogcHJldmlvdXNTbGlkZXNHcmlkLFxuICAgICAgb2Zmc2V0OiBwcmV2aW91c09mZnNldFxuICAgIH0gPSBzd2lwZXIudmlydHVhbDtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IHx8IDA7XG4gICAgbGV0IG9mZnNldFByb3A7XG4gICAgaWYgKHN3aXBlci5ydGxUcmFuc2xhdGUpIG9mZnNldFByb3AgPSAncmlnaHQnO2Vsc2Ugb2Zmc2V0UHJvcCA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIGxldCBzbGlkZXNBZnRlcjtcbiAgICBsZXQgc2xpZGVzQmVmb3JlO1xuICAgIGlmIChjZW50ZXJlZFNsaWRlcykge1xuICAgICAgc2xpZGVzQWZ0ZXIgPSBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSArIHNsaWRlc1Blckdyb3VwICsgYWRkU2xpZGVzQWZ0ZXI7XG4gICAgICBzbGlkZXNCZWZvcmUgPSBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSArIHNsaWRlc1Blckdyb3VwICsgYWRkU2xpZGVzQmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZXNBZnRlciA9IHNsaWRlc1BlclZpZXcgKyAoc2xpZGVzUGVyR3JvdXAgLSAxKSArIGFkZFNsaWRlc0FmdGVyO1xuICAgICAgc2xpZGVzQmVmb3JlID0gKGlzTG9vcCA/IHNsaWRlc1BlclZpZXcgOiBzbGlkZXNQZXJHcm91cCkgKyBhZGRTbGlkZXNCZWZvcmU7XG4gICAgfVxuICAgIGxldCBmcm9tID0gYWN0aXZlSW5kZXggLSBzbGlkZXNCZWZvcmU7XG4gICAgbGV0IHRvID0gYWN0aXZlSW5kZXggKyBzbGlkZXNBZnRlcjtcbiAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xuICAgICAgdG8gPSBNYXRoLm1pbih0bywgc2xpZGVzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gKHN3aXBlci5zbGlkZXNHcmlkW2Zyb21dIHx8IDApIC0gKHN3aXBlci5zbGlkZXNHcmlkWzBdIHx8IDApO1xuICAgIGlmIChpc0xvb3AgJiYgYWN0aXZlSW5kZXggPj0gc2xpZGVzQmVmb3JlKSB7XG4gICAgICBmcm9tIC09IHNsaWRlc0JlZm9yZTtcbiAgICAgIGlmICghY2VudGVyZWRTbGlkZXMpIG9mZnNldCArPSBzd2lwZXIuc2xpZGVzR3JpZFswXTtcbiAgICB9IGVsc2UgaWYgKGlzTG9vcCAmJiBhY3RpdmVJbmRleCA8IHNsaWRlc0JlZm9yZSkge1xuICAgICAgZnJvbSA9IC1zbGlkZXNCZWZvcmU7XG4gICAgICBpZiAoY2VudGVyZWRTbGlkZXMpIG9mZnNldCArPSBzd2lwZXIuc2xpZGVzR3JpZFswXTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIudmlydHVhbCwge1xuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc2xpZGVzR3JpZDogc3dpcGVyLnNsaWRlc0dyaWQsXG4gICAgICBzbGlkZXNCZWZvcmUsXG4gICAgICBzbGlkZXNBZnRlclxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9uUmVuZGVyZWQoKSB7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBlbWl0KCd2aXJ0dWFsVXBkYXRlJyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c0Zyb20gPT09IGZyb20gJiYgcHJldmlvdXNUbyA9PT0gdG8gJiYgIWZvcmNlKSB7XG4gICAgICBpZiAoc3dpcGVyLnNsaWRlc0dyaWQgIT09IHByZXZpb3VzU2xpZGVzR3JpZCAmJiBvZmZzZXQgIT09IHByZXZpb3VzT2Zmc2V0KSB7XG4gICAgICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICBzbGlkZUVsLnN0eWxlW29mZnNldFByb3BdID0gYCR7b2Zmc2V0IC0gTWF0aC5hYnMoc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpKX1weGA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgICBlbWl0KCd2aXJ0dWFsVXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHN3aXBlci5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbC5jYWxsKHN3aXBlciwge1xuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBzbGlkZXM6IGZ1bmN0aW9uIGdldFNsaWRlcygpIHtcbiAgICAgICAgICBjb25zdCBzbGlkZXNUb1JlbmRlciA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNsaWRlc1RvUmVuZGVyLnB1c2goc2xpZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNsaWRlc1RvUmVuZGVyO1xuICAgICAgICB9KClcbiAgICAgIH0pO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbFVwZGF0ZSkge1xuICAgICAgICBvblJlbmRlcmVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0KCd2aXJ0dWFsVXBkYXRlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXBlbmRJbmRleGVzID0gW107XG4gICAgY29uc3QgYXBwZW5kSW5kZXhlcyA9IFtdO1xuICAgIGNvbnN0IGdldFNsaWRlSW5kZXggPSBpbmRleCA9PiB7XG4gICAgICBsZXQgc2xpZGVJbmRleCA9IGluZGV4O1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBzbGlkZUluZGV4ID0gc2xpZGVzLmxlbmd0aCArIGluZGV4O1xuICAgICAgfSBlbHNlIGlmIChzbGlkZUluZGV4ID49IHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHNsaWRlSW5kZXggPSBzbGlkZUluZGV4IC0gc2xpZGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGlkZUluZGV4O1xuICAgIH07XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBzd2lwZXIuc2xpZGVzLmZpbHRlcihlbCA9PiBlbC5tYXRjaGVzKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKSkuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgc2xpZGVFbC5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNGcm9tOyBpIDw9IHByZXZpb3VzVG87IGkgKz0gMSkge1xuICAgICAgICBpZiAoaSA8IGZyb20gfHwgaSA+IHRvKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IGdldFNsaWRlSW5kZXgoaSk7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlcy5maWx0ZXIoZWwgPT4gZWwubWF0Y2hlcyhgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVJbmRleH1cIl0sIHN3aXBlci1zbGlkZVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7c2xpZGVJbmRleH1cIl1gKSkuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgICAgICAgIHNsaWRlRWwucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbG9vcEZyb20gPSBpc0xvb3AgPyAtc2xpZGVzLmxlbmd0aCA6IDA7XG4gICAgY29uc3QgbG9vcFRvID0gaXNMb29wID8gc2xpZGVzLmxlbmd0aCAqIDIgOiBzbGlkZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsb29wRnJvbTsgaSA8IGxvb3BUbzsgaSArPSAxKSB7XG4gICAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IGdldFNsaWRlSW5kZXgoaSk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNUbyA9PT0gJ3VuZGVmaW5lZCcgfHwgZm9yY2UpIHtcbiAgICAgICAgICBhcHBlbmRJbmRleGVzLnB1c2goc2xpZGVJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiBwcmV2aW91c1RvKSBhcHBlbmRJbmRleGVzLnB1c2goc2xpZGVJbmRleCk7XG4gICAgICAgICAgaWYgKGkgPCBwcmV2aW91c0Zyb20pIHByZXBlbmRJbmRleGVzLnB1c2goc2xpZGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kSW5kZXhlcy5mb3JFYWNoKGluZGV4ID0+IHtcbiAgICAgIHN3aXBlci5zbGlkZXNFbC5hcHBlbmQocmVuZGVyU2xpZGUoc2xpZGVzW2luZGV4XSwgaW5kZXgpKTtcbiAgICB9KTtcbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBmb3IgKGxldCBpID0gcHJlcGVuZEluZGV4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwcmVwZW5kSW5kZXhlc1tpXTtcbiAgICAgICAgc3dpcGVyLnNsaWRlc0VsLnByZXBlbmQocmVuZGVyU2xpZGUoc2xpZGVzW2luZGV4XSwgaW5kZXgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJlcGVuZEluZGV4ZXMuc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuICAgICAgcHJlcGVuZEluZGV4ZXMuZm9yRWFjaChpbmRleCA9PiB7XG4gICAgICAgIHN3aXBlci5zbGlkZXNFbC5wcmVwZW5kKHJlbmRlclNsaWRlKHNsaWRlc1tpbmRleF0sIGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxlbWVudENoaWxkcmVuKHN3aXBlci5zbGlkZXNFbCwgJy5zd2lwZXItc2xpZGUsIHN3aXBlci1zbGlkZScpLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlW29mZnNldFByb3BdID0gYCR7b2Zmc2V0IC0gTWF0aC5hYnMoc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpKX1weGA7XG4gICAgfSk7XG4gICAgb25SZW5kZXJlZCgpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZFNsaWRlKHNsaWRlcykge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0pIHN3aXBlci52aXJ0dWFsLnNsaWRlcy5wdXNoKHNsaWRlc1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcy5wdXNoKHNsaWRlcyk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwZW5kU2xpZGUoc2xpZGVzKSB7XG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gICAgbGV0IG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyAxO1xuICAgIGxldCBudW1iZXJPZk5ld1NsaWRlcyA9IDE7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2xpZGVzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNsaWRlc1tpXSkgc3dpcGVyLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoc2xpZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIG5ld0FjdGl2ZUluZGV4ID0gYWN0aXZlSW5kZXggKyBzbGlkZXMubGVuZ3RoO1xuICAgICAgbnVtYmVyT2ZOZXdTbGlkZXMgPSBzbGlkZXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMudW5zaGlmdChzbGlkZXMpO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHN3aXBlci52aXJ0dWFsLmNhY2hlO1xuICAgICAgY29uc3QgbmV3Q2FjaGUgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNhY2hlKS5mb3JFYWNoKGNhY2hlZEluZGV4ID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGVkRWwgPSBjYWNoZVtjYWNoZWRJbmRleF07XG4gICAgICAgIGNvbnN0IGNhY2hlZEVsSW5kZXggPSBjYWNoZWRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgICAgIGlmIChjYWNoZWRFbEluZGV4KSB7XG4gICAgICAgICAgY2FjaGVkRWwuc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIHBhcnNlSW50KGNhY2hlZEVsSW5kZXgsIDEwKSArIG51bWJlck9mTmV3U2xpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDYWNoZVtwYXJzZUludChjYWNoZWRJbmRleCwgMTApICsgbnVtYmVyT2ZOZXdTbGlkZXNdID0gY2FjaGVkRWw7XG4gICAgICB9KTtcbiAgICAgIHN3aXBlci52aXJ0dWFsLmNhY2hlID0gbmV3Q2FjaGU7XG4gICAgfVxuICAgIHVwZGF0ZSh0cnVlKTtcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlU2xpZGUoc2xpZGVzSW5kZXhlcykge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzSW5kZXhlcyA9PT0gJ3VuZGVmaW5lZCcgfHwgc2xpZGVzSW5kZXhlcyA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGxldCBhY3RpdmVJbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbGlkZXNJbmRleGVzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IHNsaWRlc0luZGV4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgICAgIGRlbGV0ZSBzd2lwZXIudmlydHVhbC5jYWNoZVtzbGlkZXNJbmRleGVzW2ldXTtcbiAgICAgICAgICAvLyBzaGlmdCBjYWNoZSBpbmRleGVzXG4gICAgICAgICAgT2JqZWN0LmtleXMoc3dpcGVyLnZpcnR1YWwuY2FjaGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPiBzbGlkZXNJbmRleGVzKSB7XG4gICAgICAgICAgICAgIHN3aXBlci52aXJ0dWFsLmNhY2hlW2tleSAtIDFdID0gc3dpcGVyLnZpcnR1YWwuY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGVba2V5IC0gMV0uc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGtleSAtIDEpO1xuICAgICAgICAgICAgICBkZWxldGUgc3dpcGVyLnZpcnR1YWwuY2FjaGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzd2lwZXIudmlydHVhbC5zbGlkZXMuc3BsaWNlKHNsaWRlc0luZGV4ZXNbaV0sIDEpO1xuICAgICAgICBpZiAoc2xpZGVzSW5kZXhlc1tpXSA8IGFjdGl2ZUluZGV4KSBhY3RpdmVJbmRleCAtPSAxO1xuICAgICAgICBhY3RpdmVJbmRleCA9IE1hdGgubWF4KGFjdGl2ZUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbC5jYWNoZSkge1xuICAgICAgICBkZWxldGUgc3dpcGVyLnZpcnR1YWwuY2FjaGVbc2xpZGVzSW5kZXhlc107XG4gICAgICAgIC8vIHNoaWZ0IGNhY2hlIGluZGV4ZXNcbiAgICAgICAgT2JqZWN0LmtleXMoc3dpcGVyLnZpcnR1YWwuY2FjaGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBpZiAoa2V5ID4gc2xpZGVzSW5kZXhlcykge1xuICAgICAgICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGVba2V5IC0gMV0gPSBzd2lwZXIudmlydHVhbC5jYWNoZVtrZXldO1xuICAgICAgICAgICAgc3dpcGVyLnZpcnR1YWwuY2FjaGVba2V5IC0gMV0uc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGtleSAtIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHN3aXBlci52aXJ0dWFsLmNhY2hlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcy5zcGxpY2Uoc2xpZGVzSW5kZXhlcywgMSk7XG4gICAgICBpZiAoc2xpZGVzSW5kZXhlcyA8IGFjdGl2ZUluZGV4KSBhY3RpdmVJbmRleCAtPSAxO1xuICAgICAgYWN0aXZlSW5kZXggPSBNYXRoLm1heChhY3RpdmVJbmRleCwgMCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cnVlKTtcbiAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQWxsU2xpZGVzKCkge1xuICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcyA9IFtdO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcbiAgICAgIHN3aXBlci52aXJ0dWFsLmNhY2hlID0ge307XG4gICAgfVxuICAgIHVwZGF0ZSh0cnVlKTtcbiAgICBzd2lwZXIuc2xpZGVUbygwLCAwKTtcbiAgfVxuICBvbignYmVmb3JlSW5pdCcsICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gICAgbGV0IGRvbVNsaWRlc0Fzc2lnbmVkO1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyLnBhc3NlZFBhcmFtcy52aXJ0dWFsLnNsaWRlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHNsaWRlcyA9IFsuLi5zd2lwZXIuc2xpZGVzRWwuY2hpbGRyZW5dLmZpbHRlcihlbCA9PiBlbC5tYXRjaGVzKGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKSk7XG4gICAgICBpZiAoc2xpZGVzICYmIHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgc3dpcGVyLnZpcnR1YWwuc2xpZGVzID0gWy4uLnNsaWRlc107XG4gICAgICAgIGRvbVNsaWRlc0Fzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgc2xpZGVzLmZvckVhY2goKHNsaWRlRWwsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBzbGlkZUVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnLCBzbGlkZUluZGV4KTtcbiAgICAgICAgICBzd2lwZXIudmlydHVhbC5jYWNoZVtzbGlkZUluZGV4XSA9IHNsaWRlRWw7XG4gICAgICAgICAgc2xpZGVFbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZG9tU2xpZGVzQXNzaWduZWQpIHtcbiAgICAgIHN3aXBlci52aXJ0dWFsLnNsaWRlcyA9IHN3aXBlci5wYXJhbXMudmlydHVhbC5zbGlkZXM7XG4gICAgfVxuICAgIHN3aXBlci5jbGFzc05hbWVzLnB1c2goYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXZpcnR1YWxgKTtcbiAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgICB1cGRhdGUoZmFsc2UsIHRydWUpO1xuICB9KTtcbiAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSAmJiAhc3dpcGVyLl9pbW1lZGlhdGVWaXJ0dWFsKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3NzTW9kZVRpbWVvdXQpO1xuICAgICAgY3NzTW9kZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICBvbignaW5pdCB1cGRhdGUgcmVzaXplJywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICBzZXRDU1NQcm9wZXJ0eShzd2lwZXIud3JhcHBlckVsLCAnLS1zd2lwZXItdmlydHVhbC1zaXplJywgYCR7c3dpcGVyLnZpcnR1YWxTaXplfXB4YCk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIudmlydHVhbCwge1xuICAgIGFwcGVuZFNsaWRlLFxuICAgIHByZXBlbmRTbGlkZSxcbiAgICByZW1vdmVTbGlkZSxcbiAgICByZW1vdmVBbGxTbGlkZXMsXG4gICAgdXBkYXRlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBWaXJ0dWFsIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGcgYXMgZ2V0RG9jdW1lbnQsIGEgYXMgZ2V0V2luZG93IH0gZnJvbSAnLi4vc2hhcmVkL3Nzci13aW5kb3cuZXNtLm1qcyc7XG5pbXBvcnQgeyBhIGFzIGVsZW1lbnRQYXJlbnRzLCBiIGFzIGVsZW1lbnRPZmZzZXQgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbmZ1bmN0aW9uIEtleWJvYXJkKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIHN3aXBlci5rZXlib2FyZCA9IHtcbiAgICBlbmFibGVkOiBmYWxzZVxuICB9O1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG9ubHlJblZpZXdwb3J0OiB0cnVlLFxuICAgICAgcGFnZVVwRG93bjogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGhhbmRsZShldmVudCkge1xuICAgIGlmICghc3dpcGVyLmVuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBydGxUcmFuc2xhdGU6IHJ0bFxuICAgIH0gPSBzd2lwZXI7XG4gICAgbGV0IGUgPSBldmVudDtcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG4gICAgY29uc3Qga2MgPSBlLmtleUNvZGUgfHwgZS5jaGFyQ29kZTtcbiAgICBjb25zdCBwYWdlVXBEb3duID0gc3dpcGVyLnBhcmFtcy5rZXlib2FyZC5wYWdlVXBEb3duO1xuICAgIGNvbnN0IGlzUGFnZVVwID0gcGFnZVVwRG93biAmJiBrYyA9PT0gMzM7XG4gICAgY29uc3QgaXNQYWdlRG93biA9IHBhZ2VVcERvd24gJiYga2MgPT09IDM0O1xuICAgIGNvbnN0IGlzQXJyb3dMZWZ0ID0ga2MgPT09IDM3O1xuICAgIGNvbnN0IGlzQXJyb3dSaWdodCA9IGtjID09PSAzOTtcbiAgICBjb25zdCBpc0Fycm93VXAgPSBrYyA9PT0gMzg7XG4gICAgY29uc3QgaXNBcnJvd0Rvd24gPSBrYyA9PT0gNDA7XG4gICAgLy8gRGlyZWN0aW9ucyBsb2Nrc1xuICAgIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgaXNBcnJvd1JpZ2h0IHx8IHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgaXNBcnJvd0Rvd24gfHwgaXNQYWdlRG93bikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgKHN3aXBlci5pc0hvcml6b250YWwoKSAmJiBpc0Fycm93TGVmdCB8fCBzd2lwZXIuaXNWZXJ0aWNhbCgpICYmIGlzQXJyb3dVcCB8fCBpc1BhZ2VVcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSAmJiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmtleWJvYXJkLm9ubHlJblZpZXdwb3J0ICYmIChpc1BhZ2VVcCB8fCBpc1BhZ2VEb3duIHx8IGlzQXJyb3dMZWZ0IHx8IGlzQXJyb3dSaWdodCB8fCBpc0Fycm93VXAgfHwgaXNBcnJvd0Rvd24pKSB7XG4gICAgICBsZXQgaW5WaWV3ID0gZmFsc2U7XG4gICAgICAvLyBDaGVjayB0aGF0IHN3aXBlciBzaG91bGQgYmUgaW5zaWRlIG9mIHZpc2libGUgYXJlYSBvZiB3aW5kb3dcbiAgICAgIGlmIChlbGVtZW50UGFyZW50cyhzd2lwZXIuZWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKS5sZW5ndGggPiAwICYmIGVsZW1lbnRQYXJlbnRzKHN3aXBlci5lbCwgYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsID0gc3dpcGVyLmVsO1xuICAgICAgY29uc3Qgc3dpcGVyV2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IHN3aXBlckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjb25zdCBzd2lwZXJPZmZzZXQgPSBlbGVtZW50T2Zmc2V0KGVsKTtcbiAgICAgIGlmIChydGwpIHN3aXBlck9mZnNldC5sZWZ0IC09IGVsLnNjcm9sbExlZnQ7XG4gICAgICBjb25zdCBzd2lwZXJDb29yZCA9IFtbc3dpcGVyT2Zmc2V0LmxlZnQsIHN3aXBlck9mZnNldC50b3BdLCBbc3dpcGVyT2Zmc2V0LmxlZnQgKyBzd2lwZXJXaWR0aCwgc3dpcGVyT2Zmc2V0LnRvcF0sIFtzd2lwZXJPZmZzZXQubGVmdCwgc3dpcGVyT2Zmc2V0LnRvcCArIHN3aXBlckhlaWdodF0sIFtzd2lwZXJPZmZzZXQubGVmdCArIHN3aXBlcldpZHRoLCBzd2lwZXJPZmZzZXQudG9wICsgc3dpcGVySGVpZ2h0XV07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlckNvb3JkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gc3dpcGVyQ29vcmRbaV07XG4gICAgICAgIGlmIChwb2ludFswXSA+PSAwICYmIHBvaW50WzBdIDw9IHdpbmRvd1dpZHRoICYmIHBvaW50WzFdID49IDAgJiYgcG9pbnRbMV0gPD0gd2luZG93SGVpZ2h0KSB7XG4gICAgICAgICAgaWYgKHBvaW50WzBdID09PSAwICYmIHBvaW50WzFdID09PSAwKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIGluVmlldyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaW5WaWV3KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBpZiAoaXNQYWdlVXAgfHwgaXNQYWdlRG93biB8fCBpc0Fycm93TGVmdCB8fCBpc0Fycm93UmlnaHQpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtlbHNlIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICgoaXNQYWdlRG93biB8fCBpc0Fycm93UmlnaHQpICYmICFydGwgfHwgKGlzUGFnZVVwIHx8IGlzQXJyb3dMZWZ0KSAmJiBydGwpIHN3aXBlci5zbGlkZU5leHQoKTtcbiAgICAgIGlmICgoaXNQYWdlVXAgfHwgaXNBcnJvd0xlZnQpICYmICFydGwgfHwgKGlzUGFnZURvd24gfHwgaXNBcnJvd1JpZ2h0KSAmJiBydGwpIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUGFnZVVwIHx8IGlzUGFnZURvd24gfHwgaXNBcnJvd1VwIHx8IGlzQXJyb3dEb3duKSB7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYWdlRG93biB8fCBpc0Fycm93RG93bikgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgaWYgKGlzUGFnZVVwIHx8IGlzQXJyb3dVcCkgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgIH1cbiAgICBlbWl0KCdrZXlQcmVzcycsIGtjKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAoc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHJldHVybjtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlKTtcbiAgICBzd2lwZXIua2V5Ym9hcmQuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBpZiAoIXN3aXBlci5rZXlib2FyZC5lbmFibGVkKSByZXR1cm47XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZSk7XG4gICAgc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5rZXlib2FyZC5lbmFibGVkKSB7XG4gICAgICBlbmFibGUoKTtcbiAgICB9XG4gIH0pO1xuICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLmtleWJvYXJkLmVuYWJsZWQpIHtcbiAgICAgIGRpc2FibGUoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuYXNzaWduKHN3aXBlci5rZXlib2FyZCwge1xuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBLZXlib2FyZCBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBhIGFzIGdldFdpbmRvdyB9IGZyb20gJy4uL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgbiBhcyBuZXh0VGljaywgZCBhcyBub3cgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbmZ1bmN0aW9uIE1vdXNld2hlZWwoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb24sXG4gICAgZW1pdFxuICB9ID0gX3JlZjtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGV4dGVuZFBhcmFtcyh7XG4gICAgbW91c2V3aGVlbDoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICByZWxlYXNlT25FZGdlczogZmFsc2UsXG4gICAgICBpbnZlcnQ6IGZhbHNlLFxuICAgICAgZm9yY2VUb0F4aXM6IGZhbHNlLFxuICAgICAgc2Vuc2l0aXZpdHk6IDEsXG4gICAgICBldmVudHNUYXJnZXQ6ICdjb250YWluZXInLFxuICAgICAgdGhyZXNob2xkRGVsdGE6IG51bGwsXG4gICAgICB0aHJlc2hvbGRUaW1lOiBudWxsLFxuICAgICAgbm9Nb3VzZXdoZWVsQ2xhc3M6ICdzd2lwZXItbm8tbW91c2V3aGVlbCdcbiAgICB9XG4gIH0pO1xuICBzd2lwZXIubW91c2V3aGVlbCA9IHtcbiAgICBlbmFibGVkOiBmYWxzZVxuICB9O1xuICBsZXQgdGltZW91dDtcbiAgbGV0IGxhc3RTY3JvbGxUaW1lID0gbm93KCk7XG4gIGxldCBsYXN0RXZlbnRCZWZvcmVTbmFwO1xuICBjb25zdCByZWNlbnRXaGVlbEV2ZW50cyA9IFtdO1xuICBmdW5jdGlvbiBub3JtYWxpemUoZSkge1xuICAgIC8vIFJlYXNvbmFibGUgZGVmYXVsdHNcbiAgICBjb25zdCBQSVhFTF9TVEVQID0gMTA7XG4gICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICBjb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcbiAgICBsZXQgc1ggPSAwO1xuICAgIGxldCBzWSA9IDA7IC8vIHNwaW5YLCBzcGluWVxuICAgIGxldCBwWCA9IDA7XG4gICAgbGV0IHBZID0gMDsgLy8gcGl4ZWxYLCBwaXhlbFlcblxuICAgIC8vIExlZ2FjeVxuICAgIGlmICgnZGV0YWlsJyBpbiBlKSB7XG4gICAgICBzWSA9IGUuZGV0YWlsO1xuICAgIH1cbiAgICBpZiAoJ3doZWVsRGVsdGEnIGluIGUpIHtcbiAgICAgIHNZID0gLWUud2hlZWxEZWx0YSAvIDEyMDtcbiAgICB9XG4gICAgaWYgKCd3aGVlbERlbHRhWScgaW4gZSkge1xuICAgICAgc1kgPSAtZS53aGVlbERlbHRhWSAvIDEyMDtcbiAgICB9XG4gICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZSkge1xuICAgICAgc1ggPSAtZS53aGVlbERlbHRhWCAvIDEyMDtcbiAgICB9XG5cbiAgICAvLyBzaWRlIHNjcm9sbGluZyBvbiBGRiB3aXRoIERPTU1vdXNlU2Nyb2xsXG4gICAgaWYgKCdheGlzJyBpbiBlICYmIGUuYXhpcyA9PT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcbiAgICAgIHNYID0gc1k7XG4gICAgICBzWSA9IDA7XG4gICAgfVxuICAgIHBYID0gc1ggKiBQSVhFTF9TVEVQO1xuICAgIHBZID0gc1kgKiBQSVhFTF9TVEVQO1xuICAgIGlmICgnZGVsdGFZJyBpbiBlKSB7XG4gICAgICBwWSA9IGUuZGVsdGFZO1xuICAgIH1cbiAgICBpZiAoJ2RlbHRhWCcgaW4gZSkge1xuICAgICAgcFggPSBlLmRlbHRhWDtcbiAgICB9XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIXBYKSB7XG4gICAgICAvLyBpZiB1c2VyIHNjcm9sbHMgd2l0aCBzaGlmdCBoZSB3YW50cyBob3Jpem9udGFsIHNjcm9sbFxuICAgICAgcFggPSBwWTtcbiAgICAgIHBZID0gMDtcbiAgICB9XG4gICAgaWYgKChwWCB8fCBwWSkgJiYgZS5kZWx0YU1vZGUpIHtcbiAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSkge1xuICAgICAgICAvLyBkZWx0YSBpbiBMSU5FIHVuaXRzXG4gICAgICAgIHBYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICBwWSAqPSBMSU5FX0hFSUdIVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbHRhIGluIFBBR0UgdW5pdHNcbiAgICAgICAgcFggKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgIHBZICo9IFBBR0VfSEVJR0hUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gICAgaWYgKHBYICYmICFzWCkge1xuICAgICAgc1ggPSBwWCA8IDEgPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmIChwWSAmJiAhc1kpIHtcbiAgICAgIHNZID0gcFkgPCAxID8gLTEgOiAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3Bpblg6IHNYLFxuICAgICAgc3Bpblk6IHNZLFxuICAgICAgcGl4ZWxYOiBwWCxcbiAgICAgIHBpeGVsWTogcFlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHN3aXBlci5tb3VzZUVudGVyZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTGVhdmUoKSB7XG4gICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHN3aXBlci5tb3VzZUVudGVyZWQgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSAmJiBuZXdFdmVudC5kZWx0YSA8IHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSkge1xuICAgICAgLy8gUHJldmVudCBpZiBkZWx0YSBvZiB3aGVlbCBzY3JvbGwgZGVsdGEgaXMgYmVsb3cgY29uZmlndXJlZCB0aHJlc2hvbGRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGRUaW1lICYmIG5vdygpIC0gbGFzdFNjcm9sbFRpbWUgPCBzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSkge1xuICAgICAgLy8gUHJldmVudCBpZiB0aW1lIGJldHdlZW4gc2Nyb2xscyBpcyBiZWxvdyBjb25maWd1cmVkIHRocmVzaG9sZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBtb3ZlbWVudCBpcyBOT1QgYmlnIGVub3VnaCBhbmRcbiAgICAvLyBpZiB0aGUgbGFzdCB0aW1lIHRoZSB1c2VyIHNjcm9sbGVkIHdhcyB0b28gY2xvc2UgdG8gdGhlIGN1cnJlbnQgb25lIChhdm9pZCBjb250aW51b3VzbHkgdHJpZ2dlcmluZyB0aGUgc2xpZGVyKTpcbiAgICAvLyAgIERvbid0IGdvIGFueSBmdXJ0aGVyIChhdm9pZCBpbnNpZ25pZmljYW50IHNjcm9sbCBtb3ZlbWVudCkuXG4gICAgaWYgKG5ld0V2ZW50LmRlbHRhID49IDYgJiYgbm93KCkgLSBsYXN0U2Nyb2xsVGltZSA8IDYwKSB7XG4gICAgICAvLyBSZXR1cm4gZmFsc2UgYXMgYSBkZWZhdWx0XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gSWYgdXNlciBpcyBzY3JvbGxpbmcgdG93YXJkcyB0aGUgZW5kOlxuICAgIC8vICAgSWYgdGhlIHNsaWRlciBoYXNuJ3QgaGl0IHRoZSBsYXRlc3Qgc2xpZGUgb3JcbiAgICAvLyAgIGlmIHRoZSBzbGlkZXIgaXMgYSBsb29wIGFuZFxuICAgIC8vICAgaWYgdGhlIHNsaWRlciBpc24ndCBtb3ZpbmcgcmlnaHQgbm93OlxuICAgIC8vICAgICBHbyB0byBuZXh0IHNsaWRlIGFuZFxuICAgIC8vICAgICBlbWl0IGEgc2Nyb2xsIGV2ZW50LlxuICAgIC8vIEVsc2UgKHRoZSB1c2VyIGlzIHNjcm9sbGluZyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcpIGFuZFxuICAgIC8vIGlmIHRoZSBzbGlkZXIgaGFzbid0IGhpdCB0aGUgZmlyc3Qgc2xpZGUgb3JcbiAgICAvLyBpZiB0aGUgc2xpZGVyIGlzIGEgbG9vcCBhbmRcbiAgICAvLyBpZiB0aGUgc2xpZGVyIGlzbid0IG1vdmluZyByaWdodCBub3c6XG4gICAgLy8gICBHbyB0byBwcmV2IHNsaWRlIGFuZFxuICAgIC8vICAgZW1pdCBhIHNjcm9sbCBldmVudC5cbiAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uIDwgMCkge1xuICAgICAgaWYgKCghc3dpcGVyLmlzRW5kIHx8IHN3aXBlci5wYXJhbXMubG9vcCkgJiYgIXN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgICAgICBlbWl0KCdzY3JvbGwnLCBuZXdFdmVudC5yYXcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKCFzd2lwZXIuaXNCZWdpbm5pbmcgfHwgc3dpcGVyLnBhcmFtcy5sb29wKSAmJiAhc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgICAgZW1pdCgnc2Nyb2xsJywgbmV3RXZlbnQucmF3KTtcbiAgICB9XG4gICAgLy8gSWYgeW91IGdvdCBoZXJlIGlzIGJlY2F1c2UgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHRyaWdnZXJlZCBzbyBzdG9yZSB0aGUgY3VycmVudCB0aW1lXG4gICAgbGFzdFNjcm9sbFRpbWUgPSBuZXcgd2luZG93LkRhdGUoKS5nZXRUaW1lKCk7XG4gICAgLy8gUmV0dXJuIGZhbHNlIGFzIGEgZGVmYXVsdFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZWxlYXNlU2Nyb2xsKG5ld0V2ZW50KSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xuICAgIGlmIChuZXdFdmVudC5kaXJlY3Rpb24gPCAwKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAgIC8vIFJldHVybiB0cnVlIHRvIGFuaW1hdGUgc2Nyb2xsIG9uIGVkZ2VzXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBhbmltYXRlIHNjcm9sbCBvbiBlZGdlc1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcbiAgICBsZXQgZSA9IGV2ZW50O1xuICAgIGxldCBkaXNhYmxlUGFyZW50U3dpcGVyID0gdHJ1ZTtcbiAgICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG5cbiAgICAvLyBJZ25vcmUgZXZlbnQgaWYgdGhlIHRhcmdldCBvciBpdHMgcGFyZW50cyBoYXZlIHRoZSBzd2lwZXItbm8tbW91c2V3aGVlbCBjbGFzc1xuICAgIGlmIChldmVudC50YXJnZXQuY2xvc2VzdChgLiR7c3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLm5vTW91c2V3aGVlbENsYXNzfWApKSByZXR1cm47XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgbGV0IHRhcmdldEVsID0gc3dpcGVyLmVsO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0ICE9PSAnY29udGFpbmVyJykge1xuICAgICAgdGFyZ2V0RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRFbENvbnRhaW5zVGFyZ2V0ID0gdGFyZ2V0RWwgJiYgdGFyZ2V0RWwuY29udGFpbnMoZS50YXJnZXQpO1xuICAgIGlmICghc3dpcGVyLm1vdXNlRW50ZXJlZCAmJiAhdGFyZ2V0RWxDb250YWluc1RhcmdldCAmJiAhcGFyYW1zLnJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50OyAvLyBqcXVlcnkgZml4XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBjb25zdCBydGxGYWN0b3IgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gLTEgOiAxO1xuICAgIGNvbnN0IGRhdGEgPSBub3JtYWxpemUoZSk7XG4gICAgaWYgKHBhcmFtcy5mb3JjZVRvQXhpcykge1xuICAgICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGF0YS5waXhlbFgpID4gTWF0aC5hYnMoZGF0YS5waXhlbFkpKSBkZWx0YSA9IC1kYXRhLnBpeGVsWCAqIHJ0bEZhY3RvcjtlbHNlIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkYXRhLnBpeGVsWSkgPiBNYXRoLmFicyhkYXRhLnBpeGVsWCkpIGRlbHRhID0gLWRhdGEucGl4ZWxZO2Vsc2UgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhID0gTWF0aC5hYnMoZGF0YS5waXhlbFgpID4gTWF0aC5hYnMoZGF0YS5waXhlbFkpID8gLWRhdGEucGl4ZWxYICogcnRsRmFjdG9yIDogLWRhdGEucGl4ZWxZO1xuICAgIH1cbiAgICBpZiAoZGVsdGEgPT09IDApIHJldHVybiB0cnVlO1xuICAgIGlmIChwYXJhbXMuaW52ZXJ0KSBkZWx0YSA9IC1kZWx0YTtcblxuICAgIC8vIEdldCB0aGUgc2Nyb2xsIHBvc2l0aW9uc1xuICAgIGxldCBwb3NpdGlvbnMgPSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCkgKyBkZWx0YSAqIHBhcmFtcy5zZW5zaXRpdml0eTtcbiAgICBpZiAocG9zaXRpb25zID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb25zID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgIGlmIChwb3NpdGlvbnMgPD0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSBwb3NpdGlvbnMgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG5cbiAgICAvLyBXaGVuIGxvb3AgaXMgdHJ1ZTpcbiAgICAvLyAgICAgdGhlIGRpc2FibGVQYXJlbnRTd2lwZXIgd2lsbCBiZSB0cnVlLlxuICAgIC8vIFdoZW4gbG9vcCBpcyBmYWxzZTpcbiAgICAvLyAgICAgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbnMgaXMgbm90IG9uIGVkZ2UsXG4gICAgLy8gICAgIHRoZW4gdGhlIGRpc2FibGVQYXJlbnRTd2lwZXIgd2lsbCBiZSB0cnVlLlxuICAgIC8vICAgICBpZiB0aGUgc2Nyb2xsIG9uIGVkZ2UgcG9zaXRpb25zLFxuICAgIC8vICAgICB0aGVuIHRoZSBkaXNhYmxlUGFyZW50U3dpcGVyIHdpbGwgYmUgZmFsc2UuXG4gICAgZGlzYWJsZVBhcmVudFN3aXBlciA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHRydWUgOiAhKHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIHx8IHBvc2l0aW9ucyA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKTtcbiAgICBpZiAoZGlzYWJsZVBhcmVudFN3aXBlciAmJiBzd2lwZXIucGFyYW1zLm5lc3RlZCkgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuZnJlZU1vZGUgfHwgIXN3aXBlci5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCkge1xuICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyBldmVudCBpbiBhIHZhcmlhYmxlIHdoaWNoIHN0b3JlcyB0aGUgcmVsZXZhbnQgZGF0YVxuICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICBkZWx0YTogTWF0aC5hYnMoZGVsdGEpLFxuICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSksXG4gICAgICAgIHJhdzogZXZlbnRcbiAgICAgIH07XG5cbiAgICAgIC8vIEtlZXAgdGhlIG1vc3QgcmVjZW50IGV2ZW50c1xuICAgICAgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNoaWZ0KCk7IC8vIG9ubHkgc3RvcmUgdGhlIGxhc3QgTiBldmVudHNcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldkV2ZW50ID0gcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoID8gcmVjZW50V2hlZWxFdmVudHNbcmVjZW50V2hlZWxFdmVudHMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTtcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByZXZpb3VzIHJlY29yZGVkIGV2ZW50OlxuICAgICAgLy8gICBJZiBkaXJlY3Rpb24gaGFzIGNoYW5nZWQgb3JcbiAgICAgIC8vICAgaWYgdGhlIHNjcm9sbCBpcyBxdWlja2VyIHRoYW4gdGhlIHByZXZpb3VzIG9uZTpcbiAgICAgIC8vICAgICBBbmltYXRlIHRoZSBzbGlkZXIuXG4gICAgICAvLyBFbHNlICh0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSB3aGVlbCBpcyBtb3ZlZCk6XG4gICAgICAvLyAgICAgQW5pbWF0ZSB0aGUgc2xpZGVyLlxuICAgICAgaWYgKHByZXZFdmVudCkge1xuICAgICAgICBpZiAobmV3RXZlbnQuZGlyZWN0aW9uICE9PSBwcmV2RXZlbnQuZGlyZWN0aW9uIHx8IG5ld0V2ZW50LmRlbHRhID4gcHJldkV2ZW50LmRlbHRhIHx8IG5ld0V2ZW50LnRpbWUgPiBwcmV2RXZlbnQudGltZSArIDE1MCkge1xuICAgICAgICAgIGFuaW1hdGVTbGlkZXIobmV3RXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRlU2xpZGVyKG5ld0V2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQncyB0aW1lIHRvIHJlbGVhc2UgdGhlIHNjcm9sbDpcbiAgICAgIC8vICAgUmV0dXJuIG5vdyBzbyB5b3UgZG9uJ3QgaGl0IHRoZSBwcmV2ZW50RGVmYXVsdC5cbiAgICAgIGlmIChyZWxlYXNlU2Nyb2xsKG5ld0V2ZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnJlZW1vZGUgb3Igc2Nyb2xsQ29udGFpbmVyOlxuXG4gICAgICAvLyBJZiB3ZSByZWNlbnRseSBzbmFwcGVkIGFmdGVyIGEgbW9tZW50dW0gc2Nyb2xsLCB0aGVuIGlnbm9yZSB3aGVlbCBldmVudHNcbiAgICAgIC8vIHRvIGdpdmUgdGltZSBmb3IgdGhlIGRlY2VsZXJhdGlvbiB0byBmaW5pc2guIFN0b3AgaWdub3JpbmcgYWZ0ZXIgNTAwIG1zZWNzXG4gICAgICAvLyBvciBpZiBpdCdzIGEgbmV3IHNjcm9sbCAobGFyZ2VyIGRlbHRhIG9yIGludmVyc2Ugc2lnbiBhcyBsYXN0IGV2ZW50IGJlZm9yZVxuICAgICAgLy8gYW4gZW5kLW9mLW1vbWVudHVtIHNuYXApLlxuICAgICAgY29uc3QgbmV3RXZlbnQgPSB7XG4gICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICBkZWx0YTogTWF0aC5hYnMoZGVsdGEpLFxuICAgICAgICBkaXJlY3Rpb246IE1hdGguc2lnbihkZWx0YSlcbiAgICAgIH07XG4gICAgICBjb25zdCBpZ25vcmVXaGVlbEV2ZW50cyA9IGxhc3RFdmVudEJlZm9yZVNuYXAgJiYgbmV3RXZlbnQudGltZSA8IGxhc3RFdmVudEJlZm9yZVNuYXAudGltZSArIDUwMCAmJiBuZXdFdmVudC5kZWx0YSA8PSBsYXN0RXZlbnRCZWZvcmVTbmFwLmRlbHRhICYmIG5ld0V2ZW50LmRpcmVjdGlvbiA9PT0gbGFzdEV2ZW50QmVmb3JlU25hcC5kaXJlY3Rpb247XG4gICAgICBpZiAoIWlnbm9yZVdoZWVsRXZlbnRzKSB7XG4gICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKSArIGRlbHRhICogcGFyYW1zLnNlbnNpdGl2aXR5O1xuICAgICAgICBjb25zdCB3YXNCZWdpbm5pbmcgPSBzd2lwZXIuaXNCZWdpbm5pbmc7XG4gICAgICAgIGNvbnN0IHdhc0VuZCA9IHN3aXBlci5pc0VuZDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkgcG9zaXRpb24gPSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHBvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShwb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgaWYgKCF3YXNCZWdpbm5pbmcgJiYgc3dpcGVyLmlzQmVnaW5uaW5nIHx8ICF3YXNFbmQgJiYgc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXdFdmVudC5kaXJlY3Rpb24gPCAwID8gJ25leHQnIDogJ3ByZXYnLFxuICAgICAgICAgICAgYnlNb3VzZXdoZWVsOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XG4gICAgICAgICAgLy8gV2hlbiB3aGVlbCBzY3JvbGxpbmcgc3RhcnRzIHdpdGggc3RpY2t5IChha2Egc25hcCkgZW5hYmxlZCwgdGhlbiBkZXRlY3RcbiAgICAgICAgICAvLyB0aGUgZW5kIG9mIGEgbW9tZW50dW0gc2Nyb2xsIGJ5IHN0b3JpbmcgcmVjZW50IChOPTE1Pykgd2hlZWwgZXZlbnRzLlxuICAgICAgICAgIC8vIDEuIGRvIGFsbCBOIGV2ZW50cyBoYXZlIGRlY3JlYXNpbmcgb3Igc2FtZSAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhP1xuICAgICAgICAgIC8vIDIuIGRpZCBhbGwgTiBldmVudHMgYXJyaXZlIGluIHRoZSBsYXN0IE0gKE09NTAwPykgbXNlY3M/XG4gICAgICAgICAgLy8gMy4gZG9lcyB0aGUgZWFybGllc3QgZXZlbnQgaGF2ZSBhbiAoYWJzb2x1dGUgdmFsdWUpIGRlbHRhIHRoYXQnc1xuICAgICAgICAgIC8vICAgIGF0IGxlYXN0IFAgKFA9MT8pIGxhcmdlciB0aGFuIHRoZSBtb3N0IHJlY2VudCBldmVudCdzIGRlbHRhP1xuICAgICAgICAgIC8vIDQuIGRvZXMgdGhlIGxhdGVzdCBldmVudCBoYXZlIGEgZGVsdGEgdGhhdCdzIHNtYWxsZXIgdGhhbiBRIChRPTY/KSBwaXhlbHM/XG4gICAgICAgICAgLy8gSWYgMS00IGFyZSBcInllc1wiIHRoZW4gd2UncmUgbmVhciB0aGUgZW5kIG9mIGEgbW9tZW50dW0gc2Nyb2xsIGRlY2VsZXJhdGlvbi5cbiAgICAgICAgICAvLyBTbmFwIGltbWVkaWF0ZWx5IGFuZCBpZ25vcmUgcmVtYWluaW5nIHdoZWVsIGV2ZW50cyBpbiB0aGlzIHNjcm9sbC5cbiAgICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBmb3IgXCJyZW1haW5pbmcgd2hlZWwgZXZlbnRzIGluIHRoaXMgc2Nyb2xsXCIgZGV0ZXJtaW5hdGlvbi5cbiAgICAgICAgICAvLyBJZiAxLTQgYXJlbid0IHNhdGlzZmllZCwgdGhlbiB3YWl0IHRvIHNuYXAgdW50aWwgNTAwbXMgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAxNSkge1xuICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc2hpZnQoKTsgLy8gb25seSBzdG9yZSB0aGUgbGFzdCBOIGV2ZW50c1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByZXZFdmVudCA9IHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA/IHJlY2VudFdoZWVsRXZlbnRzW3JlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGZpcnN0RXZlbnQgPSByZWNlbnRXaGVlbEV2ZW50c1swXTtcbiAgICAgICAgICByZWNlbnRXaGVlbEV2ZW50cy5wdXNoKG5ld0V2ZW50KTtcbiAgICAgICAgICBpZiAocHJldkV2ZW50ICYmIChuZXdFdmVudC5kZWx0YSA+IHByZXZFdmVudC5kZWx0YSB8fCBuZXdFdmVudC5kaXJlY3Rpb24gIT09IHByZXZFdmVudC5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyBJbmNyZWFzaW5nIG9yIHJldmVyc2Utc2lnbiBkZWx0YSBtZWFucyB0aGUgdXNlciBzdGFydGVkIHNjcm9sbGluZyBhZ2Fpbi4gQ2xlYXIgdGhlIHdoZWVsIGV2ZW50IGxvZy5cbiAgICAgICAgICAgIHJlY2VudFdoZWVsRXZlbnRzLnNwbGljZSgwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlY2VudFdoZWVsRXZlbnRzLmxlbmd0aCA+PSAxNSAmJiBuZXdFdmVudC50aW1lIC0gZmlyc3RFdmVudC50aW1lIDwgNTAwICYmIGZpcnN0RXZlbnQuZGVsdGEgLSBuZXdFdmVudC5kZWx0YSA+PSAxICYmIG5ld0V2ZW50LmRlbHRhIDw9IDYpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGRlY2VsZXJhdGlvbiBvZiBhIG1vbWVudHVtIHNjcm9sbCwgc28gdGhlcmUncyBubyBuZWVkXG4gICAgICAgICAgICAvLyB0byB3YWl0IGZvciBtb3JlIGV2ZW50cy4gU25hcCBBU0FQIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgICAgICAgICAvLyBBbHNvLCBiZWNhdXNlIHRoZXJlJ3Mgc29tZSByZW1haW5pbmcgbW9tZW50dW0gd2UnbGwgYmlhcyB0aGUgc25hcCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGRpcmVjdGlvbiBvZiB0aGUgb25nb2luZyBzY3JvbGwgYmVjYXVzZSBpdCdzIGJldHRlciBVWCBmb3IgdGhlIHNjcm9sbCB0byBzbmFwXG4gICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhlIHNjcm9sbCBpbnN0ZWFkIG9mIHJldmVyc2luZyB0byBzbmFwLiAgVGhlcmVmb3JlLFxuICAgICAgICAgICAgLy8gaWYgaXQncyBhbHJlYWR5IHNjcm9sbGVkIG1vcmUgdGhhbiAyMCUgaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBrZWVwIGdvaW5nLlxuICAgICAgICAgICAgY29uc3Qgc25hcFRvVGhyZXNob2xkID0gZGVsdGEgPiAwID8gMC44IDogMC4yO1xuICAgICAgICAgICAgbGFzdEV2ZW50QmVmb3JlU25hcCA9IG5ld0V2ZW50O1xuICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgdGltZW91dCA9IG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KHN3aXBlci5wYXJhbXMuc3BlZWQsIHRydWUsIHVuZGVmaW5lZCwgc25hcFRvVGhyZXNob2xkKTtcbiAgICAgICAgICAgIH0sIDApOyAvLyBubyBkZWxheTsgbW92ZSBvbiBuZXh0IHRpY2tcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGdldCBoZXJlLCB0aGVuIHdlIGhhdmVuJ3QgZGV0ZWN0ZWQgdGhlIGVuZCBvZiBhIG1vbWVudHVtIHNjcm9sbCwgc29cbiAgICAgICAgICAgIC8vIHdlJ2xsIGNvbnNpZGVyIGEgc2Nyb2xsIFwiY29tcGxldGVcIiB3aGVuIHRoZXJlIGhhdmVuJ3QgYmVlbiBhbnkgd2hlZWwgZXZlbnRzXG4gICAgICAgICAgICAvLyBmb3IgNTAwbXMuXG4gICAgICAgICAgICB0aW1lb3V0ID0gbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzbmFwVG9UaHJlc2hvbGQgPSAwLjU7XG4gICAgICAgICAgICAgIGxhc3RFdmVudEJlZm9yZVNuYXAgPSBuZXdFdmVudDtcbiAgICAgICAgICAgICAgcmVjZW50V2hlZWxFdmVudHMuc3BsaWNlKDApO1xuICAgICAgICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3Qoc3dpcGVyLnBhcmFtcy5zcGVlZCwgdHJ1ZSwgdW5kZWZpbmVkLCBzbmFwVG9UaHJlc2hvbGQpO1xuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbWl0IGV2ZW50XG4gICAgICAgIGlmICghaWdub3JlV2hlZWxFdmVudHMpIGVtaXQoJ3Njcm9sbCcsIGUpO1xuXG4gICAgICAgIC8vIFN0b3AgYXV0b3BsYXlcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkgJiYgc3dpcGVyLnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uKSBzd2lwZXIuYXV0b3BsYXkuc3RvcCgpO1xuICAgICAgICAvLyBSZXR1cm4gcGFnZSBzY3JvbGwgb24gZWRnZSBwb3NpdGlvbnNcbiAgICAgICAgaWYgKHBhcmFtcy5yZWxlYXNlT25FZGdlcyAmJiAocG9zaXRpb24gPT09IHN3aXBlci5taW5UcmFuc2xhdGUoKSB8fCBwb3NpdGlvbiA9PT0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7ZWxzZSBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICBsZXQgdGFyZ2V0RWwgPSBzd2lwZXIuZWw7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgIT09ICdjb250YWluZXInKSB7XG4gICAgICB0YXJnZXRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCk7XG4gICAgfVxuICAgIHRhcmdldEVsW21ldGhvZF0oJ21vdXNlZW50ZXInLCBoYW5kbGVNb3VzZUVudGVyKTtcbiAgICB0YXJnZXRFbFttZXRob2RdKCdtb3VzZWxlYXZlJywgaGFuZGxlTW91c2VMZWF2ZSk7XG4gICAgdGFyZ2V0RWxbbWV0aG9kXSgnd2hlZWwnLCBoYW5kbGUpO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGV2ZW50cygnYWRkRXZlbnRMaXN0ZW5lcicpO1xuICAgIHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3dpcGVyLm1vdXNld2hlZWwuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGV2ZW50cygncmVtb3ZlRXZlbnRMaXN0ZW5lcicpO1xuICAgIHN3aXBlci5tb3VzZXdoZWVsLmVuYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgZGlzYWJsZSgpO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQpIGVuYWJsZSgpO1xuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgZW5hYmxlKCk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIubW91c2V3aGVlbC5lbmFibGVkKSBkaXNhYmxlKCk7XG4gIH0pO1xuICBPYmplY3QuYXNzaWduKHN3aXBlci5tb3VzZXdoZWVsLCB7XG4gICAgZW5hYmxlLFxuICAgIGRpc2FibGVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE1vdXNld2hlZWwgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZSBhcyBlbGVtZW50Q2hpbGRyZW4sIGMgYXMgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIG9yaWdpbmFsUGFyYW1zLCBwYXJhbXMsIGNoZWNrUHJvcHMpIHtcbiAgaWYgKHN3aXBlci5wYXJhbXMuY3JlYXRlRWxlbWVudHMpIHtcbiAgICBPYmplY3Qua2V5cyhjaGVja1Byb3BzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXBhcmFtc1trZXldICYmIHBhcmFtcy5hdXRvID09PSB0cnVlKSB7XG4gICAgICAgIGxldCBlbGVtZW50ID0gZWxlbWVudENoaWxkcmVuKHN3aXBlci5lbCwgYC4ke2NoZWNrUHJvcHNba2V5XX1gKVswXTtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIGNoZWNrUHJvcHNba2V5XSk7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjaGVja1Byb3BzW2tleV07XG4gICAgICAgICAgc3dpcGVyLmVsLmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXNba2V5XSA9IGVsZW1lbnQ7XG4gICAgICAgIG9yaWdpbmFsUGFyYW1zW2tleV0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQgYXMgYyB9O1xuIiwiaW1wb3J0IHsgYyBhcyBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkIH0gZnJvbSAnLi4vc2hhcmVkL2NyZWF0ZS1lbGVtZW50LWlmLW5vdC1kZWZpbmVkLm1qcyc7XG5pbXBvcnQgeyBtIGFzIG1ha2VFbGVtZW50c0FycmF5IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIE5hdmlnYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb24sXG4gICAgZW1pdFxuICB9ID0gX3JlZjtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICBuZXh0RWw6IG51bGwsXG4gICAgICBwcmV2RWw6IG51bGwsXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICBkaXNhYmxlZENsYXNzOiAnc3dpcGVyLWJ1dHRvbi1kaXNhYmxlZCcsXG4gICAgICBoaWRkZW5DbGFzczogJ3N3aXBlci1idXR0b24taGlkZGVuJyxcbiAgICAgIGxvY2tDbGFzczogJ3N3aXBlci1idXR0b24tbG9jaycsXG4gICAgICBuYXZpZ2F0aW9uRGlzYWJsZWRDbGFzczogJ3N3aXBlci1uYXZpZ2F0aW9uLWRpc2FibGVkJ1xuICAgIH1cbiAgfSk7XG4gIHN3aXBlci5uYXZpZ2F0aW9uID0ge1xuICAgIG5leHRFbDogbnVsbCxcbiAgICBwcmV2RWw6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0RWwoZWwpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChlbCAmJiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnICYmIHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIHJlcyA9IHN3aXBlci5lbC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChlbCkge1xuICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHJlcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsKV07XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnICYmIHJlcyAmJiByZXMubGVuZ3RoID4gMSAmJiBzd2lwZXIuZWwucXVlcnlTZWxlY3RvckFsbChlbCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlcyA9IHN3aXBlci5lbC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzICYmIHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmVzID0gcmVzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWwgJiYgIXJlcykgcmV0dXJuIGVsO1xuICAgIC8vIGlmIChBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmxlbmd0aCA9PT0gMSkgcmVzID0gcmVzWzBdO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZnVuY3Rpb24gdG9nZ2xlRWwoZWwsIGRpc2FibGVkKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uO1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgaWYgKHN1YkVsKSB7XG4gICAgICAgIHN1YkVsLmNsYXNzTGlzdFtkaXNhYmxlZCA/ICdhZGQnIDogJ3JlbW92ZSddKC4uLnBhcmFtcy5kaXNhYmxlZENsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgICBpZiAoc3ViRWwudGFnTmFtZSA9PT0gJ0JVVFRPTicpIHN1YkVsLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgICAgICBzdWJFbC5jbGFzc0xpc3Rbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZCcgOiAncmVtb3ZlJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgLy8gVXBkYXRlIE5hdmlnYXRpb24gQnV0dG9uc1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRFbCxcbiAgICAgIHByZXZFbFxuICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICB0b2dnbGVFbChwcmV2RWwsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUVsKG5leHRFbCwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0b2dnbGVFbChwcmV2RWwsIHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5yZXdpbmQpO1xuICAgIHRvZ2dsZUVsKG5leHRFbCwgc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLnJld2luZCk7XG4gIH1cbiAgZnVuY3Rpb24gb25QcmV2Q2xpY2soZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKSByZXR1cm47XG4gICAgc3dpcGVyLnNsaWRlUHJldigpO1xuICAgIGVtaXQoJ25hdmlnYXRpb25QcmV2Jyk7XG4gIH1cbiAgZnVuY3Rpb24gb25OZXh0Q2xpY2soZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoc3dpcGVyLmlzRW5kICYmICFzd2lwZXIucGFyYW1zLmxvb3AgJiYgIXN3aXBlci5wYXJhbXMucmV3aW5kKSByZXR1cm47XG4gICAgc3dpcGVyLnNsaWRlTmV4dCgpO1xuICAgIGVtaXQoJ25hdmlnYXRpb25OZXh0Jyk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb247XG4gICAgc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uID0gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5uYXZpZ2F0aW9uLCBzd2lwZXIucGFyYW1zLm5hdmlnYXRpb24sIHtcbiAgICAgIG5leHRFbDogJ3N3aXBlci1idXR0b24tbmV4dCcsXG4gICAgICBwcmV2RWw6ICdzd2lwZXItYnV0dG9uLXByZXYnXG4gICAgfSk7XG4gICAgaWYgKCEocGFyYW1zLm5leHRFbCB8fCBwYXJhbXMucHJldkVsKSkgcmV0dXJuO1xuICAgIGxldCBuZXh0RWwgPSBnZXRFbChwYXJhbXMubmV4dEVsKTtcbiAgICBsZXQgcHJldkVsID0gZ2V0RWwocGFyYW1zLnByZXZFbCk7XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIubmF2aWdhdGlvbiwge1xuICAgICAgbmV4dEVsLFxuICAgICAgcHJldkVsXG4gICAgfSk7XG4gICAgbmV4dEVsID0gbWFrZUVsZW1lbnRzQXJyYXkobmV4dEVsKTtcbiAgICBwcmV2RWwgPSBtYWtlRWxlbWVudHNBcnJheShwcmV2RWwpO1xuICAgIGNvbnN0IGluaXRCdXR0b24gPSAoZWwsIGRpcikgPT4ge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGlyID09PSAnbmV4dCcgPyBvbk5leHRDbGljayA6IG9uUHJldkNsaWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3dpcGVyLmVuYWJsZWQgJiYgZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5wYXJhbXMubG9ja0NsYXNzLnNwbGl0KCcgJykpO1xuICAgICAgfVxuICAgIH07XG4gICAgbmV4dEVsLmZvckVhY2goZWwgPT4gaW5pdEJ1dHRvbihlbCwgJ25leHQnKSk7XG4gICAgcHJldkVsLmZvckVhY2goZWwgPT4gaW5pdEJ1dHRvbihlbCwgJ3ByZXYnKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBsZXQge1xuICAgICAgbmV4dEVsLFxuICAgICAgcHJldkVsXG4gICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgIG5leHRFbCA9IG1ha2VFbGVtZW50c0FycmF5KG5leHRFbCk7XG4gICAgcHJldkVsID0gbWFrZUVsZW1lbnRzQXJyYXkocHJldkVsKTtcbiAgICBjb25zdCBkZXN0cm95QnV0dG9uID0gKGVsLCBkaXIpID0+IHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGlyID09PSAnbmV4dCcgPyBvbk5leHRDbGljayA6IG9uUHJldkNsaWNrKTtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgfTtcbiAgICBuZXh0RWwuZm9yRWFjaChlbCA9PiBkZXN0cm95QnV0dG9uKGVsLCAnbmV4dCcpKTtcbiAgICBwcmV2RWwuZm9yRWFjaChlbCA9PiBkZXN0cm95QnV0dG9uKGVsLCAncHJldicpKTtcbiAgfVxuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgb24oJ3RvRWRnZSBmcm9tRWRnZSBsb2NrIHVubG9jaycsICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgIGRlc3Ryb3koKTtcbiAgfSk7XG4gIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmV4dEVsLFxuICAgICAgcHJldkVsXG4gICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uO1xuICAgIG5leHRFbCA9IG1ha2VFbGVtZW50c0FycmF5KG5leHRFbCk7XG4gICAgcHJldkVsID0gbWFrZUVsZW1lbnRzQXJyYXkocHJldkVsKTtcbiAgICBpZiAoc3dpcGVyLmVuYWJsZWQpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbLi4ubmV4dEVsLCAuLi5wcmV2RWxdLmZpbHRlcihlbCA9PiAhIWVsKS5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC5hZGQoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcykpO1xuICB9KTtcbiAgb24oJ2NsaWNrJywgKF9zLCBlKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5leHRFbCxcbiAgICAgIHByZXZFbFxuICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICBuZXh0RWwgPSBtYWtlRWxlbWVudHNBcnJheShuZXh0RWwpO1xuICAgIHByZXZFbCA9IG1ha2VFbGVtZW50c0FycmF5KHByZXZFbCk7XG4gICAgY29uc3QgdGFyZ2V0RWwgPSBlLnRhcmdldDtcbiAgICBsZXQgdGFyZ2V0SXNCdXR0b24gPSBwcmV2RWwuaW5jbHVkZXModGFyZ2V0RWwpIHx8IG5leHRFbC5pbmNsdWRlcyh0YXJnZXRFbCk7XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQgJiYgIXRhcmdldElzQnV0dG9uKSB7XG4gICAgICBjb25zdCBwYXRoID0gZS5wYXRoIHx8IGUuY29tcG9zZWRQYXRoICYmIGUuY29tcG9zZWRQYXRoKCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0YXJnZXRJc0J1dHRvbiA9IHBhdGguZmluZChwYXRoRWwgPT4gbmV4dEVsLmluY2x1ZGVzKHBhdGhFbCkgfHwgcHJldkVsLmluY2x1ZGVzKHBhdGhFbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrICYmICF0YXJnZXRJc0J1dHRvbikge1xuICAgICAgaWYgKHN3aXBlci5wYWdpbmF0aW9uICYmIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIChzd2lwZXIucGFnaW5hdGlvbi5lbCA9PT0gdGFyZ2V0RWwgfHwgc3dpcGVyLnBhZ2luYXRpb24uZWwuY29udGFpbnModGFyZ2V0RWwpKSkgcmV0dXJuO1xuICAgICAgbGV0IGlzSGlkZGVuO1xuICAgICAgaWYgKG5leHRFbC5sZW5ndGgpIHtcbiAgICAgICAgaXNIaWRkZW4gPSBuZXh0RWxbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZFbC5sZW5ndGgpIHtcbiAgICAgICAgaXNIaWRkZW4gPSBwcmV2RWxbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNIaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgZW1pdCgnbmF2aWdhdGlvblNob3cnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXQoJ25hdmlnYXRpb25IaWRlJyk7XG4gICAgICB9XG4gICAgICBbLi4ubmV4dEVsLCAuLi5wcmV2RWxdLmZpbHRlcihlbCA9PiAhIWVsKS5mb3JFYWNoKGVsID0+IGVsLmNsYXNzTGlzdC50b2dnbGUoc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZW5hYmxlID0gKCkgPT4ge1xuICAgIHN3aXBlci5lbC5jbGFzc0xpc3QucmVtb3ZlKC4uLnN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5uYXZpZ2F0aW9uRGlzYWJsZWRDbGFzcy5zcGxpdCgnICcpKTtcbiAgICBpbml0KCk7XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IGRpc2FibGUgPSAoKSA9PiB7XG4gICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoLi4uc3dpcGVyLnBhcmFtcy5uYXZpZ2F0aW9uLm5hdmlnYXRpb25EaXNhYmxlZENsYXNzLnNwbGl0KCcgJykpO1xuICAgIGRlc3Ryb3koKTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIubmF2aWdhdGlvbiwge1xuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlLFxuICAgIHVwZGF0ZSxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE5hdmlnYXRpb24gYXMgZGVmYXVsdCB9O1xuIiwiZnVuY3Rpb24gY2xhc3Nlc1RvU2VsZWN0b3IoY2xhc3Nlcykge1xuICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NlcyA9ICcnO1xuICB9XG4gIHJldHVybiBgLiR7Y2xhc3Nlcy50cmltKCkucmVwbGFjZSgvKFtcXC46IStcXC9dKS9nLCAnXFxcXCQxJykgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAucmVwbGFjZSgvIC9nLCAnLicpfWA7XG59XG5cbmV4cG9ydCB7IGNsYXNzZXNUb1NlbGVjdG9yIGFzIGMgfTtcbiIsImltcG9ydCB7IGMgYXMgY2xhc3Nlc1RvU2VsZWN0b3IgfSBmcm9tICcuLi9zaGFyZWQvY2xhc3Nlcy10by1zZWxlY3Rvci5tanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVFbGVtZW50SWZOb3REZWZpbmVkIH0gZnJvbSAnLi4vc2hhcmVkL2NyZWF0ZS1lbGVtZW50LWlmLW5vdC1kZWZpbmVkLm1qcyc7XG5pbXBvcnQgeyBtIGFzIG1ha2VFbGVtZW50c0FycmF5LCBmIGFzIGVsZW1lbnRPdXRlclNpemUsIGggYXMgZWxlbWVudEluZGV4LCBhIGFzIGVsZW1lbnRQYXJlbnRzIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIFBhZ2luYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb24sXG4gICAgZW1pdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgcGZ4ID0gJ3N3aXBlci1wYWdpbmF0aW9uJztcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBwYWdpbmF0aW9uOiB7XG4gICAgICBlbDogbnVsbCxcbiAgICAgIGJ1bGxldEVsZW1lbnQ6ICdzcGFuJyxcbiAgICAgIGNsaWNrYWJsZTogZmFsc2UsXG4gICAgICBoaWRlT25DbGljazogZmFsc2UsXG4gICAgICByZW5kZXJCdWxsZXQ6IG51bGwsXG4gICAgICByZW5kZXJQcm9ncmVzc2JhcjogbnVsbCxcbiAgICAgIHJlbmRlckZyYWN0aW9uOiBudWxsLFxuICAgICAgcmVuZGVyQ3VzdG9tOiBudWxsLFxuICAgICAgcHJvZ3Jlc3NiYXJPcHBvc2l0ZTogZmFsc2UsXG4gICAgICB0eXBlOiAnYnVsbGV0cycsXG4gICAgICAvLyAnYnVsbGV0cycgb3IgJ3Byb2dyZXNzYmFyJyBvciAnZnJhY3Rpb24nIG9yICdjdXN0b20nXG4gICAgICBkeW5hbWljQnVsbGV0czogZmFsc2UsXG4gICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXG4gICAgICBmb3JtYXRGcmFjdGlvbkN1cnJlbnQ6IG51bWJlciA9PiBudW1iZXIsXG4gICAgICBmb3JtYXRGcmFjdGlvblRvdGFsOiBudW1iZXIgPT4gbnVtYmVyLFxuICAgICAgYnVsbGV0Q2xhc3M6IGAke3BmeH0tYnVsbGV0YCxcbiAgICAgIGJ1bGxldEFjdGl2ZUNsYXNzOiBgJHtwZnh9LWJ1bGxldC1hY3RpdmVgLFxuICAgICAgbW9kaWZpZXJDbGFzczogYCR7cGZ4fS1gLFxuICAgICAgY3VycmVudENsYXNzOiBgJHtwZnh9LWN1cnJlbnRgLFxuICAgICAgdG90YWxDbGFzczogYCR7cGZ4fS10b3RhbGAsXG4gICAgICBoaWRkZW5DbGFzczogYCR7cGZ4fS1oaWRkZW5gLFxuICAgICAgcHJvZ3Jlc3NiYXJGaWxsQ2xhc3M6IGAke3BmeH0tcHJvZ3Jlc3NiYXItZmlsbGAsXG4gICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3M6IGAke3BmeH0tcHJvZ3Jlc3NiYXItb3Bwb3NpdGVgLFxuICAgICAgY2xpY2thYmxlQ2xhc3M6IGAke3BmeH0tY2xpY2thYmxlYCxcbiAgICAgIGxvY2tDbGFzczogYCR7cGZ4fS1sb2NrYCxcbiAgICAgIGhvcml6b250YWxDbGFzczogYCR7cGZ4fS1ob3Jpem9udGFsYCxcbiAgICAgIHZlcnRpY2FsQ2xhc3M6IGAke3BmeH0tdmVydGljYWxgLFxuICAgICAgcGFnaW5hdGlvbkRpc2FibGVkQ2xhc3M6IGAke3BmeH0tZGlzYWJsZWRgXG4gICAgfVxuICB9KTtcbiAgc3dpcGVyLnBhZ2luYXRpb24gPSB7XG4gICAgZWw6IG51bGwsXG4gICAgYnVsbGV0czogW11cbiAgfTtcbiAgbGV0IGJ1bGxldFNpemU7XG4gIGxldCBkeW5hbWljQnVsbGV0SW5kZXggPSAwO1xuICBmdW5jdGlvbiBpc1BhZ2luYXRpb25EaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gIXN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwgfHwgQXJyYXkuaXNBcnJheShzd2lwZXIucGFnaW5hdGlvbi5lbCkgJiYgc3dpcGVyLnBhZ2luYXRpb24uZWwubGVuZ3RoID09PSAwO1xuICB9XG4gIGZ1bmN0aW9uIHNldFNpZGVCdWxsZXRzKGJ1bGxldEVsLCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1bGxldEFjdGl2ZUNsYXNzXG4gICAgfSA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICBpZiAoIWJ1bGxldEVsKSByZXR1cm47XG4gICAgYnVsbGV0RWwgPSBidWxsZXRFbFtgJHtwb3NpdGlvbiA9PT0gJ3ByZXYnID8gJ3ByZXZpb3VzJyA6ICduZXh0J31FbGVtZW50U2libGluZ2BdO1xuICAgIGlmIChidWxsZXRFbCkge1xuICAgICAgYnVsbGV0RWwuY2xhc3NMaXN0LmFkZChgJHtidWxsZXRBY3RpdmVDbGFzc30tJHtwb3NpdGlvbn1gKTtcbiAgICAgIGJ1bGxldEVsID0gYnVsbGV0RWxbYCR7cG9zaXRpb24gPT09ICdwcmV2JyA/ICdwcmV2aW91cycgOiAnbmV4dCd9RWxlbWVudFNpYmxpbmdgXTtcbiAgICAgIGlmIChidWxsZXRFbCkge1xuICAgICAgICBidWxsZXRFbC5jbGFzc0xpc3QuYWRkKGAke2J1bGxldEFjdGl2ZUNsYXNzfS0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkJ1bGxldENsaWNrKGUpIHtcbiAgICBjb25zdCBidWxsZXRFbCA9IGUudGFyZ2V0LmNsb3Nlc3QoY2xhc3Nlc1RvU2VsZWN0b3Ioc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSk7XG4gICAgaWYgKCFidWxsZXRFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgaW5kZXggPSBlbGVtZW50SW5kZXgoYnVsbGV0RWwpICogc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICBpZiAoc3dpcGVyLnJlYWxJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgIHN3aXBlci5zbGlkZVRvTG9vcChpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIC8vIFJlbmRlciB8fCBVcGRhdGUgUGFnaW5hdGlvbiBidWxsZXRzL2l0ZW1zXG4gICAgY29uc3QgcnRsID0gc3dpcGVyLnJ0bDtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICBsZXQgZWwgPSBzd2lwZXIucGFnaW5hdGlvbi5lbDtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICAvLyBDdXJyZW50L1RvdGFsXG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgbGV0IHByZXZpb3VzSW5kZXg7XG4gICAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogc3dpcGVyLnNsaWRlcy5sZW5ndGg7XG4gICAgY29uc3QgdG90YWwgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoc2xpZGVzTGVuZ3RoIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiBzd2lwZXIuc25hcEdyaWQubGVuZ3RoO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgIHByZXZpb3VzSW5kZXggPSBzd2lwZXIucHJldmlvdXNSZWFsSW5kZXggfHwgMDtcbiAgICAgIGN1cnJlbnQgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSA/IE1hdGguZmxvb3Ioc3dpcGVyLnJlYWxJbmRleCAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogc3dpcGVyLnJlYWxJbmRleDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY3VycmVudCA9IHN3aXBlci5zbmFwSW5kZXg7XG4gICAgICBwcmV2aW91c0luZGV4ID0gc3dpcGVyLnByZXZpb3VzU25hcEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0luZGV4ID0gc3dpcGVyLnByZXZpb3VzSW5kZXggfHwgMDtcbiAgICAgIGN1cnJlbnQgPSBzd2lwZXIuYWN0aXZlSW5kZXggfHwgMDtcbiAgICB9XG4gICAgLy8gVHlwZXNcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVsbGV0cyA9IHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHM7XG4gICAgICBsZXQgZmlyc3RJbmRleDtcbiAgICAgIGxldCBsYXN0SW5kZXg7XG4gICAgICBsZXQgbWlkSW5kZXg7XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIGJ1bGxldFNpemUgPSBlbGVtZW50T3V0ZXJTaXplKGJ1bGxldHNbMF0sIHN3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgICAgIHN1YkVsLnN0eWxlW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gPSBgJHtidWxsZXRTaXplICogKHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KX1weGA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyA+IDEgJiYgcHJldmlvdXNJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ICs9IGN1cnJlbnQgLSAocHJldmlvdXNJbmRleCB8fCAwKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0J1bGxldEluZGV4ID4gcGFyYW1zLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpIHtcbiAgICAgICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleCA9IHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0J1bGxldEluZGV4IDwgMCkge1xuICAgICAgICAgICAgZHluYW1pY0J1bGxldEluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RJbmRleCA9IE1hdGgubWF4KGN1cnJlbnQgLSBkeW5hbWljQnVsbGV0SW5kZXgsIDApO1xuICAgICAgICBsYXN0SW5kZXggPSBmaXJzdEluZGV4ICsgKE1hdGgubWluKGJ1bGxldHMubGVuZ3RoLCBwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzKSAtIDEpO1xuICAgICAgICBtaWRJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSAvIDI7XG4gICAgICB9XG4gICAgICBidWxsZXRzLmZvckVhY2goYnVsbGV0RWwgPT4ge1xuICAgICAgICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbLi4uWycnLCAnLW5leHQnLCAnLW5leHQtbmV4dCcsICctcHJldicsICctcHJldi1wcmV2JywgJy1tYWluJ10ubWFwKHN1ZmZpeCA9PiBgJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9JHtzdWZmaXh9YCldLm1hcChzID0+IHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBzLmluY2x1ZGVzKCcgJykgPyBzLnNwbGl0KCcgJykgOiBzKS5mbGF0KCk7XG4gICAgICAgIGJ1bGxldEVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYnVsbGV0cy5mb3JFYWNoKGJ1bGxldCA9PiB7XG4gICAgICAgICAgY29uc3QgYnVsbGV0SW5kZXggPSBlbGVtZW50SW5kZXgoYnVsbGV0KTtcbiAgICAgICAgICBpZiAoYnVsbGV0SW5kZXggPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGJ1bGxldC5jbGFzc0xpc3QuYWRkKC4uLnBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGJ1bGxldC5zZXRBdHRyaWJ1dGUoJ3BhcnQnLCAnYnVsbGV0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA+PSBmaXJzdEluZGV4ICYmIGJ1bGxldEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICBidWxsZXQuY2xhc3NMaXN0LmFkZCguLi5gJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1bGxldEluZGV4ID09PSBmaXJzdEluZGV4KSB7XG4gICAgICAgICAgICAgIHNldFNpZGVCdWxsZXRzKGJ1bGxldCwgJ3ByZXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWxsZXRJbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgIHNldFNpZGVCdWxsZXRzKGJ1bGxldCwgJ25leHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVsbGV0ID0gYnVsbGV0c1tjdXJyZW50XTtcbiAgICAgICAgaWYgKGJ1bGxldCkge1xuICAgICAgICAgIGJ1bGxldC5jbGFzc0xpc3QuYWRkKC4uLnBhcmFtcy5idWxsZXRBY3RpdmVDbGFzcy5zcGxpdCgnICcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgICAgIGJ1bGxldHMuZm9yRWFjaCgoYnVsbGV0RWwsIGJ1bGxldEluZGV4KSA9PiB7XG4gICAgICAgICAgICBidWxsZXRFbC5zZXRBdHRyaWJ1dGUoJ3BhcnQnLCBidWxsZXRJbmRleCA9PT0gY3VycmVudCA/ICdidWxsZXQtYWN0aXZlJyA6ICdidWxsZXQnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3REaXNwbGF5ZWRCdWxsZXQgPSBidWxsZXRzW2ZpcnN0SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGxhc3REaXNwbGF5ZWRCdWxsZXQgPSBidWxsZXRzW2xhc3RJbmRleF07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0SW5kZXg7IGkgPD0gbGFzdEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChidWxsZXRzW2ldKSB7XG4gICAgICAgICAgICAgIGJ1bGxldHNbaV0uY2xhc3NMaXN0LmFkZCguLi5gJHtwYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRTaWRlQnVsbGV0cyhmaXJzdERpc3BsYXllZEJ1bGxldCwgJ3ByZXYnKTtcbiAgICAgICAgICBzZXRTaWRlQnVsbGV0cyhsYXN0RGlzcGxheWVkQnVsbGV0LCAnbmV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmR5bmFtaWNCdWxsZXRzKSB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNCdWxsZXRzTGVuZ3RoID0gTWF0aC5taW4oYnVsbGV0cy5sZW5ndGgsIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KTtcbiAgICAgICAgY29uc3QgYnVsbGV0c09mZnNldCA9IChidWxsZXRTaXplICogZHluYW1pY0J1bGxldHNMZW5ndGggLSBidWxsZXRTaXplKSAvIDIgLSBtaWRJbmRleCAqIGJ1bGxldFNpemU7XG4gICAgICAgIGNvbnN0IG9mZnNldFByb3AgPSBydGwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICBidWxsZXRzLmZvckVhY2goYnVsbGV0ID0+IHtcbiAgICAgICAgICBidWxsZXQuc3R5bGVbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gb2Zmc2V0UHJvcCA6ICd0b3AnXSA9IGAke2J1bGxldHNPZmZzZXR9cHhgO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuZm9yRWFjaCgoc3ViRWwsIHN1YkVsSW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICBzdWJFbC5xdWVyeVNlbGVjdG9yQWxsKGNsYXNzZXNUb1NlbGVjdG9yKHBhcmFtcy5jdXJyZW50Q2xhc3MpKS5mb3JFYWNoKGZyYWN0aW9uRWwgPT4ge1xuICAgICAgICAgIGZyYWN0aW9uRWwudGV4dENvbnRlbnQgPSBwYXJhbXMuZm9ybWF0RnJhY3Rpb25DdXJyZW50KGN1cnJlbnQgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YkVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLnRvdGFsQ2xhc3MpKS5mb3JFYWNoKHRvdGFsRWwgPT4ge1xuICAgICAgICAgIHRvdGFsRWwudGV4dENvbnRlbnQgPSBwYXJhbXMuZm9ybWF0RnJhY3Rpb25Ub3RhbCh0b3RhbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XG4gICAgICAgIGxldCBwcm9ncmVzc2JhckRpcmVjdGlvbjtcbiAgICAgICAgaWYgKHBhcmFtcy5wcm9ncmVzc2Jhck9wcG9zaXRlKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyZXNzYmFyRGlyZWN0aW9uID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsZSA9IChjdXJyZW50ICsgMSkgLyB0b3RhbDtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDE7XG4gICAgICAgIGxldCBzY2FsZVkgPSAxO1xuICAgICAgICBpZiAocHJvZ3Jlc3NiYXJEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHN1YkVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3Nlc1RvU2VsZWN0b3IocGFyYW1zLnByb2dyZXNzYmFyRmlsbENsYXNzKSkuZm9yRWFjaChwcm9ncmVzc0VsID0+IHtcbiAgICAgICAgICBwcm9ncmVzc0VsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGVYKCR7c2NhbGVYfSkgc2NhbGVZKCR7c2NhbGVZfSlgO1xuICAgICAgICAgIHByb2dyZXNzRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7c3dpcGVyLnBhcmFtcy5zcGVlZH1tc2A7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy50eXBlID09PSAnY3VzdG9tJyAmJiBwYXJhbXMucmVuZGVyQ3VzdG9tKSB7XG4gICAgICAgIHN1YkVsLmlubmVySFRNTCA9IHBhcmFtcy5yZW5kZXJDdXN0b20oc3dpcGVyLCBjdXJyZW50ICsgMSwgdG90YWwpO1xuICAgICAgICBpZiAoc3ViRWxJbmRleCA9PT0gMCkgZW1pdCgncGFnaW5hdGlvblJlbmRlcicsIHN1YkVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdWJFbEluZGV4ID09PSAwKSBlbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgc3ViRWwpO1xuICAgICAgICBlbWl0KCdwYWdpbmF0aW9uVXBkYXRlJywgc3ViRWwpO1xuICAgICAgfVxuICAgICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgICBzdWJFbC5jbGFzc0xpc3Rbc3dpcGVyLmlzTG9ja2VkID8gJ2FkZCcgOiAncmVtb3ZlJ10ocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIC8vIFJlbmRlciBDb250YWluZXJcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzd2lwZXIuZ3JpZCAmJiBzd2lwZXIucGFyYW1zLmdyaWQucm93cyA+IDEgPyBzd2lwZXIuc2xpZGVzLmxlbmd0aCAvIE1hdGguY2VpbChzd2lwZXIucGFyYW1zLmdyaWQucm93cykgOiBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICBsZXQgZWwgPSBzd2lwZXIucGFnaW5hdGlvbi5lbDtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBsZXQgcGFnaW5hdGlvbkhUTUwgPSAnJztcbiAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJykge1xuICAgICAgbGV0IG51bWJlck9mQnVsbGV0cyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IE1hdGguY2VpbChzbGlkZXNMZW5ndGggLyBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mcmVlTW9kZSAmJiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgbnVtYmVyT2ZCdWxsZXRzID4gc2xpZGVzTGVuZ3RoKSB7XG4gICAgICAgIG51bWJlck9mQnVsbGV0cyA9IHNsaWRlc0xlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZCdWxsZXRzOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5yZW5kZXJCdWxsZXQpIHtcbiAgICAgICAgICBwYWdpbmF0aW9uSFRNTCArPSBwYXJhbXMucmVuZGVyQnVsbGV0LmNhbGwoc3dpcGVyLCBpLCBwYXJhbXMuYnVsbGV0Q2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgIHBhZ2luYXRpb25IVE1MICs9IGA8JHtwYXJhbXMuYnVsbGV0RWxlbWVudH0gJHtzd2lwZXIuaXNFbGVtZW50ID8gJ3BhcnQ9XCJidWxsZXRcIicgOiAnJ30gY2xhc3M9XCIke3BhcmFtcy5idWxsZXRDbGFzc31cIj48LyR7cGFyYW1zLmJ1bGxldEVsZW1lbnR9PmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnZnJhY3Rpb24nKSB7XG4gICAgICBpZiAocGFyYW1zLnJlbmRlckZyYWN0aW9uKSB7XG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlckZyYWN0aW9uLmNhbGwoc3dpcGVyLCBwYXJhbXMuY3VycmVudENsYXNzLCBwYXJhbXMudG90YWxDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWdpbmF0aW9uSFRNTCA9IGA8c3BhbiBjbGFzcz1cIiR7cGFyYW1zLmN1cnJlbnRDbGFzc31cIj48L3NwYW4+YCArICcgLyAnICsgYDxzcGFuIGNsYXNzPVwiJHtwYXJhbXMudG90YWxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAncHJvZ3Jlc3NiYXInKSB7XG4gICAgICBpZiAocGFyYW1zLnJlbmRlclByb2dyZXNzYmFyKSB7XG4gICAgICAgIHBhZ2luYXRpb25IVE1MID0gcGFyYW1zLnJlbmRlclByb2dyZXNzYmFyLmNhbGwoc3dpcGVyLCBwYXJhbXMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFnaW5hdGlvbkhUTUwgPSBgPHNwYW4gY2xhc3M9XCIke3BhcmFtcy5wcm9ncmVzc2JhckZpbGxDbGFzc31cIj48L3NwYW4+YDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cyA9IFtdO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgaWYgKHBhcmFtcy50eXBlICE9PSAnY3VzdG9tJykge1xuICAgICAgICBzdWJFbC5pbm5lckhUTUwgPSBwYWdpbmF0aW9uSFRNTCB8fCAnJztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnKSB7XG4gICAgICAgIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMucHVzaCguLi5zdWJFbC5xdWVyeVNlbGVjdG9yQWxsKGNsYXNzZXNUb1NlbGVjdG9yKHBhcmFtcy5idWxsZXRDbGFzcykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdjdXN0b20nKSB7XG4gICAgICBlbWl0KCdwYWdpbmF0aW9uUmVuZGVyJywgZWxbMF0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbiA9IGNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQoc3dpcGVyLCBzd2lwZXIub3JpZ2luYWxQYXJhbXMucGFnaW5hdGlvbiwgc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLCB7XG4gICAgICBlbDogJ3N3aXBlci1wYWdpbmF0aW9uJ1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbjtcbiAgICBpZiAoIXBhcmFtcy5lbCkgcmV0dXJuO1xuICAgIGxldCBlbDtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgZWwgPSBzd2lwZXIuZWwucXVlcnlTZWxlY3RvcihwYXJhbXMuZWwpO1xuICAgIH1cbiAgICBpZiAoIWVsICYmIHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbCA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtcy5lbCldO1xuICAgIH1cbiAgICBpZiAoIWVsKSB7XG4gICAgICBlbCA9IHBhcmFtcy5lbDtcbiAgICB9XG4gICAgaWYgKCFlbCB8fCBlbC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KGVsKSAmJiBlbC5sZW5ndGggPiAxKSB7XG4gICAgICBlbCA9IFsuLi5zd2lwZXIuZWwucXVlcnlTZWxlY3RvckFsbChwYXJhbXMuZWwpXTtcbiAgICAgIC8vIGNoZWNrIGlmIGl0IGJlbG9uZ3MgdG8gYW5vdGhlciBuZXN0ZWQgU3dpcGVyXG4gICAgICBpZiAoZWwubGVuZ3RoID4gMSkge1xuICAgICAgICBlbCA9IGVsLmZpbHRlcihzdWJFbCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRQYXJlbnRzKHN1YkVsLCAnLnN3aXBlcicpWzBdICE9PSBzd2lwZXIuZWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSAmJiBlbC5sZW5ndGggPT09IDEpIGVsID0gZWxbMF07XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIucGFnaW5hdGlvbiwge1xuICAgICAgZWxcbiAgICB9KTtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBlbC5mb3JFYWNoKHN1YkVsID0+IHtcbiAgICAgIGlmIChwYXJhbXMudHlwZSA9PT0gJ2J1bGxldHMnICYmIHBhcmFtcy5jbGlja2FibGUpIHtcbiAgICAgICAgc3ViRWwuY2xhc3NMaXN0LmFkZCguLi4ocGFyYW1zLmNsaWNrYWJsZUNsYXNzIHx8ICcnKS5zcGxpdCgnICcpKTtcbiAgICAgIH1cbiAgICAgIHN1YkVsLmNsYXNzTGlzdC5hZGQocGFyYW1zLm1vZGlmaWVyQ2xhc3MgKyBwYXJhbXMudHlwZSk7XG4gICAgICBzdWJFbC5jbGFzc0xpc3QuYWRkKHN3aXBlci5pc0hvcml6b250YWwoKSA/IHBhcmFtcy5ob3Jpem9udGFsQ2xhc3MgOiBwYXJhbXMudmVydGljYWxDbGFzcyk7XG4gICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdidWxsZXRzJyAmJiBwYXJhbXMuZHluYW1pY0J1bGxldHMpIHtcbiAgICAgICAgc3ViRWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMubW9kaWZpZXJDbGFzc30ke3BhcmFtcy50eXBlfS1keW5hbWljYCk7XG4gICAgICAgIGR5bmFtaWNCdWxsZXRJbmRleCA9IDA7XG4gICAgICAgIGlmIChwYXJhbXMuZHluYW1pY01haW5CdWxsZXRzIDwgMSkge1xuICAgICAgICAgIHBhcmFtcy5keW5hbWljTWFpbkJ1bGxldHMgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnR5cGUgPT09ICdwcm9ncmVzc2JhcicgJiYgcGFyYW1zLnByb2dyZXNzYmFyT3Bwb3NpdGUpIHtcbiAgICAgICAgc3ViRWwuY2xhc3NMaXN0LmFkZChwYXJhbXMucHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuY2xpY2thYmxlKSB7XG4gICAgICAgIHN1YkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25CdWxsZXRDbGljayk7XG4gICAgICB9XG4gICAgICBpZiAoIXN3aXBlci5lbmFibGVkKSB7XG4gICAgICAgIHN1YkVsLmNsYXNzTGlzdC5hZGQocGFyYW1zLmxvY2tDbGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgaWYgKGlzUGFnaW5hdGlvbkRpc2FibGVkKCkpIHJldHVybjtcbiAgICBsZXQgZWwgPSBzd2lwZXIucGFnaW5hdGlvbi5lbDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgICAgZWwuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICAgIHN1YkVsLmNsYXNzTGlzdC5yZW1vdmUocGFyYW1zLmhpZGRlbkNsYXNzKTtcbiAgICAgICAgc3ViRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMubW9kaWZpZXJDbGFzcyArIHBhcmFtcy50eXBlKTtcbiAgICAgICAgc3ViRWwuY2xhc3NMaXN0LnJlbW92ZShzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuICAgICAgICBpZiAocGFyYW1zLmNsaWNrYWJsZSkge1xuICAgICAgICAgIHN1YkVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uKHBhcmFtcy5jbGlja2FibGVDbGFzcyB8fCAnJykuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgc3ViRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkJ1bGxldENsaWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzKSBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzLmZvckVhY2goc3ViRWwgPT4gc3ViRWwuY2xhc3NMaXN0LnJlbW92ZSguLi5wYXJhbXMuYnVsbGV0QWN0aXZlQ2xhc3Muc3BsaXQoJyAnKSkpO1xuICB9XG4gIG9uKCdjaGFuZ2VEaXJlY3Rpb24nLCAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIucGFnaW5hdGlvbiB8fCAhc3dpcGVyLnBhZ2luYXRpb24uZWwpIHJldHVybjtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIGVsXG4gICAgfSA9IHN3aXBlci5wYWdpbmF0aW9uO1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgc3ViRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMuaG9yaXpvbnRhbENsYXNzLCBwYXJhbXMudmVydGljYWxDbGFzcyk7XG4gICAgICBzdWJFbC5jbGFzc0xpc3QuYWRkKHN3aXBlci5pc0hvcml6b250YWwoKSA/IHBhcmFtcy5ob3Jpem9udGFsQ2xhc3MgOiBwYXJhbXMudmVydGljYWxDbGFzcyk7XG4gICAgfSk7XG4gIH0pO1xuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCgpO1xuICAgICAgcmVuZGVyKCk7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICBvbignYWN0aXZlSW5kZXhDaGFuZ2UnLCAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzd2lwZXIuc25hcEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgb24oJ3NuYXBJbmRleENoYW5nZScsICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIG9uKCdzbmFwR3JpZExlbmd0aENoYW5nZScsICgpID0+IHtcbiAgICByZW5kZXIoKTtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgIGRlc3Ryb3koKTtcbiAgfSk7XG4gIG9uKCdlbmFibGUgZGlzYWJsZScsICgpID0+IHtcbiAgICBsZXQge1xuICAgICAgZWxcbiAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICAgIGVsLmZvckVhY2goc3ViRWwgPT4gc3ViRWwuY2xhc3NMaXN0W3N3aXBlci5lbmFibGVkID8gJ3JlbW92ZScgOiAnYWRkJ10oc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLmxvY2tDbGFzcykpO1xuICAgIH1cbiAgfSk7XG4gIG9uKCdsb2NrIHVubG9jaycsICgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIG9uKCdjbGljaycsIChfcywgZSkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEVsID0gZS50YXJnZXQ7XG4gICAgY29uc3QgZWwgPSBtYWtlRWxlbWVudHNBcnJheShzd2lwZXIucGFnaW5hdGlvbi5lbCk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5lbCAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2sgJiYgZWwgJiYgZWwubGVuZ3RoID4gMCAmJiAhdGFyZ2V0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcykpIHtcbiAgICAgIGlmIChzd2lwZXIubmF2aWdhdGlvbiAmJiAoc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsICYmIHRhcmdldEVsID09PSBzd2lwZXIubmF2aWdhdGlvbi5wcmV2RWwpKSByZXR1cm47XG4gICAgICBjb25zdCBpc0hpZGRlbiA9IGVsWzBdLmNsYXNzTGlzdC5jb250YWlucyhzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xuICAgICAgaWYgKGlzSGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgIGVtaXQoJ3BhZ2luYXRpb25TaG93Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0KCdwYWdpbmF0aW9uSGlkZScpO1xuICAgICAgfVxuICAgICAgZWwuZm9yRWFjaChzdWJFbCA9PiBzdWJFbC5jbGFzc0xpc3QudG9nZ2xlKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5oaWRkZW5DbGFzcykpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGVuYWJsZSA9ICgpID0+IHtcbiAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LnJlbW92ZShzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpO1xuICAgIGxldCB7XG4gICAgICBlbFxuICAgIH0gPSBzd2lwZXIucGFnaW5hdGlvbjtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgICAgZWwuZm9yRWFjaChzdWJFbCA9PiBzdWJFbC5jbGFzc0xpc3QucmVtb3ZlKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcykpO1xuICAgIH1cbiAgICBpbml0KCk7XG4gICAgcmVuZGVyKCk7XG4gICAgdXBkYXRlKCk7XG4gIH07XG4gIGNvbnN0IGRpc2FibGUgPSAoKSA9PiB7XG4gICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKTtcbiAgICBsZXQge1xuICAgICAgZWxcbiAgICB9ID0gc3dpcGVyLnBhZ2luYXRpb247XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICAgIGVsLmZvckVhY2goc3ViRWwgPT4gc3ViRWwuY2xhc3NMaXN0LmFkZChzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN3aXBlci5wYWdpbmF0aW9uLCB7XG4gICAgZW5hYmxlLFxuICAgIGRpc2FibGUsXG4gICAgcmVuZGVyLFxuICAgIHVwZGF0ZSxcbiAgICBpbml0LFxuICAgIGRlc3Ryb3lcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFBhZ2luYXRpb24gYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZyBhcyBnZXREb2N1bWVudCB9IGZyb20gJy4uL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgbSBhcyBtYWtlRWxlbWVudHNBcnJheSwgaSBhcyBjbGFzc2VzVG9Ub2tlbnMsIGMgYXMgY3JlYXRlRWxlbWVudCwgbiBhcyBuZXh0VGljaywgYiBhcyBlbGVtZW50T2Zmc2V0IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBjIGFzIGNyZWF0ZUVsZW1lbnRJZk5vdERlZmluZWQgfSBmcm9tICcuLi9zaGFyZWQvY3JlYXRlLWVsZW1lbnQtaWYtbm90LWRlZmluZWQubWpzJztcbmltcG9ydCB7IGMgYXMgY2xhc3Nlc1RvU2VsZWN0b3IgfSBmcm9tICcuLi9zaGFyZWQvY2xhc3Nlcy10by1zZWxlY3Rvci5tanMnO1xuXG5mdW5jdGlvbiBTY3JvbGxiYXIoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb24sXG4gICAgZW1pdFxuICB9ID0gX3JlZjtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBsZXQgaXNUb3VjaGVkID0gZmFsc2U7XG4gIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgbGV0IGRyYWdUaW1lb3V0ID0gbnVsbDtcbiAgbGV0IGRyYWdTdGFydFBvcztcbiAgbGV0IGRyYWdTaXplO1xuICBsZXQgdHJhY2tTaXplO1xuICBsZXQgZGl2aWRlcjtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBzY3JvbGxiYXI6IHtcbiAgICAgIGVsOiBudWxsLFxuICAgICAgZHJhZ1NpemU6ICdhdXRvJyxcbiAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgIHNuYXBPblJlbGVhc2U6IHRydWUsXG4gICAgICBsb2NrQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWxvY2snLFxuICAgICAgZHJhZ0NsYXNzOiAnc3dpcGVyLXNjcm9sbGJhci1kcmFnJyxcbiAgICAgIHNjcm9sbGJhckRpc2FibGVkQ2xhc3M6ICdzd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkJyxcbiAgICAgIGhvcml6b250YWxDbGFzczogYHN3aXBlci1zY3JvbGxiYXItaG9yaXpvbnRhbGAsXG4gICAgICB2ZXJ0aWNhbENsYXNzOiBgc3dpcGVyLXNjcm9sbGJhci12ZXJ0aWNhbGBcbiAgICB9XG4gIH0pO1xuICBzd2lwZXIuc2Nyb2xsYmFyID0ge1xuICAgIGVsOiBudWxsLFxuICAgIGRyYWdFbDogbnVsbFxuICB9O1xuICBmdW5jdGlvbiBzZXRUcmFuc2xhdGUoKSB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbGJhcixcbiAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCB7XG4gICAgICBkcmFnRWwsXG4gICAgICBlbFxuICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBzd2lwZXIucHJvZ3Jlc3NMb29wIDogc3dpcGVyLnByb2dyZXNzO1xuICAgIGxldCBuZXdTaXplID0gZHJhZ1NpemU7XG4gICAgbGV0IG5ld1BvcyA9ICh0cmFja1NpemUgLSBkcmFnU2l6ZSkgKiBwcm9ncmVzcztcbiAgICBpZiAocnRsKSB7XG4gICAgICBuZXdQb3MgPSAtbmV3UG9zO1xuICAgICAgaWYgKG5ld1BvcyA+IDApIHtcbiAgICAgICAgbmV3U2l6ZSA9IGRyYWdTaXplIC0gbmV3UG9zO1xuICAgICAgICBuZXdQb3MgPSAwO1xuICAgICAgfSBlbHNlIGlmICgtbmV3UG9zICsgZHJhZ1NpemUgPiB0cmFja1NpemUpIHtcbiAgICAgICAgbmV3U2l6ZSA9IHRyYWNrU2l6ZSArIG5ld1BvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IDApIHtcbiAgICAgIG5ld1NpemUgPSBkcmFnU2l6ZSArIG5ld1BvcztcbiAgICAgIG5ld1BvcyA9IDA7XG4gICAgfSBlbHNlIGlmIChuZXdQb3MgKyBkcmFnU2l6ZSA+IHRyYWNrU2l6ZSkge1xuICAgICAgbmV3U2l6ZSA9IHRyYWNrU2l6ZSAtIG5ld1BvcztcbiAgICB9XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgZHJhZ0VsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke25ld1Bvc31weCwgMCwgMClgO1xuICAgICAgZHJhZ0VsLnN0eWxlLndpZHRoID0gYCR7bmV3U2l6ZX1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWdFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMHB4LCAke25ld1Bvc31weCwgMClgO1xuICAgICAgZHJhZ0VsLnN0eWxlLmhlaWdodCA9IGAke25ld1NpemV9cHhgO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzQwMG1zJztcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uKSB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIHN3aXBlci5zY3JvbGxiYXIuZHJhZ0VsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTaXplKCkge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXN3aXBlci5zY3JvbGxiYXIuZWwpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXJcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdFbCxcbiAgICAgIGVsXG4gICAgfSA9IHNjcm9sbGJhcjtcbiAgICBkcmFnRWwuc3R5bGUud2lkdGggPSAnJztcbiAgICBkcmFnRWwuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgdHJhY2tTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZWwub2Zmc2V0V2lkdGggOiBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgZGl2aWRlciA9IHN3aXBlci5zaXplIC8gKHN3aXBlci52aXJ0dWFsU2l6ZSArIHN3aXBlci5wYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIC0gKHN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIuc25hcEdyaWRbMF0gOiAwKSk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplID09PSAnYXV0bycpIHtcbiAgICAgIGRyYWdTaXplID0gdHJhY2tTaXplICogZGl2aWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhZ1NpemUgPSBwYXJzZUludChzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSwgMTApO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBkcmFnRWwuc3R5bGUud2lkdGggPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWdFbC5zdHlsZS5oZWlnaHQgPSBgJHtkcmFnU2l6ZX1weGA7XG4gICAgfVxuICAgIGlmIChkaXZpZGVyID49IDEpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmhpZGUpIHtcbiAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5lbmFibGVkKSB7XG4gICAgICBzY3JvbGxiYXIuZWwuY2xhc3NMaXN0W3N3aXBlci5pc0xvY2tlZCA/ICdhZGQnIDogJ3JlbW92ZSddKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihlKSB7XG4gICAgcmV0dXJuIHN3aXBlci5pc0hvcml6b250YWwoKSA/IGUuY2xpZW50WCA6IGUuY2xpZW50WTtcbiAgfVxuICBmdW5jdGlvbiBzZXREcmFnUG9zaXRpb24oZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbGJhcixcbiAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCB7XG4gICAgICBlbFxuICAgIH0gPSBzY3JvbGxiYXI7XG4gICAgbGV0IHBvc2l0aW9uUmF0aW87XG4gICAgcG9zaXRpb25SYXRpbyA9IChnZXRQb2ludGVyUG9zaXRpb24oZSkgLSBlbGVtZW50T2Zmc2V0KGVsKVtzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAnbGVmdCcgOiAndG9wJ10gLSAoZHJhZ1N0YXJ0UG9zICE9PSBudWxsID8gZHJhZ1N0YXJ0UG9zIDogZHJhZ1NpemUgLyAyKSkgLyAodHJhY2tTaXplIC0gZHJhZ1NpemUpO1xuICAgIHBvc2l0aW9uUmF0aW8gPSBNYXRoLm1heChNYXRoLm1pbihwb3NpdGlvblJhdGlvLCAxKSwgMCk7XG4gICAgaWYgKHJ0bCkge1xuICAgICAgcG9zaXRpb25SYXRpbyA9IDEgLSBwb3NpdGlvblJhdGlvO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKSArIChzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogcG9zaXRpb25SYXRpbztcbiAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MocG9zaXRpb24pO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUocG9zaXRpb24pO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH1cbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjcm9sbGJhcixcbiAgICAgIHdyYXBwZXJFbFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3Qge1xuICAgICAgZWwsXG4gICAgICBkcmFnRWxcbiAgICB9ID0gc2Nyb2xsYmFyO1xuICAgIGlzVG91Y2hlZCA9IHRydWU7XG4gICAgZHJhZ1N0YXJ0UG9zID0gZS50YXJnZXQgPT09IGRyYWdFbCA/IGdldFBvaW50ZXJQb3NpdGlvbihlKSAtIGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnXSA6IG51bGw7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgd3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcxMDBtcyc7XG4gICAgZHJhZ0VsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcxMDBtcyc7XG4gICAgc2V0RHJhZ1Bvc2l0aW9uKGUpO1xuICAgIGNsZWFyVGltZW91dChkcmFnVGltZW91dCk7XG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgaWYgKHBhcmFtcy5oaWRlKSB7XG4gICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZVsnc2Nyb2xsLXNuYXAtdHlwZSddID0gJ25vbmUnO1xuICAgIH1cbiAgICBlbWl0KCdzY3JvbGxiYXJEcmFnU3RhcnQnLCBlKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRyYWdNb3ZlKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsXG4gICAgICB3cmFwcGVyRWxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGVsLFxuICAgICAgZHJhZ0VsXG4gICAgfSA9IHNjcm9sbGJhcjtcbiAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0ICYmIGUuY2FuY2VsYWJsZSkgZS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHNldERyYWdQb3NpdGlvbihlKTtcbiAgICB3cmFwcGVyRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgZHJhZ0VsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgIGVtaXQoJ3Njcm9sbGJhckRyYWdNb3ZlJywgZSk7XG4gIH1cbiAgZnVuY3Rpb24gb25EcmFnRW5kKGUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnNjcm9sbGJhcjtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsXG4gICAgICB3cmFwcGVyRWxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHtcbiAgICAgIGVsXG4gICAgfSA9IHNjcm9sbGJhcjtcbiAgICBpZiAoIWlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGVbJ3Njcm9sbC1zbmFwLXR5cGUnXSA9ICcnO1xuICAgICAgd3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmhpZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dChkcmFnVGltZW91dCk7XG4gICAgICBkcmFnVGltZW91dCA9IG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICc0MDBtcyc7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgZW1pdCgnc2Nyb2xsYmFyRHJhZ0VuZCcsIGUpO1xuICAgIGlmIChwYXJhbXMuc25hcE9uUmVsZWFzZSkge1xuICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV2ZW50cyhtZXRob2QpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IGVsID0gc2Nyb2xsYmFyLmVsO1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXQgPSBlbDtcbiAgICBjb25zdCBhY3RpdmVMaXN0ZW5lciA9IHBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0gOiBmYWxzZTtcbiAgICBjb25zdCBwYXNzaXZlTGlzdGVuZXIgPSBwYXJhbXMucGFzc2l2ZUxpc3RlbmVycyA/IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0gOiBmYWxzZTtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50TWV0aG9kID0gbWV0aG9kID09PSAnb24nID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuICAgIHRhcmdldFtldmVudE1ldGhvZF0oJ3BvaW50ZXJkb3duJywgb25EcmFnU3RhcnQsIGFjdGl2ZUxpc3RlbmVyKTtcbiAgICBkb2N1bWVudFtldmVudE1ldGhvZF0oJ3BvaW50ZXJtb3ZlJywgb25EcmFnTW92ZSwgYWN0aXZlTGlzdGVuZXIpO1xuICAgIGRvY3VtZW50W2V2ZW50TWV0aG9kXSgncG9pbnRlcnVwJywgb25EcmFnRW5kLCBwYXNzaXZlTGlzdGVuZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZURyYWdnYWJsZSgpIHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICFzd2lwZXIuc2Nyb2xsYmFyLmVsKSByZXR1cm47XG4gICAgZXZlbnRzKCdvbicpO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGVEcmFnZ2FibGUoKSB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIGV2ZW50cygnb2ZmJyk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY3JvbGxiYXIsXG4gICAgICBlbDogc3dpcGVyRWxcbiAgICB9ID0gc3dpcGVyO1xuICAgIHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyID0gY3JlYXRlRWxlbWVudElmTm90RGVmaW5lZChzd2lwZXIsIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5zY3JvbGxiYXIsIHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLCB7XG4gICAgICBlbDogJ3N3aXBlci1zY3JvbGxiYXInXG4gICAgfSk7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgaWYgKCFwYXJhbXMuZWwpIHJldHVybjtcbiAgICBsZXQgZWw7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZWwgPT09ICdzdHJpbmcnICYmIHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGVsID0gc3dpcGVyLmVsLnF1ZXJ5U2VsZWN0b3IocGFyYW1zLmVsKTtcbiAgICB9XG4gICAgaWYgKCFlbCAmJiB0eXBlb2YgcGFyYW1zLmVsID09PSAnc3RyaW5nJykge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtcy5lbCk7XG4gICAgICBpZiAoIWVsLmxlbmd0aCkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIWVsKSB7XG4gICAgICBlbCA9IHBhcmFtcy5lbDtcbiAgICB9XG4gICAgaWYgKHN3aXBlci5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgZWwubGVuZ3RoID4gMSAmJiBzd2lwZXJFbC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtcy5lbCkubGVuZ3RoID09PSAxKSB7XG4gICAgICBlbCA9IHN3aXBlckVsLnF1ZXJ5U2VsZWN0b3IocGFyYW1zLmVsKTtcbiAgICB9XG4gICAgaWYgKGVsLmxlbmd0aCA+IDApIGVsID0gZWxbMF07XG4gICAgZWwuY2xhc3NMaXN0LmFkZChzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBwYXJhbXMuaG9yaXpvbnRhbENsYXNzIDogcGFyYW1zLnZlcnRpY2FsQ2xhc3MpO1xuICAgIGxldCBkcmFnRWw7XG4gICAgaWYgKGVsKSB7XG4gICAgICBkcmFnRWwgPSBlbC5xdWVyeVNlbGVjdG9yKGNsYXNzZXNUb1NlbGVjdG9yKHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzcykpO1xuICAgICAgaWYgKCFkcmFnRWwpIHtcbiAgICAgICAgZHJhZ0VsID0gY3JlYXRlRWxlbWVudCgnZGl2Jywgc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzKTtcbiAgICAgICAgZWwuYXBwZW5kKGRyYWdFbCk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2Nyb2xsYmFyLCB7XG4gICAgICBlbCxcbiAgICAgIGRyYWdFbFxuICAgIH0pO1xuICAgIGlmIChwYXJhbXMuZHJhZ2dhYmxlKSB7XG4gICAgICBlbmFibGVEcmFnZ2FibGUoKTtcbiAgICB9XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5jbGFzc0xpc3Rbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlJyA6ICdhZGQnXSguLi5jbGFzc2VzVG9Ub2tlbnMoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXI7XG4gICAgY29uc3QgZWwgPSBzd2lwZXIuc2Nyb2xsYmFyLmVsO1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9Ub2tlbnMoc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gcGFyYW1zLmhvcml6b250YWxDbGFzcyA6IHBhcmFtcy52ZXJ0aWNhbENsYXNzKSk7XG4gICAgfVxuICAgIGRpc2FibGVEcmFnZ2FibGUoKTtcbiAgfVxuICBvbignY2hhbmdlRGlyZWN0aW9uJywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnNjcm9sbGJhciB8fCAhc3dpcGVyLnNjcm9sbGJhci5lbCkgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuc2Nyb2xsYmFyO1xuICAgIGxldCB7XG4gICAgICBlbFxuICAgIH0gPSBzd2lwZXIuc2Nyb2xsYmFyO1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgc3ViRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMuaG9yaXpvbnRhbENsYXNzLCBwYXJhbXMudmVydGljYWxDbGFzcyk7XG4gICAgICBzdWJFbC5jbGFzc0xpc3QuYWRkKHN3aXBlci5pc0hvcml6b250YWwoKSA/IHBhcmFtcy5ob3Jpem9udGFsQ2xhc3MgOiBwYXJhbXMudmVydGljYWxDbGFzcyk7XG4gICAgfSk7XG4gIH0pO1xuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZGlzYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0KCk7XG4gICAgICB1cGRhdGVTaXplKCk7XG4gICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICB9XG4gIH0pO1xuICBvbigndXBkYXRlIHJlc2l6ZSBvYnNlcnZlclVwZGF0ZSBsb2NrIHVubG9jayBjaGFuZ2VEaXJlY3Rpb24nLCAoKSA9PiB7XG4gICAgdXBkYXRlU2l6ZSgpO1xuICB9KTtcbiAgb24oJ3NldFRyYW5zbGF0ZScsICgpID0+IHtcbiAgICBzZXRUcmFuc2xhdGUoKTtcbiAgfSk7XG4gIG9uKCdzZXRUcmFuc2l0aW9uJywgKF9zLCBkdXJhdGlvbikgPT4ge1xuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICB9KTtcbiAgb24oJ2VuYWJsZSBkaXNhYmxlJywgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsXG4gICAgfSA9IHN3aXBlci5zY3JvbGxiYXI7XG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5jbGFzc0xpc3Rbc3dpcGVyLmVuYWJsZWQgPyAncmVtb3ZlJyA6ICdhZGQnXSguLi5jbGFzc2VzVG9Ub2tlbnMoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKSk7XG4gICAgfVxuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgZGVzdHJveSgpO1xuICB9KTtcbiAgY29uc3QgZW5hYmxlID0gKCkgPT4ge1xuICAgIHN3aXBlci5lbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1Rva2Vucyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKSk7XG4gICAgaWYgKHN3aXBlci5zY3JvbGxiYXIuZWwpIHtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9Ub2tlbnMoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcykpO1xuICAgIH1cbiAgICBpbml0KCk7XG4gICAgdXBkYXRlU2l6ZSgpO1xuICAgIHNldFRyYW5zbGF0ZSgpO1xuICB9O1xuICBjb25zdCBkaXNhYmxlID0gKCkgPT4ge1xuICAgIHN3aXBlci5lbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb1Rva2Vucyhzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKSk7XG4gICAgaWYgKHN3aXBlci5zY3JvbGxiYXIuZWwpIHtcbiAgICAgIHN3aXBlci5zY3JvbGxiYXIuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9Ub2tlbnMoc3dpcGVyLnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcykpO1xuICAgIH1cbiAgICBkZXN0cm95KCk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLnNjcm9sbGJhciwge1xuICAgIGVuYWJsZSxcbiAgICBkaXNhYmxlLFxuICAgIHVwZGF0ZVNpemUsXG4gICAgc2V0VHJhbnNsYXRlLFxuICAgIGluaXQsXG4gICAgZGVzdHJveVxuICB9KTtcbn1cblxuZXhwb3J0IHsgU2Nyb2xsYmFyIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGUgYXMgZWxlbWVudENoaWxkcmVuIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIFBhcmFsbGF4KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIHBhcmFsbGF4OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGVsZW1lbnRzU2VsZWN0b3IgPSAnW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXSc7XG4gIGNvbnN0IHNldFRyYW5zZm9ybSA9IChlbCwgcHJvZ3Jlc3MpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBydGxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHJ0bEZhY3RvciA9IHJ0bCA/IC0xIDogMTtcbiAgICBjb25zdCBwID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1wYXJhbGxheCcpIHx8ICcwJztcbiAgICBsZXQgeCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItcGFyYWxsYXgteCcpO1xuICAgIGxldCB5ID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1wYXJhbGxheC15Jyk7XG4gICAgY29uc3Qgc2NhbGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlJyk7XG4gICAgY29uc3Qgb3BhY2l0eSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eScpO1xuICAgIGNvbnN0IHJvdGF0ZSA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItcGFyYWxsYXgtcm90YXRlJyk7XG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgeCA9IHggfHwgJzAnO1xuICAgICAgeSA9IHkgfHwgJzAnO1xuICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4ID0gcDtcbiAgICAgIHkgPSAnMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBwO1xuICAgICAgeCA9ICcwJztcbiAgICB9XG4gICAgaWYgKHguaW5kZXhPZignJScpID49IDApIHtcbiAgICAgIHggPSBgJHtwYXJzZUludCh4LCAxMCkgKiBwcm9ncmVzcyAqIHJ0bEZhY3Rvcn0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IGAke3ggKiBwcm9ncmVzcyAqIHJ0bEZhY3Rvcn1weGA7XG4gICAgfVxuICAgIGlmICh5LmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICB5ID0gYCR7cGFyc2VJbnQoeSwgMTApICogcHJvZ3Jlc3N9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBgJHt5ICogcHJvZ3Jlc3N9cHhgO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIG9wYWNpdHkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcGFjaXR5ID0gb3BhY2l0eSAtIChvcGFjaXR5IC0gMSkgKiAoMSAtIE1hdGguYWJzKHByb2dyZXNzKSk7XG4gICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gY3VycmVudE9wYWNpdHk7XG4gICAgfVxuICAgIGxldCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4fSwgJHt5fSwgMHB4KWA7XG4gICAgaWYgKHR5cGVvZiBzY2FsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHNjYWxlIC0gKHNjYWxlIC0gMSkgKiAoMSAtIE1hdGguYWJzKHByb2dyZXNzKSk7XG4gICAgICB0cmFuc2Zvcm0gKz0gYCBzY2FsZSgke2N1cnJlbnRTY2FsZX0pYDtcbiAgICB9XG4gICAgaWYgKHJvdGF0ZSAmJiB0eXBlb2Ygcm90YXRlICE9PSAndW5kZWZpbmVkJyAmJiByb3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3RhdGUgPSByb3RhdGUgKiBwcm9ncmVzcyAqIC0xO1xuICAgICAgdHJhbnNmb3JtICs9IGAgcm90YXRlKCR7Y3VycmVudFJvdGF0ZX1kZWcpYDtcbiAgICB9XG4gICAgZWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9O1xuICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZWwsXG4gICAgICBzbGlkZXMsXG4gICAgICBwcm9ncmVzcyxcbiAgICAgIHNuYXBHcmlkLFxuICAgICAgaXNFbGVtZW50XG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnRDaGlsZHJlbihlbCwgZWxlbWVudHNTZWxlY3Rvcik7XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goLi4uZWxlbWVudENoaWxkcmVuKHN3aXBlci5ob3N0RWwsIGVsZW1lbnRzU2VsZWN0b3IpKTtcbiAgICB9XG4gICAgZWxlbWVudHMuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICBzZXRUcmFuc2Zvcm0oc3ViRWwsIHByb2dyZXNzKTtcbiAgICB9KTtcbiAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGVFbCwgc2xpZGVJbmRleCkgPT4ge1xuICAgICAgbGV0IHNsaWRlUHJvZ3Jlc3MgPSBzbGlkZUVsLnByb2dyZXNzO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPiAxICYmIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHNsaWRlUHJvZ3Jlc3MgKz0gTWF0aC5jZWlsKHNsaWRlSW5kZXggLyAyKSAtIHByb2dyZXNzICogKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgc2xpZGVQcm9ncmVzcyA9IE1hdGgubWluKE1hdGgubWF4KHNsaWRlUHJvZ3Jlc3MsIC0xKSwgMSk7XG4gICAgICBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoYCR7ZWxlbWVudHNTZWxlY3Rvcn0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1yb3RhdGVdYCkuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICAgIHNldFRyYW5zZm9ybShzdWJFbCwgc2xpZGVQcm9ncmVzcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IHN3aXBlci5wYXJhbXMuc3BlZWQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGVsLFxuICAgICAgaG9zdEVsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5lbC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzU2VsZWN0b3IpXTtcbiAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgZWxlbWVudHMucHVzaCguLi5ob3N0RWwucXVlcnlTZWxlY3RvckFsbChlbGVtZW50c1NlbGVjdG9yKSk7XG4gICAgfVxuICAgIGVsZW1lbnRzLmZvckVhY2gocGFyYWxsYXhFbCA9PiB7XG4gICAgICBsZXQgcGFyYWxsYXhEdXJhdGlvbiA9IHBhcnNlSW50KHBhcmFsbGF4RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1wYXJhbGxheC1kdXJhdGlvbicpLCAxMCkgfHwgZHVyYXRpb247XG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHBhcmFsbGF4RHVyYXRpb24gPSAwO1xuICAgICAgcGFyYWxsYXhFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtwYXJhbGxheER1cmF0aW9ufW1zYDtcbiAgICB9KTtcbiAgfTtcbiAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQpIHJldHVybjtcbiAgICBzd2lwZXIucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gdHJ1ZTtcbiAgfSk7XG4gIG9uKCdpbml0JywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgc2V0VHJhbnNsYXRlKCk7XG4gIH0pO1xuICBvbignc2V0VHJhbnNsYXRlJywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgc2V0VHJhbnNsYXRlKCk7XG4gIH0pO1xuICBvbignc2V0VHJhbnNpdGlvbicsIChfc3dpcGVyLCBkdXJhdGlvbikgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSByZXR1cm47XG4gICAgc2V0VHJhbnNpdGlvbihkdXJhdGlvbik7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBQYXJhbGxheCBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBhIGFzIGdldFdpbmRvdyB9IGZyb20gJy4uL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgZSBhcyBlbGVtZW50Q2hpbGRyZW4sIGEgYXMgZWxlbWVudFBhcmVudHMsIGIgYXMgZWxlbWVudE9mZnNldCwgaiBhcyBnZXRUcmFuc2xhdGUgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gWm9vbShfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIGV4dGVuZFBhcmFtcyxcbiAgICBvbixcbiAgICBlbWl0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICB6b29tOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxpbWl0VG9PcmlnaW5hbFNpemU6IGZhbHNlLFxuICAgICAgbWF4UmF0aW86IDMsXG4gICAgICBtaW5SYXRpbzogMSxcbiAgICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICAgIGNvbnRhaW5lckNsYXNzOiAnc3dpcGVyLXpvb20tY29udGFpbmVyJyxcbiAgICAgIHpvb21lZFNsaWRlQ2xhc3M6ICdzd2lwZXItc2xpZGUtem9vbWVkJ1xuICAgIH1cbiAgfSk7XG4gIHN3aXBlci56b29tID0ge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH07XG4gIGxldCBjdXJyZW50U2NhbGUgPSAxO1xuICBsZXQgaXNTY2FsaW5nID0gZmFsc2U7XG4gIGxldCBmYWtlR2VzdHVyZVRvdWNoZWQ7XG4gIGxldCBmYWtlR2VzdHVyZU1vdmVkO1xuICBjb25zdCBldkNhY2hlID0gW107XG4gIGNvbnN0IGdlc3R1cmUgPSB7XG4gICAgb3JpZ2luWDogMCxcbiAgICBvcmlnaW5ZOiAwLFxuICAgIHNsaWRlRWw6IHVuZGVmaW5lZCxcbiAgICBzbGlkZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgc2xpZGVIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBpbWFnZUVsOiB1bmRlZmluZWQsXG4gICAgaW1hZ2VXcmFwRWw6IHVuZGVmaW5lZCxcbiAgICBtYXhSYXRpbzogM1xuICB9O1xuICBjb25zdCBpbWFnZSA9IHtcbiAgICBpc1RvdWNoZWQ6IHVuZGVmaW5lZCxcbiAgICBpc01vdmVkOiB1bmRlZmluZWQsXG4gICAgY3VycmVudFg6IHVuZGVmaW5lZCxcbiAgICBjdXJyZW50WTogdW5kZWZpbmVkLFxuICAgIG1pblg6IHVuZGVmaW5lZCxcbiAgICBtaW5ZOiB1bmRlZmluZWQsXG4gICAgbWF4WDogdW5kZWZpbmVkLFxuICAgIG1heFk6IHVuZGVmaW5lZCxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIHN0YXJ0WDogdW5kZWZpbmVkLFxuICAgIHN0YXJ0WTogdW5kZWZpbmVkLFxuICAgIHRvdWNoZXNTdGFydDoge30sXG4gICAgdG91Y2hlc0N1cnJlbnQ6IHt9XG4gIH07XG4gIGNvbnN0IHZlbG9jaXR5ID0ge1xuICAgIHg6IHVuZGVmaW5lZCxcbiAgICB5OiB1bmRlZmluZWQsXG4gICAgcHJldlBvc2l0aW9uWDogdW5kZWZpbmVkLFxuICAgIHByZXZQb3NpdGlvblk6IHVuZGVmaW5lZCxcbiAgICBwcmV2VGltZTogdW5kZWZpbmVkXG4gIH07XG4gIGxldCBzY2FsZSA9IDE7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzd2lwZXIuem9vbSwgJ3NjYWxlJywge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHNjYWxlICE9PSB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbWFnZUVsID0gZ2VzdHVyZS5pbWFnZUVsO1xuICAgICAgICBjb25zdCBzbGlkZUVsID0gZ2VzdHVyZS5zbGlkZUVsO1xuICAgICAgICBlbWl0KCd6b29tQ2hhbmdlJywgdmFsdWUsIGltYWdlRWwsIHNsaWRlRWwpO1xuICAgICAgfVxuICAgICAgc2NhbGUgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBnZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKCkge1xuICAgIGlmIChldkNhY2hlLmxlbmd0aCA8IDIpIHJldHVybiAxO1xuICAgIGNvbnN0IHgxID0gZXZDYWNoZVswXS5wYWdlWDtcbiAgICBjb25zdCB5MSA9IGV2Q2FjaGVbMF0ucGFnZVk7XG4gICAgY29uc3QgeDIgPSBldkNhY2hlWzFdLnBhZ2VYO1xuICAgIGNvbnN0IHkyID0gZXZDYWNoZVsxXS5wYWdlWTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCgoeDIgLSB4MSkgKiogMiArICh5MiAtIHkxKSAqKiAyKTtcbiAgICByZXR1cm4gZGlzdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TWF4UmF0aW8oKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IG1heFJhdGlvID0gZ2VzdHVyZS5pbWFnZVdyYXBFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXpvb20nKSB8fCBwYXJhbXMubWF4UmF0aW87XG4gICAgaWYgKHBhcmFtcy5saW1pdFRvT3JpZ2luYWxTaXplICYmIGdlc3R1cmUuaW1hZ2VFbCAmJiBnZXN0dXJlLmltYWdlRWwubmF0dXJhbFdpZHRoKSB7XG4gICAgICBjb25zdCBpbWFnZU1heFJhdGlvID0gZ2VzdHVyZS5pbWFnZUVsLm5hdHVyYWxXaWR0aCAvIGdlc3R1cmUuaW1hZ2VFbC5vZmZzZXRXaWR0aDtcbiAgICAgIHJldHVybiBNYXRoLm1pbihpbWFnZU1heFJhdGlvLCBtYXhSYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiBtYXhSYXRpbztcbiAgfVxuICBmdW5jdGlvbiBnZXRTY2FsZU9yaWdpbigpIHtcbiAgICBpZiAoZXZDYWNoZS5sZW5ndGggPCAyKSByZXR1cm4ge1xuICAgICAgeDogbnVsbCxcbiAgICAgIHk6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IGJveCA9IGdlc3R1cmUuaW1hZ2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyhldkNhY2hlWzBdLnBhZ2VYICsgKGV2Q2FjaGVbMV0ucGFnZVggLSBldkNhY2hlWzBdLnBhZ2VYKSAvIDIgLSBib3gueCAtIHdpbmRvdy5zY3JvbGxYKSAvIGN1cnJlbnRTY2FsZSwgKGV2Q2FjaGVbMF0ucGFnZVkgKyAoZXZDYWNoZVsxXS5wYWdlWSAtIGV2Q2FjaGVbMF0ucGFnZVkpIC8gMiAtIGJveC55IC0gd2luZG93LnNjcm9sbFkpIC8gY3VycmVudFNjYWxlXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTbGlkZVNlbGVjdG9yKCkge1xuICAgIHJldHVybiBzd2lwZXIuaXNFbGVtZW50ID8gYHN3aXBlci1zbGlkZWAgOiBgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWA7XG4gIH1cbiAgZnVuY3Rpb24gZXZlbnRXaXRoaW5TbGlkZShlKSB7XG4gICAgY29uc3Qgc2xpZGVTZWxlY3RvciA9IGdldFNsaWRlU2VsZWN0b3IoKTtcbiAgICBpZiAoZS50YXJnZXQubWF0Y2hlcyhzbGlkZVNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb250YWlucyhlLnRhcmdldCkpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBldmVudFdpdGhpblpvb21Db250YWluZXIoZSkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYC4ke3N3aXBlci5wYXJhbXMuem9vbS5jb250YWluZXJDbGFzc31gO1xuICAgIGlmIChlLnRhcmdldC5tYXRjaGVzKHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKFsuLi5zd2lwZXIuaG9zdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXS5maWx0ZXIoY29udGFpbmVyRWwgPT4gY29udGFpbmVyRWwuY29udGFpbnMoZS50YXJnZXQpKS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFdmVudHNcbiAgZnVuY3Rpb24gb25HZXN0dXJlU3RhcnQoZSkge1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICBldkNhY2hlLnNwbGljZSgwLCBldkNhY2hlLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmICghZXZlbnRXaXRoaW5TbGlkZShlKSkgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuem9vbTtcbiAgICBmYWtlR2VzdHVyZVRvdWNoZWQgPSBmYWxzZTtcbiAgICBmYWtlR2VzdHVyZU1vdmVkID0gZmFsc2U7XG4gICAgZXZDYWNoZS5wdXNoKGUpO1xuICAgIGlmIChldkNhY2hlLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFrZUdlc3R1cmVUb3VjaGVkID0gdHJ1ZTtcbiAgICBnZXN0dXJlLnNjYWxlU3RhcnQgPSBnZXREaXN0YW5jZUJldHdlZW5Ub3VjaGVzKCk7XG4gICAgaWYgKCFnZXN0dXJlLnNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuc2xpZGVFbCA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApO1xuICAgICAgaWYgKCFnZXN0dXJlLnNsaWRlRWwpIGdlc3R1cmUuc2xpZGVFbCA9IHN3aXBlci5zbGlkZXNbc3dpcGVyLmFjdGl2ZUluZGV4XTtcbiAgICAgIGxldCBpbWFnZUVsID0gZ2VzdHVyZS5zbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICAgIGlmIChpbWFnZUVsKSB7XG4gICAgICAgIGltYWdlRWwgPSBpbWFnZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BpY3R1cmUsIGltZywgc3ZnLCBjYW52YXMsIC5zd2lwZXItem9vbS10YXJnZXQnKVswXTtcbiAgICAgIH1cbiAgICAgIGdlc3R1cmUuaW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgICBpZiAoaW1hZ2VFbCkge1xuICAgICAgICBnZXN0dXJlLmltYWdlV3JhcEVsID0gZWxlbWVudFBhcmVudHMoZ2VzdHVyZS5pbWFnZUVsLCBgLiR7cGFyYW1zLmNvbnRhaW5lckNsYXNzfWApWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VzdHVyZS5pbWFnZVdyYXBFbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghZ2VzdHVyZS5pbWFnZVdyYXBFbCkge1xuICAgICAgICBnZXN0dXJlLmltYWdlRWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdlc3R1cmUubWF4UmF0aW8gPSBnZXRNYXhSYXRpbygpO1xuICAgIH1cbiAgICBpZiAoZ2VzdHVyZS5pbWFnZUVsKSB7XG4gICAgICBjb25zdCBbb3JpZ2luWCwgb3JpZ2luWV0gPSBnZXRTY2FsZU9yaWdpbigpO1xuICAgICAgZ2VzdHVyZS5vcmlnaW5YID0gb3JpZ2luWDtcbiAgICAgIGdlc3R1cmUub3JpZ2luWSA9IG9yaWdpblk7XG4gICAgICBnZXN0dXJlLmltYWdlRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgfVxuICAgIGlzU2NhbGluZyA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gb25HZXN0dXJlQ2hhbmdlKGUpIHtcbiAgICBpZiAoIWV2ZW50V2l0aGluU2xpZGUoZSkpIHJldHVybjtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGNvbnN0IHBvaW50ZXJJbmRleCA9IGV2Q2FjaGUuZmluZEluZGV4KGNhY2hlZEV2ID0+IGNhY2hlZEV2LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpO1xuICAgIGlmIChwb2ludGVySW5kZXggPj0gMCkgZXZDYWNoZVtwb2ludGVySW5kZXhdID0gZTtcbiAgICBpZiAoZXZDYWNoZS5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZha2VHZXN0dXJlTW92ZWQgPSB0cnVlO1xuICAgIGdlc3R1cmUuc2NhbGVNb3ZlID0gZ2V0RGlzdGFuY2VCZXR3ZWVuVG91Y2hlcygpO1xuICAgIGlmICghZ2VzdHVyZS5pbWFnZUVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHpvb20uc2NhbGUgPSBnZXN0dXJlLnNjYWxlTW92ZSAvIGdlc3R1cmUuc2NhbGVTdGFydCAqIGN1cnJlbnRTY2FsZTtcbiAgICBpZiAoem9vbS5zY2FsZSA+IGdlc3R1cmUubWF4UmF0aW8pIHtcbiAgICAgIHpvb20uc2NhbGUgPSBnZXN0dXJlLm1heFJhdGlvIC0gMSArICh6b29tLnNjYWxlIC0gZ2VzdHVyZS5tYXhSYXRpbyArIDEpICoqIDAuNTtcbiAgICB9XG4gICAgaWYgKHpvb20uc2NhbGUgPCBwYXJhbXMubWluUmF0aW8pIHtcbiAgICAgIHpvb20uc2NhbGUgPSBwYXJhbXMubWluUmF0aW8gKyAxIC0gKHBhcmFtcy5taW5SYXRpbyAtIHpvb20uc2NhbGUgKyAxKSAqKiAwLjU7XG4gICAgfVxuICAgIGdlc3R1cmUuaW1hZ2VFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYDtcbiAgfVxuICBmdW5jdGlvbiBvbkdlc3R1cmVFbmQoZSkge1xuICAgIGlmICghZXZlbnRXaXRoaW5TbGlkZShlKSkgcmV0dXJuO1xuICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIGUudHlwZSA9PT0gJ3BvaW50ZXJvdXQnKSByZXR1cm47XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy56b29tO1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCBwb2ludGVySW5kZXggPSBldkNhY2hlLmZpbmRJbmRleChjYWNoZWRFdiA9PiBjYWNoZWRFdi5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKTtcbiAgICBpZiAocG9pbnRlckluZGV4ID49IDApIGV2Q2FjaGUuc3BsaWNlKHBvaW50ZXJJbmRleCwgMSk7XG4gICAgaWYgKCFmYWtlR2VzdHVyZVRvdWNoZWQgfHwgIWZha2VHZXN0dXJlTW92ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFrZUdlc3R1cmVUb3VjaGVkID0gZmFsc2U7XG4gICAgZmFrZUdlc3R1cmVNb3ZlZCA9IGZhbHNlO1xuICAgIGlmICghZ2VzdHVyZS5pbWFnZUVsKSByZXR1cm47XG4gICAgem9vbS5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHpvb20uc2NhbGUsIGdlc3R1cmUubWF4UmF0aW8pLCBwYXJhbXMubWluUmF0aW8pO1xuICAgIGdlc3R1cmUuaW1hZ2VFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtzd2lwZXIucGFyYW1zLnNwZWVkfW1zYDtcbiAgICBnZXN0dXJlLmltYWdlRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3pvb20uc2NhbGV9KWA7XG4gICAgY3VycmVudFNjYWxlID0gem9vbS5zY2FsZTtcbiAgICBpc1NjYWxpbmcgPSBmYWxzZTtcbiAgICBpZiAoem9vbS5zY2FsZSA+IDEgJiYgZ2VzdHVyZS5zbGlkZUVsKSB7XG4gICAgICBnZXN0dXJlLnNsaWRlRWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMuem9vbWVkU2xpZGVDbGFzc31gKTtcbiAgICB9IGVsc2UgaWYgKHpvb20uc2NhbGUgPD0gMSAmJiBnZXN0dXJlLnNsaWRlRWwpIHtcbiAgICAgIGdlc3R1cmUuc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgIH1cbiAgICBpZiAoem9vbS5zY2FsZSA9PT0gMSkge1xuICAgICAgZ2VzdHVyZS5vcmlnaW5YID0gMDtcbiAgICAgIGdlc3R1cmUub3JpZ2luWSA9IDA7XG4gICAgICBnZXN0dXJlLnNsaWRlRWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGxldCBhbGxvd1RvdWNoTW92ZVRpbWVvdXQ7XG4gIGZ1bmN0aW9uIGFsbG93VG91Y2hNb3ZlKCkge1xuICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEucHJldmVudFRvdWNoTW92ZUZyb21Qb2ludGVyTW92ZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZlbnRUb3VjaE1vdmUoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGFsbG93VG91Y2hNb3ZlVGltZW91dCk7XG4gICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5wcmV2ZW50VG91Y2hNb3ZlRnJvbVBvaW50ZXJNb3ZlID0gdHJ1ZTtcbiAgICBhbGxvd1RvdWNoTW92ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGFsbG93VG91Y2hNb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICBjb25zdCBkZXZpY2UgPSBzd2lwZXIuZGV2aWNlO1xuICAgIGlmICghZ2VzdHVyZS5pbWFnZUVsKSByZXR1cm47XG4gICAgaWYgKGltYWdlLmlzVG91Y2hlZCkgcmV0dXJuO1xuICAgIGlmIChkZXZpY2UuYW5kcm9pZCAmJiBlLmNhbmNlbGFibGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpbWFnZS5pc1RvdWNoZWQgPSB0cnVlO1xuICAgIGNvbnN0IGV2ZW50ID0gZXZDYWNoZS5sZW5ndGggPiAwID8gZXZDYWNoZVswXSA6IGU7XG4gICAgaW1hZ2UudG91Y2hlc1N0YXJ0LnggPSBldmVudC5wYWdlWDtcbiAgICBpbWFnZS50b3VjaGVzU3RhcnQueSA9IGV2ZW50LnBhZ2VZO1xuICB9XG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICBpZiAoIWV2ZW50V2l0aGluU2xpZGUoZSkgfHwgIWV2ZW50V2l0aGluWm9vbUNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgaWYgKCFnZXN0dXJlLmltYWdlRWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpbWFnZS5pc1RvdWNoZWQgfHwgIWdlc3R1cmUuc2xpZGVFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWltYWdlLmlzTW92ZWQpIHtcbiAgICAgIGltYWdlLndpZHRoID0gZ2VzdHVyZS5pbWFnZUVsLm9mZnNldFdpZHRoIHx8IGdlc3R1cmUuaW1hZ2VFbC5jbGllbnRXaWR0aDtcbiAgICAgIGltYWdlLmhlaWdodCA9IGdlc3R1cmUuaW1hZ2VFbC5vZmZzZXRIZWlnaHQgfHwgZ2VzdHVyZS5pbWFnZUVsLmNsaWVudEhlaWdodDtcbiAgICAgIGltYWdlLnN0YXJ0WCA9IGdldFRyYW5zbGF0ZShnZXN0dXJlLmltYWdlV3JhcEVsLCAneCcpIHx8IDA7XG4gICAgICBpbWFnZS5zdGFydFkgPSBnZXRUcmFuc2xhdGUoZ2VzdHVyZS5pbWFnZVdyYXBFbCwgJ3knKSB8fCAwO1xuICAgICAgZ2VzdHVyZS5zbGlkZVdpZHRoID0gZ2VzdHVyZS5zbGlkZUVsLm9mZnNldFdpZHRoO1xuICAgICAgZ2VzdHVyZS5zbGlkZUhlaWdodCA9IGdlc3R1cmUuc2xpZGVFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICBnZXN0dXJlLmltYWdlV3JhcEVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwbXMnO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgaWYgd2UgbmVlZCBpbWFnZSBkcmFnXG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBpbWFnZS53aWR0aCAqIHpvb20uc2NhbGU7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogem9vbS5zY2FsZTtcbiAgICBpbWFnZS5taW5YID0gTWF0aC5taW4oZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIHNjYWxlZFdpZHRoIC8gMiwgMCk7XG4gICAgaW1hZ2UubWF4WCA9IC1pbWFnZS5taW5YO1xuICAgIGltYWdlLm1pblkgPSBNYXRoLm1pbihnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMiAtIHNjYWxlZEhlaWdodCAvIDIsIDApO1xuICAgIGltYWdlLm1heFkgPSAtaW1hZ2UubWluWTtcbiAgICBpbWFnZS50b3VjaGVzQ3VycmVudC54ID0gZXZDYWNoZS5sZW5ndGggPiAwID8gZXZDYWNoZVswXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA9IGV2Q2FjaGUubGVuZ3RoID4gMCA/IGV2Q2FjaGVbMF0ucGFnZVkgOiBlLnBhZ2VZO1xuICAgIGNvbnN0IHRvdWNoZXNEaWZmID0gTWF0aC5tYXgoTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIGltYWdlLnRvdWNoZXNTdGFydC54KSwgTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueSAtIGltYWdlLnRvdWNoZXNTdGFydC55KSk7XG4gICAgaWYgKHRvdWNoZXNEaWZmID4gNSkge1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpbWFnZS5pc01vdmVkICYmICFpc1NjYWxpbmcpIHtcbiAgICAgIGlmIChzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgKE1hdGguZmxvb3IoaW1hZ2UubWluWCkgPT09IE1hdGguZmxvb3IoaW1hZ2Uuc3RhcnRYKSAmJiBpbWFnZS50b3VjaGVzQ3VycmVudC54IDwgaW1hZ2UudG91Y2hlc1N0YXJ0LnggfHwgTWF0aC5mbG9vcihpbWFnZS5tYXhYKSA9PT0gTWF0aC5mbG9vcihpbWFnZS5zdGFydFgpICYmIGltYWdlLnRvdWNoZXNDdXJyZW50LnggPiBpbWFnZS50b3VjaGVzU3RhcnQueCkpIHtcbiAgICAgICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgIGFsbG93VG91Y2hNb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIChNYXRoLmZsb29yKGltYWdlLm1pblkpID09PSBNYXRoLmZsb29yKGltYWdlLnN0YXJ0WSkgJiYgaW1hZ2UudG91Y2hlc0N1cnJlbnQueSA8IGltYWdlLnRvdWNoZXNTdGFydC55IHx8IE1hdGguZmxvb3IoaW1hZ2UubWF4WSkgPT09IE1hdGguZmxvb3IoaW1hZ2Uuc3RhcnRZKSAmJiBpbWFnZS50b3VjaGVzQ3VycmVudC55ID4gaW1hZ2UudG91Y2hlc1N0YXJ0LnkpKSB7XG4gICAgICAgIGltYWdlLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICBhbGxvd1RvdWNoTW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBwcmV2ZW50VG91Y2hNb3ZlKCk7XG4gICAgaW1hZ2UuaXNNb3ZlZCA9IHRydWU7XG4gICAgY29uc3Qgc2NhbGVSYXRpbyA9ICh6b29tLnNjYWxlIC0gY3VycmVudFNjYWxlKSAvIChnZXN0dXJlLm1heFJhdGlvIC0gc3dpcGVyLnBhcmFtcy56b29tLm1pblJhdGlvKTtcbiAgICBjb25zdCB7XG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWVxuICAgIH0gPSBnZXN0dXJlO1xuICAgIGltYWdlLmN1cnJlbnRYID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIGltYWdlLnRvdWNoZXNTdGFydC54ICsgaW1hZ2Uuc3RhcnRYICsgc2NhbGVSYXRpbyAqIChpbWFnZS53aWR0aCAtIG9yaWdpblggKiAyKTtcbiAgICBpbWFnZS5jdXJyZW50WSA9IGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSBpbWFnZS50b3VjaGVzU3RhcnQueSArIGltYWdlLnN0YXJ0WSArIHNjYWxlUmF0aW8gKiAoaW1hZ2UuaGVpZ2h0IC0gb3JpZ2luWSAqIDIpO1xuICAgIGlmIChpbWFnZS5jdXJyZW50WCA8IGltYWdlLm1pblgpIHtcbiAgICAgIGltYWdlLmN1cnJlbnRYID0gaW1hZ2UubWluWCArIDEgLSAoaW1hZ2UubWluWCAtIGltYWdlLmN1cnJlbnRYICsgMSkgKiogMC44O1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuY3VycmVudFggPiBpbWFnZS5tYXhYKSB7XG4gICAgICBpbWFnZS5jdXJyZW50WCA9IGltYWdlLm1heFggLSAxICsgKGltYWdlLmN1cnJlbnRYIC0gaW1hZ2UubWF4WCArIDEpICoqIDAuODtcbiAgICB9XG4gICAgaWYgKGltYWdlLmN1cnJlbnRZIDwgaW1hZ2UubWluWSkge1xuICAgICAgaW1hZ2UuY3VycmVudFkgPSBpbWFnZS5taW5ZICsgMSAtIChpbWFnZS5taW5ZIC0gaW1hZ2UuY3VycmVudFkgKyAxKSAqKiAwLjg7XG4gICAgfVxuICAgIGlmIChpbWFnZS5jdXJyZW50WSA+IGltYWdlLm1heFkpIHtcbiAgICAgIGltYWdlLmN1cnJlbnRZID0gaW1hZ2UubWF4WSAtIDEgKyAoaW1hZ2UuY3VycmVudFkgLSBpbWFnZS5tYXhZICsgMSkgKiogMC44O1xuICAgIH1cblxuICAgIC8vIFZlbG9jaXR5XG4gICAgaWYgKCF2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YID0gaW1hZ2UudG91Y2hlc0N1cnJlbnQueDtcbiAgICBpZiAoIXZlbG9jaXR5LnByZXZQb3NpdGlvblkpIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xuICAgIGlmICghdmVsb2NpdHkucHJldlRpbWUpIHZlbG9jaXR5LnByZXZUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2ZWxvY2l0eS54ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnggLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25YKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcbiAgICB2ZWxvY2l0eS55ID0gKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gdmVsb2NpdHkucHJldlRpbWUpIC8gMjtcbiAgICBpZiAoTWF0aC5hYnMoaW1hZ2UudG91Y2hlc0N1cnJlbnQueCAtIHZlbG9jaXR5LnByZXZQb3NpdGlvblgpIDwgMikgdmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKGltYWdlLnRvdWNoZXNDdXJyZW50LnkgLSB2ZWxvY2l0eS5wcmV2UG9zaXRpb25ZKSA8IDIpIHZlbG9jaXR5LnkgPSAwO1xuICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblggPSBpbWFnZS50b3VjaGVzQ3VycmVudC54O1xuICAgIHZlbG9jaXR5LnByZXZQb3NpdGlvblkgPSBpbWFnZS50b3VjaGVzQ3VycmVudC55O1xuICAgIHZlbG9jaXR5LnByZXZUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBnZXN0dXJlLmltYWdlV3JhcEVsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2ltYWdlLmN1cnJlbnRYfXB4LCAke2ltYWdlLmN1cnJlbnRZfXB4LDApYDtcbiAgfVxuICBmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBpZiAoIWdlc3R1cmUuaW1hZ2VFbCkgcmV0dXJuO1xuICAgIGlmICghaW1hZ2UuaXNUb3VjaGVkIHx8ICFpbWFnZS5pc01vdmVkKSB7XG4gICAgICBpbWFnZS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIGltYWdlLmlzTW92ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1hZ2UuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgaW1hZ2UuaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGxldCBtb21lbnR1bUR1cmF0aW9uWCA9IDMwMDtcbiAgICBsZXQgbW9tZW50dW1EdXJhdGlvblkgPSAzMDA7XG4gICAgY29uc3QgbW9tZW50dW1EaXN0YW5jZVggPSB2ZWxvY2l0eS54ICogbW9tZW50dW1EdXJhdGlvblg7XG4gICAgY29uc3QgbmV3UG9zaXRpb25YID0gaW1hZ2UuY3VycmVudFggKyBtb21lbnR1bURpc3RhbmNlWDtcbiAgICBjb25zdCBtb21lbnR1bURpc3RhbmNlWSA9IHZlbG9jaXR5LnkgKiBtb21lbnR1bUR1cmF0aW9uWTtcbiAgICBjb25zdCBuZXdQb3NpdGlvblkgPSBpbWFnZS5jdXJyZW50WSArIG1vbWVudHVtRGlzdGFuY2VZO1xuXG4gICAgLy8gRml4IGR1cmF0aW9uXG4gICAgaWYgKHZlbG9jaXR5LnggIT09IDApIG1vbWVudHVtRHVyYXRpb25YID0gTWF0aC5hYnMoKG5ld1Bvc2l0aW9uWCAtIGltYWdlLmN1cnJlbnRYKSAvIHZlbG9jaXR5LngpO1xuICAgIGlmICh2ZWxvY2l0eS55ICE9PSAwKSBtb21lbnR1bUR1cmF0aW9uWSA9IE1hdGguYWJzKChuZXdQb3NpdGlvblkgLSBpbWFnZS5jdXJyZW50WSkgLyB2ZWxvY2l0eS55KTtcbiAgICBjb25zdCBtb21lbnR1bUR1cmF0aW9uID0gTWF0aC5tYXgobW9tZW50dW1EdXJhdGlvblgsIG1vbWVudHVtRHVyYXRpb25ZKTtcbiAgICBpbWFnZS5jdXJyZW50WCA9IG5ld1Bvc2l0aW9uWDtcbiAgICBpbWFnZS5jdXJyZW50WSA9IG5ld1Bvc2l0aW9uWTtcbiAgICAvLyBEZWZpbmUgaWYgd2UgbmVlZCBpbWFnZSBkcmFnXG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBpbWFnZS53aWR0aCAqIHpvb20uc2NhbGU7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogem9vbS5zY2FsZTtcbiAgICBpbWFnZS5taW5YID0gTWF0aC5taW4oZ2VzdHVyZS5zbGlkZVdpZHRoIC8gMiAtIHNjYWxlZFdpZHRoIC8gMiwgMCk7XG4gICAgaW1hZ2UubWF4WCA9IC1pbWFnZS5taW5YO1xuICAgIGltYWdlLm1pblkgPSBNYXRoLm1pbihnZXN0dXJlLnNsaWRlSGVpZ2h0IC8gMiAtIHNjYWxlZEhlaWdodCAvIDIsIDApO1xuICAgIGltYWdlLm1heFkgPSAtaW1hZ2UubWluWTtcbiAgICBpbWFnZS5jdXJyZW50WCA9IE1hdGgubWF4KE1hdGgubWluKGltYWdlLmN1cnJlbnRYLCBpbWFnZS5tYXhYKSwgaW1hZ2UubWluWCk7XG4gICAgaW1hZ2UuY3VycmVudFkgPSBNYXRoLm1heChNYXRoLm1pbihpbWFnZS5jdXJyZW50WSwgaW1hZ2UubWF4WSksIGltYWdlLm1pblkpO1xuICAgIGdlc3R1cmUuaW1hZ2VXcmFwRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7bW9tZW50dW1EdXJhdGlvbn1tc2A7XG4gICAgZ2VzdHVyZS5pbWFnZVdyYXBFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtpbWFnZS5jdXJyZW50WH1weCwgJHtpbWFnZS5jdXJyZW50WX1weCwwKWA7XG4gIH1cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKCkge1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBpZiAoZ2VzdHVyZS5zbGlkZUVsICYmIHN3aXBlci5hY3RpdmVJbmRleCAhPT0gc3dpcGVyLnNsaWRlcy5pbmRleE9mKGdlc3R1cmUuc2xpZGVFbCkpIHtcbiAgICAgIGlmIChnZXN0dXJlLmltYWdlRWwpIHtcbiAgICAgICAgZ2VzdHVyZS5pbWFnZUVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSknO1xuICAgICAgfVxuICAgICAgaWYgKGdlc3R1cmUuaW1hZ2VXcmFwRWwpIHtcbiAgICAgICAgZ2VzdHVyZS5pbWFnZVdyYXBFbC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIH1cbiAgICAgIGdlc3R1cmUuc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3N3aXBlci5wYXJhbXMuem9vbS56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgICAgem9vbS5zY2FsZSA9IDE7XG4gICAgICBjdXJyZW50U2NhbGUgPSAxO1xuICAgICAgZ2VzdHVyZS5zbGlkZUVsID0gdW5kZWZpbmVkO1xuICAgICAgZ2VzdHVyZS5pbWFnZUVsID0gdW5kZWZpbmVkO1xuICAgICAgZ2VzdHVyZS5pbWFnZVdyYXBFbCA9IHVuZGVmaW5lZDtcbiAgICAgIGdlc3R1cmUub3JpZ2luWCA9IDA7XG4gICAgICBnZXN0dXJlLm9yaWdpblkgPSAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB6b29tSW4oZSkge1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG4gICAgaWYgKCFnZXN0dXJlLnNsaWRlRWwpIHtcbiAgICAgIGlmIChlICYmIGUudGFyZ2V0KSB7XG4gICAgICAgIGdlc3R1cmUuc2xpZGVFbCA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApO1xuICAgICAgfVxuICAgICAgaWYgKCFnZXN0dXJlLnNsaWRlRWwpIHtcbiAgICAgICAgaWYgKHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBzd2lwZXIudmlydHVhbCkge1xuICAgICAgICAgIGdlc3R1cmUuc2xpZGVFbCA9IGVsZW1lbnRDaGlsZHJlbihzd2lwZXIuc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VzdHVyZS5zbGlkZUVsID0gc3dpcGVyLnNsaWRlc1tzd2lwZXIuYWN0aXZlSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaW1hZ2VFbCA9IGdlc3R1cmUuc2xpZGVFbC5xdWVyeVNlbGVjdG9yKGAuJHtwYXJhbXMuY29udGFpbmVyQ2xhc3N9YCk7XG4gICAgICBpZiAoaW1hZ2VFbCkge1xuICAgICAgICBpbWFnZUVsID0gaW1hZ2VFbC5xdWVyeVNlbGVjdG9yQWxsKCdwaWN0dXJlLCBpbWcsIHN2ZywgY2FudmFzLCAuc3dpcGVyLXpvb20tdGFyZ2V0JylbMF07XG4gICAgICB9XG4gICAgICBnZXN0dXJlLmltYWdlRWwgPSBpbWFnZUVsO1xuICAgICAgaWYgKGltYWdlRWwpIHtcbiAgICAgICAgZ2VzdHVyZS5pbWFnZVdyYXBFbCA9IGVsZW1lbnRQYXJlbnRzKGdlc3R1cmUuaW1hZ2VFbCwgYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlc3R1cmUuaW1hZ2VXcmFwRWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ2VzdHVyZS5pbWFnZUVsIHx8ICFnZXN0dXJlLmltYWdlV3JhcEVsKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcbiAgICB9XG4gICAgZ2VzdHVyZS5zbGlkZUVsLmNsYXNzTGlzdC5hZGQoYCR7cGFyYW1zLnpvb21lZFNsaWRlQ2xhc3N9YCk7XG4gICAgbGV0IHRvdWNoWDtcbiAgICBsZXQgdG91Y2hZO1xuICAgIGxldCBvZmZzZXRYO1xuICAgIGxldCBvZmZzZXRZO1xuICAgIGxldCBkaWZmWDtcbiAgICBsZXQgZGlmZlk7XG4gICAgbGV0IHRyYW5zbGF0ZVg7XG4gICAgbGV0IHRyYW5zbGF0ZVk7XG4gICAgbGV0IGltYWdlV2lkdGg7XG4gICAgbGV0IGltYWdlSGVpZ2h0O1xuICAgIGxldCBzY2FsZWRXaWR0aDtcbiAgICBsZXQgc2NhbGVkSGVpZ2h0O1xuICAgIGxldCB0cmFuc2xhdGVNaW5YO1xuICAgIGxldCB0cmFuc2xhdGVNaW5ZO1xuICAgIGxldCB0cmFuc2xhdGVNYXhYO1xuICAgIGxldCB0cmFuc2xhdGVNYXhZO1xuICAgIGxldCBzbGlkZVdpZHRoO1xuICAgIGxldCBzbGlkZUhlaWdodDtcbiAgICBpZiAodHlwZW9mIGltYWdlLnRvdWNoZXNTdGFydC54ID09PSAndW5kZWZpbmVkJyAmJiBlKSB7XG4gICAgICB0b3VjaFggPSBlLnBhZ2VYO1xuICAgICAgdG91Y2hZID0gZS5wYWdlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG91Y2hYID0gaW1hZ2UudG91Y2hlc1N0YXJ0Lng7XG4gICAgICB0b3VjaFkgPSBpbWFnZS50b3VjaGVzU3RhcnQueTtcbiAgICB9XG4gICAgY29uc3QgZm9yY2Vab29tUmF0aW8gPSB0eXBlb2YgZSA9PT0gJ251bWJlcicgPyBlIDogbnVsbDtcbiAgICBpZiAoY3VycmVudFNjYWxlID09PSAxICYmIGZvcmNlWm9vbVJhdGlvKSB7XG4gICAgICB0b3VjaFggPSB1bmRlZmluZWQ7XG4gICAgICB0b3VjaFkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1heFJhdGlvID0gZ2V0TWF4UmF0aW8oKTtcbiAgICB6b29tLnNjYWxlID0gZm9yY2Vab29tUmF0aW8gfHwgbWF4UmF0aW87XG4gICAgY3VycmVudFNjYWxlID0gZm9yY2Vab29tUmF0aW8gfHwgbWF4UmF0aW87XG4gICAgaWYgKGUgJiYgIShjdXJyZW50U2NhbGUgPT09IDEgJiYgZm9yY2Vab29tUmF0aW8pKSB7XG4gICAgICBzbGlkZVdpZHRoID0gZ2VzdHVyZS5zbGlkZUVsLm9mZnNldFdpZHRoO1xuICAgICAgc2xpZGVIZWlnaHQgPSBnZXN0dXJlLnNsaWRlRWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgb2Zmc2V0WCA9IGVsZW1lbnRPZmZzZXQoZ2VzdHVyZS5zbGlkZUVsKS5sZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgICBvZmZzZXRZID0gZWxlbWVudE9mZnNldChnZXN0dXJlLnNsaWRlRWwpLnRvcCArIHdpbmRvdy5zY3JvbGxZO1xuICAgICAgZGlmZlggPSBvZmZzZXRYICsgc2xpZGVXaWR0aCAvIDIgLSB0b3VjaFg7XG4gICAgICBkaWZmWSA9IG9mZnNldFkgKyBzbGlkZUhlaWdodCAvIDIgLSB0b3VjaFk7XG4gICAgICBpbWFnZVdpZHRoID0gZ2VzdHVyZS5pbWFnZUVsLm9mZnNldFdpZHRoIHx8IGdlc3R1cmUuaW1hZ2VFbC5jbGllbnRXaWR0aDtcbiAgICAgIGltYWdlSGVpZ2h0ID0gZ2VzdHVyZS5pbWFnZUVsLm9mZnNldEhlaWdodCB8fCBnZXN0dXJlLmltYWdlRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgc2NhbGVkV2lkdGggPSBpbWFnZVdpZHRoICogem9vbS5zY2FsZTtcbiAgICAgIHNjYWxlZEhlaWdodCA9IGltYWdlSGVpZ2h0ICogem9vbS5zY2FsZTtcbiAgICAgIHRyYW5zbGF0ZU1pblggPSBNYXRoLm1pbihzbGlkZVdpZHRoIC8gMiAtIHNjYWxlZFdpZHRoIC8gMiwgMCk7XG4gICAgICB0cmFuc2xhdGVNaW5ZID0gTWF0aC5taW4oc2xpZGVIZWlnaHQgLyAyIC0gc2NhbGVkSGVpZ2h0IC8gMiwgMCk7XG4gICAgICB0cmFuc2xhdGVNYXhYID0gLXRyYW5zbGF0ZU1pblg7XG4gICAgICB0cmFuc2xhdGVNYXhZID0gLXRyYW5zbGF0ZU1pblk7XG4gICAgICB0cmFuc2xhdGVYID0gZGlmZlggKiB6b29tLnNjYWxlO1xuICAgICAgdHJhbnNsYXRlWSA9IGRpZmZZICogem9vbS5zY2FsZTtcbiAgICAgIGlmICh0cmFuc2xhdGVYIDwgdHJhbnNsYXRlTWluWCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWluWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2xhdGVYID4gdHJhbnNsYXRlTWF4WCkge1xuICAgICAgICB0cmFuc2xhdGVYID0gdHJhbnNsYXRlTWF4WDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2xhdGVZIDwgdHJhbnNsYXRlTWluWSkge1xuICAgICAgICB0cmFuc2xhdGVZID0gdHJhbnNsYXRlTWluWTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2xhdGVZID4gdHJhbnNsYXRlTWF4WSkge1xuICAgICAgICB0cmFuc2xhdGVZID0gdHJhbnNsYXRlTWF4WTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNsYXRlWCA9IDA7XG4gICAgICB0cmFuc2xhdGVZID0gMDtcbiAgICB9XG4gICAgaWYgKGZvcmNlWm9vbVJhdGlvICYmIHpvb20uc2NhbGUgPT09IDEpIHtcbiAgICAgIGdlc3R1cmUub3JpZ2luWCA9IDA7XG4gICAgICBnZXN0dXJlLm9yaWdpblkgPSAwO1xuICAgIH1cbiAgICBnZXN0dXJlLmltYWdlV3JhcEVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICczMDBtcyc7XG4gICAgZ2VzdHVyZS5pbWFnZVdyYXBFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYfXB4LCAke3RyYW5zbGF0ZVl9cHgsMClgO1xuICAgIGdlc3R1cmUuaW1hZ2VFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMzAwbXMnO1xuICAgIGdlc3R1cmUuaW1hZ2VFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7em9vbS5zY2FsZX0pYDtcbiAgfVxuICBmdW5jdGlvbiB6b29tT3V0KCkge1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLnpvb207XG4gICAgaWYgKCFnZXN0dXJlLnNsaWRlRWwpIHtcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgc3dpcGVyLnZpcnR1YWwpIHtcbiAgICAgICAgZ2VzdHVyZS5zbGlkZUVsID0gZWxlbWVudENoaWxkcmVuKHN3aXBlci5zbGlkZXNFbCwgYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlc3R1cmUuc2xpZGVFbCA9IHN3aXBlci5zbGlkZXNbc3dpcGVyLmFjdGl2ZUluZGV4XTtcbiAgICAgIH1cbiAgICAgIGxldCBpbWFnZUVsID0gZ2VzdHVyZS5zbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3BhcmFtcy5jb250YWluZXJDbGFzc31gKTtcbiAgICAgIGlmIChpbWFnZUVsKSB7XG4gICAgICAgIGltYWdlRWwgPSBpbWFnZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3BpY3R1cmUsIGltZywgc3ZnLCBjYW52YXMsIC5zd2lwZXItem9vbS10YXJnZXQnKVswXTtcbiAgICAgIH1cbiAgICAgIGdlc3R1cmUuaW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgICBpZiAoaW1hZ2VFbCkge1xuICAgICAgICBnZXN0dXJlLmltYWdlV3JhcEVsID0gZWxlbWVudFBhcmVudHMoZ2VzdHVyZS5pbWFnZUVsLCBgLiR7cGFyYW1zLmNvbnRhaW5lckNsYXNzfWApWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VzdHVyZS5pbWFnZVdyYXBFbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLmltYWdlRWwgfHwgIWdlc3R1cmUuaW1hZ2VXcmFwRWwpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnRvdWNoQWN0aW9uID0gJyc7XG4gICAgfVxuICAgIHpvb20uc2NhbGUgPSAxO1xuICAgIGN1cnJlbnRTY2FsZSA9IDE7XG4gICAgZ2VzdHVyZS5pbWFnZVdyYXBFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMzAwbXMnO1xuICAgIGdlc3R1cmUuaW1hZ2VXcmFwRWwuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsMCwwKSc7XG4gICAgZ2VzdHVyZS5pbWFnZUVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICczMDBtcyc7XG4gICAgZ2VzdHVyZS5pbWFnZUVsLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSknO1xuICAgIGdlc3R1cmUuc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BhcmFtcy56b29tZWRTbGlkZUNsYXNzfWApO1xuICAgIGdlc3R1cmUuc2xpZGVFbCA9IHVuZGVmaW5lZDtcbiAgICBnZXN0dXJlLm9yaWdpblggPSAwO1xuICAgIGdlc3R1cmUub3JpZ2luWSA9IDA7XG4gIH1cblxuICAvLyBUb2dnbGUgWm9vbVxuICBmdW5jdGlvbiB6b29tVG9nZ2xlKGUpIHtcbiAgICBjb25zdCB6b29tID0gc3dpcGVyLnpvb207XG4gICAgaWYgKHpvb20uc2NhbGUgJiYgem9vbS5zY2FsZSAhPT0gMSkge1xuICAgICAgLy8gWm9vbSBPdXRcbiAgICAgIHpvb21PdXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gWm9vbSBJblxuICAgICAgem9vbUluKGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgcGFzc2l2ZUxpc3RlbmVyID0gc3dpcGVyLnBhcmFtcy5wYXNzaXZlTGlzdGVuZXJzID8ge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSA6IGZhbHNlO1xuICAgIGNvbnN0IGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmUgPSBzd2lwZXIucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMgPyB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9IDogdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzc2l2ZUxpc3RlbmVyLFxuICAgICAgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZVxuICAgIH07XG4gIH1cblxuICAvLyBBdHRhY2gvRGV0YWNoIEV2ZW50c1xuICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgY29uc3Qgem9vbSA9IHN3aXBlci56b29tO1xuICAgIGlmICh6b29tLmVuYWJsZWQpIHJldHVybjtcbiAgICB6b29tLmVuYWJsZWQgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhc3NpdmVMaXN0ZW5lcixcbiAgICAgIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmVcbiAgICB9ID0gZ2V0TGlzdGVuZXJzKCk7XG5cbiAgICAvLyBTY2FsZSBpbWFnZVxuICAgIHN3aXBlci53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICBzd2lwZXIud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25HZXN0dXJlQ2hhbmdlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcbiAgICBbJ3BvaW50ZXJ1cCcsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJvdXQnXS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvbkdlc3R1cmVFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uVG91Y2hNb3ZlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHpvb20gPSBzd2lwZXIuem9vbTtcbiAgICBpZiAoIXpvb20uZW5hYmxlZCkgcmV0dXJuO1xuICAgIHpvb20uZW5hYmxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhc3NpdmVMaXN0ZW5lcixcbiAgICAgIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmVcbiAgICB9ID0gZ2V0TGlzdGVuZXJzKCk7XG5cbiAgICAvLyBTY2FsZSBpbWFnZVxuICAgIHN3aXBlci53cmFwcGVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvbkdlc3R1cmVTdGFydCwgcGFzc2l2ZUxpc3RlbmVyKTtcbiAgICBzd2lwZXIud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25HZXN0dXJlQ2hhbmdlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcbiAgICBbJ3BvaW50ZXJ1cCcsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJvdXQnXS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvbkdlc3R1cmVFbmQsIHBhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGltYWdlXG4gICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uVG91Y2hNb3ZlLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlKTtcbiAgfVxuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQpIHtcbiAgICAgIGVuYWJsZSgpO1xuICAgIH1cbiAgfSk7XG4gIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgIGRpc2FibGUoKTtcbiAgfSk7XG4gIG9uKCd0b3VjaFN0YXJ0JywgKF9zLCBlKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgb25Ub3VjaFN0YXJ0KGUpO1xuICB9KTtcbiAgb24oJ3RvdWNoRW5kJywgKF9zLCBlKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIuem9vbS5lbmFibGVkKSByZXR1cm47XG4gICAgb25Ub3VjaEVuZCgpO1xuICB9KTtcbiAgb24oJ2RvdWJsZVRhcCcsIChfcywgZSkgPT4ge1xuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZyAmJiBzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIuem9vbS5lbmFibGVkICYmIHN3aXBlci5wYXJhbXMuem9vbS50b2dnbGUpIHtcbiAgICAgIHpvb21Ub2dnbGUoZSk7XG4gICAgfVxuICB9KTtcbiAgb24oJ3RyYW5zaXRpb25FbmQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci56b29tLmVuYWJsZWQgJiYgc3dpcGVyLnBhcmFtcy56b29tLmVuYWJsZWQpIHtcbiAgICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIH1cbiAgfSk7XG4gIG9uKCdzbGlkZUNoYW5nZScsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLnpvb20uZW5hYmxlZCAmJiBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLnpvb20sIHtcbiAgICBlbmFibGUsXG4gICAgZGlzYWJsZSxcbiAgICBpbjogem9vbUluLFxuICAgIG91dDogem9vbU91dCxcbiAgICB0b2dnbGU6IHpvb21Ub2dnbGVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IFpvb20gYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgbiBhcyBuZXh0VGljaywgayBhcyBlbGVtZW50VHJhbnNpdGlvbkVuZCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5tanMnO1xuXG4vKiBlc2xpbnQgbm8tYml0d2lzZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcIj4+XCJdIH1dICovXG5mdW5jdGlvbiBDb250cm9sbGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGNvbnRyb2xsZXI6IHtcbiAgICAgIGNvbnRyb2w6IHVuZGVmaW5lZCxcbiAgICAgIGludmVyc2U6IGZhbHNlLFxuICAgICAgYnk6ICdzbGlkZScgLy8gb3IgJ2NvbnRhaW5lcidcbiAgICB9XG4gIH0pO1xuXG4gIHN3aXBlci5jb250cm9sbGVyID0ge1xuICAgIGNvbnRyb2w6IHVuZGVmaW5lZFxuICB9O1xuICBmdW5jdGlvbiBMaW5lYXJTcGxpbmUoeCwgeSkge1xuICAgIGNvbnN0IGJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICAgIGxldCBtYXhJbmRleDtcbiAgICAgIGxldCBtaW5JbmRleDtcbiAgICAgIGxldCBndWVzcztcbiAgICAgIHJldHVybiAoYXJyYXksIHZhbCkgPT4ge1xuICAgICAgICBtaW5JbmRleCA9IC0xO1xuICAgICAgICBtYXhJbmRleCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG1heEluZGV4IC0gbWluSW5kZXggPiAxKSB7XG4gICAgICAgICAgZ3Vlc3MgPSBtYXhJbmRleCArIG1pbkluZGV4ID4+IDE7XG4gICAgICAgICAgaWYgKGFycmF5W2d1ZXNzXSA8PSB2YWwpIHtcbiAgICAgICAgICAgIG1pbkluZGV4ID0gZ3Vlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gZ3Vlc3M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhJbmRleDtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmxhc3RJbmRleCA9IHgubGVuZ3RoIC0gMTtcbiAgICAvLyBHaXZlbiBhbiB4IHZhbHVlICh4MiksIHJldHVybiB0aGUgZXhwZWN0ZWQgeTIgdmFsdWU6XG4gICAgLy8gKHgxLHkxKSBpcyB0aGUga25vd24gcG9pbnQgYmVmb3JlIGdpdmVuIHZhbHVlLFxuICAgIC8vICh4Myx5MykgaXMgdGhlIGtub3duIHBvaW50IGFmdGVyIGdpdmVuIHZhbHVlLlxuICAgIGxldCBpMTtcbiAgICBsZXQgaTM7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIGludGVycG9sYXRlKHgyKSB7XG4gICAgICBpZiAoIXgyKSByZXR1cm4gMDtcblxuICAgICAgLy8gR2V0IHRoZSBpbmRleGVzIG9mIHgxIGFuZCB4MyAodGhlIGFycmF5IGluZGV4ZXMgYmVmb3JlIGFuZCBhZnRlciBnaXZlbiB4Mik6XG4gICAgICBpMyA9IGJpbmFyeVNlYXJjaCh0aGlzLngsIHgyKTtcbiAgICAgIGkxID0gaTMgLSAxO1xuXG4gICAgICAvLyBXZSBoYXZlIG91ciBpbmRleGVzIGkxICYgaTMsIHNvIHdlIGNhbiBjYWxjdWxhdGUgYWxyZWFkeTpcbiAgICAgIC8vIHkyIDo9ICgoeDLiiJJ4MSkgw5cgKHkz4oiSeTEpKSDDtyAoeDPiiJJ4MSkgKyB5MVxuICAgICAgcmV0dXJuICh4MiAtIHRoaXMueFtpMV0pICogKHRoaXMueVtpM10gLSB0aGlzLnlbaTFdKSAvICh0aGlzLnhbaTNdIC0gdGhpcy54W2kxXSkgKyB0aGlzLnlbaTFdO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdGVGdW5jdGlvbihjKSB7XG4gICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gc3dpcGVyLnBhcmFtcy5sb29wID8gbmV3IExpbmVhclNwbGluZShzd2lwZXIuc2xpZGVzR3JpZCwgYy5zbGlkZXNHcmlkKSA6IG5ldyBMaW5lYXJTcGxpbmUoc3dpcGVyLnNuYXBHcmlkLCBjLnNuYXBHcmlkKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRUcmFuc2xhdGUoX3QsIGJ5Q29udHJvbGxlcikge1xuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBzd2lwZXIuY29udHJvbGxlci5jb250cm9sO1xuICAgIGxldCBtdWx0aXBsaWVyO1xuICAgIGxldCBjb250cm9sbGVkVHJhbnNsYXRlO1xuICAgIGNvbnN0IFN3aXBlciA9IHN3aXBlci5jb25zdHJ1Y3RvcjtcbiAgICBmdW5jdGlvbiBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGMpIHtcbiAgICAgIGlmIChjLmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgICAvLyB0aGlzIHdpbGwgY3JlYXRlIGFuIEludGVycG9sYXRlIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSBzbmFwR3JpZHNcbiAgICAgIC8vIHggaXMgdGhlIEdyaWQgb2YgdGhlIHNjcm9sbGVkIHNjcm9sbGVyIGFuZCB5IHdpbGwgYmUgdGhlIGNvbnRyb2xsZWQgc2Nyb2xsZXJcbiAgICAgIC8vIGl0IG1ha2VzIHNlbnNlIHRvIGNyZWF0ZSB0aGlzIG9ubHkgb25jZSBhbmQgcmVjYWxsIGl0IGZvciB0aGUgaW50ZXJwb2xhdGlvblxuICAgICAgLy8gdGhlIGZ1bmN0aW9uIGRvZXMgYSBsb3Qgb2YgdmFsdWUgY2FjaGluZyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmJ5ID09PSAnc2xpZGUnKSB7XG4gICAgICAgIGdldEludGVycG9sYXRlRnVuY3Rpb24oYyk7XG4gICAgICAgIC8vIGkgYW0gbm90IHN1cmUgd2h5IHRoZSB2YWx1ZXMgaGF2ZSB0byBiZSBtdWx0aXBsaWNhdGVkIHRoaXMgd2F5LCB0cmllZCB0byBpbnZlcnQgdGhlIHNuYXBHcmlkXG4gICAgICAgIC8vIGJ1dCBpdCBkaWQgbm90IHdvcmsgb3V0XG4gICAgICAgIGNvbnRyb2xsZWRUcmFuc2xhdGUgPSAtc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC10cmFuc2xhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFjb250cm9sbGVkVHJhbnNsYXRlIHx8IHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5ieSA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgbXVsdGlwbGllciA9IChjLm1heFRyYW5zbGF0ZSgpIC0gYy5taW5UcmFuc2xhdGUoKSkgLyAoc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtdWx0aXBsaWVyKSB8fCAhTnVtYmVyLmlzRmluaXRlKG11bHRpcGxpZXIpKSB7XG4gICAgICAgICAgbXVsdGlwbGllciA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlZFRyYW5zbGF0ZSA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpICogbXVsdGlwbGllciArIGMubWluVHJhbnNsYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jb250cm9sbGVyLmludmVyc2UpIHtcbiAgICAgICAgY29udHJvbGxlZFRyYW5zbGF0ZSA9IGMubWF4VHJhbnNsYXRlKCkgLSBjb250cm9sbGVkVHJhbnNsYXRlO1xuICAgICAgfVxuICAgICAgYy51cGRhdGVQcm9ncmVzcyhjb250cm9sbGVkVHJhbnNsYXRlKTtcbiAgICAgIGMuc2V0VHJhbnNsYXRlKGNvbnRyb2xsZWRUcmFuc2xhdGUsIHN3aXBlcik7XG4gICAgICBjLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBjLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udHJvbGxlZCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNsYXRlKGNvbnRyb2xsZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVkIGluc3RhbmNlb2YgU3dpcGVyICYmIGJ5Q29udHJvbGxlciAhPT0gY29udHJvbGxlZCkge1xuICAgICAgc2V0Q29udHJvbGxlZFRyYW5zbGF0ZShjb250cm9sbGVkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihkdXJhdGlvbiwgYnlDb250cm9sbGVyKSB7XG4gICAgY29uc3QgU3dpcGVyID0gc3dpcGVyLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNvbnRyb2xsZWQgPSBzd2lwZXIuY29udHJvbGxlci5jb250cm9sO1xuICAgIGxldCBpO1xuICAgIGZ1bmN0aW9uIHNldENvbnRyb2xsZWRUcmFuc2l0aW9uKGMpIHtcbiAgICAgIGlmIChjLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgYy5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBzd2lwZXIpO1xuICAgICAgaWYgKGR1cmF0aW9uICE9PSAwKSB7XG4gICAgICAgIGMudHJhbnNpdGlvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjLnBhcmFtcy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgYy51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFRyYW5zaXRpb25FbmQoYy53cmFwcGVyRWwsICgpID0+IHtcbiAgICAgICAgICBpZiAoIWNvbnRyb2xsZWQpIHJldHVybjtcbiAgICAgICAgICBjLnRyYW5zaXRpb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xsZWQpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29udHJvbGxlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udHJvbGxlZFtpXSAhPT0gYnlDb250cm9sbGVyICYmIGNvbnRyb2xsZWRbaV0gaW5zdGFuY2VvZiBTd2lwZXIpIHtcbiAgICAgICAgICBzZXRDb250cm9sbGVkVHJhbnNpdGlvbihjb250cm9sbGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlZCBpbnN0YW5jZW9mIFN3aXBlciAmJiBieUNvbnRyb2xsZXIgIT09IGNvbnRyb2xsZWQpIHtcbiAgICAgIHNldENvbnRyb2xsZWRUcmFuc2l0aW9uKGNvbnRyb2xsZWQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVTcGxpbmUoKSB7XG4gICAgaWYgKCFzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5jb250cm9sbGVyLnNwbGluZSkge1xuICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuc3BsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgZGVsZXRlIHN3aXBlci5jb250cm9sbGVyLnNwbGluZTtcbiAgICB9XG4gIH1cbiAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5jb250cm9sID09PSAnc3RyaW5nJyB8fCBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgY29uc3QgY29udHJvbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHN3aXBlci5wYXJhbXMuY29udHJvbGxlci5jb250cm9sKTtcbiAgICAgIGlmIChjb250cm9sRWxlbWVudCAmJiBjb250cm9sRWxlbWVudC5zd2lwZXIpIHtcbiAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCA9IGNvbnRyb2xFbGVtZW50LnN3aXBlcjtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb25Db250cm9sbGVyU3dpcGVyID0gZSA9PiB7XG4gICAgICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCA9IGUuZGV0YWlsWzBdO1xuICAgICAgICAgIHN3aXBlci51cGRhdGUoKTtcbiAgICAgICAgICBjb250cm9sRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbml0Jywgb25Db250cm9sbGVyU3dpcGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udHJvbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5pdCcsIG9uQ29udHJvbGxlclN3aXBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgPSBzd2lwZXIucGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbDtcbiAgfSk7XG4gIG9uKCd1cGRhdGUnLCAoKSA9PiB7XG4gICAgcmVtb3ZlU3BsaW5lKCk7XG4gIH0pO1xuICBvbigncmVzaXplJywgKCkgPT4ge1xuICAgIHJlbW92ZVNwbGluZSgpO1xuICB9KTtcbiAgb24oJ29ic2VydmVyVXBkYXRlJywgKCkgPT4ge1xuICAgIHJlbW92ZVNwbGluZSgpO1xuICB9KTtcbiAgb24oJ3NldFRyYW5zbGF0ZScsIChfcywgdHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpID0+IHtcbiAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgfHwgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBzd2lwZXIuY29udHJvbGxlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xuICB9KTtcbiAgb24oJ3NldFRyYW5zaXRpb24nLCAoX3MsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpID0+IHtcbiAgICBpZiAoIXN3aXBlci5jb250cm9sbGVyLmNvbnRyb2wgfHwgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBzd2lwZXIuY29udHJvbGxlci5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xuICB9KTtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIuY29udHJvbGxlciwge1xuICAgIHNldFRyYW5zbGF0ZSxcbiAgICBzZXRUcmFuc2l0aW9uXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb250cm9sbGVyIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGcgYXMgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi9zaGFyZWQvc3NyLXdpbmRvdy5lc20ubWpzJztcbmltcG9ydCB7IGMgYXMgY2xhc3Nlc1RvU2VsZWN0b3IgfSBmcm9tICcuLi9zaGFyZWQvY2xhc3Nlcy10by1zZWxlY3Rvci5tanMnO1xuaW1wb3J0IHsgYyBhcyBjcmVhdGVFbGVtZW50LCBoIGFzIGVsZW1lbnRJbmRleCwgbSBhcyBtYWtlRWxlbWVudHNBcnJheSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBBMTF5KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGExMXk6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBub3RpZmljYXRpb25DbGFzczogJ3N3aXBlci1ub3RpZmljYXRpb24nLFxuICAgICAgcHJldlNsaWRlTWVzc2FnZTogJ1ByZXZpb3VzIHNsaWRlJyxcbiAgICAgIG5leHRTbGlkZU1lc3NhZ2U6ICdOZXh0IHNsaWRlJyxcbiAgICAgIGZpcnN0U2xpZGVNZXNzYWdlOiAnVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGUnLFxuICAgICAgbGFzdFNsaWRlTWVzc2FnZTogJ1RoaXMgaXMgdGhlIGxhc3Qgc2xpZGUnLFxuICAgICAgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6ICdHbyB0byBzbGlkZSB7e2luZGV4fX0nLFxuICAgICAgc2xpZGVMYWJlbE1lc3NhZ2U6ICd7e2luZGV4fX0gLyB7e3NsaWRlc0xlbmd0aH19JyxcbiAgICAgIGNvbnRhaW5lck1lc3NhZ2U6IG51bGwsXG4gICAgICBjb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxuICAgICAgaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2U6IG51bGwsXG4gICAgICBzbGlkZVJvbGU6ICdncm91cCcsXG4gICAgICBpZDogbnVsbFxuICAgIH1cbiAgfSk7XG4gIHN3aXBlci5hMTF5ID0ge1xuICAgIGNsaWNrZWQ6IGZhbHNlXG4gIH07XG4gIGxldCBsaXZlUmVnaW9uID0gbnVsbDtcbiAgbGV0IHByZXZlbnRGb2N1c0hhbmRsZXI7XG4gIGxldCBmb2N1c1RhcmdldFNsaWRlRWw7XG4gIGxldCB2aXNpYmlsaXR5Q2hhbmdlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBub3RpZnkobWVzc2FnZSkge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGxpdmVSZWdpb247XG4gICAgaWYgKG5vdGlmaWNhdGlvbi5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBub3RpZmljYXRpb24uaW5uZXJIVE1MID0gJyc7XG4gICAgbm90aWZpY2F0aW9uLmlubmVySFRNTCA9IG1lc3NhZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzaXplID0gMTY7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUNoYXIgPSAoKSA9PiBNYXRoLnJvdW5kKDE2ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiAneCcucmVwZWF0KHNpemUpLnJlcGxhY2UoL3gvZywgcmFuZG9tQ2hhcik7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZUVsRm9jdXNhYmxlKGVsKSB7XG4gICAgZWwgPSBtYWtlRWxlbWVudHNBcnJheShlbCk7XG4gICAgZWwuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICBzdWJFbC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgJzAnKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlRWxOb3RGb2N1c2FibGUoZWwpIHtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBlbC5mb3JFYWNoKHN1YkVsID0+IHtcbiAgICAgIHN1YkVsLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFbFJvbGUoZWwsIHJvbGUpIHtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBlbC5mb3JFYWNoKHN1YkVsID0+IHtcbiAgICAgIHN1YkVsLnNldEF0dHJpYnV0ZSgncm9sZScsIHJvbGUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEVsUm9sZURlc2NyaXB0aW9uKGVsLCBkZXNjcmlwdGlvbikge1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgc3ViRWwuc2V0QXR0cmlidXRlKCdhcmlhLXJvbGVkZXNjcmlwdGlvbicsIGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhZGRFbENvbnRyb2xzKGVsLCBjb250cm9scykge1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgc3ViRWwuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgY29udHJvbHMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEVsTGFiZWwoZWwsIGxhYmVsKSB7XG4gICAgZWwgPSBtYWtlRWxlbWVudHNBcnJheShlbCk7XG4gICAgZWwuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICBzdWJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRWxJZChlbCwgaWQpIHtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBlbC5mb3JFYWNoKHN1YkVsID0+IHtcbiAgICAgIHN1YkVsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRWxMaXZlKGVsLCBsaXZlKSB7XG4gICAgZWwgPSBtYWtlRWxlbWVudHNBcnJheShlbCk7XG4gICAgZWwuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICBzdWJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIGxpdmUpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGRpc2FibGVFbChlbCkge1xuICAgIGVsID0gbWFrZUVsZW1lbnRzQXJyYXkoZWwpO1xuICAgIGVsLmZvckVhY2goc3ViRWwgPT4ge1xuICAgICAgc3ViRWwuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlRWwoZWwpIHtcbiAgICBlbCA9IG1ha2VFbGVtZW50c0FycmF5KGVsKTtcbiAgICBlbC5mb3JFYWNoKHN1YkVsID0+IHtcbiAgICAgIHN1YkVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvbkVudGVyT3JTcGFjZUtleShlKSB7XG4gICAgaWYgKGUua2V5Q29kZSAhPT0gMTMgJiYgZS5rZXlDb2RlICE9PSAzMikgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuYTExeTtcbiAgICBjb25zdCB0YXJnZXRFbCA9IGUudGFyZ2V0O1xuICAgIGlmIChzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFnaW5hdGlvbi5lbCAmJiAodGFyZ2V0RWwgPT09IHN3aXBlci5wYWdpbmF0aW9uLmVsIHx8IHN3aXBlci5wYWdpbmF0aW9uLmVsLmNvbnRhaW5zKGUudGFyZ2V0KSkpIHtcbiAgICAgIGlmICghZS50YXJnZXQubWF0Y2hlcyhjbGFzc2VzVG9TZWxlY3Rvcihzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLm5hdmlnYXRpb24gJiYgc3dpcGVyLm5hdmlnYXRpb24ucHJldkVsICYmIHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgICAgY29uc3QgcHJldkVscyA9IG1ha2VFbGVtZW50c0FycmF5KHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCk7XG4gICAgICBjb25zdCBuZXh0RWxzID0gbWFrZUVsZW1lbnRzQXJyYXkoc3dpcGVyLm5hdmlnYXRpb24ubmV4dEVsKTtcbiAgICAgIGlmIChuZXh0RWxzLmluY2x1ZGVzKHRhcmdldEVsKSkge1xuICAgICAgICBpZiAoIShzd2lwZXIuaXNFbmQgJiYgIXN3aXBlci5wYXJhbXMubG9vcCkpIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3aXBlci5pc0VuZCkge1xuICAgICAgICAgIG5vdGlmeShwYXJhbXMubGFzdFNsaWRlTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90aWZ5KHBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXZFbHMuaW5jbHVkZXModGFyZ2V0RWwpKSB7XG4gICAgICAgIGlmICghKHN3aXBlci5pc0JlZ2lubmluZyAmJiAhc3dpcGVyLnBhcmFtcy5sb29wKSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVByZXYoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgICAgbm90aWZ5KHBhcmFtcy5maXJzdFNsaWRlTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90aWZ5KHBhcmFtcy5wcmV2U2xpZGVNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhZ2luYXRpb24gJiYgdGFyZ2V0RWwubWF0Y2hlcyhjbGFzc2VzVG9TZWxlY3Rvcihzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSkge1xuICAgICAgdGFyZ2V0RWwuY2xpY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvbigpIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5sb29wIHx8IHN3aXBlci5wYXJhbXMucmV3aW5kIHx8ICFzd2lwZXIubmF2aWdhdGlvbikgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIG5leHRFbCxcbiAgICAgIHByZXZFbFxuICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbjtcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzQmVnaW5uaW5nKSB7XG4gICAgICAgIGRpc2FibGVFbChwcmV2RWwpO1xuICAgICAgICBtYWtlRWxOb3RGb2N1c2FibGUocHJldkVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuYWJsZUVsKHByZXZFbCk7XG4gICAgICAgIG1ha2VFbEZvY3VzYWJsZShwcmV2RWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dEVsKSB7XG4gICAgICBpZiAoc3dpcGVyLmlzRW5kKSB7XG4gICAgICAgIGRpc2FibGVFbChuZXh0RWwpO1xuICAgICAgICBtYWtlRWxOb3RGb2N1c2FibGUobmV4dEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuYWJsZUVsKG5leHRFbCk7XG4gICAgICAgIG1ha2VFbEZvY3VzYWJsZShuZXh0RWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYXNQYWdpbmF0aW9uKCkge1xuICAgIHJldHVybiBzd2lwZXIucGFnaW5hdGlvbiAmJiBzd2lwZXIucGFnaW5hdGlvbi5idWxsZXRzICYmIHN3aXBlci5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NsaWNrYWJsZVBhZ2luYXRpb24oKSB7XG4gICAgcmV0dXJuIGhhc1BhZ2luYXRpb24oKSAmJiBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVBhZ2luYXRpb24oKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5hMTF5O1xuICAgIGlmICghaGFzUGFnaW5hdGlvbigpKSByZXR1cm47XG4gICAgc3dpcGVyLnBhZ2luYXRpb24uYnVsbGV0cy5mb3JFYWNoKGJ1bGxldEVsID0+IHtcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlKSB7XG4gICAgICAgIG1ha2VFbEZvY3VzYWJsZShidWxsZXRFbCk7XG4gICAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5wYWdpbmF0aW9uLnJlbmRlckJ1bGxldCkge1xuICAgICAgICAgIGFkZEVsUm9sZShidWxsZXRFbCwgJ2J1dHRvbicpO1xuICAgICAgICAgIGFkZEVsTGFiZWwoYnVsbGV0RWwsIHBhcmFtcy5wYWdpbmF0aW9uQnVsbGV0TWVzc2FnZS5yZXBsYWNlKC9cXHtcXHtpbmRleFxcfVxcfS8sIGVsZW1lbnRJbmRleChidWxsZXRFbCkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWxsZXRFbC5tYXRjaGVzKGNsYXNzZXNUb1NlbGVjdG9yKHN3aXBlci5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRBY3RpdmVDbGFzcykpKSB7XG4gICAgICAgIGJ1bGxldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1bGxldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaW5pdE5hdkVsID0gKGVsLCB3cmFwcGVySWQsIG1lc3NhZ2UpID0+IHtcbiAgICBtYWtlRWxGb2N1c2FibGUoZWwpO1xuICAgIGlmIChlbC50YWdOYW1lICE9PSAnQlVUVE9OJykge1xuICAgICAgYWRkRWxSb2xlKGVsLCAnYnV0dG9uJyk7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25FbnRlck9yU3BhY2VLZXkpO1xuICAgIH1cbiAgICBhZGRFbExhYmVsKGVsLCBtZXNzYWdlKTtcbiAgICBhZGRFbENvbnRyb2xzKGVsLCB3cmFwcGVySWQpO1xuICB9O1xuICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IGUgPT4ge1xuICAgIGlmIChmb2N1c1RhcmdldFNsaWRlRWwgJiYgZm9jdXNUYXJnZXRTbGlkZUVsICE9PSBlLnRhcmdldCAmJiAhZm9jdXNUYXJnZXRTbGlkZUVsLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgcHJldmVudEZvY3VzSGFuZGxlciA9IHRydWU7XG4gICAgfVxuICAgIHN3aXBlci5hMTF5LmNsaWNrZWQgPSB0cnVlO1xuICB9O1xuICBjb25zdCBoYW5kbGVQb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgcHJldmVudEZvY3VzSGFuZGxlciA9IGZhbHNlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBzd2lwZXIuYTExeS5jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSBlID0+IHtcbiAgICB2aXNpYmlsaXR5Q2hhbmdlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuICBjb25zdCBoYW5kbGVGb2N1cyA9IGUgPT4ge1xuICAgIGlmIChzd2lwZXIuYTExeS5jbGlja2VkKSByZXR1cm47XG4gICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdmlzaWJpbGl0eUNoYW5nZWRUaW1lc3RhbXAgPCAxMDApIHJldHVybjtcbiAgICBjb25zdCBzbGlkZUVsID0gZS50YXJnZXQuY2xvc2VzdChgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gICAgaWYgKCFzbGlkZUVsIHx8ICFzd2lwZXIuc2xpZGVzLmluY2x1ZGVzKHNsaWRlRWwpKSByZXR1cm47XG4gICAgZm9jdXNUYXJnZXRTbGlkZUVsID0gc2xpZGVFbDtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHN3aXBlci5zbGlkZXMuaW5kZXhPZihzbGlkZUVsKSA9PT0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9IHN3aXBlci5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyAmJiBzd2lwZXIudmlzaWJsZVNsaWRlcyAmJiBzd2lwZXIudmlzaWJsZVNsaWRlcy5pbmNsdWRlcyhzbGlkZUVsKTtcbiAgICBpZiAoaXNBY3RpdmUgfHwgaXNWaXNpYmxlKSByZXR1cm47XG4gICAgaWYgKGUuc291cmNlQ2FwYWJpbGl0aWVzICYmIGUuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzd2lwZXIuZWwuc2Nyb2xsTGVmdCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbC5zY3JvbGxUb3AgPSAwO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHByZXZlbnRGb2N1c0hhbmRsZXIpIHJldHVybjtcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG9Mb29wKHBhcnNlSW50KHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpKSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuc2xpZGVzLmluZGV4T2Yoc2xpZGVFbCksIDApO1xuICAgICAgfVxuICAgICAgcHJldmVudEZvY3VzSGFuZGxlciA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBpbml0U2xpZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuYTExeTtcbiAgICBpZiAocGFyYW1zLml0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlKSB7XG4gICAgICBhZGRFbFJvbGVEZXNjcmlwdGlvbihzd2lwZXIuc2xpZGVzLCBwYXJhbXMuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnNsaWRlUm9sZSkge1xuICAgICAgYWRkRWxSb2xlKHN3aXBlci5zbGlkZXMsIHBhcmFtcy5zbGlkZVJvbGUpO1xuICAgIH1cbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgICBpZiAocGFyYW1zLnNsaWRlTGFiZWxNZXNzYWdlKSB7XG4gICAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goKHNsaWRlRWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzd2lwZXIucGFyYW1zLmxvb3AgPyBwYXJzZUludChzbGlkZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApIDogaW5kZXg7XG4gICAgICAgIGNvbnN0IGFyaWFMYWJlbE1lc3NhZ2UgPSBwYXJhbXMuc2xpZGVMYWJlbE1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7aW5kZXhcXH1cXH0vLCBzbGlkZUluZGV4ICsgMSkucmVwbGFjZSgvXFx7XFx7c2xpZGVzTGVuZ3RoXFx9XFx9Lywgc2xpZGVzTGVuZ3RoKTtcbiAgICAgICAgYWRkRWxMYWJlbChzbGlkZUVsLCBhcmlhTGFiZWxNZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmExMXk7XG4gICAgc3dpcGVyLmVsLmFwcGVuZChsaXZlUmVnaW9uKTtcblxuICAgIC8vIENvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRhaW5lckVsID0gc3dpcGVyLmVsO1xuICAgIGlmIChwYXJhbXMuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSkge1xuICAgICAgYWRkRWxSb2xlRGVzY3JpcHRpb24oY29udGFpbmVyRWwsIHBhcmFtcy5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jb250YWluZXJNZXNzYWdlKSB7XG4gICAgICBhZGRFbExhYmVsKGNvbnRhaW5lckVsLCBwYXJhbXMuY29udGFpbmVyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gV3JhcHBlclxuICAgIGNvbnN0IHdyYXBwZXJFbCA9IHN3aXBlci53cmFwcGVyRWw7XG4gICAgY29uc3Qgd3JhcHBlcklkID0gcGFyYW1zLmlkIHx8IHdyYXBwZXJFbC5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgYHN3aXBlci13cmFwcGVyLSR7Z2V0UmFuZG9tTnVtYmVyKDE2KX1gO1xuICAgIGNvbnN0IGxpdmUgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5ICYmIHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCA/ICdvZmYnIDogJ3BvbGl0ZSc7XG4gICAgYWRkRWxJZCh3cmFwcGVyRWwsIHdyYXBwZXJJZCk7XG4gICAgYWRkRWxMaXZlKHdyYXBwZXJFbCwgbGl2ZSk7XG5cbiAgICAvLyBTbGlkZVxuICAgIGluaXRTbGlkZXMoKTtcblxuICAgIC8vIE5hdmlnYXRpb25cbiAgICBsZXQge1xuICAgICAgbmV4dEVsLFxuICAgICAgcHJldkVsXG4gICAgfSA9IHN3aXBlci5uYXZpZ2F0aW9uID8gc3dpcGVyLm5hdmlnYXRpb24gOiB7fTtcbiAgICBuZXh0RWwgPSBtYWtlRWxlbWVudHNBcnJheShuZXh0RWwpO1xuICAgIHByZXZFbCA9IG1ha2VFbGVtZW50c0FycmF5KHByZXZFbCk7XG4gICAgaWYgKG5leHRFbCkge1xuICAgICAgbmV4dEVsLmZvckVhY2goZWwgPT4gaW5pdE5hdkVsKGVsLCB3cmFwcGVySWQsIHBhcmFtcy5uZXh0U2xpZGVNZXNzYWdlKSk7XG4gICAgfVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5mb3JFYWNoKGVsID0+IGluaXROYXZFbChlbCwgd3JhcHBlcklkLCBwYXJhbXMucHJldlNsaWRlTWVzc2FnZSkpO1xuICAgIH1cblxuICAgIC8vIFBhZ2luYXRpb25cbiAgICBpZiAoaGFzQ2xpY2thYmxlUGFnaW5hdGlvbigpKSB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRWwgPSBtYWtlRWxlbWVudHNBcnJheShzd2lwZXIucGFnaW5hdGlvbi5lbCk7XG4gICAgICBwYWdpbmF0aW9uRWwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbkVudGVyT3JTcGFjZUtleSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUYWIgZm9jdXNcbiAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgc3dpcGVyLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMsIHRydWUpO1xuICAgIHN3aXBlci5lbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgICBzd2lwZXIuZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgc3dpcGVyLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZVBvaW50ZXJVcCwgdHJ1ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKGxpdmVSZWdpb24pIGxpdmVSZWdpb24ucmVtb3ZlKCk7XG4gICAgbGV0IHtcbiAgICAgIG5leHRFbCxcbiAgICAgIHByZXZFbFxuICAgIH0gPSBzd2lwZXIubmF2aWdhdGlvbiA/IHN3aXBlci5uYXZpZ2F0aW9uIDoge307XG4gICAgbmV4dEVsID0gbWFrZUVsZW1lbnRzQXJyYXkobmV4dEVsKTtcbiAgICBwcmV2RWwgPSBtYWtlRWxlbWVudHNBcnJheShwcmV2RWwpO1xuICAgIGlmIChuZXh0RWwpIHtcbiAgICAgIG5leHRFbC5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbkVudGVyT3JTcGFjZUtleSkpO1xuICAgIH1cbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25FbnRlck9yU3BhY2VLZXkpKTtcbiAgICB9XG5cbiAgICAvLyBQYWdpbmF0aW9uXG4gICAgaWYgKGhhc0NsaWNrYWJsZVBhZ2luYXRpb24oKSkge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkVsID0gbWFrZUVsZW1lbnRzQXJyYXkoc3dpcGVyLnBhZ2luYXRpb24uZWwpO1xuICAgICAgcGFnaW5hdGlvbkVsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25FbnRlck9yU3BhY2VLZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAvLyBUYWIgZm9jdXNcbiAgICBpZiAoc3dpcGVyLmVsICYmIHR5cGVvZiBzd2lwZXIuZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2lwZXIuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cywgdHJ1ZSk7XG4gICAgICBzd2lwZXIuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICBzd2lwZXIuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgaGFuZGxlUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgbGl2ZVJlZ2lvbiA9IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBzd2lwZXIucGFyYW1zLmExMXkubm90aWZpY2F0aW9uQ2xhc3MpO1xuICAgIGxpdmVSZWdpb24uc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgbGl2ZVJlZ2lvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcbiAgfSk7XG4gIG9uKCdhZnRlckluaXQnLCAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgIGluaXQoKTtcbiAgfSk7XG4gIG9uKCdzbGlkZXNMZW5ndGhDaGFuZ2Ugc25hcEdyaWRMZW5ndGhDaGFuZ2Ugc2xpZGVzR3JpZExlbmd0aENoYW5nZScsICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgaW5pdFNsaWRlcygpO1xuICB9KTtcbiAgb24oJ2Zyb21FZGdlIHRvRWRnZSBhZnRlckluaXQgbG9jayB1bmxvY2snLCAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmExMXkuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgfSk7XG4gIG9uKCdwYWdpbmF0aW9uVXBkYXRlJywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5hMTF5LmVuYWJsZWQpIHJldHVybjtcbiAgICB1cGRhdGVQYWdpbmF0aW9uKCk7XG4gIH0pO1xuICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuYTExeS5lbmFibGVkKSByZXR1cm47XG4gICAgZGVzdHJveSgpO1xuICB9KTtcbn1cblxuZXhwb3J0IHsgQTExeSBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBhIGFzIGdldFdpbmRvdyB9IGZyb20gJy4uL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMnO1xuXG5mdW5jdGlvbiBIaXN0b3J5KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGhpc3Rvcnk6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgcm9vdDogJycsXG4gICAgICByZXBsYWNlU3RhdGU6IGZhbHNlLFxuICAgICAga2V5OiAnc2xpZGVzJyxcbiAgICAgIGtlZXBRdWVyeTogZmFsc2VcbiAgICB9XG4gIH0pO1xuICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgbGV0IHBhdGhzID0ge307XG4gIGNvbnN0IHNsdWdpZnkgPSB0ZXh0ID0+IHtcbiAgICByZXR1cm4gdGV4dC50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJy0nKS5yZXBsYWNlKC9bXlxcdy1dKy9nLCAnJykucmVwbGFjZSgvLS0rL2csICctJykucmVwbGFjZSgvXi0rLywgJycpLnJlcGxhY2UoLy0rJC8sICcnKTtcbiAgfTtcbiAgY29uc3QgZ2V0UGF0aFZhbHVlcyA9IHVybE92ZXJyaWRlID0+IHtcbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICBsZXQgbG9jYXRpb247XG4gICAgaWYgKHVybE92ZXJyaWRlKSB7XG4gICAgICBsb2NhdGlvbiA9IG5ldyBVUkwodXJsT3ZlcnJpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgcGF0aEFycmF5ID0gbG9jYXRpb24ucGF0aG5hbWUuc2xpY2UoMSkuc3BsaXQoJy8nKS5maWx0ZXIocGFydCA9PiBwYXJ0ICE9PSAnJyk7XG4gICAgY29uc3QgdG90YWwgPSBwYXRoQXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IGtleSA9IHBhdGhBcnJheVt0b3RhbCAtIDJdO1xuICAgIGNvbnN0IHZhbHVlID0gcGF0aEFycmF5W3RvdGFsIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc2V0SGlzdG9yeSA9IChrZXksIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgaWYgKCFpbml0aWFsaXplZCB8fCAhc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHJldHVybjtcbiAgICBsZXQgbG9jYXRpb247XG4gICAgaWYgKHN3aXBlci5wYXJhbXMudXJsKSB7XG4gICAgICBsb2NhdGlvbiA9IG5ldyBVUkwoc3dpcGVyLnBhcmFtcy51cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGUgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci5zbGlkZXNFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2luZGV4fVwiXWApIDogc3dpcGVyLnNsaWRlc1tpbmRleF07XG4gICAgbGV0IHZhbHVlID0gc2x1Z2lmeShzbGlkZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGlzdG9yeScpKTtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJvb3QubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHJvb3QgPSBzd2lwZXIucGFyYW1zLmhpc3Rvcnkucm9vdDtcbiAgICAgIGlmIChyb290W3Jvb3QubGVuZ3RoIC0gMV0gPT09ICcvJykgcm9vdCA9IHJvb3Quc2xpY2UoMCwgcm9vdC5sZW5ndGggLSAxKTtcbiAgICAgIHZhbHVlID0gYCR7cm9vdH0vJHtrZXkgPyBgJHtrZXl9L2AgOiAnJ30ke3ZhbHVlfWA7XG4gICAgfSBlbHNlIGlmICghbG9jYXRpb24ucGF0aG5hbWUuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgdmFsdWUgPSBgJHtrZXkgPyBgJHtrZXl9L2AgOiAnJ30ke3ZhbHVlfWA7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmhpc3Rvcnkua2VlcFF1ZXJ5KSB7XG4gICAgICB2YWx1ZSArPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlO1xuICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0sIG51bGwsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0sIG51bGwsIHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNjcm9sbFRvU2xpZGUgPSAoc3BlZWQsIHZhbHVlLCBydW5DYWxsYmFja3MpID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlc1tpXTtcbiAgICAgICAgY29uc3Qgc2xpZGVIaXN0b3J5ID0gc2x1Z2lmeShzbGlkZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGlzdG9yeScpKTtcbiAgICAgICAgaWYgKHNsaWRlSGlzdG9yeSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KHNsaWRlKTtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhpbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oMCwgc3BlZWQsIHJ1bkNhbGxiYWNrcyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRIaXN0b3J5UG9wU3RhdGUgPSAoKSA9PiB7XG4gICAgcGF0aHMgPSBnZXRQYXRoVmFsdWVzKHN3aXBlci5wYXJhbXMudXJsKTtcbiAgICBzY3JvbGxUb1NsaWRlKHN3aXBlci5wYXJhbXMuc3BlZWQsIHBhdGhzLnZhbHVlLCBmYWxzZSk7XG4gIH07XG4gIGNvbnN0IGluaXQgPSAoKSA9PiB7XG4gICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmhpc3RvcnkpIHJldHVybjtcbiAgICBpZiAoIXdpbmRvdy5oaXN0b3J5IHx8ICF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcbiAgICAgIHN3aXBlci5wYXJhbXMuaGlzdG9yeS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgcGF0aHMgPSBnZXRQYXRoVmFsdWVzKHN3aXBlci5wYXJhbXMudXJsKTtcbiAgICBpZiAoIXBhdGhzLmtleSAmJiAhcGF0aHMudmFsdWUpIHtcbiAgICAgIGlmICghc3dpcGVyLnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBzZXRIaXN0b3J5UG9wU3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY3JvbGxUb1NsaWRlKDAsIHBhdGhzLnZhbHVlLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCk7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLmhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBzZXRIaXN0b3J5UG9wU3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHNldEhpc3RvcnlQb3BTdGF0ZSk7XG4gICAgfVxuICB9O1xuICBvbignaW5pdCcsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG4gIH0pO1xuICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHtcbiAgICAgIGRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuICBvbigndHJhbnNpdGlvbkVuZCBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScsICgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHNldEhpc3Rvcnkoc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmtleSwgc3dpcGVyLmFjdGl2ZUluZGV4KTtcbiAgICB9XG4gIH0pO1xuICBvbignc2xpZGVDaGFuZ2UnLCAoKSA9PiB7XG4gICAgaWYgKGluaXRpYWxpemVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc2V0SGlzdG9yeShzd2lwZXIucGFyYW1zLmhpc3Rvcnkua2V5LCBzd2lwZXIuYWN0aXZlSW5kZXgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnkgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZyBhcyBnZXREb2N1bWVudCwgYSBhcyBnZXRXaW5kb3cgfSBmcm9tICcuLi9zaGFyZWQvc3NyLXdpbmRvdy5lc20ubWpzJztcbmltcG9ydCB7IGUgYXMgZWxlbWVudENoaWxkcmVuIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIEhhc2hOYXZpZ2F0aW9uKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIGVtaXQsXG4gICAgb25cbiAgfSA9IF9yZWY7XG4gIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGhhc2hOYXZpZ2F0aW9uOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogZmFsc2UsXG4gICAgICB3YXRjaFN0YXRlOiBmYWxzZSxcbiAgICAgIGdldFNsaWRlSW5kZXgoX3MsIGhhc2gpIHtcbiAgICAgICAgaWYgKHN3aXBlci52aXJ0dWFsICYmIHN3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICAgICAgY29uc3Qgc2xpZGVXaXRoSGFzaCA9IHN3aXBlci5zbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFzaCcpID09PSBoYXNoKVswXTtcbiAgICAgICAgICBpZiAoIXNsaWRlV2l0aEhhc2gpIHJldHVybiAwO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoc2xpZGVXaXRoSGFzaC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN3aXBlci5nZXRTbGlkZUluZGV4KGVsZW1lbnRDaGlsZHJlbihzd2lwZXIuc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtaGFzaD1cIiR7aGFzaH1cIl0sIHN3aXBlci1zbGlkZVtkYXRhLWhhc2g9XCIke2hhc2h9XCJdYClbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG9uSGFzaENoYW5nZSA9ICgpID0+IHtcbiAgICBlbWl0KCdoYXNoQ2hhbmdlJyk7XG4gICAgY29uc3QgbmV3SGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKTtcbiAgICBjb25zdCBhY3RpdmVTbGlkZUVsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyBzd2lwZXIuc2xpZGVzRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIuYWN0aXZlSW5kZXh9XCJdYCkgOiBzd2lwZXIuc2xpZGVzW3N3aXBlci5hY3RpdmVJbmRleF07XG4gICAgY29uc3QgYWN0aXZlU2xpZGVIYXNoID0gYWN0aXZlU2xpZGVFbCA/IGFjdGl2ZVNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhc2gnKSA6ICcnO1xuICAgIGlmIChuZXdIYXNoICE9PSBhY3RpdmVTbGlkZUhhc2gpIHtcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gc3dpcGVyLnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5nZXRTbGlkZUluZGV4KHN3aXBlciwgbmV3SGFzaCk7XG4gICAgICBpZiAodHlwZW9mIG5ld0luZGV4ID09PSAndW5kZWZpbmVkJyB8fCBOdW1iZXIuaXNOYU4obmV3SW5kZXgpKSByZXR1cm47XG4gICAgICBzd2lwZXIuc2xpZGVUbyhuZXdJbmRleCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRIYXNoID0gKCkgPT4ge1xuICAgIGlmICghaW5pdGlhbGl6ZWQgfHwgIXN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkgcmV0dXJuO1xuICAgIGNvbnN0IGFjdGl2ZVNsaWRlRWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci5zbGlkZXNFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3N3aXBlci5hY3RpdmVJbmRleH1cIl1gKSA6IHN3aXBlci5zbGlkZXNbc3dpcGVyLmFjdGl2ZUluZGV4XTtcbiAgICBjb25zdCBhY3RpdmVTbGlkZUhhc2ggPSBhY3RpdmVTbGlkZUVsID8gYWN0aXZlU2xpZGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFzaCcpIHx8IGFjdGl2ZVNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWhpc3RvcnknKSA6ICcnO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLnJlcGxhY2VTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBgIyR7YWN0aXZlU2xpZGVIYXNofWAgfHwgJycpO1xuICAgICAgZW1pdCgnaGFzaFNldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5sb2NhdGlvbi5oYXNoID0gYWN0aXZlU2xpZGVIYXNoIHx8ICcnO1xuICAgICAgZW1pdCgnaGFzaFNldCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCB8fCBzd2lwZXIucGFyYW1zLmhpc3RvcnkgJiYgc3dpcGVyLnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHJldHVybjtcbiAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgY29uc3QgaGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKTtcbiAgICBpZiAoaGFzaCkge1xuICAgICAgY29uc3Qgc3BlZWQgPSAwO1xuICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmdldFNsaWRlSW5kZXgoc3dpcGVyLCBoYXNoKTtcbiAgICAgIHN3aXBlci5zbGlkZVRvKGluZGV4IHx8IDAsIHNwZWVkLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLndhdGNoU3RhdGUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBvbkhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcbiAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkge1xuICAgICAgaW5pdCgpO1xuICAgIH1cbiAgfSk7XG4gIG9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQpIHtcbiAgICAgIGRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuICBvbigndHJhbnNpdGlvbkVuZCBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScsICgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHNldEhhc2goKTtcbiAgICB9XG4gIH0pO1xuICBvbignc2xpZGVDaGFuZ2UnLCAoKSA9PiB7XG4gICAgaWYgKGluaXRpYWxpemVkICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc2V0SGFzaCgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IEhhc2hOYXZpZ2F0aW9uIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGcgYXMgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi9zaGFyZWQvc3NyLXdpbmRvdy5lc20ubWpzJztcblxuLyogZXNsaW50IG5vLXVuZGVyc2NvcmUtZGFuZ2xlOiBcIm9mZlwiICovXG4vKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIEF1dG9wbGF5KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXQsXG4gICAgcGFyYW1zXG4gIH0gPSBfcmVmO1xuICBzd2lwZXIuYXV0b3BsYXkgPSB7XG4gICAgcnVubmluZzogZmFsc2UsXG4gICAgcGF1c2VkOiBmYWxzZSxcbiAgICB0aW1lTGVmdDogMFxuICB9O1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGF1dG9wbGF5OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGRlbGF5OiAzMDAwLFxuICAgICAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG4gICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2UsXG4gICAgICBzdG9wT25MYXN0U2xpZGU6IGZhbHNlLFxuICAgICAgcmV2ZXJzZURpcmVjdGlvbjogZmFsc2UsXG4gICAgICBwYXVzZU9uTW91c2VFbnRlcjogZmFsc2VcbiAgICB9XG4gIH0pO1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHJhZjtcbiAgbGV0IGF1dG9wbGF5RGVsYXlUb3RhbCA9IHBhcmFtcyAmJiBwYXJhbXMuYXV0b3BsYXkgPyBwYXJhbXMuYXV0b3BsYXkuZGVsYXkgOiAzMDAwO1xuICBsZXQgYXV0b3BsYXlEZWxheUN1cnJlbnQgPSBwYXJhbXMgJiYgcGFyYW1zLmF1dG9wbGF5ID8gcGFyYW1zLmF1dG9wbGF5LmRlbGF5IDogMzAwMDtcbiAgbGV0IGF1dG9wbGF5VGltZUxlZnQ7XG4gIGxldCBhdXRvcGxheVN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBsZXQgd2FzUGF1c2VkO1xuICBsZXQgaXNUb3VjaGVkO1xuICBsZXQgcGF1c2VkQnlUb3VjaDtcbiAgbGV0IHRvdWNoU3RhcnRUaW1lb3V0O1xuICBsZXQgc2xpZGVDaGFuZ2VkO1xuICBsZXQgcGF1c2VkQnlJbnRlcmFjdGlvbjtcbiAgbGV0IHBhdXNlZEJ5UG9pbnRlckVudGVyO1xuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZSkge1xuICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci53cmFwcGVyRWwpIHJldHVybjtcbiAgICBpZiAoZS50YXJnZXQgIT09IHN3aXBlci53cmFwcGVyRWwpIHJldHVybjtcbiAgICBzd2lwZXIud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBvblRyYW5zaXRpb25FbmQpO1xuICAgIGlmIChwYXVzZWRCeVBvaW50ZXJFbnRlciB8fCBlLmRldGFpbCAmJiBlLmRldGFpbC5ieVN3aXBlclRvdWNoTW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN1bWUoKTtcbiAgfVxuICBjb25zdCBjYWxjVGltZUxlZnQgPSAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS5wYXVzZWQpIHtcbiAgICAgIHdhc1BhdXNlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3YXNQYXVzZWQpIHtcbiAgICAgIGF1dG9wbGF5RGVsYXlDdXJyZW50ID0gYXV0b3BsYXlUaW1lTGVmdDtcbiAgICAgIHdhc1BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0aW1lTGVmdCA9IHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPyBhdXRvcGxheVRpbWVMZWZ0IDogYXV0b3BsYXlTdGFydFRpbWUgKyBhdXRvcGxheURlbGF5Q3VycmVudCAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHN3aXBlci5hdXRvcGxheS50aW1lTGVmdCA9IHRpbWVMZWZ0O1xuICAgIGVtaXQoJ2F1dG9wbGF5VGltZUxlZnQnLCB0aW1lTGVmdCwgdGltZUxlZnQgLyBhdXRvcGxheURlbGF5VG90YWwpO1xuICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjYWxjVGltZUxlZnQoKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ2V0U2xpZGVEZWxheSA9ICgpID0+IHtcbiAgICBsZXQgYWN0aXZlU2xpZGVFbDtcbiAgICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIGFjdGl2ZVNsaWRlRWwgPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdzd2lwZXItc2xpZGUtYWN0aXZlJykpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVTbGlkZUVsID0gc3dpcGVyLnNsaWRlc1tzd2lwZXIuYWN0aXZlSW5kZXhdO1xuICAgIH1cbiAgICBpZiAoIWFjdGl2ZVNsaWRlRWwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgY3VycmVudFNsaWRlRGVsYXkgPSBwYXJzZUludChhY3RpdmVTbGlkZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItYXV0b3BsYXknKSwgMTApO1xuICAgIHJldHVybiBjdXJyZW50U2xpZGVEZWxheTtcbiAgfTtcbiAgY29uc3QgcnVuID0gZGVsYXlGb3JjZSA9PiB7XG4gICAgaWYgKHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICBjYWxjVGltZUxlZnQoKTtcbiAgICBsZXQgZGVsYXkgPSB0eXBlb2YgZGVsYXlGb3JjZSA9PT0gJ3VuZGVmaW5lZCcgPyBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5IDogZGVsYXlGb3JjZTtcbiAgICBhdXRvcGxheURlbGF5VG90YWwgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgIGF1dG9wbGF5RGVsYXlDdXJyZW50ID0gc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcbiAgICBjb25zdCBjdXJyZW50U2xpZGVEZWxheSA9IGdldFNsaWRlRGVsYXkoKTtcbiAgICBpZiAoIU51bWJlci5pc05hTihjdXJyZW50U2xpZGVEZWxheSkgJiYgY3VycmVudFNsaWRlRGVsYXkgPiAwICYmIHR5cGVvZiBkZWxheUZvcmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsYXkgPSBjdXJyZW50U2xpZGVEZWxheTtcbiAgICAgIGF1dG9wbGF5RGVsYXlUb3RhbCA9IGN1cnJlbnRTbGlkZURlbGF5O1xuICAgICAgYXV0b3BsYXlEZWxheUN1cnJlbnQgPSBjdXJyZW50U2xpZGVEZWxheTtcbiAgICB9XG4gICAgYXV0b3BsYXlUaW1lTGVmdCA9IGRlbGF5O1xuICAgIGNvbnN0IHNwZWVkID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgICBjb25zdCBwcm9jZWVkID0gKCkgPT4ge1xuICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkucmV2ZXJzZURpcmVjdGlvbikge1xuICAgICAgICBpZiAoIXN3aXBlci5pc0JlZ2lubmluZyB8fCBzd2lwZXIucGFyYW1zLmxvb3AgfHwgc3dpcGVyLnBhcmFtcy5yZXdpbmQpIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVQcmV2KHNwZWVkLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBlbWl0KCdhdXRvcGxheScpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSwgc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc3dpcGVyLmlzRW5kIHx8IHN3aXBlci5wYXJhbXMubG9vcCB8fCBzd2lwZXIucGFyYW1zLnJld2luZCkge1xuICAgICAgICAgIHN3aXBlci5zbGlkZU5leHQoc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlKSB7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oMCwgc3BlZWQsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGVtaXQoJ2F1dG9wbGF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICAgICAgYXV0b3BsYXlTdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHByb2NlZWQoKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJvY2VlZCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xuICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICBhdXRvcGxheVN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHN3aXBlci5hdXRvcGxheS5ydW5uaW5nID0gdHJ1ZTtcbiAgICBydW4oKTtcbiAgICBlbWl0KCdhdXRvcGxheVN0YXJ0Jyk7XG4gIH07XG4gIGNvbnN0IHN0b3AgPSAoKSA9PiB7XG4gICAgc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICBlbWl0KCdhdXRvcGxheVN0b3AnKTtcbiAgfTtcbiAgY29uc3QgcGF1c2UgPSAoaW50ZXJuYWwsIHJlc2V0KSA9PiB7XG4gICAgaWYgKHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgIHBhdXNlZEJ5SW50ZXJhY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZWVkID0gKCkgPT4ge1xuICAgICAgZW1pdCgnYXV0b3BsYXlQYXVzZScpO1xuICAgICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkud2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VtZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgc3dpcGVyLmF1dG9wbGF5LnBhdXNlZCA9IHRydWU7XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICBpZiAoc2xpZGVDaGFuZ2VkKSB7XG4gICAgICAgIGF1dG9wbGF5VGltZUxlZnQgPSBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgICAgfVxuICAgICAgc2xpZGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBwcm9jZWVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gYXV0b3BsYXlUaW1lTGVmdCB8fCBzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xuICAgIGF1dG9wbGF5VGltZUxlZnQgPSBkZWxheSAtIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGF1dG9wbGF5U3RhcnRUaW1lKTtcbiAgICBpZiAoc3dpcGVyLmlzRW5kICYmIGF1dG9wbGF5VGltZUxlZnQgPCAwICYmICFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgICBpZiAoYXV0b3BsYXlUaW1lTGVmdCA8IDApIGF1dG9wbGF5VGltZUxlZnQgPSAwO1xuICAgIHByb2NlZWQoKTtcbiAgfTtcbiAgY29uc3QgcmVzdW1lID0gKCkgPT4ge1xuICAgIGlmIChzd2lwZXIuaXNFbmQgJiYgYXV0b3BsYXlUaW1lTGVmdCA8IDAgJiYgIXN3aXBlci5wYXJhbXMubG9vcCB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuYXV0b3BsYXkucnVubmluZykgcmV0dXJuO1xuICAgIGF1dG9wbGF5U3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKHBhdXNlZEJ5SW50ZXJhY3Rpb24pIHtcbiAgICAgIHBhdXNlZEJ5SW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgIHJ1bihhdXRvcGxheVRpbWVMZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnVuKCk7XG4gICAgfVxuICAgIHN3aXBlci5hdXRvcGxheS5wYXVzZWQgPSBmYWxzZTtcbiAgICBlbWl0KCdhdXRvcGxheVJlc3VtZScpO1xuICB9O1xuICBjb25zdCBvblZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5kZXN0cm95ZWQgfHwgIXN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSByZXR1cm47XG4gICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICBwYXVzZWRCeUludGVyYWN0aW9uID0gdHJ1ZTtcbiAgICAgIHBhdXNlKHRydWUpO1xuICAgIH1cbiAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgIHJlc3VtZSgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25Qb2ludGVyRW50ZXIgPSBlID0+IHtcbiAgICBpZiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJykgcmV0dXJuO1xuICAgIHBhdXNlZEJ5SW50ZXJhY3Rpb24gPSB0cnVlO1xuICAgIHBhdXNlZEJ5UG9pbnRlckVudGVyID0gdHJ1ZTtcbiAgICBpZiAoc3dpcGVyLmFuaW1hdGluZyB8fCBzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSByZXR1cm47XG4gICAgcGF1c2UodHJ1ZSk7XG4gIH07XG4gIGNvbnN0IG9uUG9pbnRlckxlYXZlID0gZSA9PiB7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScpIHJldHVybjtcbiAgICBwYXVzZWRCeVBvaW50ZXJFbnRlciA9IGZhbHNlO1xuICAgIGlmIChzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSB7XG4gICAgICByZXN1bWUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGF0dGFjaE1vdXNlRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LnBhdXNlT25Nb3VzZUVudGVyKSB7XG4gICAgICBzd2lwZXIuZWwuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgb25Qb2ludGVyRW50ZXIpO1xuICAgICAgc3dpcGVyLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIG9uUG9pbnRlckxlYXZlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGRldGFjaE1vdXNlRXZlbnRzID0gKCkgPT4ge1xuICAgIGlmIChzd2lwZXIuZWwgJiYgdHlwZW9mIHN3aXBlci5lbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHN3aXBlci5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZW50ZXInLCBvblBvaW50ZXJFbnRlcik7XG4gICAgICBzd2lwZXIuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgb25Qb2ludGVyTGVhdmUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYXR0YWNoRG9jdW1lbnRFdmVudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICB9O1xuICBjb25zdCBkZXRhY2hEb2N1bWVudEV2ZW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIH07XG4gIG9uKCdpbml0JywgKCkgPT4ge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQpIHtcbiAgICAgIGF0dGFjaE1vdXNlRXZlbnRzKCk7XG4gICAgICBhdHRhY2hEb2N1bWVudEV2ZW50cygpO1xuICAgICAgc3RhcnQoKTtcbiAgICB9XG4gIH0pO1xuICBvbignZGVzdHJveScsICgpID0+IHtcbiAgICBkZXRhY2hNb3VzZUV2ZW50cygpO1xuICAgIGRldGFjaERvY3VtZW50RXZlbnRzKCk7XG4gICAgaWYgKHN3aXBlci5hdXRvcGxheS5ydW5uaW5nKSB7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgb24oJ19mcmVlTW9kZVN0YXRpY1JlbGVhc2UnLCAoKSA9PiB7XG4gICAgaWYgKHBhdXNlZEJ5VG91Y2ggfHwgcGF1c2VkQnlJbnRlcmFjdGlvbikge1xuICAgICAgcmVzdW1lKCk7XG4gICAgfVxuICB9KTtcbiAgb24oJ19mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlJywgKCkgPT4ge1xuICAgIGlmICghc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgcGF1c2UodHJ1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH0pO1xuICBvbignYmVmb3JlVHJhbnNpdGlvblN0YXJ0JywgKF9zLCBzcGVlZCwgaW50ZXJuYWwpID0+IHtcbiAgICBpZiAoc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybjtcbiAgICBpZiAoaW50ZXJuYWwgfHwgIXN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIHBhdXNlKHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgb24oJ3NsaWRlckZpcnN0TW92ZScsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbikge1xuICAgICAgc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1RvdWNoZWQgPSB0cnVlO1xuICAgIHBhdXNlZEJ5VG91Y2ggPSBmYWxzZTtcbiAgICBwYXVzZWRCeUludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgdG91Y2hTdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHBhdXNlZEJ5SW50ZXJhY3Rpb24gPSB0cnVlO1xuICAgICAgcGF1c2VkQnlUb3VjaCA9IHRydWU7XG4gICAgICBwYXVzZSh0cnVlKTtcbiAgICB9LCAyMDApO1xuICB9KTtcbiAgb24oJ3RvdWNoRW5kJywgKCkgPT4ge1xuICAgIGlmIChzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuYXV0b3BsYXkucnVubmluZyB8fCAhaXNUb3VjaGVkKSByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRvdWNoU3RhcnRUaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24pIHtcbiAgICAgIHBhdXNlZEJ5VG91Y2ggPSBmYWxzZTtcbiAgICAgIGlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGF1c2VkQnlUb3VjaCAmJiBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHJlc3VtZSgpO1xuICAgIHBhdXNlZEJ5VG91Y2ggPSBmYWxzZTtcbiAgICBpc1RvdWNoZWQgPSBmYWxzZTtcbiAgfSk7XG4gIG9uKCdzbGlkZUNoYW5nZScsICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmF1dG9wbGF5LnJ1bm5pbmcpIHJldHVybjtcbiAgICBzbGlkZUNoYW5nZWQgPSB0cnVlO1xuICB9KTtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIuYXV0b3BsYXksIHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIHBhdXNlLFxuICAgIHJlc3VtZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgQXV0b3BsYXkgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZyBhcyBnZXREb2N1bWVudCB9IGZyb20gJy4uL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgbCBhcyBpc09iamVjdCwgZSBhcyBlbGVtZW50Q2hpbGRyZW4gfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gVGh1bWIoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgb25cbiAgfSA9IF9yZWY7XG4gIGV4dGVuZFBhcmFtcyh7XG4gICAgdGh1bWJzOiB7XG4gICAgICBzd2lwZXI6IG51bGwsXG4gICAgICBtdWx0aXBsZUFjdGl2ZVRodW1iczogdHJ1ZSxcbiAgICAgIGF1dG9TY3JvbGxPZmZzZXQ6IDAsXG4gICAgICBzbGlkZVRodW1iQWN0aXZlQ2xhc3M6ICdzd2lwZXItc2xpZGUtdGh1bWItYWN0aXZlJyxcbiAgICAgIHRodW1ic0NvbnRhaW5lckNsYXNzOiAnc3dpcGVyLXRodW1icydcbiAgICB9XG4gIH0pO1xuICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgbGV0IHN3aXBlckNyZWF0ZWQgPSBmYWxzZTtcbiAgc3dpcGVyLnRodW1icyA9IHtcbiAgICBzd2lwZXI6IG51bGxcbiAgfTtcbiAgZnVuY3Rpb24gb25UaHVtYkNsaWNrKCkge1xuICAgIGNvbnN0IHRodW1ic1N3aXBlciA9IHN3aXBlci50aHVtYnMuc3dpcGVyO1xuICAgIGlmICghdGh1bWJzU3dpcGVyIHx8IHRodW1ic1N3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBjb25zdCBjbGlja2VkSW5kZXggPSB0aHVtYnNTd2lwZXIuY2xpY2tlZEluZGV4O1xuICAgIGNvbnN0IGNsaWNrZWRTbGlkZSA9IHRodW1ic1N3aXBlci5jbGlja2VkU2xpZGU7XG4gICAgaWYgKGNsaWNrZWRTbGlkZSAmJiBjbGlja2VkU2xpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKHN3aXBlci5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcykpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNsaWNrZWRJbmRleCA9PT0gJ3VuZGVmaW5lZCcgfHwgY2xpY2tlZEluZGV4ID09PSBudWxsKSByZXR1cm47XG4gICAgbGV0IHNsaWRlVG9JbmRleDtcbiAgICBpZiAodGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgICBzbGlkZVRvSW5kZXggPSBwYXJzZUludCh0aHVtYnNTd2lwZXIuY2xpY2tlZFNsaWRlLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZVRvSW5kZXggPSBjbGlja2VkSW5kZXg7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvTG9vcChzbGlkZVRvSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRodW1iczogdGh1bWJzUGFyYW1zXG4gICAgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgaWYgKGluaXRpYWxpemVkKSByZXR1cm4gZmFsc2U7XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGNvbnN0IFN3aXBlckNsYXNzID0gc3dpcGVyLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0aHVtYnNQYXJhbXMuc3dpcGVyIGluc3RhbmNlb2YgU3dpcGVyQ2xhc3MpIHtcbiAgICAgIHN3aXBlci50aHVtYnMuc3dpcGVyID0gdGh1bWJzUGFyYW1zLnN3aXBlcjtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3dpcGVyLnRodW1icy5zd2lwZXIub3JpZ2luYWxQYXJhbXMsIHtcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihzd2lwZXIudGh1bWJzLnN3aXBlci5wYXJhbXMsIHtcbiAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgc3dpcGVyLnRodW1icy5zd2lwZXIudXBkYXRlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0aHVtYnNQYXJhbXMuc3dpcGVyKSkge1xuICAgICAgY29uc3QgdGh1bWJzU3dpcGVyUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGh1bWJzUGFyYW1zLnN3aXBlcik7XG4gICAgICBPYmplY3QuYXNzaWduKHRodW1ic1N3aXBlclBhcmFtcywge1xuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBzd2lwZXIudGh1bWJzLnN3aXBlciA9IG5ldyBTd2lwZXJDbGFzcyh0aHVtYnNTd2lwZXJQYXJhbXMpO1xuICAgICAgc3dpcGVyQ3JlYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLmVsLmNsYXNzTGlzdC5hZGQoc3dpcGVyLnBhcmFtcy50aHVtYnMudGh1bWJzQ29udGFpbmVyQ2xhc3MpO1xuICAgIHN3aXBlci50aHVtYnMuc3dpcGVyLm9uKCd0YXAnLCBvblRodW1iQ2xpY2spO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShpbml0aWFsKSB7XG4gICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgaWYgKCF0aHVtYnNTd2lwZXIgfHwgdGh1bWJzU3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IHNsaWRlc1BlclZpZXcgPSB0aHVtYnNTd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHRodW1ic1N3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogdGh1bWJzU3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuXG4gICAgLy8gQWN0aXZhdGUgdGh1bWJzXG4gICAgbGV0IHRodW1ic1RvQWN0aXZhdGUgPSAxO1xuICAgIGNvbnN0IHRodW1iQWN0aXZlQ2xhc3MgPSBzd2lwZXIucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3M7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEgJiYgIXN3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHRodW1ic1RvQWN0aXZhdGUgPSBzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gICAgfVxuICAgIGlmICghc3dpcGVyLnBhcmFtcy50aHVtYnMubXVsdGlwbGVBY3RpdmVUaHVtYnMpIHtcbiAgICAgIHRodW1ic1RvQWN0aXZhdGUgPSAxO1xuICAgIH1cbiAgICB0aHVtYnNUb0FjdGl2YXRlID0gTWF0aC5mbG9vcih0aHVtYnNUb0FjdGl2YXRlKTtcbiAgICB0aHVtYnNTd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiBzbGlkZUVsLmNsYXNzTGlzdC5yZW1vdmUodGh1bWJBY3RpdmVDbGFzcykpO1xuICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3AgfHwgdGh1bWJzU3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmIHRodW1ic1N3aXBlci5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRodW1ic1RvQWN0aXZhdGU7IGkgKz0gMSkge1xuICAgICAgICBlbGVtZW50Q2hpbGRyZW4odGh1bWJzU3dpcGVyLnNsaWRlc0VsLCBgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzd2lwZXIucmVhbEluZGV4ICsgaX1cIl1gKS5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgICAgIHNsaWRlRWwuY2xhc3NMaXN0LmFkZCh0aHVtYkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGh1bWJzVG9BY3RpdmF0ZTsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aHVtYnNTd2lwZXIuc2xpZGVzW3N3aXBlci5yZWFsSW5kZXggKyBpXSkge1xuICAgICAgICAgIHRodW1ic1N3aXBlci5zbGlkZXNbc3dpcGVyLnJlYWxJbmRleCArIGldLmNsYXNzTGlzdC5hZGQodGh1bWJBY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXV0b1Njcm9sbE9mZnNldCA9IHN3aXBlci5wYXJhbXMudGh1bWJzLmF1dG9TY3JvbGxPZmZzZXQ7XG4gICAgY29uc3QgdXNlT2Zmc2V0ID0gYXV0b1Njcm9sbE9mZnNldCAmJiAhdGh1bWJzU3dpcGVyLnBhcmFtcy5sb29wO1xuICAgIGlmIChzd2lwZXIucmVhbEluZGV4ICE9PSB0aHVtYnNTd2lwZXIucmVhbEluZGV4IHx8IHVzZU9mZnNldCkge1xuICAgICAgY29uc3QgY3VycmVudFRodW1ic0luZGV4ID0gdGh1bWJzU3dpcGVyLmFjdGl2ZUluZGV4O1xuICAgICAgbGV0IG5ld1RodW1ic0luZGV4O1xuICAgICAgbGV0IGRpcmVjdGlvbjtcbiAgICAgIGlmICh0aHVtYnNTd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICAgICAgY29uc3QgbmV3VGh1bWJzU2xpZGUgPSB0aHVtYnNTd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpID09PSBgJHtzd2lwZXIucmVhbEluZGV4fWApWzBdO1xuICAgICAgICBuZXdUaHVtYnNJbmRleCA9IHRodW1ic1N3aXBlci5zbGlkZXMuaW5kZXhPZihuZXdUaHVtYnNTbGlkZSk7XG4gICAgICAgIGRpcmVjdGlvbiA9IHN3aXBlci5hY3RpdmVJbmRleCA+IHN3aXBlci5wcmV2aW91c0luZGV4ID8gJ25leHQnIDogJ3ByZXYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VGh1bWJzSW5kZXggPSBzd2lwZXIucmVhbEluZGV4O1xuICAgICAgICBkaXJlY3Rpb24gPSBuZXdUaHVtYnNJbmRleCA+IHN3aXBlci5wcmV2aW91c0luZGV4ID8gJ25leHQnIDogJ3ByZXYnO1xuICAgICAgfVxuICAgICAgaWYgKHVzZU9mZnNldCkge1xuICAgICAgICBuZXdUaHVtYnNJbmRleCArPSBkaXJlY3Rpb24gPT09ICduZXh0JyA/IGF1dG9TY3JvbGxPZmZzZXQgOiAtMSAqIGF1dG9TY3JvbGxPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodGh1bWJzU3dpcGVyLnZpc2libGVTbGlkZXNJbmRleGVzICYmIHRodW1ic1N3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcy5pbmRleE9mKG5ld1RodW1ic0luZGV4KSA8IDApIHtcbiAgICAgICAgaWYgKHRodW1ic1N3aXBlci5wYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgICBpZiAobmV3VGh1bWJzSW5kZXggPiBjdXJyZW50VGh1bWJzSW5kZXgpIHtcbiAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggLSBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RodW1ic0luZGV4ID0gbmV3VGh1bWJzSW5kZXggKyBNYXRoLmZsb29yKHNsaWRlc1BlclZpZXcgLyAyKSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1RodW1ic0luZGV4ID4gY3VycmVudFRodW1ic0luZGV4ICYmIHRodW1ic1N3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEpIDtcbiAgICAgICAgdGh1bWJzU3dpcGVyLnNsaWRlVG8obmV3VGh1bWJzSW5kZXgsIGluaXRpYWwgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdGh1bWJzXG4gICAgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgaWYgKCF0aHVtYnMgfHwgIXRodW1icy5zd2lwZXIpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRodW1icy5zd2lwZXIgPT09ICdzdHJpbmcnIHx8IHRodW1icy5zd2lwZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgY29uc3QgZ2V0VGh1bWJzRWxlbWVudEFuZEluaXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRodW1ic0VsZW1lbnQgPSB0eXBlb2YgdGh1bWJzLnN3aXBlciA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRodW1icy5zd2lwZXIpIDogdGh1bWJzLnN3aXBlcjtcbiAgICAgICAgaWYgKHRodW1ic0VsZW1lbnQgJiYgdGh1bWJzRWxlbWVudC5zd2lwZXIpIHtcbiAgICAgICAgICB0aHVtYnMuc3dpcGVyID0gdGh1bWJzRWxlbWVudC5zd2lwZXI7XG4gICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aHVtYnNFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3Qgb25UaHVtYnNTd2lwZXIgPSBlID0+IHtcbiAgICAgICAgICAgIHRodW1icy5zd2lwZXIgPSBlLmRldGFpbFswXTtcbiAgICAgICAgICAgIHRodW1ic0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5pdCcsIG9uVGh1bWJzU3dpcGVyKTtcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICAgIHVwZGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIHRodW1icy5zd2lwZXIudXBkYXRlKCk7XG4gICAgICAgICAgICBzd2lwZXIudXBkYXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aHVtYnNFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2luaXQnLCBvblRodW1ic1N3aXBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRodW1ic0VsZW1lbnQ7XG4gICAgICB9O1xuICAgICAgY29uc3Qgd2F0Y2hGb3JUaHVtYnNUb0FwcGVhciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgdGh1bWJzRWxlbWVudCA9IGdldFRodW1ic0VsZW1lbnRBbmRJbml0KCk7XG4gICAgICAgIGlmICghdGh1bWJzRWxlbWVudCkge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh3YXRjaEZvclRodW1ic1RvQXBwZWFyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh3YXRjaEZvclRodW1ic1RvQXBwZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCgpO1xuICAgICAgdXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfSk7XG4gIG9uKCdzbGlkZUNoYW5nZSB1cGRhdGUgcmVzaXplIG9ic2VydmVyVXBkYXRlJywgKCkgPT4ge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbiAgb24oJ3NldFRyYW5zaXRpb24nLCAoX3MsIGR1cmF0aW9uKSA9PiB7XG4gICAgY29uc3QgdGh1bWJzU3dpcGVyID0gc3dpcGVyLnRodW1icy5zd2lwZXI7XG4gICAgaWYgKCF0aHVtYnNTd2lwZXIgfHwgdGh1bWJzU3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIHRodW1ic1N3aXBlci5zZXRUcmFuc2l0aW9uKGR1cmF0aW9uKTtcbiAgfSk7XG4gIG9uKCdiZWZvcmVEZXN0cm95JywgKCkgPT4ge1xuICAgIGNvbnN0IHRodW1ic1N3aXBlciA9IHN3aXBlci50aHVtYnMuc3dpcGVyO1xuICAgIGlmICghdGh1bWJzU3dpcGVyIHx8IHRodW1ic1N3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyQ3JlYXRlZCkge1xuICAgICAgdGh1bWJzU3dpcGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuYXNzaWduKHN3aXBlci50aHVtYnMsIHtcbiAgICBpbml0LFxuICAgIHVwZGF0ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgVGh1bWIgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZCBhcyBub3csIGsgYXMgZWxlbWVudFRyYW5zaXRpb25FbmQgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gZnJlZU1vZGUoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBleHRlbmRQYXJhbXMsXG4gICAgZW1pdCxcbiAgICBvbmNlXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGZyZWVNb2RlOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG1vbWVudHVtOiB0cnVlLFxuICAgICAgbW9tZW50dW1SYXRpbzogMSxcbiAgICAgIG1vbWVudHVtQm91bmNlOiB0cnVlLFxuICAgICAgbW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcbiAgICAgIG1vbWVudHVtVmVsb2NpdHlSYXRpbzogMSxcbiAgICAgIHN0aWNreTogZmFsc2UsXG4gICAgICBtaW5pbXVtVmVsb2NpdHk6IDAuMDJcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5nZXRUcmFuc2xhdGUoKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHRyYW5zbGF0ZSk7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XG4gICAgc3dpcGVyLmZyZWVNb2RlLm9uVG91Y2hFbmQoe1xuICAgICAgY3VycmVudFBvczogc3dpcGVyLnJ0bCA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKCkge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmNzc01vZGUpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IGRhdGEsXG4gICAgICB0b3VjaGVzXG4gICAgfSA9IHN3aXBlcjtcbiAgICAvLyBWZWxvY2l0eVxuICAgIGlmIChkYXRhLnZlbG9jaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkYXRhLnZlbG9jaXRpZXMucHVzaCh7XG4gICAgICAgIHBvc2l0aW9uOiB0b3VjaGVzW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzdGFydFgnIDogJ3N0YXJ0WSddLFxuICAgICAgICB0aW1lOiBkYXRhLnRvdWNoU3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgZGF0YS52ZWxvY2l0aWVzLnB1c2goe1xuICAgICAgcG9zaXRpb246IHRvdWNoZXNbc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gJ2N1cnJlbnRYJyA6ICdjdXJyZW50WSddLFxuICAgICAgdGltZTogbm93KClcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvblRvdWNoRW5kKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRQb3NcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHdyYXBwZXJFbCxcbiAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgICAgc25hcEdyaWQsXG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IGRhdGFcbiAgICB9ID0gc3dpcGVyO1xuICAgIC8vIFRpbWUgZGlmZlxuICAgIGNvbnN0IHRvdWNoRW5kVGltZSA9IG5vdygpO1xuICAgIGNvbnN0IHRpbWVEaWZmID0gdG91Y2hFbmRUaW1lIC0gZGF0YS50b3VjaFN0YXJ0VGltZTtcbiAgICBpZiAoY3VycmVudFBvcyA8IC1zd2lwZXIubWluVHJhbnNsYXRlKCkpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UG9zID4gLXN3aXBlci5tYXhUcmFuc2xhdGUoKSkge1xuICAgICAgaWYgKHN3aXBlci5zbGlkZXMubGVuZ3RoIDwgc25hcEdyaWQubGVuZ3RoKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNuYXBHcmlkLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bSkge1xuICAgICAgaWYgKGRhdGEudmVsb2NpdGllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGxhc3RNb3ZlRXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5RXZlbnQgPSBkYXRhLnZlbG9jaXRpZXMucG9wKCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbGFzdE1vdmVFdmVudC5wb3NpdGlvbiAtIHZlbG9jaXR5RXZlbnQucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHRpbWUgPSBsYXN0TW92ZUV2ZW50LnRpbWUgLSB2ZWxvY2l0eUV2ZW50LnRpbWU7XG4gICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IGRpc3RhbmNlIC8gdGltZTtcbiAgICAgICAgc3dpcGVyLnZlbG9jaXR5IC89IDI7XG4gICAgICAgIGlmIChNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpIDwgcGFyYW1zLmZyZWVNb2RlLm1pbmltdW1WZWxvY2l0eSkge1xuICAgICAgICAgIHN3aXBlci52ZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpbXBsaWVzIHRoYXQgdGhlIHVzZXIgc3RvcHBlZCBtb3ZpbmcgYSBmaW5nZXIgdGhlbiByZWxlYXNlZC5cbiAgICAgICAgLy8gVGhlcmUgd291bGQgYmUgbm8gZXZlbnRzIHdpdGggZGlzdGFuY2UgemVybywgc28gdGhlIGxhc3QgZXZlbnQgaXMgc3RhbGUuXG4gICAgICAgIGlmICh0aW1lID4gMTUwIHx8IG5vdygpIC0gbGFzdE1vdmVFdmVudC50aW1lID4gMzAwKSB7XG4gICAgICAgICAgc3dpcGVyLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnZlbG9jaXR5ID0gMDtcbiAgICAgIH1cbiAgICAgIHN3aXBlci52ZWxvY2l0eSAqPSBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1WZWxvY2l0eVJhdGlvO1xuICAgICAgZGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XG4gICAgICBsZXQgbW9tZW50dW1EdXJhdGlvbiA9IDEwMDAgKiBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1SYXRpbztcbiAgICAgIGNvbnN0IG1vbWVudHVtRGlzdGFuY2UgPSBzd2lwZXIudmVsb2NpdHkgKiBtb21lbnR1bUR1cmF0aW9uO1xuICAgICAgbGV0IG5ld1Bvc2l0aW9uID0gc3dpcGVyLnRyYW5zbGF0ZSArIG1vbWVudHVtRGlzdGFuY2U7XG4gICAgICBpZiAocnRsKSBuZXdQb3NpdGlvbiA9IC1uZXdQb3NpdGlvbjtcbiAgICAgIGxldCBkb0JvdW5jZSA9IGZhbHNlO1xuICAgICAgbGV0IGFmdGVyQm91bmNlUG9zaXRpb247XG4gICAgICBjb25zdCBib3VuY2VBbW91bnQgPSBNYXRoLmFicyhzd2lwZXIudmVsb2NpdHkpICogMjAgKiBwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2VSYXRpbztcbiAgICAgIGxldCBuZWVkc0xvb3BGaXg7XG4gICAgICBpZiAobmV3UG9zaXRpb24gPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSkge1xuICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiArIHN3aXBlci5tYXhUcmFuc2xhdGUoKSA8IC1ib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gYm91bmNlQW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckJvdW5jZVBvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5ld1Bvc2l0aW9uID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UpIHtcbiAgICAgICAgICBpZiAobmV3UG9zaXRpb24gLSBzd2lwZXIubWluVHJhbnNsYXRlKCkgPiBib3VuY2VBbW91bnQpIHtcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgYm91bmNlQW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckJvdW5jZVBvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGRvQm91bmNlID0gdHJ1ZTtcbiAgICAgICAgICBkYXRhLmFsbG93TW9tZW50dW1Cb3VuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubG9vcCAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXMpIG5lZWRzTG9vcEZpeCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgbGV0IG5leHRTbGlkZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbmFwR3JpZC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChzbmFwR3JpZFtqXSA+IC1uZXdQb3NpdGlvbikge1xuICAgICAgICAgICAgbmV4dFNsaWRlID0gajtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoc25hcEdyaWRbbmV4dFNsaWRlXSAtIG5ld1Bvc2l0aW9uKSA8IE1hdGguYWJzKHNuYXBHcmlkW25leHRTbGlkZSAtIDFdIC0gbmV3UG9zaXRpb24pIHx8IHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgICAgbmV3UG9zaXRpb24gPSBzbmFwR3JpZFtuZXh0U2xpZGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Bvc2l0aW9uID0gc25hcEdyaWRbbmV4dFNsaWRlIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3UG9zaXRpb24gPSAtbmV3UG9zaXRpb247XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNMb29wRml4KSB7XG4gICAgICAgIG9uY2UoJ3RyYW5zaXRpb25FbmQnLCAoKSA9PiB7XG4gICAgICAgICAgc3dpcGVyLmxvb3BGaXgoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBGaXggZHVyYXRpb25cbiAgICAgIGlmIChzd2lwZXIudmVsb2NpdHkgIT09IDApIHtcbiAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBNYXRoLmFicygoLW5ld1Bvc2l0aW9uIC0gc3dpcGVyLnRyYW5zbGF0ZSkgLyBzd2lwZXIudmVsb2NpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBNYXRoLmFicygobmV3UG9zaXRpb24gLSBzd2lwZXIudHJhbnNsYXRlKSAvIHN3aXBlci52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5zdGlja3kpIHtcbiAgICAgICAgICAvLyBJZiBmcmVlTW9kZS5zdGlja3kgaXMgYWN0aXZlIGFuZCB0aGUgdXNlciBlbmRzIGEgc3dpcGUgd2l0aCBhIHNsb3ctdmVsb2NpdHlcbiAgICAgICAgICAvLyBldmVudCwgdGhlbiBkdXJhdGlvbnMgY2FuIGJlIDIwKyBzZWNvbmRzIHRvIHNsaWRlIG9uZSAob3IgemVybyEpIHNsaWRlcy5cbiAgICAgICAgICAvLyBJdCdzIGVhc3kgdG8gc2VlIHRoaXMgd2hlbiBzaW11bGF0aW5nIHRvdWNoIHdpdGggbW91c2UgZXZlbnRzLiBUbyBmaXggdGhpcyxcbiAgICAgICAgICAvLyBsaW1pdCBzaW5nbGUtc2xpZGUgc3dpcGVzIHRvIHRoZSBkZWZhdWx0IHNsaWRlIGR1cmF0aW9uLiBUaGlzIGFsc28gaGFzIHRoZVxuICAgICAgICAgIC8vIG5pY2Ugc2lkZSBlZmZlY3Qgb2YgbWF0Y2hpbmcgc2xpZGUgc3BlZWQgaWYgdGhlIHVzZXIgc3RvcHBlZCBtb3ZpbmcgYmVmb3JlXG4gICAgICAgICAgLy8gbGlmdGluZyBmaW5nZXIgb3IgbW91c2UgdnMuIG1vdmluZyBzbG93bHkgYmVmb3JlIGxpZnRpbmcgdGhlIGZpbmdlci9tb3VzZS5cbiAgICAgICAgICAvLyBGb3IgZmFzdGVyIHN3aXBlcywgYWxzbyBhcHBseSBsaW1pdHMgKGFsYmVpdCBoaWdoZXIgb25lcykuXG4gICAgICAgICAgY29uc3QgbW92ZURpc3RhbmNlID0gTWF0aC5hYnMoKHJ0bCA/IC1uZXdQb3NpdGlvbiA6IG5ld1Bvc2l0aW9uKSAtIHN3aXBlci50cmFuc2xhdGUpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZVNpemUgPSBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5hY3RpdmVJbmRleF07XG4gICAgICAgICAgaWYgKG1vdmVEaXN0YW5jZSA8IGN1cnJlbnRTbGlkZVNpemUpIHtcbiAgICAgICAgICAgIG1vbWVudHVtRHVyYXRpb24gPSBwYXJhbXMuc3BlZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChtb3ZlRGlzdGFuY2UgPCAyICogY3VycmVudFNsaWRlU2l6ZSkge1xuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZCAqIDEuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9tZW50dW1EdXJhdGlvbiA9IHBhcmFtcy5zcGVlZCAqIDIuNTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgICBzd2lwZXIuc2xpZGVUb0Nsb3Nlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSAmJiBkb0JvdW5jZSkge1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoYWZ0ZXJCb3VuY2VQb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKG1vbWVudHVtRHVyYXRpb24pO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydCh0cnVlLCBzd2lwZXIuc3dpcGVEaXJlY3Rpb24pO1xuICAgICAgICBzd2lwZXIuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudFRyYW5zaXRpb25FbmQod3JhcHBlckVsLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhZGF0YS5hbGxvd01vbWVudHVtQm91bmNlKSByZXR1cm47XG4gICAgICAgICAgZW1pdCgnbW9tZW50dW1Cb3VuY2UnKTtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihwYXJhbXMuc3BlZWQpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShhZnRlckJvdW5jZVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGVsZW1lbnRUcmFuc2l0aW9uRW5kKHdyYXBwZXJFbCwgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN3aXBlci52ZWxvY2l0eSkge1xuICAgICAgICBlbWl0KCdfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZScpO1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3UG9zaXRpb24pO1xuICAgICAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihtb21lbnR1bUR1cmF0aW9uKTtcbiAgICAgICAgc3dpcGVyLnNldFRyYW5zbGF0ZShuZXdQb3NpdGlvbik7XG4gICAgICAgIHN3aXBlci50cmFuc2l0aW9uU3RhcnQodHJ1ZSwgc3dpcGVyLnN3aXBlRGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzd2lwZXIuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgZWxlbWVudFRyYW5zaXRpb25FbmQod3JhcHBlckVsLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MobmV3UG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xuICAgICAgc3dpcGVyLnNsaWRlVG9DbG9zZXN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuZnJlZU1vZGUpIHtcbiAgICAgIGVtaXQoJ19mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlJyk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zLmZyZWVNb2RlLm1vbWVudHVtIHx8IHRpbWVEaWZmID49IHBhcmFtcy5sb25nU3dpcGVzTXMpIHtcbiAgICAgIGVtaXQoJ19mcmVlTW9kZVN0YXRpY1JlbGVhc2UnKTtcbiAgICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICAgICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICAgIH1cbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIGZyZWVNb2RlOiB7XG4gICAgICBvblRvdWNoU3RhcnQsXG4gICAgICBvblRvdWNoTW92ZSxcbiAgICAgIG9uVG91Y2hFbmRcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBmcmVlTW9kZSBhcyBkZWZhdWx0IH07XG4iLCJmdW5jdGlvbiBHcmlkKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGdyaWQ6IHtcbiAgICAgIHJvd3M6IDEsXG4gICAgICBmaWxsOiAnY29sdW1uJ1xuICAgIH1cbiAgfSk7XG4gIGxldCBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzO1xuICBsZXQgc2xpZGVzUGVyUm93O1xuICBsZXQgbnVtRnVsbENvbHVtbnM7XG4gIGxldCB3YXNNdWx0aVJvdztcbiAgY29uc3QgZ2V0U3BhY2VCZXR3ZWVuID0gKCkgPT4ge1xuICAgIGxldCBzcGFjZUJldHdlZW4gPSBzd2lwZXIucGFyYW1zLnNwYWNlQmV0d2VlbjtcbiAgICBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycgJiYgc3BhY2VCZXR3ZWVuLmluZGV4T2YoJyUnKSA+PSAwKSB7XG4gICAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlci5zaXplO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNwYWNlQmV0d2VlbiA9IHBhcnNlRmxvYXQoc3BhY2VCZXR3ZWVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlQmV0d2VlbjtcbiAgfTtcbiAgY29uc3QgaW5pdFNsaWRlcyA9IHNsaWRlcyA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVzUGVyVmlld1xuICAgIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmaWxsXG4gICAgfSA9IHN3aXBlci5wYXJhbXMuZ3JpZDtcbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzbGlkZXMubGVuZ3RoO1xuICAgIG51bUZ1bGxDb2x1bW5zID0gTWF0aC5mbG9vcihzbGlkZXNMZW5ndGggLyByb3dzKTtcbiAgICBpZiAoTWF0aC5mbG9vcihzbGlkZXNMZW5ndGggLyByb3dzKSA9PT0gc2xpZGVzTGVuZ3RoIC8gcm93cykge1xuICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IHNsaWRlc0xlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVzTnVtYmVyRXZlblRvUm93cyA9IE1hdGguY2VpbChzbGlkZXNMZW5ndGggLyByb3dzKSAqIHJvd3M7XG4gICAgfVxuICAgIGlmIChzbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgZmlsbCA9PT0gJ3JvdycpIHtcbiAgICAgIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgPSBNYXRoLm1heChzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzLCBzbGlkZXNQZXJWaWV3ICogcm93cyk7XG4gICAgfVxuICAgIHNsaWRlc1BlclJvdyA9IHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgLyByb3dzO1xuICB9O1xuICBjb25zdCB1bnNldFNsaWRlcyA9ICgpID0+IHtcbiAgICBpZiAoc3dpcGVyLnNsaWRlcykge1xuICAgICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IHtcbiAgICAgICAgaWYgKHNsaWRlLnN3aXBlclNsaWRlR3JpZFNldCkge1xuICAgICAgICAgIHNsaWRlLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgICAgIHNsaWRlLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnbWFyZ2luLXRvcCcpXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZVNsaWRlID0gKGksIHNsaWRlLCBzbGlkZXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXNQZXJHcm91cFxuICAgIH0gPSBzd2lwZXIucGFyYW1zO1xuICAgIGNvbnN0IHNwYWNlQmV0d2VlbiA9IGdldFNwYWNlQmV0d2VlbigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmaWxsXG4gICAgfSA9IHN3aXBlci5wYXJhbXMuZ3JpZDtcbiAgICBjb25zdCBzbGlkZXNMZW5ndGggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBzbGlkZXMubGVuZ3RoO1xuICAgIC8vIFNldCBzbGlkZXMgb3JkZXJcbiAgICBsZXQgbmV3U2xpZGVPcmRlckluZGV4O1xuICAgIGxldCBjb2x1bW47XG4gICAgbGV0IHJvdztcbiAgICBpZiAoZmlsbCA9PT0gJ3JvdycgJiYgc2xpZGVzUGVyR3JvdXAgPiAxKSB7XG4gICAgICBjb25zdCBncm91cEluZGV4ID0gTWF0aC5mbG9vcihpIC8gKHNsaWRlc1Blckdyb3VwICogcm93cykpO1xuICAgICAgY29uc3Qgc2xpZGVJbmRleEluR3JvdXAgPSBpIC0gcm93cyAqIHNsaWRlc1Blckdyb3VwICogZ3JvdXBJbmRleDtcbiAgICAgIGNvbnN0IGNvbHVtbnNJbkdyb3VwID0gZ3JvdXBJbmRleCA9PT0gMCA/IHNsaWRlc1Blckdyb3VwIDogTWF0aC5taW4oTWF0aC5jZWlsKChzbGlkZXNMZW5ndGggLSBncm91cEluZGV4ICogcm93cyAqIHNsaWRlc1Blckdyb3VwKSAvIHJvd3MpLCBzbGlkZXNQZXJHcm91cCk7XG4gICAgICByb3cgPSBNYXRoLmZsb29yKHNsaWRlSW5kZXhJbkdyb3VwIC8gY29sdW1uc0luR3JvdXApO1xuICAgICAgY29sdW1uID0gc2xpZGVJbmRleEluR3JvdXAgLSByb3cgKiBjb2x1bW5zSW5Hcm91cCArIGdyb3VwSW5kZXggKiBzbGlkZXNQZXJHcm91cDtcbiAgICAgIG5ld1NsaWRlT3JkZXJJbmRleCA9IGNvbHVtbiArIHJvdyAqIHNsaWRlc051bWJlckV2ZW5Ub1Jvd3MgLyByb3dzO1xuICAgICAgc2xpZGUuc3R5bGUub3JkZXIgPSBuZXdTbGlkZU9yZGVySW5kZXg7XG4gICAgfSBlbHNlIGlmIChmaWxsID09PSAnY29sdW1uJykge1xuICAgICAgY29sdW1uID0gTWF0aC5mbG9vcihpIC8gcm93cyk7XG4gICAgICByb3cgPSBpIC0gY29sdW1uICogcm93cztcbiAgICAgIGlmIChjb2x1bW4gPiBudW1GdWxsQ29sdW1ucyB8fCBjb2x1bW4gPT09IG51bUZ1bGxDb2x1bW5zICYmIHJvdyA9PT0gcm93cyAtIDEpIHtcbiAgICAgICAgcm93ICs9IDE7XG4gICAgICAgIGlmIChyb3cgPj0gcm93cykge1xuICAgICAgICAgIHJvdyA9IDA7XG4gICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcm93ID0gTWF0aC5mbG9vcihpIC8gc2xpZGVzUGVyUm93KTtcbiAgICAgIGNvbHVtbiA9IGkgLSByb3cgKiBzbGlkZXNQZXJSb3c7XG4gICAgfVxuICAgIHNsaWRlLnJvdyA9IHJvdztcbiAgICBzbGlkZS5jb2x1bW4gPSBjb2x1bW47XG4gICAgc2xpZGUuc3R5bGUuaGVpZ2h0ID0gYGNhbGMoKDEwMCUgLSAkeyhyb3dzIC0gMSkgKiBzcGFjZUJldHdlZW59cHgpIC8gJHtyb3dzfSlgO1xuICAgIHNsaWRlLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnbWFyZ2luLXRvcCcpXSA9IHJvdyAhPT0gMCA/IHNwYWNlQmV0d2VlbiAmJiBgJHtzcGFjZUJldHdlZW59cHhgIDogJyc7XG4gICAgc2xpZGUuc3dpcGVyU2xpZGVHcmlkU2V0ID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlV3JhcHBlclNpemUgPSAoc2xpZGVTaXplLCBzbmFwR3JpZCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbnRlcmVkU2xpZGVzLFxuICAgICAgcm91bmRMZW5ndGhzXG4gICAgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgY29uc3Qgc3BhY2VCZXR3ZWVuID0gZ2V0U3BhY2VCZXR3ZWVuKCk7XG4gICAgY29uc3Qge1xuICAgICAgcm93c1xuICAgIH0gPSBzd2lwZXIucGFyYW1zLmdyaWQ7XG4gICAgc3dpcGVyLnZpcnR1YWxTaXplID0gKHNsaWRlU2l6ZSArIHNwYWNlQmV0d2VlbikgKiBzbGlkZXNOdW1iZXJFdmVuVG9Sb3dzO1xuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGguY2VpbChzd2lwZXIudmlydHVhbFNpemUgLyByb3dzKSAtIHNwYWNlQmV0d2VlbjtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZVtzd2lwZXIuZ2V0RGlyZWN0aW9uTGFiZWwoJ3dpZHRoJyldID0gYCR7c3dpcGVyLnZpcnR1YWxTaXplICsgc3BhY2VCZXR3ZWVufXB4YDtcbiAgICB9XG4gICAgaWYgKGNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBjb25zdCBuZXdTbGlkZXNHcmlkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBzbGlkZXNHcmlkSXRlbSA9IHNuYXBHcmlkW2ldO1xuICAgICAgICBpZiAocm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgICBpZiAoc25hcEdyaWRbaV0gPCBzd2lwZXIudmlydHVhbFNpemUgKyBzbmFwR3JpZFswXSkgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIH1cbiAgICAgIHNuYXBHcmlkLnNwbGljZSgwLCBzbmFwR3JpZC5sZW5ndGgpO1xuICAgICAgc25hcEdyaWQucHVzaCguLi5uZXdTbGlkZXNHcmlkKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uSW5pdCA9ICgpID0+IHtcbiAgICB3YXNNdWx0aVJvdyA9IHN3aXBlci5wYXJhbXMuZ3JpZCAmJiBzd2lwZXIucGFyYW1zLmdyaWQucm93cyA+IDE7XG4gIH07XG4gIGNvbnN0IG9uVXBkYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIGVsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBpc011bHRpUm93ID0gcGFyYW1zLmdyaWQgJiYgcGFyYW1zLmdyaWQucm93cyA+IDE7XG4gICAgaWYgKHdhc011bHRpUm93ICYmICFpc011bHRpUm93KSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWRgLCBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApO1xuICAgICAgbnVtRnVsbENvbHVtbnMgPSAxO1xuICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgfSBlbHNlIGlmICghd2FzTXVsdGlSb3cgJiYgaXNNdWx0aVJvdykge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCk7XG4gICAgICBpZiAocGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApO1xuICAgICAgfVxuICAgICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgfVxuICAgIHdhc011bHRpUm93ID0gaXNNdWx0aVJvdztcbiAgfTtcbiAgb24oJ2luaXQnLCBvbkluaXQpO1xuICBvbigndXBkYXRlJywgb25VcGRhdGUpO1xuICBzd2lwZXIuZ3JpZCA9IHtcbiAgICBpbml0U2xpZGVzLFxuICAgIHVuc2V0U2xpZGVzLFxuICAgIHVwZGF0ZVNsaWRlLFxuICAgIHVwZGF0ZVdyYXBwZXJTaXplXG4gIH07XG59XG5cbmV4cG9ydCB7IEdyaWQgYXMgZGVmYXVsdCB9O1xuIiwiZnVuY3Rpb24gYXBwZW5kU2xpZGUoc2xpZGVzKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc2xpZGVzRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gIH1cbiAgY29uc3QgYXBwZW5kRWxlbWVudCA9IHNsaWRlRWwgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVFbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRlbXBET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRlbXBET00uaW5uZXJIVE1MID0gc2xpZGVFbDtcbiAgICAgIHNsaWRlc0VsLmFwcGVuZCh0ZW1wRE9NLmNoaWxkcmVuWzBdKTtcbiAgICAgIHRlbXBET00uaW5uZXJIVE1MID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNsaWRlc0VsLmFwcGVuZChzbGlkZUVsKTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHNsaWRlc1tpXSkgYXBwZW5kRWxlbWVudChzbGlkZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcHBlbmRFbGVtZW50KHNsaWRlcyk7XG4gIH1cbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcENyZWF0ZSgpO1xuICB9XG4gIGlmICghcGFyYW1zLm9ic2VydmVyIHx8IHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICBzd2lwZXIudXBkYXRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGVuZFNsaWRlKHNsaWRlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIHNsaWRlc0VsXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICB9XG4gIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICsgMTtcbiAgY29uc3QgcHJlcGVuZEVsZW1lbnQgPSBzbGlkZUVsID0+IHtcbiAgICBpZiAodHlwZW9mIHNsaWRlRWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0ZW1wRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0ZW1wRE9NLmlubmVySFRNTCA9IHNsaWRlRWw7XG4gICAgICBzbGlkZXNFbC5wcmVwZW5kKHRlbXBET00uY2hpbGRyZW5bMF0pO1xuICAgICAgdGVtcERPTS5pbm5lckhUTUwgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVzRWwucHJlcGVuZChzbGlkZUVsKTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2Ygc2xpZGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHNsaWRlc1tpXSkgcHJlcGVuZEVsZW1lbnQoc2xpZGVzW2ldKTtcbiAgICB9XG4gICAgbmV3QWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCArIHNsaWRlcy5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcHJlcGVuZEVsZW1lbnQoc2xpZGVzKTtcbiAgfVxuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gIH1cbiAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIgfHwgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHN3aXBlci51cGRhdGUoKTtcbiAgfVxuICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhZGRTbGlkZShpbmRleCwgc2xpZGVzKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgc2xpZGVzRWxcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGFjdGl2ZUluZGV4QnVmZmVyID0gYWN0aXZlSW5kZXg7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGFjdGl2ZUluZGV4QnVmZmVyIC09IHN3aXBlci5sb29wZWRTbGlkZXM7XG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gICAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICB9XG4gIGNvbnN0IGJhc2VMZW5ndGggPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgaWYgKGluZGV4IDw9IDApIHtcbiAgICBzd2lwZXIucHJlcGVuZFNsaWRlKHNsaWRlcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmRleCA+PSBiYXNlTGVuZ3RoKSB7XG4gICAgc3dpcGVyLmFwcGVuZFNsaWRlKHNsaWRlcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIDEgOiBhY3RpdmVJbmRleEJ1ZmZlcjtcbiAgY29uc3Qgc2xpZGVzQnVmZmVyID0gW107XG4gIGZvciAobGV0IGkgPSBiYXNlTGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaSAtPSAxKSB7XG4gICAgY29uc3QgY3VycmVudFNsaWRlID0gc3dpcGVyLnNsaWRlc1tpXTtcbiAgICBjdXJyZW50U2xpZGUucmVtb3ZlKCk7XG4gICAgc2xpZGVzQnVmZmVyLnVuc2hpZnQoY3VycmVudFNsaWRlKTtcbiAgfVxuICBpZiAodHlwZW9mIHNsaWRlcyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gc2xpZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzbGlkZXNbaV0pIHNsaWRlc0VsLmFwcGVuZChzbGlkZXNbaV0pO1xuICAgIH1cbiAgICBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyID4gaW5kZXggPyBhY3RpdmVJbmRleEJ1ZmZlciArIHNsaWRlcy5sZW5ndGggOiBhY3RpdmVJbmRleEJ1ZmZlcjtcbiAgfSBlbHNlIHtcbiAgICBzbGlkZXNFbC5hcHBlbmQoc2xpZGVzKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0J1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHNsaWRlc0VsLmFwcGVuZChzbGlkZXNCdWZmZXJbaV0pO1xuICB9XG4gIHN3aXBlci5yZWNhbGNTbGlkZXMoKTtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgfVxuICBpZiAoIXBhcmFtcy5vYnNlcnZlciB8fCBzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4ICsgc3dpcGVyLmxvb3BlZFNsaWRlcywgMCwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHN3aXBlci5zbGlkZVRvKG5ld0FjdGl2ZUluZGV4LCAwLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2xpZGUoc2xpZGVzSW5kZXhlcykge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIGFjdGl2ZUluZGV4XG4gIH0gPSBzd2lwZXI7XG4gIGxldCBhY3RpdmVJbmRleEJ1ZmZlciA9IGFjdGl2ZUluZGV4O1xuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBhY3RpdmVJbmRleEJ1ZmZlciAtPSBzd2lwZXIubG9vcGVkU2xpZGVzO1xuICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICB9XG4gIGxldCBuZXdBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4QnVmZmVyO1xuICBsZXQgaW5kZXhUb1JlbW92ZTtcbiAgaWYgKHR5cGVvZiBzbGlkZXNJbmRleGVzID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBzbGlkZXNJbmRleGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNJbmRleGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpbmRleFRvUmVtb3ZlID0gc2xpZGVzSW5kZXhlc1tpXTtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdKSBzd2lwZXIuc2xpZGVzW2luZGV4VG9SZW1vdmVdLnJlbW92ZSgpO1xuICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPCBuZXdBY3RpdmVJbmRleCkgbmV3QWN0aXZlSW5kZXggLT0gMTtcbiAgICB9XG4gICAgbmV3QWN0aXZlSW5kZXggPSBNYXRoLm1heChuZXdBY3RpdmVJbmRleCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXhUb1JlbW92ZSA9IHNsaWRlc0luZGV4ZXM7XG4gICAgaWYgKHN3aXBlci5zbGlkZXNbaW5kZXhUb1JlbW92ZV0pIHN3aXBlci5zbGlkZXNbaW5kZXhUb1JlbW92ZV0ucmVtb3ZlKCk7XG4gICAgaWYgKGluZGV4VG9SZW1vdmUgPCBuZXdBY3RpdmVJbmRleCkgbmV3QWN0aXZlSW5kZXggLT0gMTtcbiAgICBuZXdBY3RpdmVJbmRleCA9IE1hdGgubWF4KG5ld0FjdGl2ZUluZGV4LCAwKTtcbiAgfVxuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIHN3aXBlci5sb29wQ3JlYXRlKCk7XG4gIH1cbiAgaWYgKCFwYXJhbXMub2JzZXJ2ZXIgfHwgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHN3aXBlci51cGRhdGUoKTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCArIHN3aXBlci5sb29wZWRTbGlkZXMsIDAsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXIuc2xpZGVUbyhuZXdBY3RpdmVJbmRleCwgMCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbFNsaWRlcygpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qgc2xpZGVzSW5kZXhlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZXNJbmRleGVzLnB1c2goaSk7XG4gIH1cbiAgc3dpcGVyLnJlbW92ZVNsaWRlKHNsaWRlc0luZGV4ZXMpO1xufVxuXG5mdW5jdGlvbiBNYW5pcHVsYXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlclxuICB9ID0gX3JlZjtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBhcHBlbmRTbGlkZTogYXBwZW5kU2xpZGUuYmluZChzd2lwZXIpLFxuICAgIHByZXBlbmRTbGlkZTogcHJlcGVuZFNsaWRlLmJpbmQoc3dpcGVyKSxcbiAgICBhZGRTbGlkZTogYWRkU2xpZGUuYmluZChzd2lwZXIpLFxuICAgIHJlbW92ZVNsaWRlOiByZW1vdmVTbGlkZS5iaW5kKHN3aXBlciksXG4gICAgcmVtb3ZlQWxsU2xpZGVzOiByZW1vdmVBbGxTbGlkZXMuYmluZChzd2lwZXIpXG4gIH0pO1xufVxuXG5leHBvcnQgeyBNYW5pcHVsYXRpb24gYXMgZGVmYXVsdCB9O1xuIiwiZnVuY3Rpb24gZWZmZWN0SW5pdChwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGVmZmVjdCxcbiAgICBzd2lwZXIsXG4gICAgb24sXG4gICAgc2V0VHJhbnNsYXRlLFxuICAgIHNldFRyYW5zaXRpb24sXG4gICAgb3ZlcndyaXRlUGFyYW1zLFxuICAgIHBlcnNwZWN0aXZlLFxuICAgIHJlY3JlYXRlU2hhZG93cyxcbiAgICBnZXRFZmZlY3RQYXJhbXNcbiAgfSA9IHBhcmFtcztcbiAgb24oJ2JlZm9yZUluaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSBlZmZlY3QpIHJldHVybjtcbiAgICBzd2lwZXIuY2xhc3NOYW1lcy5wdXNoKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke2VmZmVjdH1gKTtcbiAgICBpZiAocGVyc3BlY3RpdmUgJiYgcGVyc3BlY3RpdmUoKSkge1xuICAgICAgc3dpcGVyLmNsYXNzTmFtZXMucHVzaChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcndyaXRlUGFyYW1zUmVzdWx0ID0gb3ZlcndyaXRlUGFyYW1zID8gb3ZlcndyaXRlUGFyYW1zKCkgOiB7fTtcbiAgICBPYmplY3QuYXNzaWduKHN3aXBlci5wYXJhbXMsIG92ZXJ3cml0ZVBhcmFtc1Jlc3VsdCk7XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIub3JpZ2luYWxQYXJhbXMsIG92ZXJ3cml0ZVBhcmFtc1Jlc3VsdCk7XG4gIH0pO1xuICBvbignc2V0VHJhbnNsYXRlJywgKCkgPT4ge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gZWZmZWN0KSByZXR1cm47XG4gICAgc2V0VHJhbnNsYXRlKCk7XG4gIH0pO1xuICBvbignc2V0VHJhbnNpdGlvbicsIChfcywgZHVyYXRpb24pID0+IHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5lZmZlY3QgIT09IGVmZmVjdCkgcmV0dXJuO1xuICAgIHNldFRyYW5zaXRpb24oZHVyYXRpb24pO1xuICB9KTtcbiAgb24oJ3RyYW5zaXRpb25FbmQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZWZmZWN0ICE9PSBlZmZlY3QpIHJldHVybjtcbiAgICBpZiAocmVjcmVhdGVTaGFkb3dzKSB7XG4gICAgICBpZiAoIWdldEVmZmVjdFBhcmFtcyB8fCAhZ2V0RWZmZWN0UGFyYW1zKCkuc2xpZGVTaGFkb3dzKSByZXR1cm47XG4gICAgICAvLyByZW1vdmUgc2hhZG93c1xuICAgICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgICBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpLmZvckVhY2goc2hhZG93RWwgPT4gc2hhZG93RWwucmVtb3ZlKCkpO1xuICAgICAgfSk7XG4gICAgICAvLyBjcmVhdGUgbmV3IG9uZVxuICAgICAgcmVjcmVhdGVTaGFkb3dzKCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IHJlcXVpcmVVcGRhdGVPblZpcnR1YWw7XG4gIG9uKCd2aXJ0dWFsVXBkYXRlJywgKCkgPT4ge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmVmZmVjdCAhPT0gZWZmZWN0KSByZXR1cm47XG4gICAgaWYgKCFzd2lwZXIuc2xpZGVzLmxlbmd0aCkge1xuICAgICAgcmVxdWlyZVVwZGF0ZU9uVmlydHVhbCA9IHRydWU7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAocmVxdWlyZVVwZGF0ZU9uVmlydHVhbCAmJiBzd2lwZXIuc2xpZGVzICYmIHN3aXBlci5zbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHNldFRyYW5zbGF0ZSgpO1xuICAgICAgICByZXF1aXJlVXBkYXRlT25WaXJ0dWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBlZmZlY3RJbml0IGFzIGUgfTtcbiIsImltcG9ydCB7IGcgYXMgZ2V0U2xpZGVUcmFuc2Zvcm1FbCB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuZnVuY3Rpb24gZWZmZWN0VGFyZ2V0KGVmZmVjdFBhcmFtcywgc2xpZGVFbCkge1xuICBjb25zdCB0cmFuc2Zvcm1FbCA9IGdldFNsaWRlVHJhbnNmb3JtRWwoc2xpZGVFbCk7XG4gIGlmICh0cmFuc2Zvcm1FbCAhPT0gc2xpZGVFbCkge1xuICAgIHRyYW5zZm9ybUVsLnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIHRyYW5zZm9ybUVsLnN0eWxlWyctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHknXSA9ICdoaWRkZW4nO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1FbDtcbn1cblxuZXhwb3J0IHsgZWZmZWN0VGFyZ2V0IGFzIGUgfTtcbiIsImltcG9ydCB7IGsgYXMgZWxlbWVudFRyYW5zaXRpb25FbmQgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIGVmZmVjdFZpcnR1YWxUcmFuc2l0aW9uRW5kKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZHVyYXRpb24sXG4gICAgdHJhbnNmb3JtRWxlbWVudHMsXG4gICAgYWxsU2xpZGVzXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlSW5kZXhcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgZ2V0U2xpZGUgPSBlbCA9PiB7XG4gICAgaWYgKCFlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBhc3N1bWUgc2hhZG93IHJvb3RcbiAgICAgIGNvbnN0IHNsaWRlID0gc3dpcGVyLnNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLnNoYWRvd1Jvb3QgJiYgc2xpZGVFbC5zaGFkb3dSb290ID09PSBlbC5wYXJlbnROb2RlKVswXTtcbiAgICAgIHJldHVybiBzbGlkZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsLnBhcmVudEVsZW1lbnQ7XG4gIH07XG4gIGlmIChzd2lwZXIucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgZHVyYXRpb24gIT09IDApIHtcbiAgICBsZXQgZXZlbnRUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICBsZXQgdHJhbnNpdGlvbkVuZFRhcmdldDtcbiAgICBpZiAoYWxsU2xpZGVzKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kVGFyZ2V0ID0gdHJhbnNmb3JtRWxlbWVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRpb25FbmRUYXJnZXQgPSB0cmFuc2Zvcm1FbGVtZW50cy5maWx0ZXIodHJhbnNmb3JtRWwgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IHRyYW5zZm9ybUVsLmNsYXNzTGlzdC5jb250YWlucygnc3dpcGVyLXNsaWRlLXRyYW5zZm9ybScpID8gZ2V0U2xpZGUodHJhbnNmb3JtRWwpIDogdHJhbnNmb3JtRWw7XG4gICAgICAgIHJldHVybiBzd2lwZXIuZ2V0U2xpZGVJbmRleChlbCkgPT09IGFjdGl2ZUluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zaXRpb25FbmRUYXJnZXQuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbGVtZW50VHJhbnNpdGlvbkVuZChlbCwgKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnRUcmlnZ2VyZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBldmVudFRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIHN3aXBlci5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZXZ0ID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudCgndHJhbnNpdGlvbmVuZCcsIHtcbiAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQgYXMgZSB9O1xuIiwiaW1wb3J0IHsgZSBhcyBlZmZlY3RJbml0IH0gZnJvbSAnLi4vc2hhcmVkL2VmZmVjdC1pbml0Lm1qcyc7XG5pbXBvcnQgeyBlIGFzIGVmZmVjdFRhcmdldCB9IGZyb20gJy4uL3NoYXJlZC9lZmZlY3QtdGFyZ2V0Lm1qcyc7XG5pbXBvcnQgeyBlIGFzIGVmZmVjdFZpcnR1YWxUcmFuc2l0aW9uRW5kIH0gZnJvbSAnLi4vc2hhcmVkL2VmZmVjdC12aXJ0dWFsLXRyYW5zaXRpb24tZW5kLm1qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFNsaWRlVHJhbnNmb3JtRWwgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gRWZmZWN0RmFkZShfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIGV4dGVuZFBhcmFtcyxcbiAgICBvblxuICB9ID0gX3JlZjtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBmYWRlRWZmZWN0OiB7XG4gICAgICBjcm9zc0ZhZGU6IGZhbHNlXG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc2V0VHJhbnNsYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5mYWRlRWZmZWN0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzbGlkZUVsID0gc3dpcGVyLnNsaWRlc1tpXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHNsaWRlRWwuc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICBsZXQgdHggPSAtb2Zmc2V0O1xuICAgICAgaWYgKCFzd2lwZXIucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUpIHR4IC09IHN3aXBlci50cmFuc2xhdGU7XG4gICAgICBsZXQgdHkgPSAwO1xuICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgdHkgPSB0eDtcbiAgICAgICAgdHggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVPcGFjaXR5ID0gc3dpcGVyLnBhcmFtcy5mYWRlRWZmZWN0LmNyb3NzRmFkZSA/IE1hdGgubWF4KDEgLSBNYXRoLmFicyhzbGlkZUVsLnByb2dyZXNzKSwgMCkgOiAxICsgTWF0aC5taW4oTWF0aC5tYXgoc2xpZGVFbC5wcm9ncmVzcywgLTEpLCAwKTtcbiAgICAgIGNvbnN0IHRhcmdldEVsID0gZWZmZWN0VGFyZ2V0KHBhcmFtcywgc2xpZGVFbCk7XG4gICAgICB0YXJnZXRFbC5zdHlsZS5vcGFjaXR5ID0gc2xpZGVPcGFjaXR5O1xuICAgICAgdGFyZ2V0RWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsIDBweClgO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1FbGVtZW50cyA9IHN3aXBlci5zbGlkZXMubWFwKHNsaWRlRWwgPT4gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKSk7XG4gICAgdHJhbnNmb3JtRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtkdXJhdGlvbn1tc2A7XG4gICAgfSk7XG4gICAgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0cmFuc2Zvcm1FbGVtZW50cyxcbiAgICAgIGFsbFNsaWRlczogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICBlZmZlY3RJbml0KHtcbiAgICBlZmZlY3Q6ICdmYWRlJyxcbiAgICBzd2lwZXIsXG4gICAgb24sXG4gICAgc2V0VHJhbnNsYXRlLFxuICAgIHNldFRyYW5zaXRpb24sXG4gICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe1xuICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxuICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogdHJ1ZSxcbiAgICAgIHNwYWNlQmV0d2VlbjogMCxcbiAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICFzd2lwZXIucGFyYW1zLmNzc01vZGVcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgRWZmZWN0RmFkZSBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBlIGFzIGVmZmVjdEluaXQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LWluaXQubWpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBFZmZlY3RDdWJlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGN1YmVFZmZlY3Q6IHtcbiAgICAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgICAgIHNoYWRvdzogdHJ1ZSxcbiAgICAgIHNoYWRvd09mZnNldDogMjAsXG4gICAgICBzaGFkb3dTY2FsZTogMC45NFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZVNsaWRlU2hhZG93cyA9IChzbGlkZUVsLCBwcm9ncmVzcywgaXNIb3Jpem9udGFsKSA9PiB7XG4gICAgbGV0IHNoYWRvd0JlZm9yZSA9IGlzSG9yaXpvbnRhbCA/IHNsaWRlRWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdCcpIDogc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AnKTtcbiAgICBsZXQgc2hhZG93QWZ0ZXIgPSBpc0hvcml6b250YWwgPyBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0JykgOiBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbScpO1xuICAgIGlmICghc2hhZG93QmVmb3JlKSB7XG4gICAgICBzaGFkb3dCZWZvcmUgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCBgc3dpcGVyLXNsaWRlLXNoYWRvdy1jdWJlIHN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJ31gLnNwbGl0KCcgJykpO1xuICAgICAgc2xpZGVFbC5hcHBlbmQoc2hhZG93QmVmb3JlKTtcbiAgICB9XG4gICAgaWYgKCFzaGFkb3dBZnRlcikge1xuICAgICAgc2hhZG93QWZ0ZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCBgc3dpcGVyLXNsaWRlLXNoYWRvdy1jdWJlIHN3aXBlci1zbGlkZS1zaGFkb3ctJHtpc0hvcml6b250YWwgPyAncmlnaHQnIDogJ2JvdHRvbSd9YC5zcGxpdCgnICcpKTtcbiAgICAgIHNsaWRlRWwuYXBwZW5kKHNoYWRvd0FmdGVyKTtcbiAgICB9XG4gICAgaWYgKHNoYWRvd0JlZm9yZSkgc2hhZG93QmVmb3JlLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtcHJvZ3Jlc3MsIDApO1xuICAgIGlmIChzaGFkb3dBZnRlcikgc2hhZG93QWZ0ZXIuc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHByb2dyZXNzLCAwKTtcbiAgfTtcbiAgY29uc3QgcmVjcmVhdGVTaGFkb3dzID0gKCkgPT4ge1xuICAgIC8vIGNyZWF0ZSBuZXcgb25lc1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKHNsaWRlRWwucHJvZ3Jlc3MsIDEpLCAtMSk7XG4gICAgICBjcmVhdGVTbGlkZVNoYWRvd3Moc2xpZGVFbCwgcHJvZ3Jlc3MsIGlzSG9yaXpvbnRhbCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbCxcbiAgICAgIHdyYXBwZXJFbCxcbiAgICAgIHNsaWRlcyxcbiAgICAgIHdpZHRoOiBzd2lwZXJXaWR0aCxcbiAgICAgIGhlaWdodDogc3dpcGVySGVpZ2h0LFxuICAgICAgcnRsVHJhbnNsYXRlOiBydGwsXG4gICAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgICAgYnJvd3NlclxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jdWJlRWZmZWN0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICBsZXQgd3JhcHBlclJvdGF0ZSA9IDA7XG4gICAgbGV0IGN1YmVTaGFkb3dFbDtcbiAgICBpZiAocGFyYW1zLnNoYWRvdykge1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdWJlU2hhZG93RWwgPSBzd2lwZXIud3JhcHBlckVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItY3ViZS1zaGFkb3cnKTtcbiAgICAgICAgaWYgKCFjdWJlU2hhZG93RWwpIHtcbiAgICAgICAgICBjdWJlU2hhZG93RWwgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCAnc3dpcGVyLWN1YmUtc2hhZG93Jyk7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5hcHBlbmQoY3ViZVNoYWRvd0VsKTtcbiAgICAgICAgfVxuICAgICAgICBjdWJlU2hhZG93RWwuc3R5bGUuaGVpZ2h0ID0gYCR7c3dpcGVyV2lkdGh9cHhgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3ViZVNoYWRvd0VsID0gZWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1jdWJlLXNoYWRvdycpO1xuICAgICAgICBpZiAoIWN1YmVTaGFkb3dFbCkge1xuICAgICAgICAgIGN1YmVTaGFkb3dFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsICdzd2lwZXItY3ViZS1zaGFkb3cnKTtcbiAgICAgICAgICBlbC5hcHBlbmQoY3ViZVNoYWRvd0VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2xpZGVFbCA9IHNsaWRlc1tpXTtcbiAgICAgIGxldCBzbGlkZUluZGV4ID0gaTtcbiAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgc2xpZGVJbmRleCA9IHBhcnNlSW50KHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpLCAxMCk7XG4gICAgICB9XG4gICAgICBsZXQgc2xpZGVBbmdsZSA9IHNsaWRlSW5kZXggKiA5MDtcbiAgICAgIGxldCByb3VuZCA9IE1hdGguZmxvb3Ioc2xpZGVBbmdsZSAvIDM2MCk7XG4gICAgICBpZiAocnRsKSB7XG4gICAgICAgIHNsaWRlQW5nbGUgPSAtc2xpZGVBbmdsZTtcbiAgICAgICAgcm91bmQgPSBNYXRoLmZsb29yKC1zbGlkZUFuZ2xlIC8gMzYwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoTWF0aC5taW4oc2xpZGVFbC5wcm9ncmVzcywgMSksIC0xKTtcbiAgICAgIGxldCB0eCA9IDA7XG4gICAgICBsZXQgdHkgPSAwO1xuICAgICAgbGV0IHR6ID0gMDtcbiAgICAgIGlmIChzbGlkZUluZGV4ICUgNCA9PT0gMCkge1xuICAgICAgICB0eCA9IC1yb3VuZCAqIDQgKiBzd2lwZXJTaXplO1xuICAgICAgICB0eiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKChzbGlkZUluZGV4IC0gMSkgJSA0ID09PSAwKSB7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgdHogPSAtcm91bmQgKiA0ICogc3dpcGVyU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHNsaWRlSW5kZXggLSAyKSAlIDQgPT09IDApIHtcbiAgICAgICAgdHggPSBzd2lwZXJTaXplICsgcm91bmQgKiA0ICogc3dpcGVyU2l6ZTtcbiAgICAgICAgdHogPSBzd2lwZXJTaXplO1xuICAgICAgfSBlbHNlIGlmICgoc2xpZGVJbmRleCAtIDMpICUgNCA9PT0gMCkge1xuICAgICAgICB0eCA9IC1zd2lwZXJTaXplO1xuICAgICAgICB0eiA9IDMgKiBzd2lwZXJTaXplICsgc3dpcGVyU2l6ZSAqIDQgKiByb3VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChydGwpIHtcbiAgICAgICAgdHggPSAtdHg7XG4gICAgICB9XG4gICAgICBpZiAoIWlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eSA9IHR4O1xuICAgICAgICB0eCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgcm90YXRlWCgke2lzSG9yaXpvbnRhbCA/IDAgOiAtc2xpZGVBbmdsZX1kZWcpIHJvdGF0ZVkoJHtpc0hvcml6b250YWwgPyBzbGlkZUFuZ2xlIDogMH1kZWcpIHRyYW5zbGF0ZTNkKCR7dHh9cHgsICR7dHl9cHgsICR7dHp9cHgpYDtcbiAgICAgIGlmIChwcm9ncmVzcyA8PSAxICYmIHByb2dyZXNzID4gLTEpIHtcbiAgICAgICAgd3JhcHBlclJvdGF0ZSA9IHNsaWRlSW5kZXggKiA5MCArIHByb2dyZXNzICogOTA7XG4gICAgICAgIGlmIChydGwpIHdyYXBwZXJSb3RhdGUgPSAtc2xpZGVJbmRleCAqIDkwIC0gcHJvZ3Jlc3MgKiA5MDtcbiAgICAgICAgaWYgKHN3aXBlci5icm93c2VyICYmIHN3aXBlci5icm93c2VyLm5lZWQzZEZpeCAmJiBNYXRoLmFicyh3cmFwcGVyUm90YXRlKSAvIDkwICUgMiA9PT0gMSkge1xuICAgICAgICAgIHdyYXBwZXJSb3RhdGUgKz0gMC4wMDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNsaWRlRWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgY3JlYXRlU2xpZGVTaGFkb3dzKHNsaWRlRWwsIHByb2dyZXNzLCBpc0hvcml6b250YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICB3cmFwcGVyRWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYDUwJSA1MCUgLSR7c3dpcGVyU2l6ZSAvIDJ9cHhgO1xuICAgIHdyYXBwZXJFbC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luJ10gPSBgNTAlIDUwJSAtJHtzd2lwZXJTaXplIC8gMn1weGA7XG4gICAgaWYgKHBhcmFtcy5zaGFkb3cpIHtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3ViZVNoYWRvd0VsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwcHgsICR7c3dpcGVyV2lkdGggLyAyICsgcGFyYW1zLnNoYWRvd09mZnNldH1weCwgJHstc3dpcGVyV2lkdGggLyAyfXB4KSByb3RhdGVYKDg5Ljk5ZGVnKSByb3RhdGVaKDBkZWcpIHNjYWxlKCR7cGFyYW1zLnNoYWRvd1NjYWxlfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2hhZG93QW5nbGUgPSBNYXRoLmFicyh3cmFwcGVyUm90YXRlKSAtIE1hdGguZmxvb3IoTWF0aC5hYnMod3JhcHBlclJvdGF0ZSkgLyA5MCkgKiA5MDtcbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IDEuNSAtIChNYXRoLnNpbihzaGFkb3dBbmdsZSAqIDIgKiBNYXRoLlBJIC8gMzYwKSAvIDIgKyBNYXRoLmNvcyhzaGFkb3dBbmdsZSAqIDIgKiBNYXRoLlBJIC8gMzYwKSAvIDIpO1xuICAgICAgICBjb25zdCBzY2FsZTEgPSBwYXJhbXMuc2hhZG93U2NhbGU7XG4gICAgICAgIGNvbnN0IHNjYWxlMiA9IHBhcmFtcy5zaGFkb3dTY2FsZSAvIG11bHRpcGxpZXI7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcmFtcy5zaGFkb3dPZmZzZXQ7XG4gICAgICAgIGN1YmVTaGFkb3dFbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUzZCgke3NjYWxlMX0sIDEsICR7c2NhbGUyfSkgdHJhbnNsYXRlM2QoMHB4LCAke3N3aXBlckhlaWdodCAvIDIgKyBvZmZzZXR9cHgsICR7LXN3aXBlckhlaWdodCAvIDIgLyBzY2FsZTJ9cHgpIHJvdGF0ZVgoLTg5Ljk5ZGVnKWA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHpGYWN0b3IgPSAoYnJvd3Nlci5pc1NhZmFyaSB8fCBicm93c2VyLmlzV2ViVmlldykgJiYgYnJvd3Nlci5uZWVkUGVyc3BlY3RpdmVGaXggPyAtc3dpcGVyU2l6ZSAvIDIgOiAwO1xuICAgIHdyYXBwZXJFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMHB4LDAsJHt6RmFjdG9yfXB4KSByb3RhdGVYKCR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gMCA6IHdyYXBwZXJSb3RhdGV9ZGVnKSByb3RhdGVZKCR7c3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gLXdyYXBwZXJSb3RhdGUgOiAwfWRlZylgO1xuICAgIHdyYXBwZXJFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1zd2lwZXItY3ViZS10cmFuc2xhdGUteicsIGAke3pGYWN0b3J9cHhgKTtcbiAgfTtcbiAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbCxcbiAgICAgIHNsaWRlc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIHNsaWRlRWwucXVlcnlTZWxlY3RvckFsbCgnLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JykuZm9yRWFjaChzdWJFbCA9PiB7XG4gICAgICAgIHN1YkVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmICFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IHNoYWRvd0VsID0gZWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1jdWJlLXNoYWRvdycpO1xuICAgICAgaWYgKHNoYWRvd0VsKSBzaGFkb3dFbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtkdXJhdGlvbn1tc2A7XG4gICAgfVxuICB9O1xuICBlZmZlY3RJbml0KHtcbiAgICBlZmZlY3Q6ICdjdWJlJyxcbiAgICBzd2lwZXIsXG4gICAgb24sXG4gICAgc2V0VHJhbnNsYXRlLFxuICAgIHNldFRyYW5zaXRpb24sXG4gICAgcmVjcmVhdGVTaGFkb3dzLFxuICAgIGdldEVmZmVjdFBhcmFtczogKCkgPT4gc3dpcGVyLnBhcmFtcy5jdWJlRWZmZWN0LFxuICAgIHBlcnNwZWN0aXZlOiAoKSA9PiB0cnVlLFxuICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICByZXNpc3RhbmNlUmF0aW86IDAsXG4gICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICBjZW50ZXJlZFNsaWRlczogZmFsc2UsXG4gICAgICB2aXJ0dWFsVHJhbnNsYXRlOiB0cnVlXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEVmZmVjdEN1YmUgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZyBhcyBnZXRTbGlkZVRyYW5zZm9ybUVsLCBjIGFzIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYWRvdyhzdWZmaXgsIHNsaWRlRWwsIHNpZGUpIHtcbiAgY29uc3Qgc2hhZG93Q2xhc3MgPSBgc3dpcGVyLXNsaWRlLXNoYWRvdyR7c2lkZSA/IGAtJHtzaWRlfWAgOiAnJ30ke3N1ZmZpeCA/IGAgc3dpcGVyLXNsaWRlLXNoYWRvdy0ke3N1ZmZpeH1gIDogJyd9YDtcbiAgY29uc3Qgc2hhZG93Q29udGFpbmVyID0gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKTtcbiAgbGV0IHNoYWRvd0VsID0gc2hhZG93Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC4ke3NoYWRvd0NsYXNzLnNwbGl0KCcgJykuam9pbignLicpfWApO1xuICBpZiAoIXNoYWRvd0VsKSB7XG4gICAgc2hhZG93RWwgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCBzaGFkb3dDbGFzcy5zcGxpdCgnICcpKTtcbiAgICBzaGFkb3dDb250YWluZXIuYXBwZW5kKHNoYWRvd0VsKTtcbiAgfVxuICByZXR1cm4gc2hhZG93RWw7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVNoYWRvdyBhcyBjIH07XG4iLCJpbXBvcnQgeyBjIGFzIGNyZWF0ZVNoYWRvdyB9IGZyb20gJy4uL3NoYXJlZC9jcmVhdGUtc2hhZG93Lm1qcyc7XG5pbXBvcnQgeyBlIGFzIGVmZmVjdEluaXQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LWluaXQubWpzJztcbmltcG9ydCB7IGUgYXMgZWZmZWN0VGFyZ2V0IH0gZnJvbSAnLi4vc2hhcmVkL2VmZmVjdC10YXJnZXQubWpzJztcbmltcG9ydCB7IGUgYXMgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LXZpcnR1YWwtdHJhbnNpdGlvbi1lbmQubWpzJztcbmltcG9ydCB7IGcgYXMgZ2V0U2xpZGVUcmFuc2Zvcm1FbCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBFZmZlY3RGbGlwKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGZsaXBFZmZlY3Q6IHtcbiAgICAgIHNsaWRlU2hhZG93czogdHJ1ZSxcbiAgICAgIGxpbWl0Um90YXRpb246IHRydWVcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjcmVhdGVTbGlkZVNoYWRvd3MgPSAoc2xpZGVFbCwgcHJvZ3Jlc3MpID0+IHtcbiAgICBsZXQgc2hhZG93QmVmb3JlID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0JykgOiBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCcpO1xuICAgIGxldCBzaGFkb3dBZnRlciA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHNsaWRlRWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQnKSA6IHNsaWRlRWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tJyk7XG4gICAgaWYgKCFzaGFkb3dCZWZvcmUpIHtcbiAgICAgIHNoYWRvd0JlZm9yZSA9IGNyZWF0ZVNoYWRvdygnZmxpcCcsIHNsaWRlRWwsIHN3aXBlci5pc0hvcml6b250YWwoKSA/ICdsZWZ0JyA6ICd0b3AnKTtcbiAgICB9XG4gICAgaWYgKCFzaGFkb3dBZnRlcikge1xuICAgICAgc2hhZG93QWZ0ZXIgPSBjcmVhdGVTaGFkb3coJ2ZsaXAnLCBzbGlkZUVsLCBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyAncmlnaHQnIDogJ2JvdHRvbScpO1xuICAgIH1cbiAgICBpZiAoc2hhZG93QmVmb3JlKSBzaGFkb3dCZWZvcmUuc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1wcm9ncmVzcywgMCk7XG4gICAgaWYgKHNoYWRvd0FmdGVyKSBzaGFkb3dBZnRlci5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgocHJvZ3Jlc3MsIDApO1xuICB9O1xuICBjb25zdCByZWNyZWF0ZVNoYWRvd3MgPSAoKSA9PiB7XG4gICAgLy8gU2V0IHNoYWRvd3NcbiAgICBzd2lwZXIucGFyYW1zLmZsaXBFZmZlY3Q7XG4gICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgbGV0IHByb2dyZXNzID0gc2xpZGVFbC5wcm9ncmVzcztcbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmZsaXBFZmZlY3QubGltaXRSb3RhdGlvbikge1xuICAgICAgICBwcm9ncmVzcyA9IE1hdGgubWF4KE1hdGgubWluKHNsaWRlRWwucHJvZ3Jlc3MsIDEpLCAtMSk7XG4gICAgICB9XG4gICAgICBjcmVhdGVTbGlkZVNoYWRvd3Moc2xpZGVFbCwgcHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzZXRUcmFuc2xhdGUgPSAoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVzLFxuICAgICAgcnRsVHJhbnNsYXRlOiBydGxcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuZmxpcEVmZmVjdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2xpZGVFbCA9IHNsaWRlc1tpXTtcbiAgICAgIGxldCBwcm9ncmVzcyA9IHNsaWRlRWwucHJvZ3Jlc3M7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24pIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbihzbGlkZUVsLnByb2dyZXNzLCAxKSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gc2xpZGVFbC5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICAgIGNvbnN0IHJvdGF0ZSA9IC0xODAgKiBwcm9ncmVzcztcbiAgICAgIGxldCByb3RhdGVZID0gcm90YXRlO1xuICAgICAgbGV0IHJvdGF0ZVggPSAwO1xuICAgICAgbGV0IHR4ID0gc3dpcGVyLnBhcmFtcy5jc3NNb2RlID8gLW9mZnNldCAtIHN3aXBlci50cmFuc2xhdGUgOiAtb2Zmc2V0O1xuICAgICAgbGV0IHR5ID0gMDtcbiAgICAgIGlmICghc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHR5ID0gdHg7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgcm90YXRlWCA9IC1yb3RhdGVZO1xuICAgICAgICByb3RhdGVZID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocnRsKSB7XG4gICAgICAgIHJvdGF0ZVkgPSAtcm90YXRlWTtcbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIuYnJvd3NlciAmJiBzd2lwZXIuYnJvd3Nlci5uZWVkM2RGaXgpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0ZVkpIC8gOTAgJSAyID09PSAxKSB7XG4gICAgICAgICAgcm90YXRlWSArPSAwLjAwMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRlWCkgLyA5MCAlIDIgPT09IDEpIHtcbiAgICAgICAgICByb3RhdGVYICs9IDAuMDAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzbGlkZUVsLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHByb2dyZXNzKSkgKyBzbGlkZXMubGVuZ3RoO1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgY3JlYXRlU2xpZGVTaGFkb3dzKHNsaWRlRWwsIHByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3R4fXB4LCAke3R5fXB4LCAwcHgpIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKWA7XG4gICAgICBjb25zdCB0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsIHNsaWRlRWwpO1xuICAgICAgdGFyZ2V0RWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1FbGVtZW50cyA9IHN3aXBlci5zbGlkZXMubWFwKHNsaWRlRWwgPT4gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKSk7XG4gICAgdHJhbnNmb3JtRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtkdXJhdGlvbn1tc2A7XG4gICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKS5mb3JFYWNoKHNoYWRvd0VsID0+IHtcbiAgICAgICAgc2hhZG93RWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7ZHVyYXRpb259bXNgO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQoe1xuICAgICAgc3dpcGVyLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0cmFuc2Zvcm1FbGVtZW50c1xuICAgIH0pO1xuICB9O1xuICBlZmZlY3RJbml0KHtcbiAgICBlZmZlY3Q6ICdmbGlwJyxcbiAgICBzd2lwZXIsXG4gICAgb24sXG4gICAgc2V0VHJhbnNsYXRlLFxuICAgIHNldFRyYW5zaXRpb24sXG4gICAgcmVjcmVhdGVTaGFkb3dzLFxuICAgIGdldEVmZmVjdFBhcmFtczogKCkgPT4gc3dpcGVyLnBhcmFtcy5mbGlwRWZmZWN0LFxuICAgIHBlcnNwZWN0aXZlOiAoKSA9PiB0cnVlLFxuICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICBzbGlkZXNQZXJHcm91cDogMSxcbiAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWUsXG4gICAgICBzcGFjZUJldHdlZW46IDAsXG4gICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhc3dpcGVyLnBhcmFtcy5jc3NNb2RlXG4gICAgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEVmZmVjdEZsaXAgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgYyBhcyBjcmVhdGVTaGFkb3cgfSBmcm9tICcuLi9zaGFyZWQvY3JlYXRlLXNoYWRvdy5tanMnO1xuaW1wb3J0IHsgZSBhcyBlZmZlY3RJbml0IH0gZnJvbSAnLi4vc2hhcmVkL2VmZmVjdC1pbml0Lm1qcyc7XG5pbXBvcnQgeyBlIGFzIGVmZmVjdFRhcmdldCB9IGZyb20gJy4uL3NoYXJlZC9lZmZlY3QtdGFyZ2V0Lm1qcyc7XG5pbXBvcnQgeyBnIGFzIGdldFNsaWRlVHJhbnNmb3JtRWwgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMubWpzJztcblxuZnVuY3Rpb24gRWZmZWN0Q292ZXJmbG93KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGNvdmVyZmxvd0VmZmVjdDoge1xuICAgICAgcm90YXRlOiA1MCxcbiAgICAgIHN0cmV0Y2g6IDAsXG4gICAgICBkZXB0aDogMTAwLFxuICAgICAgc2NhbGU6IDEsXG4gICAgICBtb2RpZmllcjogMSxcbiAgICAgIHNsaWRlU2hhZG93czogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogc3dpcGVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHN3aXBlckhlaWdodCxcbiAgICAgIHNsaWRlcyxcbiAgICAgIHNsaWRlc1NpemVzR3JpZFxuICAgIH0gPSBzd2lwZXI7XG4gICAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3Q7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN3aXBlci50cmFuc2xhdGU7XG4gICAgY29uc3QgY2VudGVyID0gaXNIb3Jpem9udGFsID8gLXRyYW5zZm9ybSArIHN3aXBlcldpZHRoIC8gMiA6IC10cmFuc2Zvcm0gKyBzd2lwZXJIZWlnaHQgLyAyO1xuICAgIGNvbnN0IHJvdGF0ZSA9IGlzSG9yaXpvbnRhbCA/IHBhcmFtcy5yb3RhdGUgOiAtcGFyYW1zLnJvdGF0ZTtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBwYXJhbXMuZGVwdGg7XG4gICAgLy8gRWFjaCBzbGlkZSBvZmZzZXQgZnJvbSBjZW50ZXJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2xpZGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzbGlkZUVsID0gc2xpZGVzW2ldO1xuICAgICAgY29uc3Qgc2xpZGVTaXplID0gc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgICAgY29uc3Qgc2xpZGVPZmZzZXQgPSBzbGlkZUVsLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgICAgY29uc3QgY2VudGVyT2Zmc2V0ID0gKGNlbnRlciAtIHNsaWRlT2Zmc2V0IC0gc2xpZGVTaXplIC8gMikgLyBzbGlkZVNpemU7XG4gICAgICBjb25zdCBvZmZzZXRNdWx0aXBsaWVyID0gdHlwZW9mIHBhcmFtcy5tb2RpZmllciA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmFtcy5tb2RpZmllcihjZW50ZXJPZmZzZXQpIDogY2VudGVyT2Zmc2V0ICogcGFyYW1zLm1vZGlmaWVyO1xuICAgICAgbGV0IHJvdGF0ZVkgPSBpc0hvcml6b250YWwgPyByb3RhdGUgKiBvZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgIGxldCByb3RhdGVYID0gaXNIb3Jpem9udGFsID8gMCA6IHJvdGF0ZSAqIG9mZnNldE11bHRpcGxpZXI7XG4gICAgICAvLyB2YXIgcm90YXRlWiA9IDBcbiAgICAgIGxldCB0cmFuc2xhdGVaID0gLXRyYW5zbGF0ZSAqIE1hdGguYWJzKG9mZnNldE11bHRpcGxpZXIpO1xuICAgICAgbGV0IHN0cmV0Y2ggPSBwYXJhbXMuc3RyZXRjaDtcbiAgICAgIC8vIEFsbG93IHBlcmNlbnRhZ2UgdG8gbWFrZSBhIHJlbGF0aXZlIHN0cmV0Y2ggZm9yIHJlc3BvbnNpdmUgc2xpZGVyc1xuICAgICAgaWYgKHR5cGVvZiBzdHJldGNoID09PSAnc3RyaW5nJyAmJiBzdHJldGNoLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgc3RyZXRjaCA9IHBhcnNlRmxvYXQocGFyYW1zLnN0cmV0Y2gpIC8gMTAwICogc2xpZGVTaXplO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zbGF0ZVkgPSBpc0hvcml6b250YWwgPyAwIDogc3RyZXRjaCAqIG9mZnNldE11bHRpcGxpZXI7XG4gICAgICBsZXQgdHJhbnNsYXRlWCA9IGlzSG9yaXpvbnRhbCA/IHN0cmV0Y2ggKiBvZmZzZXRNdWx0aXBsaWVyIDogMDtcbiAgICAgIGxldCBzY2FsZSA9IDEgLSAoMSAtIHBhcmFtcy5zY2FsZSkgKiBNYXRoLmFicyhvZmZzZXRNdWx0aXBsaWVyKTtcblxuICAgICAgLy8gRml4IGZvciB1bHRyYSBzbWFsbCB2YWx1ZXNcbiAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGVYKSA8IDAuMDAxKSB0cmFuc2xhdGVYID0gMDtcbiAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGVZKSA8IDAuMDAxKSB0cmFuc2xhdGVZID0gMDtcbiAgICAgIGlmIChNYXRoLmFicyh0cmFuc2xhdGVaKSA8IDAuMDAxKSB0cmFuc2xhdGVaID0gMDtcbiAgICAgIGlmIChNYXRoLmFicyhyb3RhdGVZKSA8IDAuMDAxKSByb3RhdGVZID0gMDtcbiAgICAgIGlmIChNYXRoLmFicyhyb3RhdGVYKSA8IDAuMDAxKSByb3RhdGVYID0gMDtcbiAgICAgIGlmIChNYXRoLmFicyhzY2FsZSkgPCAwLjAwMSkgc2NhbGUgPSAwO1xuICAgICAgaWYgKHN3aXBlci5icm93c2VyICYmIHN3aXBlci5icm93c2VyLm5lZWQzZEZpeCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMocm90YXRlWSkgLyA5MCAlIDIgPT09IDEpIHtcbiAgICAgICAgICByb3RhdGVZICs9IDAuMDAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGVYKSAvIDkwICUgMiA9PT0gMSkge1xuICAgICAgICAgIHJvdGF0ZVggKz0gMC4wMDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNsaWRlVHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlWH1weCwke3RyYW5zbGF0ZVl9cHgsJHt0cmFuc2xhdGVafXB4KSAgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSByb3RhdGVZKCR7cm90YXRlWX1kZWcpIHNjYWxlKCR7c2NhbGV9KWA7XG4gICAgICBjb25zdCB0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsIHNsaWRlRWwpO1xuICAgICAgdGFyZ2V0RWwuc3R5bGUudHJhbnNmb3JtID0gc2xpZGVUcmFuc2Zvcm07XG4gICAgICBzbGlkZUVsLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKG9mZnNldE11bHRpcGxpZXIpKSArIDE7XG4gICAgICBpZiAocGFyYW1zLnNsaWRlU2hhZG93cykge1xuICAgICAgICAvLyBTZXQgc2hhZG93c1xuICAgICAgICBsZXQgc2hhZG93QmVmb3JlRWwgPSBpc0hvcml6b250YWwgPyBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKSA6IHNsaWRlRWwucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wJyk7XG4gICAgICAgIGxldCBzaGFkb3dBZnRlckVsID0gaXNIb3Jpem9udGFsID8gc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCcpIDogc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20nKTtcbiAgICAgICAgaWYgKCFzaGFkb3dCZWZvcmVFbCkge1xuICAgICAgICAgIHNoYWRvd0JlZm9yZUVsID0gY3JlYXRlU2hhZG93KCdjb3ZlcmZsb3cnLCBzbGlkZUVsLCBpc0hvcml6b250YWwgPyAnbGVmdCcgOiAndG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaGFkb3dBZnRlckVsKSB7XG4gICAgICAgICAgc2hhZG93QWZ0ZXJFbCA9IGNyZWF0ZVNoYWRvdygnY292ZXJmbG93Jywgc2xpZGVFbCwgaXNIb3Jpem9udGFsID8gJ3JpZ2h0JyA6ICdib3R0b20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhZG93QmVmb3JlRWwpIHNoYWRvd0JlZm9yZUVsLnN0eWxlLm9wYWNpdHkgPSBvZmZzZXRNdWx0aXBsaWVyID4gMCA/IG9mZnNldE11bHRpcGxpZXIgOiAwO1xuICAgICAgICBpZiAoc2hhZG93QWZ0ZXJFbCkgc2hhZG93QWZ0ZXJFbC5zdHlsZS5vcGFjaXR5ID0gLW9mZnNldE11bHRpcGxpZXIgPiAwID8gLW9mZnNldE11bHRpcGxpZXIgOiAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0VHJhbnNpdGlvbiA9IGR1cmF0aW9uID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1FbGVtZW50cyA9IHN3aXBlci5zbGlkZXMubWFwKHNsaWRlRWwgPT4gZ2V0U2xpZGVUcmFuc2Zvcm1FbChzbGlkZUVsKSk7XG4gICAgdHJhbnNmb3JtRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHtkdXJhdGlvbn1tc2A7XG4gICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnQnKS5mb3JFYWNoKHNoYWRvd0VsID0+IHtcbiAgICAgICAgc2hhZG93RWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7ZHVyYXRpb259bXNgO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGVmZmVjdEluaXQoe1xuICAgIGVmZmVjdDogJ2NvdmVyZmxvdycsXG4gICAgc3dpcGVyLFxuICAgIG9uLFxuICAgIHNldFRyYW5zbGF0ZSxcbiAgICBzZXRUcmFuc2l0aW9uLFxuICAgIHBlcnNwZWN0aXZlOiAoKSA9PiB0cnVlLFxuICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHtcbiAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IHRydWVcbiAgICB9KVxuICB9KTtcbn1cblxuZXhwb3J0IHsgRWZmZWN0Q292ZXJmbG93IGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGMgYXMgY3JlYXRlU2hhZG93IH0gZnJvbSAnLi4vc2hhcmVkL2NyZWF0ZS1zaGFkb3cubWpzJztcbmltcG9ydCB7IGUgYXMgZWZmZWN0SW5pdCB9IGZyb20gJy4uL3NoYXJlZC9lZmZlY3QtaW5pdC5tanMnO1xuaW1wb3J0IHsgZSBhcyBlZmZlY3RUYXJnZXQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LXRhcmdldC5tanMnO1xuaW1wb3J0IHsgZSBhcyBlZmZlY3RWaXJ0dWFsVHJhbnNpdGlvbkVuZCB9IGZyb20gJy4uL3NoYXJlZC9lZmZlY3QtdmlydHVhbC10cmFuc2l0aW9uLWVuZC5tanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRTbGlkZVRyYW5zZm9ybUVsIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIEVmZmVjdENyZWF0aXZlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uXG4gIH0gPSBfcmVmO1xuICBleHRlbmRQYXJhbXMoe1xuICAgIGNyZWF0aXZlRWZmZWN0OiB7XG4gICAgICBsaW1pdFByb2dyZXNzOiAxLFxuICAgICAgc2hhZG93UGVyUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgcHJvZ3Jlc3NNdWx0aXBsaWVyOiAxLFxuICAgICAgcGVyc3BlY3RpdmU6IHRydWUsXG4gICAgICBwcmV2OiB7XG4gICAgICAgIHRyYW5zbGF0ZTogWzAsIDAsIDBdLFxuICAgICAgICByb3RhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDFcbiAgICAgIH0sXG4gICAgICBuZXh0OiB7XG4gICAgICAgIHRyYW5zbGF0ZTogWzAsIDAsIDBdLFxuICAgICAgICByb3RhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDFcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb25zdCBnZXRUcmFuc2xhdGVWYWx1ZSA9IHZhbHVlID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBgJHt2YWx1ZX1weGA7XG4gIH07XG4gIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXMsXG4gICAgICB3cmFwcGVyRWwsXG4gICAgICBzbGlkZXNTaXplc0dyaWRcbiAgICB9ID0gc3dpcGVyO1xuICAgIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXMuY3JlYXRpdmVFZmZlY3Q7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3Jlc3NNdWx0aXBsaWVyOiBtdWx0aXBsaWVyXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBpc0NlbnRlcmVkU2xpZGVzID0gc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcztcbiAgICBpZiAoaXNDZW50ZXJlZFNsaWRlcykge1xuICAgICAgY29uc3QgbWFyZ2luID0gc2xpZGVzU2l6ZXNHcmlkWzBdIC8gMiAtIHN3aXBlci5wYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIHx8IDA7XG4gICAgICB3cmFwcGVyRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoY2FsYyg1MCUgLSAke21hcmdpbn1weCkpYDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNsaWRlRWwgPSBzbGlkZXNbaV07XG4gICAgICBjb25zdCBzbGlkZVByb2dyZXNzID0gc2xpZGVFbC5wcm9ncmVzcztcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGVFbC5wcm9ncmVzcywgLXBhcmFtcy5saW1pdFByb2dyZXNzKSwgcGFyYW1zLmxpbWl0UHJvZ3Jlc3MpO1xuICAgICAgbGV0IG9yaWdpbmFsUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIGlmICghaXNDZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBvcmlnaW5hbFByb2dyZXNzID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGVFbC5vcmlnaW5hbFByb2dyZXNzLCAtcGFyYW1zLmxpbWl0UHJvZ3Jlc3MpLCBwYXJhbXMubGltaXRQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBzbGlkZUVsLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgICAgY29uc3QgdCA9IFtzd2lwZXIucGFyYW1zLmNzc01vZGUgPyAtb2Zmc2V0IC0gc3dpcGVyLnRyYW5zbGF0ZSA6IC1vZmZzZXQsIDAsIDBdO1xuICAgICAgY29uc3QgciA9IFswLCAwLCAwXTtcbiAgICAgIGxldCBjdXN0b20gPSBmYWxzZTtcbiAgICAgIGlmICghc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHRbMV0gPSB0WzBdO1xuICAgICAgICB0WzBdID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICB0cmFuc2xhdGU6IFswLCAwLCAwXSxcbiAgICAgICAgcm90YXRlOiBbMCwgMCwgMF0sXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9O1xuICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICBkYXRhID0gcGFyYW1zLm5leHQ7XG4gICAgICAgIGN1c3RvbSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByb2dyZXNzID4gMCkge1xuICAgICAgICBkYXRhID0gcGFyYW1zLnByZXY7XG4gICAgICAgIGN1c3RvbSA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBzZXQgdHJhbnNsYXRlXG4gICAgICB0LmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICB0W2luZGV4XSA9IGBjYWxjKCR7dmFsdWV9cHggKyAoJHtnZXRUcmFuc2xhdGVWYWx1ZShkYXRhLnRyYW5zbGF0ZVtpbmRleF0pfSAqICR7TWF0aC5hYnMocHJvZ3Jlc3MgKiBtdWx0aXBsaWVyKX0pKWA7XG4gICAgICB9KTtcbiAgICAgIC8vIHNldCByb3RhdGVzXG4gICAgICByLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsID0gZGF0YS5yb3RhdGVbaW5kZXhdICogTWF0aC5hYnMocHJvZ3Jlc3MgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgaWYgKHN3aXBlci5icm93c2VyICYmIHN3aXBlci5icm93c2VyLm5lZWQzZEZpeCAmJiBNYXRoLmFicyh2YWwpIC8gOTAgJSAyID09PSAxKSB7XG4gICAgICAgICAgdmFsICs9IDAuMDAxO1xuICAgICAgICB9XG4gICAgICAgIHJbaW5kZXhdID0gdmFsO1xuICAgICAgfSk7XG4gICAgICBzbGlkZUVsLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKHNsaWRlUHJvZ3Jlc3MpKSArIHNsaWRlcy5sZW5ndGg7XG4gICAgICBjb25zdCB0cmFuc2xhdGVTdHJpbmcgPSB0LmpvaW4oJywgJyk7XG4gICAgICBjb25zdCByb3RhdGVTdHJpbmcgPSBgcm90YXRlWCgke3JbMF19ZGVnKSByb3RhdGVZKCR7clsxXX1kZWcpIHJvdGF0ZVooJHtyWzJdfWRlZylgO1xuICAgICAgY29uc3Qgc2NhbGVTdHJpbmcgPSBvcmlnaW5hbFByb2dyZXNzIDwgMCA/IGBzY2FsZSgkezEgKyAoMSAtIGRhdGEuc2NhbGUpICogb3JpZ2luYWxQcm9ncmVzcyAqIG11bHRpcGxpZXJ9KWAgOiBgc2NhbGUoJHsxIC0gKDEgLSBkYXRhLnNjYWxlKSAqIG9yaWdpbmFsUHJvZ3Jlc3MgKiBtdWx0aXBsaWVyfSlgO1xuICAgICAgY29uc3Qgb3BhY2l0eVN0cmluZyA9IG9yaWdpbmFsUHJvZ3Jlc3MgPCAwID8gMSArICgxIC0gZGF0YS5vcGFjaXR5KSAqIG9yaWdpbmFsUHJvZ3Jlc3MgKiBtdWx0aXBsaWVyIDogMSAtICgxIC0gZGF0YS5vcGFjaXR5KSAqIG9yaWdpbmFsUHJvZ3Jlc3MgKiBtdWx0aXBsaWVyO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7dHJhbnNsYXRlU3RyaW5nfSkgJHtyb3RhdGVTdHJpbmd9ICR7c2NhbGVTdHJpbmd9YDtcblxuICAgICAgLy8gU2V0IHNoYWRvd3NcbiAgICAgIGlmIChjdXN0b20gJiYgZGF0YS5zaGFkb3cgfHwgIWN1c3RvbSkge1xuICAgICAgICBsZXQgc2hhZG93RWwgPSBzbGlkZUVsLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZXItc2xpZGUtc2hhZG93Jyk7XG4gICAgICAgIGlmICghc2hhZG93RWwgJiYgZGF0YS5zaGFkb3cpIHtcbiAgICAgICAgICBzaGFkb3dFbCA9IGNyZWF0ZVNoYWRvdygnY3JlYXRpdmUnLCBzbGlkZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhZG93RWwpIHtcbiAgICAgICAgICBjb25zdCBzaGFkb3dPcGFjaXR5ID0gcGFyYW1zLnNoYWRvd1BlclByb2dyZXNzID8gcHJvZ3Jlc3MgKiAoMSAvIHBhcmFtcy5saW1pdFByb2dyZXNzKSA6IHByb2dyZXNzO1xuICAgICAgICAgIHNoYWRvd0VsLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhzaGFkb3dPcGFjaXR5KSwgMCksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRFbCA9IGVmZmVjdFRhcmdldChwYXJhbXMsIHNsaWRlRWwpO1xuICAgICAgdGFyZ2V0RWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGFyZ2V0RWwuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHlTdHJpbmc7XG4gICAgICBpZiAoZGF0YS5vcmlnaW4pIHtcbiAgICAgICAgdGFyZ2V0RWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gZGF0YS5vcmlnaW47XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZHVyYXRpb24gPT4ge1xuICAgIGNvbnN0IHRyYW5zZm9ybUVsZW1lbnRzID0gc3dpcGVyLnNsaWRlcy5tYXAoc2xpZGVFbCA9PiBnZXRTbGlkZVRyYW5zZm9ybUVsKHNsaWRlRWwpKTtcbiAgICB0cmFuc2Zvcm1FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zd2lwZXItc2xpZGUtc2hhZG93JykuZm9yRWFjaChzaGFkb3dFbCA9PiB7XG4gICAgICAgIHNoYWRvd0VsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVmZmVjdFZpcnR1YWxUcmFuc2l0aW9uRW5kKHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdHJhbnNmb3JtRWxlbWVudHMsXG4gICAgICBhbGxTbGlkZXM6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgZWZmZWN0SW5pdCh7XG4gICAgZWZmZWN0OiAnY3JlYXRpdmUnLFxuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBzZXRUcmFuc2xhdGUsXG4gICAgc2V0VHJhbnNpdGlvbixcbiAgICBwZXJzcGVjdGl2ZTogKCkgPT4gc3dpcGVyLnBhcmFtcy5jcmVhdGl2ZUVmZmVjdC5wZXJzcGVjdGl2ZSxcbiAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XG4gICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgdmlydHVhbFRyYW5zbGF0ZTogIXN3aXBlci5wYXJhbXMuY3NzTW9kZVxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBFZmZlY3RDcmVhdGl2ZSBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBjIGFzIGNyZWF0ZVNoYWRvdyB9IGZyb20gJy4uL3NoYXJlZC9jcmVhdGUtc2hhZG93Lm1qcyc7XG5pbXBvcnQgeyBlIGFzIGVmZmVjdEluaXQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LWluaXQubWpzJztcbmltcG9ydCB7IGUgYXMgZWZmZWN0VGFyZ2V0IH0gZnJvbSAnLi4vc2hhcmVkL2VmZmVjdC10YXJnZXQubWpzJztcbmltcG9ydCB7IGUgYXMgZWZmZWN0VmlydHVhbFRyYW5zaXRpb25FbmQgfSBmcm9tICcuLi9zaGFyZWQvZWZmZWN0LXZpcnR1YWwtdHJhbnNpdGlvbi1lbmQubWpzJztcbmltcG9ydCB7IGcgYXMgZ2V0U2xpZGVUcmFuc2Zvcm1FbCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBFZmZlY3RDYXJkcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIGV4dGVuZFBhcmFtcyxcbiAgICBvblxuICB9ID0gX3JlZjtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBjYXJkc0VmZmVjdDoge1xuICAgICAgc2xpZGVTaGFkb3dzOiB0cnVlLFxuICAgICAgcm90YXRlOiB0cnVlLFxuICAgICAgcGVyU2xpZGVSb3RhdGU6IDIsXG4gICAgICBwZXJTbGlkZU9mZnNldDogOFxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNldFRyYW5zbGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXMsXG4gICAgICBhY3RpdmVJbmRleCxcbiAgICAgIHJ0bFRyYW5zbGF0ZTogcnRsXG4gICAgfSA9IHN3aXBlcjtcbiAgICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zLmNhcmRzRWZmZWN0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0VHJhbnNsYXRlLFxuICAgICAgaXNUb3VjaGVkXG4gICAgfSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZSA9IHJ0bCA/IC1zd2lwZXIudHJhbnNsYXRlIDogc3dpcGVyLnRyYW5zbGF0ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2xpZGVFbCA9IHNsaWRlc1tpXTtcbiAgICAgIGNvbnN0IHNsaWRlUHJvZ3Jlc3MgPSBzbGlkZUVsLnByb2dyZXNzO1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChzbGlkZVByb2dyZXNzLCAtNCksIDQpO1xuICAgICAgbGV0IG9mZnNldCA9IHNsaWRlRWwuc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgICBpZiAoc3dpcGVyLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiAhc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICAgIHN3aXBlci53cmFwcGVyRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtzd2lwZXIubWluVHJhbnNsYXRlKCl9cHgpYDtcbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHN3aXBlci5wYXJhbXMuY3NzTW9kZSkge1xuICAgICAgICBvZmZzZXQgLT0gc2xpZGVzWzBdLnN3aXBlclNsaWRlT2Zmc2V0O1xuICAgICAgfVxuICAgICAgbGV0IHRYID0gc3dpcGVyLnBhcmFtcy5jc3NNb2RlID8gLW9mZnNldCAtIHN3aXBlci50cmFuc2xhdGUgOiAtb2Zmc2V0O1xuICAgICAgbGV0IHRZID0gMDtcbiAgICAgIGNvbnN0IHRaID0gLTEwMCAqIE1hdGguYWJzKHByb2dyZXNzKTtcbiAgICAgIGxldCBzY2FsZSA9IDE7XG4gICAgICBsZXQgcm90YXRlID0gLXBhcmFtcy5wZXJTbGlkZVJvdGF0ZSAqIHByb2dyZXNzO1xuICAgICAgbGV0IHRYQWRkID0gcGFyYW1zLnBlclNsaWRlT2Zmc2V0IC0gTWF0aC5hYnMocHJvZ3Jlc3MpICogMC43NTtcbiAgICAgIGNvbnN0IHNsaWRlSW5kZXggPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHN3aXBlci52aXJ0dWFsLmZyb20gKyBpIDogaTtcbiAgICAgIGNvbnN0IGlzU3dpcGVUb05leHQgPSAoc2xpZGVJbmRleCA9PT0gYWN0aXZlSW5kZXggfHwgc2xpZGVJbmRleCA9PT0gYWN0aXZlSW5kZXggLSAxKSAmJiBwcm9ncmVzcyA+IDAgJiYgcHJvZ3Jlc3MgPCAxICYmIChpc1RvdWNoZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSAmJiBjdXJyZW50VHJhbnNsYXRlIDwgc3RhcnRUcmFuc2xhdGU7XG4gICAgICBjb25zdCBpc1N3aXBlVG9QcmV2ID0gKHNsaWRlSW5kZXggPT09IGFjdGl2ZUluZGV4IHx8IHNsaWRlSW5kZXggPT09IGFjdGl2ZUluZGV4ICsgMSkgJiYgcHJvZ3Jlc3MgPCAwICYmIHByb2dyZXNzID4gLTEgJiYgKGlzVG91Y2hlZCB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpICYmIGN1cnJlbnRUcmFuc2xhdGUgPiBzdGFydFRyYW5zbGF0ZTtcbiAgICAgIGlmIChpc1N3aXBlVG9OZXh0IHx8IGlzU3dpcGVUb1ByZXYpIHtcbiAgICAgICAgY29uc3Qgc3ViUHJvZ3Jlc3MgPSAoMSAtIE1hdGguYWJzKChNYXRoLmFicyhwcm9ncmVzcykgLSAwLjUpIC8gMC41KSkgKiogMC41O1xuICAgICAgICByb3RhdGUgKz0gLTI4ICogcHJvZ3Jlc3MgKiBzdWJQcm9ncmVzcztcbiAgICAgICAgc2NhbGUgKz0gLTAuNSAqIHN1YlByb2dyZXNzO1xuICAgICAgICB0WEFkZCArPSA5NiAqIHN1YlByb2dyZXNzO1xuICAgICAgICB0WSA9IGAkey0yNSAqIHN1YlByb2dyZXNzICogTWF0aC5hYnMocHJvZ3Jlc3MpfSVgO1xuICAgICAgfVxuICAgICAgaWYgKHByb2dyZXNzIDwgMCkge1xuICAgICAgICAvLyBuZXh0XG4gICAgICAgIHRYID0gYGNhbGMoJHt0WH1weCAke3J0bCA/ICctJyA6ICcrJ30gKCR7dFhBZGQgKiBNYXRoLmFicyhwcm9ncmVzcyl9JSkpYDtcbiAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPiAwKSB7XG4gICAgICAgIC8vIHByZXZcbiAgICAgICAgdFggPSBgY2FsYygke3RYfXB4ICR7cnRsID8gJy0nIDogJysnfSAoLSR7dFhBZGQgKiBNYXRoLmFicyhwcm9ncmVzcyl9JSkpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRYID0gYCR7dFh9cHhgO1xuICAgICAgfVxuICAgICAgaWYgKCFzd2lwZXIuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgY29uc3QgcHJldlkgPSB0WTtcbiAgICAgICAgdFkgPSB0WDtcbiAgICAgICAgdFggPSBwcmV2WTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlU3RyaW5nID0gcHJvZ3Jlc3MgPCAwID8gYCR7MSArICgxIC0gc2NhbGUpICogcHJvZ3Jlc3N9YCA6IGAkezEgLSAoMSAtIHNjYWxlKSAqIHByb2dyZXNzfWA7XG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgXG4gICAgICAgIHRyYW5zbGF0ZTNkKCR7dFh9LCAke3RZfSwgJHt0Wn1weClcbiAgICAgICAgcm90YXRlWigke3BhcmFtcy5yb3RhdGUgPyBydGwgPyAtcm90YXRlIDogcm90YXRlIDogMH1kZWcpXG4gICAgICAgIHNjYWxlKCR7c2NhbGVTdHJpbmd9KVxuICAgICAgYDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgICAgaWYgKHBhcmFtcy5zbGlkZVNoYWRvd3MpIHtcbiAgICAgICAgLy8gU2V0IHNoYWRvd3NcbiAgICAgICAgbGV0IHNoYWRvd0VsID0gc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXNoYWRvdycpO1xuICAgICAgICBpZiAoIXNoYWRvd0VsKSB7XG4gICAgICAgICAgc2hhZG93RWwgPSBjcmVhdGVTaGFkb3coJ2NhcmRzJywgc2xpZGVFbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWRvd0VsKSBzaGFkb3dFbC5zdHlsZS5vcGFjaXR5ID0gTWF0aC5taW4oTWF0aC5tYXgoKE1hdGguYWJzKHByb2dyZXNzKSAtIDAuNSkgLyAwLjUsIDApLCAxKTtcbiAgICAgIH1cbiAgICAgIHNsaWRlRWwuc3R5bGUuekluZGV4ID0gLU1hdGguYWJzKE1hdGgucm91bmQoc2xpZGVQcm9ncmVzcykpICsgc2xpZGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRhcmdldEVsID0gZWZmZWN0VGFyZ2V0KHBhcmFtcywgc2xpZGVFbCk7XG4gICAgICB0YXJnZXRFbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRUcmFuc2l0aW9uID0gZHVyYXRpb24gPT4ge1xuICAgIGNvbnN0IHRyYW5zZm9ybUVsZW1lbnRzID0gc3dpcGVyLnNsaWRlcy5tYXAoc2xpZGVFbCA9PiBnZXRTbGlkZVRyYW5zZm9ybUVsKHNsaWRlRWwpKTtcbiAgICB0cmFuc2Zvcm1FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zd2lwZXItc2xpZGUtc2hhZG93JykuZm9yRWFjaChzaGFkb3dFbCA9PiB7XG4gICAgICAgIHNoYWRvd0VsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVmZmVjdFZpcnR1YWxUcmFuc2l0aW9uRW5kKHtcbiAgICAgIHN3aXBlcixcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdHJhbnNmb3JtRWxlbWVudHNcbiAgICB9KTtcbiAgfTtcbiAgZWZmZWN0SW5pdCh7XG4gICAgZWZmZWN0OiAnY2FyZHMnLFxuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBzZXRUcmFuc2xhdGUsXG4gICAgc2V0VHJhbnNpdGlvbixcbiAgICBwZXJzcGVjdGl2ZTogKCkgPT4gdHJ1ZSxcbiAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XG4gICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiB0cnVlLFxuICAgICAgdmlydHVhbFRyYW5zbGF0ZTogIXN3aXBlci5wYXJhbXMuY3NzTW9kZVxuICAgIH0pXG4gIH0pO1xufVxuXG5leHBvcnQgeyBFZmZlY3RDYXJkcyBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIFN3aXBlciAxMS4xLjRcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXG4gKiBodHRwczovL3N3aXBlcmpzLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDE0LTIwMjQgVmxhZGltaXIgS2hhcmxhbXBpZGlcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBSZWxlYXNlZCBvbjogTWF5IDMwLCAyMDI0XG4gKi9cblxuaW1wb3J0IHsgUyBhcyBTd2lwZXIgfSBmcm9tICcuL3NoYXJlZC9zd2lwZXItY29yZS5tanMnO1xuaW1wb3J0IFZpcnR1YWwgZnJvbSAnLi9tb2R1bGVzL3ZpcnR1YWwubWpzJztcbmltcG9ydCBLZXlib2FyZCBmcm9tICcuL21vZHVsZXMva2V5Ym9hcmQubWpzJztcbmltcG9ydCBNb3VzZXdoZWVsIGZyb20gJy4vbW9kdWxlcy9tb3VzZXdoZWVsLm1qcyc7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuL21vZHVsZXMvbmF2aWdhdGlvbi5tanMnO1xuaW1wb3J0IFBhZ2luYXRpb24gZnJvbSAnLi9tb2R1bGVzL3BhZ2luYXRpb24ubWpzJztcbmltcG9ydCBTY3JvbGxiYXIgZnJvbSAnLi9tb2R1bGVzL3Njcm9sbGJhci5tanMnO1xuaW1wb3J0IFBhcmFsbGF4IGZyb20gJy4vbW9kdWxlcy9wYXJhbGxheC5tanMnO1xuaW1wb3J0IFpvb20gZnJvbSAnLi9tb2R1bGVzL3pvb20ubWpzJztcbmltcG9ydCBDb250cm9sbGVyIGZyb20gJy4vbW9kdWxlcy9jb250cm9sbGVyLm1qcyc7XG5pbXBvcnQgQTExeSBmcm9tICcuL21vZHVsZXMvYTExeS5tanMnO1xuaW1wb3J0IEhpc3RvcnkgZnJvbSAnLi9tb2R1bGVzL2hpc3RvcnkubWpzJztcbmltcG9ydCBIYXNoTmF2aWdhdGlvbiBmcm9tICcuL21vZHVsZXMvaGFzaC1uYXZpZ2F0aW9uLm1qcyc7XG5pbXBvcnQgQXV0b3BsYXkgZnJvbSAnLi9tb2R1bGVzL2F1dG9wbGF5Lm1qcyc7XG5pbXBvcnQgVGh1bWIgZnJvbSAnLi9tb2R1bGVzL3RodW1icy5tanMnO1xuaW1wb3J0IGZyZWVNb2RlIGZyb20gJy4vbW9kdWxlcy9mcmVlLW1vZGUubWpzJztcbmltcG9ydCBHcmlkIGZyb20gJy4vbW9kdWxlcy9ncmlkLm1qcyc7XG5pbXBvcnQgTWFuaXB1bGF0aW9uIGZyb20gJy4vbW9kdWxlcy9tYW5pcHVsYXRpb24ubWpzJztcbmltcG9ydCBFZmZlY3RGYWRlIGZyb20gJy4vbW9kdWxlcy9lZmZlY3QtZmFkZS5tanMnO1xuaW1wb3J0IEVmZmVjdEN1YmUgZnJvbSAnLi9tb2R1bGVzL2VmZmVjdC1jdWJlLm1qcyc7XG5pbXBvcnQgRWZmZWN0RmxpcCBmcm9tICcuL21vZHVsZXMvZWZmZWN0LWZsaXAubWpzJztcbmltcG9ydCBFZmZlY3RDb3ZlcmZsb3cgZnJvbSAnLi9tb2R1bGVzL2VmZmVjdC1jb3ZlcmZsb3cubWpzJztcbmltcG9ydCBFZmZlY3RDcmVhdGl2ZSBmcm9tICcuL21vZHVsZXMvZWZmZWN0LWNyZWF0aXZlLm1qcyc7XG5pbXBvcnQgRWZmZWN0Q2FyZHMgZnJvbSAnLi9tb2R1bGVzL2VmZmVjdC1jYXJkcy5tanMnO1xuXG4vLyBTd2lwZXIgQ2xhc3NcbmNvbnN0IG1vZHVsZXMgPSBbVmlydHVhbCwgS2V5Ym9hcmQsIE1vdXNld2hlZWwsIE5hdmlnYXRpb24sIFBhZ2luYXRpb24sIFNjcm9sbGJhciwgUGFyYWxsYXgsIFpvb20sIENvbnRyb2xsZXIsIEExMXksIEhpc3RvcnksIEhhc2hOYXZpZ2F0aW9uLCBBdXRvcGxheSwgVGh1bWIsIGZyZWVNb2RlLCBHcmlkLCBNYW5pcHVsYXRpb24sIEVmZmVjdEZhZGUsIEVmZmVjdEN1YmUsIEVmZmVjdEZsaXAsIEVmZmVjdENvdmVyZmxvdywgRWZmZWN0Q3JlYXRpdmUsIEVmZmVjdENhcmRzXTtcblN3aXBlci51c2UobW9kdWxlcyk7XG5cbmV4cG9ydCB7IFN3aXBlciwgU3dpcGVyIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCBTd2lwZXIgZnJvbSBcInN3aXBlci9idW5kbGVcIjtcblxuaW1wb3J0IFwic3dpcGVyL2Nzcy9idW5kbGVcIjtcblxuY29uc3Qgc3dpcGVyID0gbmV3IFN3aXBlcihcIi5zd2lwZXJcIiwge1xuICBzbGlkZXNQZXJWaWV3OiA0LFxuICBhdXRvV2lkdGg6IHRydWUsXG4gIGJyZWFrcG9pbnRzOiB7XG4gICAgMjAwOiB7XG4gICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgc3BhY2VCZXR3ZWVuOiAxMixcbiAgICB9LFxuICAgIDQyNToge1xuICAgICAgc2xpZGVzUGVyVmlldzogMixcbiAgICAgIHNwYWNlQmV0d2VlbjogMTQsXG4gICAgfSxcbiAgICA3Njg6IHtcbiAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICBzcGFjZUJldHdlZW46IDI0LFxuICAgIH0sXG4gICAgMTAyNDoge1xuICAgICAgc2xpZGVzUGVyVmlldzogNCxcbiAgICB9LFxuICB9LFxuICBzcGFjZUJldHdlZW46IDMyLFxuXG4gIG5hdmlnYXRpb246IHtcbiAgICBuZXh0RWw6IFwiLnBvcHVsYXJfX25leHRcIixcbiAgICBwcmV2RWw6IFwiLnBvcHVsYXJfX3ByZXdcIixcbiAgfSxcbn0pO1xuXG4vLyBUZXN0aW1vbmlhbHMgc3dpcGVyIGNvbmZpZ1xuXG5jb25zdCBzd2lwZXJDb25maWcgPSB7XG4gIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICBzbGlkZXNQZXJWaWV3OiBcImF1dG9cIixcbiAgc3BhY2VCZXR3ZWVuOiAzMixcbiAgZ3JhYkN1cnNvcjogdHJ1ZSxcbiAgZnJlZU1vZGU6IHRydWUsXG4gIHNwZWVkOiA2MDAwLFxuICBsb29wOiB0cnVlLFxuICBhdXRvcGxheToge1xuICAgIGRlbGF5OiAwLjAsXG4gICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246IGZhbHNlLFxuICB9LFxuICBsb29wQWRkaXRpb25hbFNsaWRlczogOSxcbn07XG5cbmNvbnN0IHN3aXBlckhvcml6b250YWxDb25maWcgPSB7XG4gIHNsaWRlc1BlclZpZXc6IDMsXG4gIGF1dG9IZWlnaHQ6IHRydWUsXG4gIGJyZWFrcG9pbnRzOiB7XG4gICAgMjAwOiB7XG4gICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgIH0sXG4gICAgNDgwOiB7XG4gICAgICBzbGlkZXNQZXJWaWV3OiAyLFxuICAgIH0sXG4gICAgNzgwOiB7XG4gICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgIH0sXG4gIH0sXG4gIHNwYWNlQmV0d2VlbjogMjAsXG4gIHNwZWVkOiA2MDAwLFxuICBsb29wOiB0cnVlLFxuICBncmFiQ3Vyc29yOiB0cnVlLFxuICBmcmVlTW9kZTogdHJ1ZSxcbiAgYXV0b3BsYXk6IHtcbiAgICBkZWxheTogMC4wLFxuICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcbiAgfSxcbn07XG5cbmxldCB0ZXN0aW1vbmlhbHNTd2lwZXI7XG5sZXQgdGVzdGltb25pYWxzU3dpcGVyMjtcbmxldCB0ZXN0aW1vbmlhbHNTd2lwZXIzO1xubGV0IHRlc3RpbW9uaWFsc0hvcml6b250YWw7XG5cbmNvbnN0IHN3aXBlckJyZWFja3BvaW50ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIobWF4LXdpZHRoOiAxMDI0cHgpXCIpO1xuXG5sZXQgc3dpcGVyVGVzdGltb25pYWxzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoc3dpcGVyQnJlYWNrcG9pbnQubWF0Y2hlcyA9PT0gdHJ1ZSkge1xuICAgIGlmICh0ZXN0aW1vbmlhbHNTd2lwZXIpIHtcbiAgICAgIHRlc3RpbW9uaWFsc1N3aXBlci5kZXN0cm95KHRydWUsIHRydWUpO1xuICAgICAgdGVzdGltb25pYWxzU3dpcGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGVzdGltb25pYWxzU3dpcGVyMikge1xuICAgICAgdGVzdGltb25pYWxzU3dpcGVyMi5kZXN0cm95KHRydWUsIHRydWUpO1xuICAgICAgdGVzdGltb25pYWxzU3dpcGVyMiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRlc3RpbW9uaWFsc1N3aXBlcjMpIHtcbiAgICAgIHRlc3RpbW9uaWFsc1N3aXBlcjMuZGVzdHJveSh0cnVlLCB0cnVlKTtcbiAgICAgIHRlc3RpbW9uaWFsc1N3aXBlcjMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaG9yaXpvbnRhbFN3aXBlcigpO1xuXG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCFzd2lwZXJCcmVhY2twb2ludC5tYXRjaGVzKSB7XG4gICAgaWYgKHRlc3RpbW9uaWFsc0hvcml6b250YWwpIHtcbiAgICAgIHRlc3RpbW9uaWFsc0hvcml6b250YWwuZGVzdHJveSh0cnVlLCB0cnVlKTtcbiAgICAgIHRlc3RpbW9uaWFsc0hvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGVzdGltb25pYWxzU3dpcGVycygpO1xuXG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5jb25zdCB0ZXN0aW1vbmlhbHNTd2lwZXJzID0gZnVuY3Rpb24gKCkge1xuICB0ZXN0aW1vbmlhbHNTd2lwZXIgPSBuZXcgU3dpcGVyKFwiLnRlc3RpbW9uaWFsc19fZmlyc3QtYmxvY2tcIiwgc3dpcGVyQ29uZmlnKTtcbiAgdGVzdGltb25pYWxzU3dpcGVyMiA9IG5ldyBTd2lwZXIoXCIudGVzdGltb25pYWxzX19zZWNvbmQtYmxvY2tcIiwgc3dpcGVyQ29uZmlnKTtcbiAgdGVzdGltb25pYWxzU3dpcGVyMyA9IG5ldyBTd2lwZXIoXCIudGVzdGltb25pYWxzX190aGlyZC1ibG9ja1wiLCBzd2lwZXJDb25maWcpO1xufTtcblxuY29uc3QgaG9yaXpvbnRhbFN3aXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGVzdGltb25pYWxzSG9yaXpvbnRhbCA9IG5ldyBTd2lwZXIoXG4gICAgXCIudGVzdGltb25pYWxzX19ob3Jpem9udGFsLXNsaWRlclwiLFxuICAgIHN3aXBlckhvcml6b250YWxDb25maWdcbiAgKTtcbn07XG5cbnN3aXBlckJyZWFja3BvaW50LmFkZExpc3RlbmVyKHN3aXBlclRlc3RpbW9uaWFscyk7XG5zd2lwZXJUZXN0aW1vbmlhbHMoKTtcbiIsIi8qISBAbGljZW5zZSBpcy1kb20tbm9kZSB2MS4wLjRcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5cdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcblx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuXHRTT0ZUV0FSRS5cblxuKi9cbmZ1bmN0aW9uIGlzRG9tTm9kZSh4KSB7XG5cdHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGUgPT09ICdvYmplY3QnXG5cdFx0PyB4IGluc3RhbmNlb2Ygd2luZG93Lk5vZGVcblx0XHQ6IHggIT09IG51bGwgJiZcblx0XHRcdFx0dHlwZW9mIHggPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdHR5cGVvZiB4Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0XHR0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZydcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNEb21Ob2RlO1xuIiwiLyohIEBsaWNlbnNlIGlzLWRvbS1ub2RlLWxpc3QgdjEuMi4xXG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG5pbXBvcnQgaXNEb21Ob2RlIGZyb20gJ2lzLWRvbS1ub2RlJztcblxuZnVuY3Rpb24gaXNEb21Ob2RlTGlzdCh4KSB7XG5cdHZhciBwcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KTtcblx0dmFyIHJlZ2V4ID0gL15cXFtvYmplY3QgKEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0fE9iamVjdClcXF0kLztcblxuXHRyZXR1cm4gdHlwZW9mIHdpbmRvdy5Ob2RlTGlzdCA9PT0gJ29iamVjdCdcblx0XHQ/IHggaW5zdGFuY2VvZiB3aW5kb3cuTm9kZUxpc3Rcblx0XHQ6IHggIT09IG51bGwgJiZcblx0XHRcdFx0dHlwZW9mIHggPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdFx0cmVnZXgudGVzdChwcm90b3R5cGVUb1N0cmluZykgJiZcblx0XHRcdFx0KHgubGVuZ3RoID09PSAwIHx8IGlzRG9tTm9kZSh4WzBdKSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNEb21Ob2RlTGlzdDtcbiIsIi8qISBAbGljZW5zZSBUZWFsaWdodCB2MC4zLjZcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5cdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcblx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuXHRTT0ZUV0FSRS5cblxuKi9cbmltcG9ydCBpc0RvbU5vZGUgZnJvbSAnaXMtZG9tLW5vZGUnO1xuaW1wb3J0IGlzRG9tTm9kZUxpc3QgZnJvbSAnaXMtZG9tLW5vZGUtbGlzdCc7XG5cbmZ1bmN0aW9uIHRlYWxpZ2h0KHRhcmdldCwgY29udGV4dCkge1xuICBpZiAoIGNvbnRleHQgPT09IHZvaWQgMCApIGNvbnRleHQgPSBkb2N1bWVudDtcblxuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHsgcmV0dXJuIHRhcmdldC5maWx0ZXIoaXNEb21Ob2RlKTsgfVxuICBpZiAoaXNEb21Ob2RlKHRhcmdldCkpIHsgcmV0dXJuIFt0YXJnZXRdOyB9XG4gIGlmIChpc0RvbU5vZGVMaXN0KHRhcmdldCkpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCk7IH1cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHF1ZXJ5ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCk7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocXVlcnkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRlYWxpZ2h0O1xuIiwiLyohIEBsaWNlbnNlIFJlbWF0cml4IHYwLjMuMFxuXG5cdENvcHlyaWdodCAyMDE4IEp1bGlhbiBMbG95ZC5cblxuXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5cdG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcblx0aW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuXHR0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5cdGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuXHRmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5cdGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcblx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5cdEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuXHRBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5cdExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5cdE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblx0VEhFIFNPRlRXQVJFLlxuKi9cbi8qKlxuICogQG1vZHVsZSBSZW1hdHJpeFxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gbWF0cmljZXMgaW4gdGhlIGJyb3dzZXIgY29tZSBpbiB0d28gZmxhdm9yczpcbiAqXG4gKiAgLSBgbWF0cml4YCB1c2luZyA2IHZhbHVlcyAoc2hvcnQpXG4gKiAgLSBgbWF0cml4M2RgIHVzaW5nIDE2IHZhbHVlcyAobG9uZylcbiAqXG4gKiBUaGlzIHV0aWxpdHkgZm9sbG93cyB0aGlzIFtjb252ZXJzaW9uIGd1aWRlXShodHRwczovL2dvby5nbC9FSmxVUTEpXG4gKiB0byBleHBhbmQgc2hvcnQgZm9ybSBtYXRyaWNlcyB0byB0aGVpciBlcXVpdmFsZW50IGxvbmcgZm9ybS5cbiAqXG4gKiBAcGFyYW0gIHthcnJheX0gc291cmNlIC0gQWNjZXB0cyBib3RoIHNob3J0IGFuZCBsb25nIGZvcm0gbWF0cmljZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHNvdXJjZSkge1xuXHRpZiAoc291cmNlLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFycmF5LicpXG5cdH1cblx0aWYgKHNvdXJjZS5sZW5ndGggPT09IDE2KSB7XG5cdFx0cmV0dXJuIHNvdXJjZVxuXHR9XG5cdGlmIChzb3VyY2UubGVuZ3RoID09PSA2KSB7XG5cdFx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdFx0bWF0cml4WzBdID0gc291cmNlWzBdO1xuXHRcdG1hdHJpeFsxXSA9IHNvdXJjZVsxXTtcblx0XHRtYXRyaXhbNF0gPSBzb3VyY2VbMl07XG5cdFx0bWF0cml4WzVdID0gc291cmNlWzNdO1xuXHRcdG1hdHJpeFsxMl0gPSBzb3VyY2VbNF07XG5cdFx0bWF0cml4WzEzXSA9IHNvdXJjZVs1XTtcblx0XHRyZXR1cm4gbWF0cml4XG5cdH1cblx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0V4cGVjdGVkIGFycmF5IHdpdGggZWl0aGVyIDYgb3IgMTYgdmFsdWVzLicpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdHJpeCByZXByZXNlbnRpbmcgbm8gdHJhbnNmb3JtYXRpb24uIFRoZSBwcm9kdWN0IG9mIGFueSBtYXRyaXhcbiAqIG11bHRpcGxpZWQgYnkgdGhlIGlkZW50aXR5IG1hdHJpeCB3aWxsIGJlIHRoZSBvcmlnaW5hbCBtYXRyaXguXG4gKlxuICogPiAqKlRpcDoqKiBTaW1pbGFyIHRvIGhvdyBgNSAqIDEgPT09IDVgLCB3aGVyZSBgMWAgaXMgdGhlIGlkZW50aXR5LlxuICpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcblx0dmFyIG1hdHJpeCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0XHRpICUgNSA9PSAwID8gbWF0cml4LnB1c2goMSkgOiBtYXRyaXgucHVzaCgwKTtcblx0fVxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG1hdHJpeCBkZXNjcmliaW5nIHRoZSBpbnZlcnNlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBzb3VyY2VcbiAqIG1hdHJpeC4gVGhlIHByb2R1Y3Qgb2YgYW55IG1hdHJpeCBtdWx0aXBsaWVkIGJ5IGl0cyBpbnZlcnNlIHdpbGwgYmUgdGhlXG4gKiBpZGVudGl0eSBtYXRyaXguXG4gKlxuICogPiAqKlRpcDoqKiBTaW1pbGFyIHRvIGhvdyBgNSAqICgxLzUpID09PSAxYCwgd2hlcmUgYDEvNWAgaXMgdGhlIGludmVyc2UuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNvdXJjZSAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uoc291cmNlKSB7XG5cdHZhciBtID0gZm9ybWF0KHNvdXJjZSk7XG5cblx0dmFyIHMwID0gbVswXSAqIG1bNV0gLSBtWzRdICogbVsxXTtcblx0dmFyIHMxID0gbVswXSAqIG1bNl0gLSBtWzRdICogbVsyXTtcblx0dmFyIHMyID0gbVswXSAqIG1bN10gLSBtWzRdICogbVszXTtcblx0dmFyIHMzID0gbVsxXSAqIG1bNl0gLSBtWzVdICogbVsyXTtcblx0dmFyIHM0ID0gbVsxXSAqIG1bN10gLSBtWzVdICogbVszXTtcblx0dmFyIHM1ID0gbVsyXSAqIG1bN10gLSBtWzZdICogbVszXTtcblxuXHR2YXIgYzUgPSBtWzEwXSAqIG1bMTVdIC0gbVsxNF0gKiBtWzExXTtcblx0dmFyIGM0ID0gbVs5XSAqIG1bMTVdIC0gbVsxM10gKiBtWzExXTtcblx0dmFyIGMzID0gbVs5XSAqIG1bMTRdIC0gbVsxM10gKiBtWzEwXTtcblx0dmFyIGMyID0gbVs4XSAqIG1bMTVdIC0gbVsxMl0gKiBtWzExXTtcblx0dmFyIGMxID0gbVs4XSAqIG1bMTRdIC0gbVsxMl0gKiBtWzEwXTtcblx0dmFyIGMwID0gbVs4XSAqIG1bMTNdIC0gbVsxMl0gKiBtWzldO1xuXG5cdHZhciBkZXRlcm1pbmFudCA9IDEgLyAoczAgKiBjNSAtIHMxICogYzQgKyBzMiAqIGMzICsgczMgKiBjMiAtIHM0ICogYzEgKyBzNSAqIGMwKTtcblxuXHRpZiAoaXNOYU4oZGV0ZXJtaW5hbnQpIHx8IGRldGVybWluYW50ID09PSBJbmZpbml0eSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52ZXJzZSBkZXRlcm1pbmFudCBhdHRlbXB0ZWQgdG8gZGl2aWRlIGJ5IHplcm8uJylcblx0fVxuXG5cdHJldHVybiBbXG5cdFx0KG1bNV0gKiBjNSAtIG1bNl0gKiBjNCArIG1bN10gKiBjMykgKiBkZXRlcm1pbmFudCxcblx0XHQoLW1bMV0gKiBjNSArIG1bMl0gKiBjNCAtIG1bM10gKiBjMykgKiBkZXRlcm1pbmFudCxcblx0XHQobVsxM10gKiBzNSAtIG1bMTRdICogczQgKyBtWzE1XSAqIHMzKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVs5XSAqIHM1ICsgbVsxMF0gKiBzNCAtIG1bMTFdICogczMpICogZGV0ZXJtaW5hbnQsXG5cblx0XHQoLW1bNF0gKiBjNSArIG1bNl0gKiBjMiAtIG1bN10gKiBjMSkgKiBkZXRlcm1pbmFudCxcblx0XHQobVswXSAqIGM1IC0gbVsyXSAqIGMyICsgbVszXSAqIGMxKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVsxMl0gKiBzNSArIG1bMTRdICogczIgLSBtWzE1XSAqIHMxKSAqIGRldGVybWluYW50LFxuXHRcdChtWzhdICogczUgLSBtWzEwXSAqIHMyICsgbVsxMV0gKiBzMSkgKiBkZXRlcm1pbmFudCxcblxuXHRcdChtWzRdICogYzQgLSBtWzVdICogYzIgKyBtWzddICogYzApICogZGV0ZXJtaW5hbnQsXG5cdFx0KC1tWzBdICogYzQgKyBtWzFdICogYzIgLSBtWzNdICogYzApICogZGV0ZXJtaW5hbnQsXG5cdFx0KG1bMTJdICogczQgLSBtWzEzXSAqIHMyICsgbVsxNV0gKiBzMCkgKiBkZXRlcm1pbmFudCxcblx0XHQoLW1bOF0gKiBzNCArIG1bOV0gKiBzMiAtIG1bMTFdICogczApICogZGV0ZXJtaW5hbnQsXG5cblx0XHQoLW1bNF0gKiBjMyArIG1bNV0gKiBjMSAtIG1bNl0gKiBjMCkgKiBkZXRlcm1pbmFudCxcblx0XHQobVswXSAqIGMzIC0gbVsxXSAqIGMxICsgbVsyXSAqIGMwKSAqIGRldGVybWluYW50LFxuXHRcdCgtbVsxMl0gKiBzMyArIG1bMTNdICogczEgLSBtWzE0XSAqIHMwKSAqIGRldGVybWluYW50LFxuXHRcdChtWzhdICogczMgLSBtWzldICogczEgKyBtWzEwXSAqIHMwKSAqIGRldGVybWluYW50XG5cdF1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbnNcbiAqIG9mIGJvdGggYXJndW1lbnRzLlxuICpcbiAqID4gKipOb3RlOioqIE9yZGVyIGlzIHZlcnkgaW1wb3J0YW50LiBGb3IgZXhhbXBsZSwgcm90YXRpbmcgNDXCsFxuICogYWxvbmcgdGhlIFotYXhpcywgZm9sbG93ZWQgYnkgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcy4uLiBpcyBub3QgdGhlIHNhbWUgYXMgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcywgZm9sbG93ZWQgYnkgcm90YXRpbmcgNDXCsCBhbG9uZyBvbiB0aGUgWi1heGlzLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBtIC0gQWNjZXB0cyBib3RoIHNob3J0IGFuZCBsb25nIGZvcm0gbWF0cmljZXMuXG4gKiBAcGFyYW0gIHthcnJheX0geCAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG0sIHgpIHtcblx0dmFyIGZtID0gZm9ybWF0KG0pO1xuXHR2YXIgZnggPSBmb3JtYXQoeCk7XG5cdHZhciBwcm9kdWN0ID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHR2YXIgcm93ID0gW2ZtW2ldLCBmbVtpICsgNF0sIGZtW2kgKyA4XSwgZm1baSArIDEyXV07XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcblx0XHRcdHZhciBrID0gaiAqIDQ7XG5cdFx0XHR2YXIgY29sID0gW2Z4W2tdLCBmeFtrICsgMV0sIGZ4W2sgKyAyXSwgZnhbayArIDNdXTtcblx0XHRcdHZhciByZXN1bHQgPVxuXHRcdFx0XHRyb3dbMF0gKiBjb2xbMF0gKyByb3dbMV0gKiBjb2xbMV0gKyByb3dbMl0gKiBjb2xbMl0gKyByb3dbM10gKiBjb2xbM107XG5cblx0XHRcdHByb2R1Y3RbaSArIGtdID0gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9kdWN0XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmV0dXJuIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBDU1MgdHJhbnNmb3JtXG4gKiBtYXRyaXggcGFzc2VkIGluLCBidXQgd2lsbCByZXR1cm4gdGhlIGlkZW50aXR5IG1hdHJpeCBhcyBhXG4gKiBmYWxsYmFjay5cbiAqXG4gKiA+ICoqVGlwOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY29udmVydCBhIENTUyBtYXRyaXggKHJldHJpZXZlZCBhcyBhXG4gKiBgc3RyaW5nYCBmcm9tIGNvbXB1dGVkIHN0eWxlcykgdG8gaXRzIGVxdWl2YWxlbnQgYXJyYXkgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlIC0gYG1hdHJpeGAgb3IgYG1hdHJpeDNkYCBDU1MgVHJhbnNmb3JtIHZhbHVlLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSkge1xuXHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2goL21hdHJpeCgzZCk/XFwoKFteKV0rKVxcKS8pO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0dmFyIHJhdyA9IG1hdGNoWzJdLnNwbGl0KCcsICcpLm1hcChwYXJzZUZsb2F0KTtcblx0XHRcdHJldHVybiBmb3JtYXQocmF3KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaWRlbnRpdHkoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWi1heGlzIHJvdGF0aW9uLlxuICpcbiAqID4gKipUaXA6KiogVGhpcyBpcyBqdXN0IGFuIGFsaWFzIGZvciBgUmVtYXRyaXgucm90YXRlWmAgZm9yIHBhcml0eSB3aXRoIENTU1xuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuXHRyZXR1cm4gcm90YXRlWihhbmdsZSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFgtYXhpcyByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlIC0gTWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiByb3RhdGVYKGFuZ2xlKSB7XG5cdHZhciB0aGV0YSA9IE1hdGguUEkgLyAxODAgKiBhbmdsZTtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cblx0bWF0cml4WzVdID0gbWF0cml4WzEwXSA9IE1hdGguY29zKHRoZXRhKTtcblx0bWF0cml4WzZdID0gbWF0cml4WzldID0gTWF0aC5zaW4odGhldGEpO1xuXHRtYXRyaXhbOV0gKj0gLTE7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWS1heGlzIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMF0gPSBtYXRyaXhbMTBdID0gTWF0aC5jb3ModGhldGEpO1xuXHRtYXRyaXhbMl0gPSBtYXRyaXhbOF0gPSBNYXRoLnNpbih0aGV0YSk7XG5cdG1hdHJpeFsyXSAqPSAtMTtcblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBaLWF4aXMgcm90YXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSAtIE1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuXHR2YXIgdGhldGEgPSBNYXRoLlBJIC8gMTgwICogYW5nbGU7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFswXSA9IG1hdHJpeFs1XSA9IE1hdGguY29zKHRoZXRhKTtcblx0bWF0cml4WzFdID0gbWF0cml4WzRdID0gTWF0aC5zaW4odGhldGEpO1xuXHRtYXRyaXhbNF0gKj0gLTE7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgMkQgc2NhbGluZy4gVGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBpcyB1c2VkIGZvciBib3RoIFggYW5kIFktYXhpcyBzY2FsaW5nLCB1bmxlc3MgYW4gb3B0aW9uYWxcbiAqIHNlY29uZCBhcmd1bWVudCBpcyBwcm92aWRlZCB0byBleHBsaWNpdGx5IGRlZmluZSBZLWF4aXMgc2NhbGluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNjYWxhciAgICAtIERlY2ltYWwgbXVsdGlwbGllci5cbiAqIEBwYXJhbSAge251bWJlcn0gW3NjYWxhclldIC0gRGVjaW1hbCBtdWx0aXBsaWVyLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKHNjYWxhciwgc2NhbGFyWSkge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMF0gPSBzY2FsYXI7XG5cdG1hdHJpeFs1XSA9IHR5cGVvZiBzY2FsYXJZID09PSAnbnVtYmVyJyA/IHNjYWxhclkgOiBzY2FsYXI7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWC1heGlzIHNjYWxpbmcuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBzY2FsYXIgLSBEZWNpbWFsIG11bHRpcGxpZXIuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2NhbGVYKHNjYWxhcikge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblx0bWF0cml4WzBdID0gc2NhbGFyO1xuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBZLWF4aXMgc2NhbGluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHNjYWxhciAtIERlY2ltYWwgbXVsdGlwbGllci5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBzY2FsZVkoc2NhbGFyKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbNV0gPSBzY2FsYXI7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFotYXhpcyBzY2FsaW5nLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gc2NhbGFyIC0gRGVjaW1hbCBtdWx0aXBsaWVyLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNjYWxlWihzY2FsYXIpIHtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdG1hdHJpeFsxMF0gPSBzY2FsYXI7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHNoZWFyLiBUaGUgZmlyc3QgYXJndW1lbnRcbiAqIGRlZmluZXMgWC1heGlzIHNoZWFyaW5nLCBhbmQgYW4gb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50XG4gKiBkZWZpbmVzIFktYXhpcyBzaGVhcmluZy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlWCAgIC0gTWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW2FuZ2xlWV0gLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHNrZXcoYW5nbGVYLCBhbmdsZVkpIHtcblx0dmFyIHRoZXRhWCA9IE1hdGguUEkgLyAxODAgKiBhbmdsZVg7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFs0XSA9IE1hdGgudGFuKHRoZXRhWCk7XG5cblx0aWYgKGFuZ2xlWSkge1xuXHRcdHZhciB0aGV0YVkgPSBNYXRoLlBJIC8gMTgwICogYW5nbGVZO1xuXHRcdG1hdHJpeFsxXSA9IE1hdGgudGFuKHRoZXRhWSk7XG5cdH1cblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBYLWF4aXMgc2hlYXIuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSAtIE1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2tld1goYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbNF0gPSBNYXRoLnRhbih0aGV0YSk7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWS1heGlzIHNoZWFyLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2tld1koYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbMV0gPSBNYXRoLnRhbih0aGV0YSk7XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBDU1MgVHJhbnNmb3JtIHByb3BlcnR5IHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIHNvdXJjZSBtYXRyaXguXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNvdXJjZSAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzb3VyY2UpIHtcblx0cmV0dXJuIChcIm1hdHJpeDNkKFwiICsgKGZvcm1hdChzb3VyY2UpLmpvaW4oJywgJykpICsgXCIpXCIpXG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyAyRCB0cmFuc2xhdGlvbi4gVGhlIGZpcnN0XG4gKiBhcmd1bWVudCBkZWZpbmVzIFgtYXhpcyB0cmFuc2xhdGlvbiwgYW5kIGFuIG9wdGlvbmFsIHNlY29uZFxuICogYXJndW1lbnQgZGVmaW5lcyBZLWF4aXMgdHJhbnNsYXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBkaXN0YW5jZVggICAtIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge251bWJlcn0gW2Rpc3RhbmNlWV0gLSBNZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKGRpc3RhbmNlWCwgZGlzdGFuY2VZKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbMTJdID0gZGlzdGFuY2VYO1xuXG5cdGlmIChkaXN0YW5jZVkpIHtcblx0XHRtYXRyaXhbMTNdID0gZGlzdGFuY2VZO1xuXHR9XG5cblx0cmV0dXJuIG1hdHJpeFxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWC1heGlzIHRyYW5zbGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gZGlzdGFuY2UgLSBNZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlWChkaXN0YW5jZSkge1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblx0bWF0cml4WzEyXSA9IGRpc3RhbmNlO1xuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBZLWF4aXMgdHJhbnNsYXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBkaXN0YW5jZSAtIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbMTNdID0gZGlzdGFuY2U7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFotYXhpcyB0cmFuc2xhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRpc3RhbmNlIC0gTWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZVooZGlzdGFuY2UpIHtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdG1hdHJpeFsxNF0gPSBkaXN0YW5jZTtcblx0cmV0dXJuIG1hdHJpeFxufVxuXG5leHBvcnQgeyBmb3JtYXQsIGlkZW50aXR5LCBpbnZlcnNlLCBtdWx0aXBseSwgcGFyc2UsIHJvdGF0ZSwgcm90YXRlWCwgcm90YXRlWSwgcm90YXRlWiwgc2NhbGUsIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHNrZXcsIHNrZXdYLCBza2V3WSwgdG9TdHJpbmcsIHRyYW5zbGF0ZSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdHJhbnNsYXRlWiB9O1xuIiwiLyohIEBsaWNlbnNlIG1pbmlyYWYgdjEuMC4wXG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG52YXIgcG9seWZpbGwgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgY2xvY2sgPSBEYXRlLm5vdygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHR2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGlmIChjdXJyZW50VGltZSAtIGNsb2NrID4gMTYpIHtcblx0XHRcdGNsb2NrID0gY3VycmVudFRpbWU7XG5cdFx0XHRjYWxsYmFjayhjdXJyZW50VGltZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9seWZpbGwoY2FsbGJhY2spOyB9LCAwKTtcblx0XHR9XG5cdH1cbn0pKCk7XG5cbnZhciBpbmRleCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdHBvbHlmaWxsO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsIi8qISBAbGljZW5zZSBTY3JvbGxSZXZlYWwgdjQuMC45XG5cblx0Q29weXJpZ2h0IDIwMjEgRmlzc3Npb24gTExDLlxuXG5cdExpY2Vuc2VkIHVuZGVyIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSAzLjAgZm9yXG5cdGNvbXBhdGlibGUgb3BlbiBzb3VyY2UgcHJvamVjdHMgYW5kIG5vbi1jb21tZXJjaWFsIHVzZS5cblxuXHRGb3IgY29tbWVyY2lhbCBzaXRlcywgdGhlbWVzLCBwcm9qZWN0cywgYW5kIGFwcGxpY2F0aW9ucyxcblx0a2VlcCB5b3VyIHNvdXJjZSBjb2RlIHByaXZhdGUvcHJvcHJpZXRhcnkgYnkgcHVyY2hhc2luZ1xuXHRhIGNvbW1lcmNpYWwgbGljZW5zZSBmcm9tIGh0dHBzOi8vc2Nyb2xscmV2ZWFsanMub3JnL1xuKi9cbmltcG9ydCAkIGZyb20gJ3RlYWxpZ2h0JztcbmltcG9ydCB7IHRyYW5zbGF0ZVksIHRyYW5zbGF0ZVgsIHJvdGF0ZVgsIHJvdGF0ZVksIHJvdGF0ZVosIHNjYWxlLCBwYXJzZSwgbXVsdGlwbHkgfSBmcm9tICdyZW1hdHJpeCc7XG5pbXBvcnQgcmFmIGZyb20gJ21pbmlyYWYnO1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGRlbGF5OiAwLFxuXHRkaXN0YW5jZTogJzAnLFxuXHRkdXJhdGlvbjogNjAwLFxuXHRlYXNpbmc6ICdjdWJpYy1iZXppZXIoMC41LCAwLCAwLCAxKScsXG5cdGludGVydmFsOiAwLFxuXHRvcGFjaXR5OiAwLFxuXHRvcmlnaW46ICdib3R0b20nLFxuXHRyb3RhdGU6IHtcblx0XHR4OiAwLFxuXHRcdHk6IDAsXG5cdFx0ejogMFxuXHR9LFxuXHRzY2FsZTogMSxcblx0Y2xlYW51cDogZmFsc2UsXG5cdGNvbnRhaW5lcjogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRkZXNrdG9wOiB0cnVlLFxuXHRtb2JpbGU6IHRydWUsXG5cdHJlc2V0OiBmYWxzZSxcblx0dXNlRGVsYXk6ICdhbHdheXMnLFxuXHR2aWV3RmFjdG9yOiAwLjAsXG5cdHZpZXdPZmZzZXQ6IHtcblx0XHR0b3A6IDAsXG5cdFx0cmlnaHQ6IDAsXG5cdFx0Ym90dG9tOiAwLFxuXHRcdGxlZnQ6IDBcblx0fSxcblx0YWZ0ZXJSZXNldDogZnVuY3Rpb24gYWZ0ZXJSZXNldCgpIHt9LFxuXHRhZnRlclJldmVhbDogZnVuY3Rpb24gYWZ0ZXJSZXZlYWwoKSB7fSxcblx0YmVmb3JlUmVzZXQ6IGZ1bmN0aW9uIGJlZm9yZVJlc2V0KCkge30sXG5cdGJlZm9yZVJldmVhbDogZnVuY3Rpb24gYmVmb3JlUmV2ZWFsKCkge31cbn07XG5cbmZ1bmN0aW9uIGZhaWx1cmUoKSB7XG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzcicpO1xuXG5cdHJldHVybiB7XG5cdFx0Y2xlYW46IGZ1bmN0aW9uIGNsZWFuKCkge30sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHt9LFxuXHRcdHJldmVhbDogZnVuY3Rpb24gcmV2ZWFsKCkge30sXG5cdFx0c3luYzogZnVuY3Rpb24gc3luYygpIHt9LFxuXHRcdGdldCBub29wKCkge1xuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc3VjY2VzcygpIHtcblx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3NyJyk7XG5cblx0aWYgKGRvY3VtZW50LmJvZHkpIHtcblx0XHRkb2N1bWVudC5ib2R5LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblx0fSBlbHNlIHtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0fSk7XG5cdH1cbn1cblxudmFyIG1vdW50ID0geyBzdWNjZXNzOiBzdWNjZXNzLCBmYWlsdXJlOiBmYWlsdXJlIH07XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcblx0cmV0dXJuIChcblx0XHR4ICE9PSBudWxsICYmXG5cdFx0eCBpbnN0YW5jZW9mIE9iamVjdCAmJlxuXHRcdCh4LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHxcblx0XHRcdE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpXG5cdClcbn1cblxuZnVuY3Rpb24gZWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuXHRpZiAoaXNPYmplY3QoY29sbGVjdGlvbikpIHtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuXHRcdHJldHVybiBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pOyB9KVxuXHR9XG5cdGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiBjYWxsYmFjayhpdGVtLCBpLCBjb2xsZWN0aW9uKTsgfSlcblx0fVxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBlaXRoZXIgYW4gYXJyYXkgb3Igb2JqZWN0IGxpdGVyYWwuJylcbn1cblxuZnVuY3Rpb24gbG9nZ2VyKG1lc3NhZ2UpIHtcblx0dmFyIGRldGFpbHMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdHdoaWxlICggbGVuLS0gPiAwICkgZGV0YWlsc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuXHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5kZWJ1ZyAmJiBjb25zb2xlKSB7XG5cdFx0dmFyIHJlcG9ydCA9IFwiJWNTY3JvbGxSZXZlYWw6IFwiICsgbWVzc2FnZTtcblx0XHRkZXRhaWxzLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbCkgeyByZXR1cm4gKHJlcG9ydCArPSBcIlxcbiDigJQgXCIgKyBkZXRhaWwpOyB9KTtcblx0XHRjb25zb2xlLmxvZyhyZXBvcnQsICdjb2xvcjogI2VhNjU0YjsnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdH1cbn1cblxuZnVuY3Rpb24gcmluc2UoKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHZhciBzdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuXHRcdGFjdGl2ZTogW10sXG5cdFx0c3RhbGU6IFtdXG5cdH0pOyB9O1xuXG5cdHZhciBlbGVtZW50SWRzID0gc3RydWN0KCk7XG5cdHZhciBzZXF1ZW5jZUlkcyA9IHN0cnVjdCgpO1xuXHR2YXIgY29udGFpbmVySWRzID0gc3RydWN0KCk7XG5cblx0LyoqXG5cdCAqIFRha2Ugc3RvY2sgb2YgYWN0aXZlIGVsZW1lbnQgSURzLlxuXHQgKi9cblx0dHJ5IHtcblx0XHRlYWNoKCQoJ1tkYXRhLXNyLWlkXScpLCBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGlkID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKSk7XG5cdFx0XHRlbGVtZW50SWRzLmFjdGl2ZS5wdXNoKGlkKTtcblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRocm93IGVcblx0fVxuXHQvKipcblx0ICogRGVzdHJveSBzdGFsZSBlbGVtZW50cy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudElkcy5hY3RpdmUuaW5kZXhPZihlbGVtZW50LmlkKSA9PT0gLTEpIHtcblx0XHRcdGVsZW1lbnRJZHMuc3RhbGUucHVzaChlbGVtZW50LmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goZWxlbWVudElkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHsgcmV0dXJuIGRlbGV0ZSB0aGlzJDEuc3RvcmUuZWxlbWVudHNbc3RhbGVJZF07IH0pO1xuXG5cdC8qKlxuXHQgKiBUYWtlIHN0b2NrIG9mIGFjdGl2ZSBjb250YWluZXIgYW5kIHNlcXVlbmNlIElEcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoY29udGFpbmVySWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuY29udGFpbmVySWQpID09PSAtMSkge1xuXHRcdFx0Y29udGFpbmVySWRzLmFjdGl2ZS5wdXNoKGVsZW1lbnQuY29udGFpbmVySWQpO1xuXHRcdH1cblx0XHRpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnc2VxdWVuY2UnKSkge1xuXHRcdFx0aWYgKHNlcXVlbmNlSWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuc2VxdWVuY2UuaWQpID09PSAtMSkge1xuXHRcdFx0XHRzZXF1ZW5jZUlkcy5hY3RpdmUucHVzaChlbGVtZW50LnNlcXVlbmNlLmlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIGNvbnRhaW5lcnMuXG5cdCAqL1xuXHRlYWNoKHRoaXMuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdGlmIChjb250YWluZXJJZHMuYWN0aXZlLmluZGV4T2YoY29udGFpbmVyLmlkKSA9PT0gLTEpIHtcblx0XHRcdGNvbnRhaW5lcklkcy5zdGFsZS5wdXNoKGNvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9KTtcblxuXHRlYWNoKGNvbnRhaW5lcklkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHtcblx0XHR2YXIgc3RhbGUgPSB0aGlzJDEuc3RvcmUuY29udGFpbmVyc1tzdGFsZUlkXS5ub2RlO1xuXHRcdHN0YWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0c3RhbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcyQxLmRlbGVnYXRlKTtcblx0XHRkZWxldGUgdGhpcyQxLnN0b3JlLmNvbnRhaW5lcnNbc3RhbGVJZF07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIHNlcXVlbmNlcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5zZXF1ZW5jZXMsIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuXHRcdGlmIChzZXF1ZW5jZUlkcy5hY3RpdmUuaW5kZXhPZihzZXF1ZW5jZS5pZCkgPT09IC0xKSB7XG5cdFx0XHRzZXF1ZW5jZUlkcy5zdGFsZS5wdXNoKHNlcXVlbmNlLmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goc2VxdWVuY2VJZHMuc3RhbGUsIGZ1bmN0aW9uIChzdGFsZUlkKSB7IHJldHVybiBkZWxldGUgdGhpcyQxLnN0b3JlLnNlcXVlbmNlc1tzdGFsZUlkXTsgfSk7XG59XG5cbnZhciBnZXRQcmVmaXhlZENzc1Byb3AgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgcHJvcGVydGllcyA9IHt9O1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cblx0ZnVuY3Rpb24gZ2V0UHJlZml4ZWRDc3NQcm9wZXJ0eShuYW1lLCBzb3VyY2UpIHtcblx0XHRpZiAoIHNvdXJjZSA9PT0gdm9pZCAwICkgc291cmNlID0gc3R5bGU7XG5cblx0XHRpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmIChwcm9wZXJ0aWVzW25hbWVdKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0aWVzW25hbWVdXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZVtuYW1lXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIChwcm9wZXJ0aWVzW25hbWVdID0gbmFtZSlcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Ygc291cmNlWyhcIi13ZWJraXQtXCIgKyBuYW1lKV0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiAocHJvcGVydGllc1tuYW1lXSA9IFwiLXdlYmtpdC1cIiArIG5hbWUpXG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigoXCJVbmFibGUgdG8gZmluZCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHN0eWxlIHByb3BlcnR5LlwiKSlcblx0XHR9XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcuJylcblx0fVxuXG5cdGdldFByZWZpeGVkQ3NzUHJvcGVydHkuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwcm9wZXJ0aWVzID0ge30pOyB9O1xuXG5cdHJldHVybiBnZXRQcmVmaXhlZENzc1Byb3BlcnR5XG59KSgpO1xuXG5mdW5jdGlvbiBzdHlsZShlbGVtZW50KSB7XG5cdHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQubm9kZSk7XG5cdHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkLnBvc2l0aW9uO1xuXHR2YXIgY29uZmlnID0gZWxlbWVudC5jb25maWc7XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGlubGluZSBzdHlsZXNcblx0ICovXG5cdHZhciBpbmxpbmUgPSB7fTtcblx0dmFyIGlubGluZVN0eWxlID0gZWxlbWVudC5ub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcblx0dmFyIGlubGluZU1hdGNoID0gaW5saW5lU3R5bGUubWF0Y2goL1tcXHctXStcXHMqOlxccypbXjtdK1xccyovZ2kpIHx8IFtdO1xuXG5cdGlubGluZS5jb21wdXRlZCA9IGlubGluZU1hdGNoID8gaW5saW5lTWF0Y2gubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRyaW0oKTsgfSkuam9pbignOyAnKSArICc7JyA6ICcnO1xuXG5cdGlubGluZS5nZW5lcmF0ZWQgPSBpbmxpbmVNYXRjaC5zb21lKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLm1hdGNoKC92aXNpYmlsaXR5XFxzPzpcXHM/dmlzaWJsZS9pKTsgfSlcblx0XHQ/IGlubGluZS5jb21wdXRlZFxuXHRcdDogaW5saW5lTWF0Y2guY29uY2F0KCBbJ3Zpc2liaWxpdHk6IHZpc2libGUnXSkubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnRyaW0oKTsgfSkuam9pbignOyAnKSArICc7JztcblxuXHQvKipcblx0ICogR2VuZXJhdGUgb3BhY2l0eSBzdHlsZXNcblx0ICovXG5cdHZhciBjb21wdXRlZE9wYWNpdHkgPSBwYXJzZUZsb2F0KGNvbXB1dGVkLm9wYWNpdHkpO1xuXHR2YXIgY29uZmlnT3BhY2l0eSA9ICFpc05hTihwYXJzZUZsb2F0KGNvbmZpZy5vcGFjaXR5KSlcblx0XHQ/IHBhcnNlRmxvYXQoY29uZmlnLm9wYWNpdHkpXG5cdFx0OiBwYXJzZUZsb2F0KGNvbXB1dGVkLm9wYWNpdHkpO1xuXG5cdHZhciBvcGFjaXR5ID0ge1xuXHRcdGNvbXB1dGVkOiBjb21wdXRlZE9wYWNpdHkgIT09IGNvbmZpZ09wYWNpdHkgPyAoXCJvcGFjaXR5OiBcIiArIGNvbXB1dGVkT3BhY2l0eSArIFwiO1wiKSA6ICcnLFxuXHRcdGdlbmVyYXRlZDogY29tcHV0ZWRPcGFjaXR5ICE9PSBjb25maWdPcGFjaXR5ID8gKFwib3BhY2l0eTogXCIgKyBjb25maWdPcGFjaXR5ICsgXCI7XCIpIDogJydcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgdHJhbnNmb3JtYXRpb24gc3R5bGVzXG5cdCAqL1xuXHR2YXIgdHJhbnNmb3JtYXRpb25zID0gW107XG5cblx0aWYgKHBhcnNlRmxvYXQoY29uZmlnLmRpc3RhbmNlKSkge1xuXHRcdHZhciBheGlzID0gY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgY29uZmlnLm9yaWdpbiA9PT0gJ2JvdHRvbScgPyAnWScgOiAnWCc7XG5cblx0XHQvKipcblx0XHQgKiBMZXTigJlzIG1ha2Ugc3VyZSBvdXIgb3VyIHBpeGVsIGRpc3RhbmNlcyBhcmUgbmVnYXRpdmUgZm9yIHRvcCBhbmQgbGVmdC5cblx0XHQgKiBlLmcuIHsgb3JpZ2luOiAndG9wJywgZGlzdGFuY2U6ICcyNXB4JyB9IHN0YXJ0cyBhdCBgdG9wOiAtMjVweGAgaW4gQ1NTLlxuXHRcdCAqL1xuXHRcdHZhciBkaXN0YW5jZSA9IGNvbmZpZy5kaXN0YW5jZTtcblx0XHRpZiAoY29uZmlnLm9yaWdpbiA9PT0gJ3RvcCcgfHwgY29uZmlnLm9yaWdpbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRkaXN0YW5jZSA9IC9eLS8udGVzdChkaXN0YW5jZSkgPyBkaXN0YW5jZS5zdWJzdHIoMSkgOiAoXCItXCIgKyBkaXN0YW5jZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlZiA9IGRpc3RhbmNlLm1hdGNoKC8oXi0/XFxkK1xcLj9cXGQ/KXwoZW0kfHB4JHwlJCkvZyk7XG5cdFx0dmFyIHZhbHVlID0gcmVmWzBdO1xuXHRcdHZhciB1bml0ID0gcmVmWzFdO1xuXG5cdFx0c3dpdGNoICh1bml0KSB7XG5cdFx0XHRjYXNlICdlbSc6XG5cdFx0XHRcdGRpc3RhbmNlID0gcGFyc2VJbnQoY29tcHV0ZWQuZm9udFNpemUpICogdmFsdWU7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdweCc6XG5cdFx0XHRcdGRpc3RhbmNlID0gdmFsdWU7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICclJzpcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEhlcmUgd2UgdXNlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIGluc3RlYWQgb2Zcblx0XHRcdFx0ICogdGhlIGV4aXN0aW5nIGRhdGEgYXR0YWNoZWQgdG8gYGVsZW1lbnQuZ2VvbWV0cnlgXG5cdFx0XHRcdCAqIGJlY2F1c2Ugb25seSB0aGUgZm9ybWVyIGluY2x1ZGVzIGFueSB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdFx0ICogY3VycmVudCBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiB0aGF0IGJlaGF2aW9yIGVuZHMgdXAgYmVpbmcgdW5pbnR1aXRpdmUsIHRoaXNcblx0XHRcdFx0ICogbG9naWMgY291bGQgaW5zdGVhZCB1dGlsaXplIGBlbGVtZW50Lmdlb21ldHJ5LmhlaWdodGBcblx0XHRcdFx0ICogYW5kIGBlbGVtZW50Lmdlb2VtZXRyeS53aWR0aGAgZm9yIHRoZSBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZGlzdGFuY2UgPVxuXHRcdFx0XHRcdGF4aXMgPT09ICdZJ1xuXHRcdFx0XHRcdFx0PyAoZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAqIHZhbHVlKSAvIDEwMFxuXHRcdFx0XHRcdFx0OiAoZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICogdmFsdWUpIC8gMTAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1VucmVjb2duaXplZCBvciBtaXNzaW5nIGRpc3RhbmNlIHVuaXQuJylcblx0XHR9XG5cblx0XHRpZiAoYXhpcyA9PT0gJ1knKSB7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaCh0cmFuc2xhdGVZKGRpc3RhbmNlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKHRyYW5zbGF0ZVgoZGlzdGFuY2UpKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29uZmlnLnJvdGF0ZS54KSB7IHRyYW5zZm9ybWF0aW9ucy5wdXNoKHJvdGF0ZVgoY29uZmlnLnJvdGF0ZS54KSk7IH1cblx0aWYgKGNvbmZpZy5yb3RhdGUueSkgeyB0cmFuc2Zvcm1hdGlvbnMucHVzaChyb3RhdGVZKGNvbmZpZy5yb3RhdGUueSkpOyB9XG5cdGlmIChjb25maWcucm90YXRlLnopIHsgdHJhbnNmb3JtYXRpb25zLnB1c2gocm90YXRlWihjb25maWcucm90YXRlLnopKTsgfVxuXHRpZiAoY29uZmlnLnNjYWxlICE9PSAxKSB7XG5cdFx0aWYgKGNvbmZpZy5zY2FsZSA9PT0gMCkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgQ1NTIFRyYW5zZm9ybXMgbWF0cml4IGludGVycG9sYXRpb24gc3BlY2lmaWNhdGlvblxuXHRcdFx0ICogYmFzaWNhbGx5IGRpc2FsbG93cyB0cmFuc2l0aW9ucyBvZiBub24taW52ZXJ0aWJsZVxuXHRcdFx0ICogbWF0cml4ZXMsIHdoaWNoIG1lYW5zIGJyb3dzZXJzIHdvbid0IHRyYW5zaXRpb25cblx0XHRcdCAqIGVsZW1lbnRzIHdpdGggemVybyBzY2FsZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGF04oCZcyBpbmNvbnZlbmllbnQgZm9yIHRoZSBBUEkgYW5kIGRldmVsb3BlclxuXHRcdFx0ICogZXhwZXJpZW5jZSwgc28gd2Ugc2ltcGx5IG51ZGdlIHRoZWlyIHZhbHVlXG5cdFx0XHQgKiBzbGlnaHRseSBhYm92ZSB6ZXJvOyB0aGlzIGFsbG93cyBicm93c2Vyc1xuXHRcdFx0ICogdG8gdHJhbnNpdGlvbiBvdXIgZWxlbWVudCBhcyBleHBlY3RlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBgMC4wMDAyYCB3YXMgdGhlIHNtYWxsZXN0IG51bWJlclxuXHRcdFx0ICogdGhhdCBwZXJmb3JtZWQgYWNyb3NzIGJyb3dzZXJzLlxuXHRcdFx0ICovXG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaChzY2FsZSgwLjAwMDIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2goc2NhbGUoY29uZmlnLnNjYWxlKSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHRyYW5zZm9ybSA9IHt9O1xuXHRpZiAodHJhbnNmb3JtYXRpb25zLmxlbmd0aCkge1xuXHRcdHRyYW5zZm9ybS5wcm9wZXJ0eSA9IGdldFByZWZpeGVkQ3NzUHJvcCgndHJhbnNmb3JtJyk7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgY29tcHV0ZWQgdHJhbnNmb3JtIHZhbHVlIHNob3VsZCBiZSBvbmUgb2Y6XG5cdFx0ICogdW5kZWZpbmVkIHx8ICdub25lJyB8fCAnbWF0cml4KCknIHx8ICdtYXRyaXgzZCgpJ1xuXHRcdCAqL1xuXHRcdHRyYW5zZm9ybS5jb21wdXRlZCA9IHtcblx0XHRcdHJhdzogY29tcHV0ZWRbdHJhbnNmb3JtLnByb3BlcnR5XSxcblx0XHRcdG1hdHJpeDogcGFyc2UoY29tcHV0ZWRbdHJhbnNmb3JtLnByb3BlcnR5XSlcblx0XHR9O1xuXG5cdFx0dHJhbnNmb3JtYXRpb25zLnVuc2hpZnQodHJhbnNmb3JtLmNvbXB1dGVkLm1hdHJpeCk7XG5cdFx0dmFyIHByb2R1Y3QgPSB0cmFuc2Zvcm1hdGlvbnMucmVkdWNlKG11bHRpcGx5KTtcblxuXHRcdHRyYW5zZm9ybS5nZW5lcmF0ZWQgPSB7XG5cdFx0XHRpbml0aWFsOiAoKHRyYW5zZm9ybS5wcm9wZXJ0eSkgKyBcIjogbWF0cml4M2QoXCIgKyAocHJvZHVjdC5qb2luKCcsICcpKSArIFwiKTtcIiksXG5cdFx0XHRmaW5hbDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCI6IG1hdHJpeDNkKFwiICsgKHRyYW5zZm9ybS5jb21wdXRlZC5tYXRyaXguam9pbignLCAnKSkgKyBcIik7XCIpXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0cmFuc2Zvcm0uZ2VuZXJhdGVkID0ge1xuXHRcdFx0aW5pdGlhbDogJycsXG5cdFx0XHRmaW5hbDogJydcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRyYW5zaXRpb24gc3R5bGVzXG5cdCAqL1xuXHR2YXIgdHJhbnNpdGlvbiA9IHt9O1xuXHRpZiAob3BhY2l0eS5nZW5lcmF0ZWQgfHwgdHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsKSB7XG5cdFx0dHJhbnNpdGlvbi5wcm9wZXJ0eSA9IGdldFByZWZpeGVkQ3NzUHJvcCgndHJhbnNpdGlvbicpO1xuXHRcdHRyYW5zaXRpb24uY29tcHV0ZWQgPSBjb21wdXRlZFt0cmFuc2l0aW9uLnByb3BlcnR5XTtcblx0XHR0cmFuc2l0aW9uLmZyYWdtZW50cyA9IFtdO1xuXG5cdFx0dmFyIGRlbGF5ID0gY29uZmlnLmRlbGF5O1xuXHRcdHZhciBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcblx0XHR2YXIgZWFzaW5nID0gY29uZmlnLmVhc2luZztcblxuXHRcdGlmIChvcGFjaXR5LmdlbmVyYXRlZCkge1xuXHRcdFx0dHJhbnNpdGlvbi5mcmFnbWVudHMucHVzaCh7XG5cdFx0XHRcdGRlbGF5ZWQ6IChcIm9wYWNpdHkgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIFwiICsgKGRlbGF5IC8gMTAwMCkgKyBcInNcIiksXG5cdFx0XHRcdGluc3RhbnQ6IChcIm9wYWNpdHkgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIDBzXCIpXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsKSB7XG5cdFx0XHR0cmFuc2l0aW9uLmZyYWdtZW50cy5wdXNoKHtcblx0XHRcdFx0ZGVsYXllZDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCIgXCIgKyAoZHVyYXRpb24gLyAxMDAwKSArIFwicyBcIiArIGVhc2luZyArIFwiIFwiICsgKGRlbGF5IC8gMTAwMCkgKyBcInNcIiksXG5cdFx0XHRcdGluc3RhbnQ6ICgodHJhbnNmb3JtLnByb3BlcnR5KSArIFwiIFwiICsgKGR1cmF0aW9uIC8gMTAwMCkgKyBcInMgXCIgKyBlYXNpbmcgKyBcIiAwc1wiKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgY29tcHV0ZWQgdHJhbnNpdGlvbiBwcm9wZXJ0eSBzaG91bGQgYmUgdW5kZWZpbmVkLCBvciBvbmUgb2Y6XG5cdFx0ICogJycgfHwgJ25vbmUgMHMgZWFzZSAwcycgfHwgJ2FsbCAwcyBlYXNlIDBzJyB8fCAnYWxsIDBzIDBzIGN1YmljLWJlemllcigpJ1xuXHRcdCAqL1xuXHRcdHZhciBoYXNDdXN0b21UcmFuc2l0aW9uID1cblx0XHRcdHRyYW5zaXRpb24uY29tcHV0ZWQgJiYgIXRyYW5zaXRpb24uY29tcHV0ZWQubWF0Y2goL2FsbCAwc3xub25lIDBzLyk7XG5cblx0XHRpZiAoaGFzQ3VzdG9tVHJhbnNpdGlvbikge1xuXHRcdFx0dHJhbnNpdGlvbi5mcmFnbWVudHMudW5zaGlmdCh7XG5cdFx0XHRcdGRlbGF5ZWQ6IHRyYW5zaXRpb24uY29tcHV0ZWQsXG5cdFx0XHRcdGluc3RhbnQ6IHRyYW5zaXRpb24uY29tcHV0ZWRcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBjb21wb3NlZCA9IHRyYW5zaXRpb24uZnJhZ21lbnRzLnJlZHVjZShcblx0XHRcdGZ1bmN0aW9uIChjb21wb3NpdGlvbiwgZnJhZ21lbnQsIGkpIHtcblx0XHRcdFx0Y29tcG9zaXRpb24uZGVsYXllZCArPSBpID09PSAwID8gZnJhZ21lbnQuZGVsYXllZCA6IChcIiwgXCIgKyAoZnJhZ21lbnQuZGVsYXllZCkpO1xuXHRcdFx0XHRjb21wb3NpdGlvbi5pbnN0YW50ICs9IGkgPT09IDAgPyBmcmFnbWVudC5pbnN0YW50IDogKFwiLCBcIiArIChmcmFnbWVudC5pbnN0YW50KSk7XG5cdFx0XHRcdHJldHVybiBjb21wb3NpdGlvblxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZGVsYXllZDogJycsXG5cdFx0XHRcdGluc3RhbnQ6ICcnXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHRyYW5zaXRpb24uZ2VuZXJhdGVkID0ge1xuXHRcdFx0ZGVsYXllZDogKCh0cmFuc2l0aW9uLnByb3BlcnR5KSArIFwiOiBcIiArIChjb21wb3NlZC5kZWxheWVkKSArIFwiO1wiKSxcblx0XHRcdGluc3RhbnQ6ICgodHJhbnNpdGlvbi5wcm9wZXJ0eSkgKyBcIjogXCIgKyAoY29tcG9zZWQuaW5zdGFudCkgKyBcIjtcIilcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRyYW5zaXRpb24uZ2VuZXJhdGVkID0ge1xuXHRcdFx0ZGVsYXllZDogJycsXG5cdFx0XHRpbnN0YW50OiAnJ1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGlubGluZTogaW5saW5lLFxuXHRcdG9wYWNpdHk6IG9wYWNpdHksXG5cdFx0cG9zaXRpb246IHBvc2l0aW9uLFxuXHRcdHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuXHRcdHRyYW5zaXRpb246IHRyYW5zaXRpb25cblx0fVxufVxuXG4vKipcbiAqIGFwcGx5IGEgQ1NTIHN0cmluZyB0byBhbiBlbGVtZW50IHVzaW5nIHRoZSBDU1NPTSAoZWxlbWVudC5zdHlsZSkgcmF0aGVyXG4gKiB0aGFuIHNldEF0dHJpYnV0ZSwgd2hpY2ggbWF5IHZpb2xhdGUgdGhlIGNvbnRlbnQgc2VjdXJpdHkgcG9saWN5LlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gICBbZWxdICBFbGVtZW50IHRvIHJlY2VpdmUgc3R5bGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtkZWNsYXJhdGlvbl0gU3R5bGVzIHRvIGFwcGx5LlxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlIChlbCwgZGVjbGFyYXRpb24pIHtcblx0ZGVjbGFyYXRpb24uc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG5cdFx0dmFyIHJlZiA9IHBhaXIuc3BsaXQoJzonKTtcblx0XHR2YXIgcHJvcGVydHkgPSByZWZbMF07XG5cdFx0dmFyIHZhbHVlID0gcmVmLnNsaWNlKDEpO1xuXHRcdGlmIChwcm9wZXJ0eSAmJiB2YWx1ZSkge1xuXHRcdFx0ZWwuc3R5bGVbcHJvcGVydHkudHJpbSgpXSA9IHZhbHVlLmpvaW4oJzonKTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhbih0YXJnZXQpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dmFyIGRpcnR5O1xuXHR0cnkge1xuXHRcdGVhY2goJCh0YXJnZXQpLCBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKTtcblx0XHRcdGlmIChpZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRkaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdGhpcyQxLnN0b3JlLmVsZW1lbnRzW2lkXTtcblx0XHRcdFx0aWYgKGVsZW1lbnQuY2FsbGJhY2tUaW1lcikge1xuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoZWxlbWVudC5jYWxsYmFja1RpbWVyLmNsb2NrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhcHBseVN0eWxlKGVsZW1lbnQubm9kZSwgZWxlbWVudC5zdHlsZXMuaW5saW5lLmdlbmVyYXRlZCk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyLWlkJyk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzJDEuc3RvcmUuZWxlbWVudHNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGxvZ2dlci5jYWxsKHRoaXMsICdDbGVhbiBmYWlsZWQuJywgZS5tZXNzYWdlKVxuXHR9XG5cblx0aWYgKGRpcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJpbnNlLmNhbGwodGhpcyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGxvZ2dlci5jYWxsKHRoaXMsICdDbGVhbiBmYWlsZWQuJywgZS5tZXNzYWdlKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBnZW5lcmF0ZWQgc3R5bGVzIGFuZCBlbGVtZW50IGlkc1xuXHQgKi9cblx0ZWFjaCh0aGlzLnN0b3JlLmVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdGFwcGx5U3R5bGUoZWxlbWVudC5ub2RlLCBlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkKTtcblx0XHRlbGVtZW50Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyLWlkJyk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5jb250YWluZXJzLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0dmFyIHRhcmdldCA9XG5cdFx0XHRjb250YWluZXIubm9kZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogY29udGFpbmVyLm5vZGU7XG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgZGF0YSBmcm9tIHRoZSBzdG9yZVxuXHQgKi9cblx0dGhpcy5zdG9yZSA9IHtcblx0XHRjb250YWluZXJzOiB7fSxcblx0XHRlbGVtZW50czoge30sXG5cdFx0aGlzdG9yeTogW10sXG5cdFx0c2VxdWVuY2VzOiB7fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCkge1xuXHR2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0d2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdGlmIChpc09iamVjdCh0YXJnZXQpKSB7XG5cdFx0ZWFjaChzb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuXHRcdFx0XHRpZiAoaXNPYmplY3QoZGF0YSkpIHtcblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldIHx8ICFpc09iamVjdCh0YXJnZXRba2V5XSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZXBBc3NpZ24odGFyZ2V0W2tleV0sIGRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRhcmdldFxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCBsaXRlcmFsLicpXG5cdH1cbn1cblxuZnVuY3Rpb24gaXNNb2JpbGUoYWdlbnQpIHtcblx0aWYgKCBhZ2VudCA9PT0gdm9pZCAwICkgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5cdHJldHVybiAvQW5kcm9pZHxpUGhvbmV8aVBhZHxpUG9kL2kudGVzdChhZ2VudClcbn1cblxudmFyIG5leHRVbmlxdWVJZCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB1aWQgPSAwO1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdWlkKys7IH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHJpbnNlLmNhbGwodGhpcyk7XG5cblx0ZWFjaCh0aGlzLnN0b3JlLmVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdHZhciBzdHlsZXMgPSBbZWxlbWVudC5zdHlsZXMuaW5saW5lLmdlbmVyYXRlZF07XG5cblx0XHRpZiAoZWxlbWVudC52aXNpYmxlKSB7XG5cdFx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy5vcGFjaXR5LmNvbXB1dGVkKTtcblx0XHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLnRyYW5zZm9ybS5nZW5lcmF0ZWQuZmluYWwpO1xuXHRcdFx0ZWxlbWVudC5yZXZlYWxlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkuZ2VuZXJhdGVkKTtcblx0XHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLnRyYW5zZm9ybS5nZW5lcmF0ZWQuaW5pdGlhbCk7XG5cdFx0XHRlbGVtZW50LnJldmVhbGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0YXBwbHlTdHlsZShlbGVtZW50Lm5vZGUsIHN0eWxlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KS5qb2luKCcgJykpO1xuXHR9KTtcblxuXHRlYWNoKHRoaXMuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHZhciB0YXJnZXQgPVxuXHRcdFx0Y29udGFpbmVyLm5vZGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/IHdpbmRvdyA6IGNvbnRhaW5lci5ub2RlO1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzJDEuZGVsZWdhdGUpO1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzJDEuZGVsZWdhdGUpO1xuXHR9KTtcblxuXHQvKipcblx0ICogTWFudWFsbHkgaW52b2tlIGRlbGVnYXRlIG9uY2UgdG8gY2FwdHVyZVxuXHQgKiBlbGVtZW50IGFuZCBjb250YWluZXIgZGltZW5zaW9ucywgY29udGFpbmVyXG5cdCAqIHNjcm9sbCBwb3NpdGlvbiwgYW5kIHRyaWdnZXIgYW55IHZhbGlkIHJldmVhbHNcblx0ICovXG5cdHRoaXMuZGVsZWdhdGUoKTtcblxuXHQvKipcblx0ICogV2lwZSBhbnkgZXhpc3RpbmcgYHNldFRpbWVvdXRgIG5vd1xuXHQgKiB0aGF0IGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWQuXG5cdCAqL1xuXHR0aGlzLmluaXRUaW1lb3V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBmb3JjZSkge1xuXHRpZiAoIGZvcmNlID09PSB2b2lkIDAgKSBmb3JjZSA9IHt9O1xuXG5cdHZhciBwcmlzdGluZSA9IGZvcmNlLnByaXN0aW5lIHx8IHRoaXMucHJpc3RpbmU7XG5cdHZhciBkZWxheWVkID1cblx0XHRlbGVtZW50LmNvbmZpZy51c2VEZWxheSA9PT0gJ2Fsd2F5cycgfHxcblx0XHQoZWxlbWVudC5jb25maWcudXNlRGVsYXkgPT09ICdvbmxvYWQnICYmIHByaXN0aW5lKSB8fFxuXHRcdChlbGVtZW50LmNvbmZpZy51c2VEZWxheSA9PT0gJ29uY2UnICYmICFlbGVtZW50LnNlZW4pO1xuXG5cdHZhciBzaG91bGRSZXZlYWwgPSBlbGVtZW50LnZpc2libGUgJiYgIWVsZW1lbnQucmV2ZWFsZWQ7XG5cdHZhciBzaG91bGRSZXNldCA9ICFlbGVtZW50LnZpc2libGUgJiYgZWxlbWVudC5yZXZlYWxlZCAmJiBlbGVtZW50LmNvbmZpZy5yZXNldDtcblxuXHRpZiAoZm9yY2UucmV2ZWFsIHx8IHNob3VsZFJldmVhbCkge1xuXHRcdHJldHVybiB0cmlnZ2VyUmV2ZWFsLmNhbGwodGhpcywgZWxlbWVudCwgZGVsYXllZClcblx0fVxuXG5cdGlmIChmb3JjZS5yZXNldCB8fCBzaG91bGRSZXNldCkge1xuXHRcdHJldHVybiB0cmlnZ2VyUmVzZXQuY2FsbCh0aGlzLCBlbGVtZW50KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJSZXZlYWwoZWxlbWVudCwgZGVsYXllZCkge1xuXHR2YXIgc3R5bGVzID0gW1xuXHRcdGVsZW1lbnQuc3R5bGVzLmlubGluZS5nZW5lcmF0ZWQsXG5cdFx0ZWxlbWVudC5zdHlsZXMub3BhY2l0eS5jb21wdXRlZCxcblx0XHRlbGVtZW50LnN0eWxlcy50cmFuc2Zvcm0uZ2VuZXJhdGVkLmZpbmFsXG5cdF07XG5cdGlmIChkZWxheWVkKSB7XG5cdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMudHJhbnNpdGlvbi5nZW5lcmF0ZWQuZGVsYXllZCk7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMudHJhbnNpdGlvbi5nZW5lcmF0ZWQuaW5zdGFudCk7XG5cdH1cblx0ZWxlbWVudC5yZXZlYWxlZCA9IGVsZW1lbnQuc2VlbiA9IHRydWU7XG5cdGFwcGx5U3R5bGUoZWxlbWVudC5ub2RlLCBzdHlsZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzICE9PSAnJzsgfSkuam9pbignICcpKTtcblx0cmVnaXN0ZXJDYWxsYmFja3MuY2FsbCh0aGlzLCBlbGVtZW50LCBkZWxheWVkKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlclJlc2V0KGVsZW1lbnQpIHtcblx0dmFyIHN0eWxlcyA9IFtcblx0XHRlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkuZ2VuZXJhdGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLnRyYW5zZm9ybS5nZW5lcmF0ZWQuaW5pdGlhbCxcblx0XHRlbGVtZW50LnN0eWxlcy50cmFuc2l0aW9uLmdlbmVyYXRlZC5pbnN0YW50XG5cdF07XG5cdGVsZW1lbnQucmV2ZWFsZWQgPSBmYWxzZTtcblx0YXBwbHlTdHlsZShlbGVtZW50Lm5vZGUsIHN0eWxlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KS5qb2luKCcgJykpO1xuXHRyZWdpc3RlckNhbGxiYWNrcy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckNhbGxiYWNrcyhlbGVtZW50LCBpc0RlbGF5ZWQpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dmFyIGR1cmF0aW9uID0gaXNEZWxheWVkXG5cdFx0PyBlbGVtZW50LmNvbmZpZy5kdXJhdGlvbiArIGVsZW1lbnQuY29uZmlnLmRlbGF5XG5cdFx0OiBlbGVtZW50LmNvbmZpZy5kdXJhdGlvbjtcblxuXHR2YXIgYmVmb3JlQ2FsbGJhY2sgPSBlbGVtZW50LnJldmVhbGVkXG5cdFx0PyBlbGVtZW50LmNvbmZpZy5iZWZvcmVSZXZlYWxcblx0XHQ6IGVsZW1lbnQuY29uZmlnLmJlZm9yZVJlc2V0O1xuXG5cdHZhciBhZnRlckNhbGxiYWNrID0gZWxlbWVudC5yZXZlYWxlZFxuXHRcdD8gZWxlbWVudC5jb25maWcuYWZ0ZXJSZXZlYWxcblx0XHQ6IGVsZW1lbnQuY29uZmlnLmFmdGVyUmVzZXQ7XG5cblx0dmFyIGVsYXBzZWQgPSAwO1xuXHRpZiAoZWxlbWVudC5jYWxsYmFja1RpbWVyKSB7XG5cdFx0ZWxhcHNlZCA9IERhdGUubm93KCkgLSBlbGVtZW50LmNhbGxiYWNrVGltZXIuc3RhcnQ7XG5cdFx0d2luZG93LmNsZWFyVGltZW91dChlbGVtZW50LmNhbGxiYWNrVGltZXIuY2xvY2spO1xuXHR9XG5cblx0YmVmb3JlQ2FsbGJhY2soZWxlbWVudC5ub2RlKTtcblxuXHRlbGVtZW50LmNhbGxiYWNrVGltZXIgPSB7XG5cdFx0c3RhcnQ6IERhdGUubm93KCksXG5cdFx0Y2xvY2s6IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdGFmdGVyQ2FsbGJhY2soZWxlbWVudC5ub2RlKTtcblx0XHRcdGVsZW1lbnQuY2FsbGJhY2tUaW1lciA9IG51bGw7XG5cdFx0XHRpZiAoZWxlbWVudC5yZXZlYWxlZCAmJiAhZWxlbWVudC5jb25maWcucmVzZXQgJiYgZWxlbWVudC5jb25maWcuY2xlYW51cCkge1xuXHRcdFx0XHRjbGVhbi5jYWxsKHRoaXMkMSwgZWxlbWVudC5ub2RlKTtcblx0XHRcdH1cblx0XHR9LCBkdXJhdGlvbiAtIGVsYXBzZWQpXG5cdH07XG59XG5cbmZ1bmN0aW9uIHNlcXVlbmNlKGVsZW1lbnQsIHByaXN0aW5lKSB7XG5cdGlmICggcHJpc3RpbmUgPT09IHZvaWQgMCApIHByaXN0aW5lID0gdGhpcy5wcmlzdGluZTtcblxuXHQvKipcblx0ICogV2UgZmlyc3QgY2hlY2sgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIHJlc2V0LlxuXHQgKi9cblx0aWYgKCFlbGVtZW50LnZpc2libGUgJiYgZWxlbWVudC5yZXZlYWxlZCAmJiBlbGVtZW50LmNvbmZpZy5yZXNldCkge1xuXHRcdHJldHVybiBhbmltYXRlLmNhbGwodGhpcywgZWxlbWVudCwgeyByZXNldDogdHJ1ZSB9KVxuXHR9XG5cblx0dmFyIHNlcSA9IHRoaXMuc3RvcmUuc2VxdWVuY2VzW2VsZW1lbnQuc2VxdWVuY2UuaWRdO1xuXHR2YXIgaSA9IGVsZW1lbnQuc2VxdWVuY2UuaW5kZXg7XG5cblx0aWYgKHNlcSkge1xuXHRcdHZhciB2aXNpYmxlID0gbmV3IFNlcXVlbmNlTW9kZWwoc2VxLCAndmlzaWJsZScsIHRoaXMuc3RvcmUpO1xuXHRcdHZhciByZXZlYWxlZCA9IG5ldyBTZXF1ZW5jZU1vZGVsKHNlcSwgJ3JldmVhbGVkJywgdGhpcy5zdG9yZSk7XG5cblx0XHRzZXEubW9kZWxzID0geyB2aXNpYmxlOiB2aXNpYmxlLCByZXZlYWxlZDogcmV2ZWFsZWQgfTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRoZSBzZXF1ZW5jZSBoYXMgbm8gcmV2ZWFsZWQgbWVtYmVycyxcblx0XHQgKiB0aGVuIHdlIHJldmVhbCB0aGUgZmlyc3QgdmlzaWJsZSBlbGVtZW50XG5cdFx0ICogd2l0aGluIHRoYXQgc2VxdWVuY2UuXG5cdFx0ICpcblx0XHQgKiBUaGUgc2VxdWVuY2UgdGhlbiBjdWVzIGEgcmVjdXJzaXZlIGNhbGxcblx0XHQgKiBpbiBib3RoIGRpcmVjdGlvbnMuXG5cdFx0ICovXG5cdFx0aWYgKCFyZXZlYWxlZC5ib2R5Lmxlbmd0aCkge1xuXHRcdFx0dmFyIG5leHRJZCA9IHNlcS5tZW1iZXJzW3Zpc2libGUuYm9keVswXV07XG5cdFx0XHR2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLnN0b3JlLmVsZW1lbnRzW25leHRJZF07XG5cblx0XHRcdGlmIChuZXh0RWxlbWVudCkge1xuXHRcdFx0XHRjdWUuY2FsbCh0aGlzLCBzZXEsIHZpc2libGUuYm9keVswXSwgLTEsIHByaXN0aW5lKTtcblx0XHRcdFx0Y3VlLmNhbGwodGhpcywgc2VxLCB2aXNpYmxlLmJvZHlbMF0sICsxLCBwcmlzdGluZSk7XG5cdFx0XHRcdHJldHVybiBhbmltYXRlLmNhbGwodGhpcywgbmV4dEVsZW1lbnQsIHsgcmV2ZWFsOiB0cnVlLCBwcmlzdGluZTogcHJpc3RpbmUgfSlcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJZiBvdXIgZWxlbWVudCBpc27igJl0IHJlc2V0dGluZywgd2UgY2hlY2sgdGhlXG5cdFx0ICogZWxlbWVudCBzZXF1ZW5jZSBpbmRleCBhZ2FpbnN0IHRoZSBoZWFkLCBhbmRcblx0XHQgKiB0aGVuIHRoZSBmb290IG9mIHRoZSBzZXF1ZW5jZS5cblx0XHQgKi9cblx0XHRpZiAoXG5cdFx0XHQhc2VxLmJsb2NrZWQuaGVhZCAmJlxuXHRcdFx0aSA9PT0gW10uY29uY2F0KCByZXZlYWxlZC5oZWFkICkucG9wKCkgJiZcblx0XHRcdGkgPj0gW10uY29uY2F0KCB2aXNpYmxlLmJvZHkgKS5zaGlmdCgpXG5cdFx0KSB7XG5cdFx0XHRjdWUuY2FsbCh0aGlzLCBzZXEsIGksIC0xLCBwcmlzdGluZSk7XG5cdFx0XHRyZXR1cm4gYW5pbWF0ZS5jYWxsKHRoaXMsIGVsZW1lbnQsIHsgcmV2ZWFsOiB0cnVlLCBwcmlzdGluZTogcHJpc3RpbmUgfSlcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHQhc2VxLmJsb2NrZWQuZm9vdCAmJlxuXHRcdFx0aSA9PT0gW10uY29uY2F0KCByZXZlYWxlZC5mb290ICkuc2hpZnQoKSAmJlxuXHRcdFx0aSA8PSBbXS5jb25jYXQoIHZpc2libGUuYm9keSApLnBvcCgpXG5cdFx0KSB7XG5cdFx0XHRjdWUuY2FsbCh0aGlzLCBzZXEsIGksICsxLCBwcmlzdGluZSk7XG5cdFx0XHRyZXR1cm4gYW5pbWF0ZS5jYWxsKHRoaXMsIGVsZW1lbnQsIHsgcmV2ZWFsOiB0cnVlLCBwcmlzdGluZTogcHJpc3RpbmUgfSlcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gU2VxdWVuY2UoaW50ZXJ2YWwpIHtcblx0dmFyIGkgPSBNYXRoLmFicyhpbnRlcnZhbCk7XG5cdGlmICghaXNOYU4oaSkpIHtcblx0XHR0aGlzLmlkID0gbmV4dFVuaXF1ZUlkKCk7XG5cdFx0dGhpcy5pbnRlcnZhbCA9IE1hdGgubWF4KGksIDE2KTtcblx0XHR0aGlzLm1lbWJlcnMgPSBbXTtcblx0XHR0aGlzLm1vZGVscyA9IHt9O1xuXHRcdHRoaXMuYmxvY2tlZCA9IHtcblx0XHRcdGhlYWQ6IGZhbHNlLFxuXHRcdFx0Zm9vdDogZmFsc2Vcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHNlcXVlbmNlIGludGVydmFsLicpXG5cdH1cbn1cblxuZnVuY3Rpb24gU2VxdWVuY2VNb2RlbChzZXEsIHByb3AsIHN0b3JlKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHRoaXMuaGVhZCA9IFtdO1xuXHR0aGlzLmJvZHkgPSBbXTtcblx0dGhpcy5mb290ID0gW107XG5cblx0ZWFjaChzZXEubWVtYmVycywgZnVuY3Rpb24gKGlkLCBpbmRleCkge1xuXHRcdHZhciBlbGVtZW50ID0gc3RvcmUuZWxlbWVudHNbaWRdO1xuXHRcdGlmIChlbGVtZW50ICYmIGVsZW1lbnRbcHJvcF0pIHtcblx0XHRcdHRoaXMkMS5ib2R5LnB1c2goaW5kZXgpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKHRoaXMuYm9keS5sZW5ndGgpIHtcblx0XHRlYWNoKHNlcS5tZW1iZXJzLCBmdW5jdGlvbiAoaWQsIGluZGV4KSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHN0b3JlLmVsZW1lbnRzW2lkXTtcblx0XHRcdGlmIChlbGVtZW50ICYmICFlbGVtZW50W3Byb3BdKSB7XG5cdFx0XHRcdGlmIChpbmRleCA8IHRoaXMkMS5ib2R5WzBdKSB7XG5cdFx0XHRcdFx0dGhpcyQxLmhlYWQucHVzaChpbmRleCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcyQxLmZvb3QucHVzaChpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG5mdW5jdGlvbiBjdWUoc2VxLCBpLCBkaXJlY3Rpb24sIHByaXN0aW5lKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHZhciBibG9ja2VkID0gWydoZWFkJywgbnVsbCwgJ2Zvb3QnXVsxICsgZGlyZWN0aW9uXTtcblx0dmFyIG5leHRJZCA9IHNlcS5tZW1iZXJzW2kgKyBkaXJlY3Rpb25dO1xuXHR2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLnN0b3JlLmVsZW1lbnRzW25leHRJZF07XG5cblx0c2VxLmJsb2NrZWRbYmxvY2tlZF0gPSB0cnVlO1xuXG5cdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdHNlcS5ibG9ja2VkW2Jsb2NrZWRdID0gZmFsc2U7XG5cdFx0aWYgKG5leHRFbGVtZW50KSB7XG5cdFx0XHRzZXF1ZW5jZS5jYWxsKHRoaXMkMSwgbmV4dEVsZW1lbnQsIHByaXN0aW5lKTtcblx0XHR9XG5cdH0sIHNlcS5pbnRlcnZhbCk7XG59XG5cbmZ1bmN0aW9uIHJldmVhbCh0YXJnZXQsIG9wdGlvbnMsIHN5bmNpbmcpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXHRpZiAoIHN5bmNpbmcgPT09IHZvaWQgMCApIHN5bmNpbmcgPSBmYWxzZTtcblxuXHR2YXIgY29udGFpbmVyQnVmZmVyID0gW107XG5cdHZhciBzZXF1ZW5jZSQkMTtcblx0dmFyIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCBkZWZhdWx0cy5pbnRlcnZhbDtcblxuXHR0cnkge1xuXHRcdGlmIChpbnRlcnZhbCkge1xuXHRcdFx0c2VxdWVuY2UkJDEgPSBuZXcgU2VxdWVuY2UoaW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdHZhciBub2RlcyA9ICQodGFyZ2V0KTtcblx0XHRpZiAoIW5vZGVzLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldmVhbCB0YXJnZXQuJylcblx0XHR9XG5cblx0XHR2YXIgZWxlbWVudHMgPSBub2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKGVsZW1lbnRCdWZmZXIsIGVsZW1lbnROb2RlKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHt9O1xuXHRcdFx0dmFyIGV4aXN0aW5nSWQgPSBlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKTtcblxuXHRcdFx0aWYgKGV4aXN0aW5nSWQpIHtcblx0XHRcdFx0ZGVlcEFzc2lnbihlbGVtZW50LCB0aGlzJDEuc3RvcmUuZWxlbWVudHNbZXhpc3RpbmdJZF0pO1xuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBJbiBvcmRlciB0byBwcmV2ZW50IHByZXZpb3VzbHkgZ2VuZXJhdGVkIHN0eWxlc1xuXHRcdFx0XHQgKiBmcm9tIHRocm93aW5nIG9mZiB0aGUgbmV3IHN0eWxlcywgdGhlIHN0eWxlIHRhZ1xuXHRcdFx0XHQgKiBoYXMgdG8gYmUgcmV2ZXJ0ZWQgdG8gaXRzIHByZS1yZXZlYWwgc3RhdGUuXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRhcHBseVN0eWxlKGVsZW1lbnQubm9kZSwgZWxlbWVudC5zdHlsZXMuaW5saW5lLmNvbXB1dGVkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuaWQgPSBuZXh0VW5pcXVlSWQoKTtcblx0XHRcdFx0ZWxlbWVudC5ub2RlID0gZWxlbWVudE5vZGU7XG5cdFx0XHRcdGVsZW1lbnQuc2VlbiA9IGZhbHNlO1xuXHRcdFx0XHRlbGVtZW50LnJldmVhbGVkID0gZmFsc2U7XG5cdFx0XHRcdGVsZW1lbnQudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29uZmlnID0gZGVlcEFzc2lnbih7fSwgZWxlbWVudC5jb25maWcgfHwgdGhpcyQxLmRlZmF1bHRzLCBvcHRpb25zKTtcblxuXHRcdFx0aWYgKCghY29uZmlnLm1vYmlsZSAmJiBpc01vYmlsZSgpKSB8fCAoIWNvbmZpZy5kZXNrdG9wICYmICFpc01vYmlsZSgpKSkge1xuXHRcdFx0XHRpZiAoZXhpc3RpbmdJZCkge1xuXHRcdFx0XHRcdGNsZWFuLmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZWxlbWVudEJ1ZmZlciAvLyBza2lwIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FibGVkXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250YWluZXJOb2RlID0gJChjb25maWcuY29udGFpbmVyKVswXTtcblx0XHRcdGlmICghY29udGFpbmVyTm9kZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udGFpbmVyLicpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbnRhaW5lck5vZGUuY29udGFpbnMoZWxlbWVudE5vZGUpKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyIC8vIHNraXAgZWxlbWVudHMgZm91bmQgb3V0c2lkZSB0aGUgY29udGFpbmVyXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250YWluZXJJZDtcblx0XHRcdHtcblx0XHRcdFx0Y29udGFpbmVySWQgPSBnZXRDb250YWluZXJJZChcblx0XHRcdFx0XHRjb250YWluZXJOb2RlLFxuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlcixcblx0XHRcdFx0XHR0aGlzJDEuc3RvcmUuY29udGFpbmVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoY29udGFpbmVySWQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb250YWluZXJJZCA9IG5leHRVbmlxdWVJZCgpO1xuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlci5wdXNoKHsgaWQ6IGNvbnRhaW5lcklkLCBub2RlOiBjb250YWluZXJOb2RlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuY29uZmlnID0gY29uZmlnO1xuXHRcdFx0ZWxlbWVudC5jb250YWluZXJJZCA9IGNvbnRhaW5lcklkO1xuXHRcdFx0ZWxlbWVudC5zdHlsZXMgPSBzdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2VxdWVuY2UgPSB7XG5cdFx0XHRcdFx0aWQ6IHNlcXVlbmNlJCQxLmlkLFxuXHRcdFx0XHRcdGluZGV4OiBzZXF1ZW5jZSQkMS5tZW1iZXJzLmxlbmd0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzZXF1ZW5jZSQkMS5tZW1iZXJzLnB1c2goZWxlbWVudC5pZCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRCdWZmZXIucHVzaChlbGVtZW50KTtcblx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyXG5cdFx0fSwgW10pO1xuXG5cdFx0LyoqXG5cdFx0ICogTW9kaWZ5aW5nIHRoZSBET00gdmlhIHNldEF0dHJpYnV0ZSBuZWVkcyB0byBiZSBoYW5kbGVkXG5cdFx0ICogc2VwYXJhdGVseSBmcm9tIHJlYWRpbmcgY29tcHV0ZWQgc3R5bGVzIGluIHRoZSBtYXAgYWJvdmVcblx0XHQgKiBmb3IgdGhlIGJyb3dzZXIgdG8gYmF0Y2ggRE9NIGNoYW5nZXMgKGxpbWl0aW5nIHJlZmxvd3MpXG5cdFx0ICovXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHRoaXMkMS5zdG9yZS5lbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXNyLWlkJywgZWxlbWVudC5pZCk7XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gbG9nZ2VyLmNhbGwodGhpcywgJ1JldmVhbCBmYWlsZWQuJywgZS5tZXNzYWdlKVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vdyB0aGF0IGVsZW1lbnQgc2V0LXVwIGlzIGNvbXBsZXRlLi4uXG5cdCAqIExldOKAmXMgY29tbWl0IGFueSBjb250YWluZXIgYW5kIHNlcXVlbmNlIGRhdGEgd2UgaGF2ZSB0byB0aGUgc3RvcmUuXG5cdCAqL1xuXHRlYWNoKGNvbnRhaW5lckJ1ZmZlciwgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHRoaXMkMS5zdG9yZS5jb250YWluZXJzW2NvbnRhaW5lci5pZF0gPSB7XG5cdFx0XHRpZDogY29udGFpbmVyLmlkLFxuXHRcdFx0bm9kZTogY29udGFpbmVyLm5vZGVcblx0XHR9O1xuXHR9KTtcblx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0dGhpcy5zdG9yZS5zZXF1ZW5jZXNbc2VxdWVuY2UkJDEuaWRdID0gc2VxdWVuY2UkJDE7XG5cdH1cblxuXHQvKipcblx0ICogSWYgcmV2ZWFsIHdhc24ndCBpbnZva2VkIGJ5IHN5bmMsIHdlIHdhbnQgdG9cblx0ICogbWFrZSBzdXJlIHRvIGFkZCB0aGlzIGNhbGwgdG8gdGhlIGhpc3RvcnkuXG5cdCAqL1xuXHRpZiAoc3luY2luZyAhPT0gdHJ1ZSkge1xuXHRcdHRoaXMuc3RvcmUuaGlzdG9yeS5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cblx0XHQvKipcblx0XHQgKiBQdXNoIGluaXRpYWxpemF0aW9uIHRvIHRoZSBldmVudCBxdWV1ZSwgZ2l2aW5nXG5cdFx0ICogbXVsdGlwbGUgcmV2ZWFsIGNhbGxzIHRpbWUgdG8gYmUgaW50ZXJwcmV0ZWQuXG5cdFx0ICovXG5cdFx0aWYgKHRoaXMuaW5pdFRpbWVvdXQpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5pbml0VGltZW91dCk7XG5cdFx0fVxuXHRcdHRoaXMuaW5pdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChpbml0aWFsaXplLmJpbmQodGhpcyksIDApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcklkKG5vZGUpIHtcblx0dmFyIGNvbGxlY3Rpb25zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHR3aGlsZSAoIGxlbi0tID4gMCApIGNvbGxlY3Rpb25zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdHZhciBpZCA9IG51bGw7XG5cdGVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG5cdFx0ZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0XHRpZiAoaWQgPT09IG51bGwgJiYgY29udGFpbmVyLm5vZGUgPT09IG5vZGUpIHtcblx0XHRcdFx0aWQgPSBjb250YWluZXIuaWQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBSZS1ydW5zIHRoZSByZXZlYWwgbWV0aG9kIGZvciBlYWNoIHJlY29yZCBzdG9yZWQgaW4gaGlzdG9yeSxcbiAqIGZvciBjYXB0dXJpbmcgbmV3IGNvbnRlbnQgYXN5bmNocm9ub3VzbHkgbG9hZGVkIGludG8gdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gc3luYygpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ZWFjaCh0aGlzLnN0b3JlLmhpc3RvcnksIGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRyZXZlYWwuY2FsbCh0aGlzJDEsIHJlY29yZC50YXJnZXQsIHJlY29yZC5vcHRpb25zLCB0cnVlKTtcblx0fSk7XG5cblx0aW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xufVxuXG52YXIgcG9seWZpbGwgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7IH07XG52YXIgbWF0aFNpZ24gPSBNYXRoLnNpZ24gfHwgcG9seWZpbGw7XG5cbmZ1bmN0aW9uIGdldEdlb21ldHJ5KHRhcmdldCwgaXNDb250YWluZXIpIHtcblx0LyoqXG5cdCAqIFdlIHdhbnQgdG8gaWdub3JlIHBhZGRpbmcgYW5kIHNjcm9sbGJhcnMgZm9yIGNvbnRhaW5lciBlbGVtZW50cy5cblx0ICogTW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL2dvby5nbC92T1pwYnpcblx0ICovXG5cdHZhciBoZWlnaHQgPSBpc0NvbnRhaW5lciA/IHRhcmdldC5ub2RlLmNsaWVudEhlaWdodCA6IHRhcmdldC5ub2RlLm9mZnNldEhlaWdodDtcblx0dmFyIHdpZHRoID0gaXNDb250YWluZXIgPyB0YXJnZXQubm9kZS5jbGllbnRXaWR0aCA6IHRhcmdldC5ub2RlLm9mZnNldFdpZHRoO1xuXG5cdHZhciBvZmZzZXRUb3AgPSAwO1xuXHR2YXIgb2Zmc2V0TGVmdCA9IDA7XG5cdHZhciBub2RlID0gdGFyZ2V0Lm5vZGU7XG5cblx0ZG8ge1xuXHRcdGlmICghaXNOYU4obm9kZS5vZmZzZXRUb3ApKSB7XG5cdFx0XHRvZmZzZXRUb3AgKz0gbm9kZS5vZmZzZXRUb3A7XG5cdFx0fVxuXHRcdGlmICghaXNOYU4obm9kZS5vZmZzZXRMZWZ0KSkge1xuXHRcdFx0b2Zmc2V0TGVmdCArPSBub2RlLm9mZnNldExlZnQ7XG5cdFx0fVxuXHRcdG5vZGUgPSBub2RlLm9mZnNldFBhcmVudDtcblx0fSB3aGlsZSAobm9kZSlcblxuXHRyZXR1cm4ge1xuXHRcdGJvdW5kczoge1xuXHRcdFx0dG9wOiBvZmZzZXRUb3AsXG5cdFx0XHRyaWdodDogb2Zmc2V0TGVmdCArIHdpZHRoLFxuXHRcdFx0Ym90dG9tOiBvZmZzZXRUb3AgKyBoZWlnaHQsXG5cdFx0XHRsZWZ0OiBvZmZzZXRMZWZ0XG5cdFx0fSxcblx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHR3aWR0aDogd2lkdGhcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxlZChjb250YWluZXIpIHtcblx0dmFyIHRvcCwgbGVmdDtcblx0aWYgKGNvbnRhaW5lci5ub2RlID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcblx0XHR0b3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cdFx0bGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcblx0fSBlbHNlIHtcblx0XHR0b3AgPSBjb250YWluZXIubm9kZS5zY3JvbGxUb3A7XG5cdFx0bGVmdCA9IGNvbnRhaW5lci5ub2RlLnNjcm9sbExlZnQ7XG5cdH1cblx0cmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfVxufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnRWaXNpYmxlKGVsZW1lbnQpIHtcblx0aWYgKCBlbGVtZW50ID09PSB2b2lkIDAgKSBlbGVtZW50ID0ge307XG5cblx0dmFyIGNvbnRhaW5lciA9IHRoaXMuc3RvcmUuY29udGFpbmVyc1tlbGVtZW50LmNvbnRhaW5lcklkXTtcblx0aWYgKCFjb250YWluZXIpIHsgcmV0dXJuIH1cblxuXHR2YXIgdmlld0ZhY3RvciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGVsZW1lbnQuY29uZmlnLnZpZXdGYWN0b3IpKTtcblx0dmFyIHZpZXdPZmZzZXQgPSBlbGVtZW50LmNvbmZpZy52aWV3T2Zmc2V0O1xuXG5cdHZhciBlbGVtZW50Qm91bmRzID0ge1xuXHRcdHRvcDogZWxlbWVudC5nZW9tZXRyeS5ib3VuZHMudG9wICsgZWxlbWVudC5nZW9tZXRyeS5oZWlnaHQgKiB2aWV3RmFjdG9yLFxuXHRcdHJpZ2h0OiBlbGVtZW50Lmdlb21ldHJ5LmJvdW5kcy5yaWdodCAtIGVsZW1lbnQuZ2VvbWV0cnkud2lkdGggKiB2aWV3RmFjdG9yLFxuXHRcdGJvdHRvbTogZWxlbWVudC5nZW9tZXRyeS5ib3VuZHMuYm90dG9tIC0gZWxlbWVudC5nZW9tZXRyeS5oZWlnaHQgKiB2aWV3RmFjdG9yLFxuXHRcdGxlZnQ6IGVsZW1lbnQuZ2VvbWV0cnkuYm91bmRzLmxlZnQgKyBlbGVtZW50Lmdlb21ldHJ5LndpZHRoICogdmlld0ZhY3RvclxuXHR9O1xuXG5cdHZhciBjb250YWluZXJCb3VuZHMgPSB7XG5cdFx0dG9wOiBjb250YWluZXIuZ2VvbWV0cnkuYm91bmRzLnRvcCArIGNvbnRhaW5lci5zY3JvbGwudG9wICsgdmlld09mZnNldC50b3AsXG5cdFx0cmlnaHQ6IGNvbnRhaW5lci5nZW9tZXRyeS5ib3VuZHMucmlnaHQgKyBjb250YWluZXIuc2Nyb2xsLmxlZnQgLSB2aWV3T2Zmc2V0LnJpZ2h0LFxuXHRcdGJvdHRvbTpcblx0XHRcdGNvbnRhaW5lci5nZW9tZXRyeS5ib3VuZHMuYm90dG9tICsgY29udGFpbmVyLnNjcm9sbC50b3AgLSB2aWV3T2Zmc2V0LmJvdHRvbSxcblx0XHRsZWZ0OiBjb250YWluZXIuZ2VvbWV0cnkuYm91bmRzLmxlZnQgKyBjb250YWluZXIuc2Nyb2xsLmxlZnQgKyB2aWV3T2Zmc2V0LmxlZnRcblx0fTtcblxuXHRyZXR1cm4gKFxuXHRcdChlbGVtZW50Qm91bmRzLnRvcCA8IGNvbnRhaW5lckJvdW5kcy5ib3R0b20gJiZcblx0XHRcdGVsZW1lbnRCb3VuZHMucmlnaHQgPiBjb250YWluZXJCb3VuZHMubGVmdCAmJlxuXHRcdFx0ZWxlbWVudEJvdW5kcy5ib3R0b20gPiBjb250YWluZXJCb3VuZHMudG9wICYmXG5cdFx0XHRlbGVtZW50Qm91bmRzLmxlZnQgPCBjb250YWluZXJCb3VuZHMucmlnaHQpIHx8XG5cdFx0ZWxlbWVudC5zdHlsZXMucG9zaXRpb24gPT09ICdmaXhlZCdcblx0KVxufVxuXG5mdW5jdGlvbiBkZWxlZ2F0ZShcblx0ZXZlbnQsXG5cdGVsZW1lbnRzXG4pIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cdGlmICggZXZlbnQgPT09IHZvaWQgMCApIGV2ZW50ID0geyB0eXBlOiAnaW5pdCcgfTtcblx0aWYgKCBlbGVtZW50cyA9PT0gdm9pZCAwICkgZWxlbWVudHMgPSB0aGlzLnN0b3JlLmVsZW1lbnRzO1xuXG5cdHJhZihmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHN0YWxlID0gZXZlbnQudHlwZSA9PT0gJ2luaXQnIHx8IGV2ZW50LnR5cGUgPT09ICdyZXNpemUnO1xuXG5cdFx0ZWFjaCh0aGlzJDEuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdFx0aWYgKHN0YWxlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5nZW9tZXRyeSA9IGdldEdlb21ldHJ5LmNhbGwodGhpcyQxLCBjb250YWluZXIsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNjcm9sbCA9IGdldFNjcm9sbGVkLmNhbGwodGhpcyQxLCBjb250YWluZXIpO1xuXHRcdFx0aWYgKGNvbnRhaW5lci5zY3JvbGwpIHtcblx0XHRcdFx0Y29udGFpbmVyLmRpcmVjdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBtYXRoU2lnbihzY3JvbGwubGVmdCAtIGNvbnRhaW5lci5zY3JvbGwubGVmdCksXG5cdFx0XHRcdFx0eTogbWF0aFNpZ24oc2Nyb2xsLnRvcCAtIGNvbnRhaW5lci5zY3JvbGwudG9wKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLnNjcm9sbCA9IHNjcm9sbDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIER1ZSB0byBob3cgdGhlIHNlcXVlbmNlciBpcyBpbXBsZW1lbnRlZCwgaXTigJlzXG5cdFx0ICogaW1wb3J0YW50IHRoYXQgd2UgdXBkYXRlIHRoZSBzdGF0ZSBvZiBhbGxcblx0XHQgKiBlbGVtZW50cywgYmVmb3JlIGFueSBhbmltYXRpb24gbG9naWMgaXNcblx0XHQgKiBldmFsdWF0ZWQgKGluIHRoZSBzZWNvbmQgbG9vcCBiZWxvdykuXG5cdFx0ICovXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdGlmIChzdGFsZSB8fCBlbGVtZW50Lmdlb21ldHJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZWxlbWVudC5nZW9tZXRyeSA9IGdldEdlb21ldHJ5LmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQudmlzaWJsZSA9IGlzRWxlbWVudFZpc2libGUuY2FsbCh0aGlzJDEsIGVsZW1lbnQpO1xuXHRcdH0pO1xuXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdGlmIChlbGVtZW50LnNlcXVlbmNlKSB7XG5cdFx0XHRcdHNlcXVlbmNlLmNhbGwodGhpcyQxLCBlbGVtZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuaW1hdGUuY2FsbCh0aGlzJDEsIGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcyQxLnByaXN0aW5lID0gZmFsc2U7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBpc1RyYW5zZm9ybVN1cHBvcnRlZCgpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXHRyZXR1cm4gJ3RyYW5zZm9ybScgaW4gc3R5bGUgfHwgJ1dlYmtpdFRyYW5zZm9ybScgaW4gc3R5bGVcbn1cblxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uU3VwcG9ydGVkKCkge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cdHJldHVybiAndHJhbnNpdGlvbicgaW4gc3R5bGUgfHwgJ1dlYmtpdFRyYW5zaXRpb24nIGluIHN0eWxlXG59XG5cbnZhciB2ZXJzaW9uID0gXCI0LjAuOVwiO1xuXG52YXIgYm91bmREZWxlZ2F0ZTtcbnZhciBib3VuZERlc3Ryb3k7XG52YXIgYm91bmRSZXZlYWw7XG52YXIgYm91bmRDbGVhbjtcbnZhciBib3VuZFN5bmM7XG52YXIgY29uZmlnO1xudmFyIGRlYnVnO1xudmFyIGluc3RhbmNlO1xuXG5mdW5jdGlvbiBTY3JvbGxSZXZlYWwob3B0aW9ucykge1xuXHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHR2YXIgaW52b2tlZFdpdGhvdXROZXcgPVxuXHRcdHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fFxuXHRcdE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gU2Nyb2xsUmV2ZWFsLnByb3RvdHlwZTtcblxuXHRpZiAoaW52b2tlZFdpdGhvdXROZXcpIHtcblx0XHRyZXR1cm4gbmV3IFNjcm9sbFJldmVhbChvcHRpb25zKVxuXHR9XG5cblx0aWYgKCFTY3JvbGxSZXZlYWwuaXNTdXBwb3J0ZWQoKSkge1xuXHRcdGxvZ2dlci5jYWxsKHRoaXMsICdJbnN0YW50aWF0aW9uIGZhaWxlZC4nLCAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0dmFyIGJ1ZmZlcjtcblx0dHJ5IHtcblx0XHRidWZmZXIgPSBjb25maWdcblx0XHRcdD8gZGVlcEFzc2lnbih7fSwgY29uZmlnLCBvcHRpb25zKVxuXHRcdFx0OiBkZWVwQXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRsb2dnZXIuY2FsbCh0aGlzLCAnSW52YWxpZCBjb25maWd1cmF0aW9uLicsIGUubWVzc2FnZSk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0dHJ5IHtcblx0XHR2YXIgY29udGFpbmVyID0gJChidWZmZXIuY29udGFpbmVyKVswXTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbnRhaW5lci4nKVxuXHRcdH1cblx0fSBjYXRjaCAoZSkge1xuXHRcdGxvZ2dlci5jYWxsKHRoaXMsIGUubWVzc2FnZSk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0Y29uZmlnID0gYnVmZmVyO1xuXG5cdGlmICgoIWNvbmZpZy5tb2JpbGUgJiYgaXNNb2JpbGUoKSkgfHwgKCFjb25maWcuZGVza3RvcCAmJiAhaXNNb2JpbGUoKSkpIHtcblx0XHRsb2dnZXIuY2FsbChcblx0XHRcdHRoaXMsXG5cdFx0XHQnVGhpcyBkZXZpY2UgaXMgZGlzYWJsZWQuJyxcblx0XHRcdChcImRlc2t0b3A6IFwiICsgKGNvbmZpZy5kZXNrdG9wKSksXG5cdFx0XHQoXCJtb2JpbGU6IFwiICsgKGNvbmZpZy5tb2JpbGUpKVxuXHRcdCk7XG5cdFx0cmV0dXJuIG1vdW50LmZhaWx1cmUoKVxuXHR9XG5cblx0bW91bnQuc3VjY2VzcygpO1xuXG5cdHRoaXMuc3RvcmUgPSB7XG5cdFx0Y29udGFpbmVyczoge30sXG5cdFx0ZWxlbWVudHM6IHt9LFxuXHRcdGhpc3Rvcnk6IFtdLFxuXHRcdHNlcXVlbmNlczoge31cblx0fTtcblxuXHR0aGlzLnByaXN0aW5lID0gdHJ1ZTtcblxuXHRib3VuZERlbGVnYXRlID0gYm91bmREZWxlZ2F0ZSB8fCBkZWxlZ2F0ZS5iaW5kKHRoaXMpO1xuXHRib3VuZERlc3Ryb3kgPSBib3VuZERlc3Ryb3kgfHwgZGVzdHJveS5iaW5kKHRoaXMpO1xuXHRib3VuZFJldmVhbCA9IGJvdW5kUmV2ZWFsIHx8IHJldmVhbC5iaW5kKHRoaXMpO1xuXHRib3VuZENsZWFuID0gYm91bmRDbGVhbiB8fCBjbGVhbi5iaW5kKHRoaXMpO1xuXHRib3VuZFN5bmMgPSBib3VuZFN5bmMgfHwgc3luYy5iaW5kKHRoaXMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVsZWdhdGUnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmREZWxlZ2F0ZTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZXN0cm95JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvdW5kRGVzdHJveTsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXZlYWwnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmRSZXZlYWw7IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2xlYW4nLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmRDbGVhbjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzeW5jJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJvdW5kU3luYzsgfSB9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RlZmF1bHRzJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2ZXJzaW9uJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZlcnNpb247IH0gfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9vcCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSB9KTtcblxuXHRyZXR1cm4gaW5zdGFuY2UgPyBpbnN0YW5jZSA6IChpbnN0YW5jZSA9IHRoaXMpXG59XG5cblNjcm9sbFJldmVhbC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzVHJhbnNmb3JtU3VwcG9ydGVkKCkgJiYgaXNUcmFuc2l0aW9uU3VwcG9ydGVkKCk7IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JvbGxSZXZlYWwsICdkZWJ1ZycsIHtcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWJ1ZyB8fCBmYWxzZTsgfSxcblx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIChkZWJ1ZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nID8gdmFsdWUgOiBkZWJ1Zyk7IH1cbn0pO1xuXG5TY3JvbGxSZXZlYWwoKTtcblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsUmV2ZWFsO1xuIiwiaW1wb3J0IFNjcm9sbFJldmVhbCBmcm9tIFwic2Nyb2xscmV2ZWFsXCI7XG5cblNjcm9sbFJldmVhbCh7IGRpc3RhbmNlOiBcIjYwcHhcIiwgZHVyYXRpb246IDEwMDAsIHJlc2V0OiB0cnVlLCBtb2JpbGU6IGZhbHNlIH0pO1xuU2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKFwiLmhlYWRlclwiLCB7IG9yaWdpbjogXCJ0b3BcIiB9KTtcblNjcm9sbFJldmVhbCgpLnJldmVhbChcIi5kaXNjb3Zlcl9fZGVzY1wiLCB7IG9yaWdpbjogXCJsZWZ0XCIsIG1vYmlsZTogZmFsc2UgfSk7XG5TY3JvbGxSZXZlYWwoKS5yZXZlYWwoXCIuZGlzY292ZXJfX3BpY3R1cmVcIiwgeyBvcmlnaW46IFwicmlnaHRcIiwgbW9iaWxlOiBmYWxzZSB9KTtcblNjcm9sbFJldmVhbCgpLnJldmVhbChcIi5wb3B1bGFyXCIsIHsgb3JpZ2luOiBcInJpZ2h0XCIsIG1vYmlsZTogZmFsc2UgfSk7XG5TY3JvbGxSZXZlYWwoKS5yZXZlYWwoXCIuc2VydmljZXNcIiwgeyBvcmlnaW46IFwibGVmdFwiLCBtb2JpbGU6IGZhbHNlIH0pO1xuU2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKFwiLmV4cGxvcmVcIiwgeyBvcmlnaW46IFwicmlnaHRcIiwgbW9iaWxlOiBmYWxzZSB9KTtcbiIsImltcG9ydCBcIi4vc3R5bGUvc3R5bGUuc2Nzc1wiO1xuaW1wb3J0IFwiLi9odG1sL2luZGV4LnB1Z1wiO1xuXG5pbXBvcnQgXCIuL2pzL2F1dG9jb21wbGV0ZS5qc1wiO1xuaW1wb3J0IFwiLi9qcy9kYXRlUGlja2VyLmpzXCI7XG5pbXBvcnQgXCIuL2pzL3N3aXBlci5qc1wiO1xuaW1wb3J0IFwiLi9qcy9yZXZlYWwuanNcIjtcbmltcG9ydCBcIi4vanMvbW9iaWxlLW1lbnUuanNcIjtcbiJdLCJuYW1lcyI6WyJjb3VudHJpZXMiLCJhdXRvQ29tcGxldGUiLCJhdXRvQ29tcGxldGVKUyIsInNlbGVjdG9yIiwicGxhY2VIb2xkZXIiLCJkYXRhIiwic3JjIiwiY2FjaGUiLCJyZXN1bHRJdGVtIiwiaGlnaGxpZ2h0IiwiZXZlbnRzIiwiaW5wdXQiLCJzZWxlY3Rpb24iLCJldmVudCIsImRldGFpbCIsInZhbHVlIiwiZWFzZXBpY2siLCJwaWNrZXIiLCJjcmVhdGUiLCJlbGVtZW50IiwiY3NzIiwiekluZGV4IiwiZm9ybWF0IiwiU3dpcGVyIiwic3dpcGVyIiwic2xpZGVzUGVyVmlldyIsImF1dG9XaWR0aCIsImJyZWFrcG9pbnRzIiwic3BhY2VCZXR3ZWVuIiwibmF2aWdhdGlvbiIsIm5leHRFbCIsInByZXZFbCIsInN3aXBlckNvbmZpZyIsImRpcmVjdGlvbiIsImdyYWJDdXJzb3IiLCJmcmVlTW9kZSIsInNwZWVkIiwibG9vcCIsImF1dG9wbGF5IiwiZGVsYXkiLCJkaXNhYmxlT25JbnRlcmFjdGlvbiIsImxvb3BBZGRpdGlvbmFsU2xpZGVzIiwic3dpcGVySG9yaXpvbnRhbENvbmZpZyIsImF1dG9IZWlnaHQiLCJ0ZXN0aW1vbmlhbHNTd2lwZXIiLCJ0ZXN0aW1vbmlhbHNTd2lwZXIyIiwidGVzdGltb25pYWxzU3dpcGVyMyIsInRlc3RpbW9uaWFsc0hvcml6b250YWwiLCJzd2lwZXJCcmVhY2twb2ludCIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJzd2lwZXJUZXN0aW1vbmlhbHMiLCJtYXRjaGVzIiwiZGVzdHJveSIsInVuZGVmaW5lZCIsImhvcml6b250YWxTd2lwZXIiLCJ0ZXN0aW1vbmlhbHNTd2lwZXJzIiwiYWRkTGlzdGVuZXIiLCJTY3JvbGxSZXZlYWwiLCJkaXN0YW5jZSIsImR1cmF0aW9uIiwicmVzZXQiLCJtb2JpbGUiLCJyZXZlYWwiLCJvcmlnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5637\n")},4345:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;let destinations = [\n{ city: \'Venice, Italy\', image: \'venice.jpg\', rating: \'(4.5)\', price: 900 },\n{ city: \'Bali, Indonesia\', image: \'bali.jpg\', rating: \'4.5\', price: 480 },\n{ city: \'Bangkok, Thailand\', image: \'bangkok.jpg\', rating: \'4.5\', price: 440 },\n{ city: \'Santorini, Greek\', image: \'santorini.jpg\', rating: \'4.5\', price: 900 },\n{ city: \'Paris, France\', image: \'paris.jpg\', rating: \'4.5\', price: 1100 },\n{ city: \'New York, USA\', image: \'new-york.jpg\', rating: \'4.5\', price: 1800 },\n{ city: \'Dubai, UAE\', image: \'dubai.jpg\', rating: \'4.5\', price: 900 }\n]\n// iterate destinations\n;(function(){\n  var $$obj = destinations;\n  if (\'number\' == typeof $$obj.length) {\n      for (var pug_index0 = 0, $$l = $$obj.length; pug_index0 < $$l; pug_index0++) {\n        var card = $$obj[pug_index0];\npug_html = pug_html + "\\u003Carticle class=\\"card swiper-slide\\"\\u003E\\u003Cdiv class=\\"card__image\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(2507)(`./${card.image}`), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"card__title\\"\\u003E\\u003Ch3 class=\\"card__header title-5\\"\\u003E" + (pug.escape(null == (pug_interp = card.city) ? "" : pug_interp)) + "\\u003C\\u002Fh3\\u003E\\u003Cspan class=\\"card__raiting\\"\\u003E" + (pug.escape(null == (pug_interp = card.rating) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"card__price\\"\\u003E Starts from \\u003Cspan class=\\"card__price--dollor\\"\\u003E$\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"card__price--summ\\"\\u003E" + (pug.escape(null == (pug_interp = card.price) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Farticle\\u003E";\n      }\n  } else {\n    var $$l = 0;\n    for (var pug_index0 in $$obj) {\n      $$l++;\n      var card = $$obj[pug_index0];\npug_html = pug_html + "\\u003Carticle class=\\"card swiper-slide\\"\\u003E\\u003Cdiv class=\\"card__image\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(2507)(`./${card.image}`), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"card__title\\"\\u003E\\u003Ch3 class=\\"card__header title-5\\"\\u003E" + (pug.escape(null == (pug_interp = card.city) ? "" : pug_interp)) + "\\u003C\\u002Fh3\\u003E\\u003Cspan class=\\"card__raiting\\"\\u003E" + (pug.escape(null == (pug_interp = card.rating) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"card__price\\"\\u003E Starts from \\u003Cspan class=\\"card__price--dollor\\"\\u003E$\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"card__price--summ\\"\\u003E" + (pug.escape(null == (pug_interp = card.price) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Farticle\\u003E";\n    }\n  }\n}).call(this);\n;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM0NS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBZ0Q7O0FBRWxFLDJCQUEyQixrQ0FBa0MsYUFBYTtBQUMxRSxFQUFFLHlFQUF5RTtBQUMzRSxFQUFFLHVFQUF1RTtBQUN6RSxFQUFFLDRFQUE0RTtBQUM5RSxFQUFFLDZFQUE2RTtBQUMvRSxFQUFFLHVFQUF1RTtBQUN6RSxFQUFFLDBFQUEwRTtBQUM1RSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBLDBJQUEwSSwwQkFBUSxHQUEyQixFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzVMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLDBCQUFRLEdBQTJCLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDNUw7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy9lbGVtZW50cy9kZXN0aW5hdGlvbi5wdWc/NGEzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHVnID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanNcIik7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge3ZhciBwdWdfaHRtbCA9IFwiXCIsIHB1Z19taXhpbnMgPSB7fSwgcHVnX2ludGVycDtsZXQgZGVzdGluYXRpb25zID0gW1xueyBjaXR5OiAnVmVuaWNlLCBJdGFseScsIGltYWdlOiAndmVuaWNlLmpwZycsIHJhdGluZzogJyg0LjUpJywgcHJpY2U6IDkwMCB9LFxueyBjaXR5OiAnQmFsaSwgSW5kb25lc2lhJywgaW1hZ2U6ICdiYWxpLmpwZycsIHJhdGluZzogJzQuNScsIHByaWNlOiA0ODAgfSxcbnsgY2l0eTogJ0Jhbmdrb2ssIFRoYWlsYW5kJywgaW1hZ2U6ICdiYW5na29rLmpwZycsIHJhdGluZzogJzQuNScsIHByaWNlOiA0NDAgfSxcbnsgY2l0eTogJ1NhbnRvcmluaSwgR3JlZWsnLCBpbWFnZTogJ3NhbnRvcmluaS5qcGcnLCByYXRpbmc6ICc0LjUnLCBwcmljZTogOTAwIH0sXG57IGNpdHk6ICdQYXJpcywgRnJhbmNlJywgaW1hZ2U6ICdwYXJpcy5qcGcnLCByYXRpbmc6ICc0LjUnLCBwcmljZTogMTEwMCB9LFxueyBjaXR5OiAnTmV3IFlvcmssIFVTQScsIGltYWdlOiAnbmV3LXlvcmsuanBnJywgcmF0aW5nOiAnNC41JywgcHJpY2U6IDE4MDAgfSxcbnsgY2l0eTogJ0R1YmFpLCBVQUUnLCBpbWFnZTogJ2R1YmFpLmpwZycsIHJhdGluZzogJzQuNScsIHByaWNlOiA5MDAgfVxuXVxuLy8gaXRlcmF0ZSBkZXN0aW5hdGlvbnNcbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0gZGVzdGluYXRpb25zO1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcHVnX2luZGV4MCA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgcHVnX2luZGV4MCA8ICQkbDsgcHVnX2luZGV4MCsrKSB7XG4gICAgICAgIHZhciBjYXJkID0gJCRvYmpbcHVnX2luZGV4MF07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDYXJ0aWNsZSBjbGFzcz1cXFwiY2FyZCBzd2lwZXItc2xpZGVcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNhcmRfX2ltYWdlXFxcIlxcdTAwM0UgXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoYC4vLi4vLi4vLi4vaW1hZ2VzL3Byb2R1Y3QvJHtjYXJkLmltYWdlfWApLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJjYXJkX190aXRsZVxcXCJcXHUwMDNFXFx1MDAzQ2gzIGNsYXNzPVxcXCJjYXJkX19oZWFkZXIgdGl0bGUtNVxcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gY2FyZC5jaXR5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGaDNcXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImNhcmRfX3JhaXRpbmdcXFwiXFx1MDAzRVwiICsgKHB1Zy5lc2NhcGUobnVsbCA9PSAocHVnX2ludGVycCA9IGNhcmQucmF0aW5nKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJjYXJkX19wcmljZVxcXCJcXHUwMDNFIFN0YXJ0cyBmcm9tIFxcdTAwM0NzcGFuIGNsYXNzPVxcXCJjYXJkX19wcmljZS0tZG9sbG9yXFxcIlxcdTAwM0UkXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJjYXJkX19wcmljZS0tc3VtbVxcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gY2FyZC5wcmljZSkgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZhcnRpY2xlXFx1MDAzRVwiO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyIHB1Z19pbmRleDAgaW4gJCRvYmopIHtcbiAgICAgICQkbCsrO1xuICAgICAgdmFyIGNhcmQgPSAkJG9ialtwdWdfaW5kZXgwXTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NhcnRpY2xlIGNsYXNzPVxcXCJjYXJkIHN3aXBlci1zbGlkZVxcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY2FyZF9faW1hZ2VcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZShgLi8uLi8uLi8uLi9pbWFnZXMvcHJvZHVjdC8ke2NhcmQuaW1hZ2V9YCksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNhcmRfX3RpdGxlXFxcIlxcdTAwM0VcXHUwMDNDaDMgY2xhc3M9XFxcImNhcmRfX2hlYWRlciB0aXRsZS01XFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBjYXJkLmNpdHkpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZoM1xcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiY2FyZF9fcmFpdGluZ1xcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gY2FyZC5yYXRpbmcpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNhcmRfX3ByaWNlXFxcIlxcdTAwM0UgU3RhcnRzIGZyb20gXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImNhcmRfX3ByaWNlLS1kb2xsb3JcXFwiXFx1MDAzRSRcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImNhcmRfX3ByaWNlLS1zdW1tXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBjYXJkLnByaWNlKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmFydGljbGVcXHUwMDNFXCI7XG4gICAgfVxuICB9XG59KS5jYWxsKHRoaXMpO1xuO3JldHVybiBwdWdfaHRtbDt9O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4345\n')},9062:function(module,__unused_webpack_exports,__webpack_require__){eval("var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;let reviews = [\n{ name: 'Hendra Paru Paru', image: '01.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Akbar Cenglu', image: '02.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"I had a seamless booking process with this travel website. Their website was easy to navigate, and I got fantastic deals on flights and accommodation. Will definitely use them for future trips.\"' },\n{ name: 'Jake Paul', image: '03.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"Amazing experience! The travel website made booking our vacation a breeze. Everything was well-organized, and we had a fantastic time exploring new places. Highly recommend!\"' },\n{ name: 'Nichole Edward', image: '04.jpg', status: 'Travel Enthusiast', raiting: 2, review: '\"I loved the personalized itinerary feature of this travel website. It allowed me to plan my trip according to my preferences, making it a truly customized experience.\"' },\n{ name: 'Jennice Ong', image: '05.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Figa T.', image: '06.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"A one-stop-shop for all things travel! The website\\'s variety of travel options and user reviews helped me make informed decisions and ensured a smooth trip.\"' },\n{ name: 'Jonathan R.', image: '07.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Angela Cole', image: '02.jpg', status: 'Travel Enthusiast', raiting: 1, review: '\"The detailed travel guides provided by this website were invaluable during our journey. We felt confident exploring a new destination, thanks to their helpful tips and insights. erat.\"' },\n{ name: 'Bambang Susilo', image: '03.jpg', status: 'Travel Enthusiast', raiting: 2, review: '\"Hands down the best travel website I\\'ve ever used! The user interface was so intuitive, and I was able to book my dream vacation effortlessly. erat.\"' },\n{ name: 'Hendra Paru Paru', image: '01.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Akbar Cenglu', image: '02.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"I had a seamless booking process with this travel website. Their website was easy to navigate, and I got fantastic deals on flights and accommodation. Will definitely use them for future trips.\"' },\n{ name: 'Jake Paul', image: '03.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"Amazing experience! The travel website made booking our vacation a breeze. Everything was well-organized, and we had a fantastic time exploring new places. Highly recommend!\"' },\n{ name: 'Nichole Edward', image: '04.jpg', status: 'Travel Enthusiast', raiting: 2, review: '\"I loved the personalized itinerary feature of this travel website. It allowed me to plan my trip according to my preferences, making it a truly customized experience.\"' },\n{ name: 'Jennice Ong', image: '05.jpg', status: 'Travel Enthusiast', raiting: 4, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Figa T.', image: '06.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"A one-stop-shop for all things travel! The website\\'s variety of travel options and user reviews helped me make informed decisions and ensured a smooth trip.\"' },\n{ name: 'Jonathan R.', image: '07.jpg', status: 'Travel Enthusiast', raiting: 5, review: '\"An outstanding resource for travel enthusiasts! The website\\'s destination reviews and travel advice were spot-on. I now trust their recommendations for all my trips..\"' },\n{ name: 'Angela Cole', image: '02.jpg', status: 'Travel Enthusiast', raiting: 1, review: '\"The detailed travel guides provided by this website were invaluable during our journey. We felt confident exploring a new destination, thanks to their helpful tips and insights. erat.\"' },\n{ name: 'Bambang Susilo', image: '03.jpg', status: 'Travel Enthusiast', raiting: 2, review: '\"Hands down the best travel website I\\'ve ever used! The user interface was so intuitive, and I was able to book my dream vacation effortlessly. erat.\"' },\n]\nlet maxRaiting = 5;\n// iterate reviews \n;(function(){\n  var $$obj = reviews ;\n  if ('number' == typeof $$obj.length) {\n      for (var pug_index0 = 0, $$l = $$obj.length; pug_index0 < $$l; pug_index0++) {\n        var item = $$obj[pug_index0];\npug_html = pug_html + \"\\u003Carticle class=\\\"swiper-slide review\\\"\\u003E\\u003Cdiv class=\\\"review__raiting\\\"\\u003E \";\nfor(let i = 0; i < item.raiting; i++)\n{\npug_html = pug_html + \"\\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(2713), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\";\n}\nfor(let i = item.raiting; i < 5; i++)\n{\npug_html = pug_html + \"\\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(9741), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\";\n}\npug_html = pug_html + \"\\u003C\\u002Fdiv\\u003E\\u003Cp class=\\\"review__text\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.review) ? \"\" : pug_interp)) + \"\\u003C\\u002Fp\\u003E\\u003Cdiv class=\\\"review__author\\\"\\u003E \\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(58)(`./${item.image}`), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\\u003Cdiv class=\\\"review__header\\\"\\u003E \\u003Cspan class=\\\"review__author-name\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.name) ? \"\" : pug_interp)) + \"\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\\"review__author-status\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.status) ? \"\" : pug_interp)) + \"\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Farticle\\u003E\";\n      }\n  } else {\n    var $$l = 0;\n    for (var pug_index0 in $$obj) {\n      $$l++;\n      var item = $$obj[pug_index0];\npug_html = pug_html + \"\\u003Carticle class=\\\"swiper-slide review\\\"\\u003E\\u003Cdiv class=\\\"review__raiting\\\"\\u003E \";\nfor(let i = 0; i < item.raiting; i++)\n{\npug_html = pug_html + \"\\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(2713), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\";\n}\nfor(let i = item.raiting; i < 5; i++)\n{\npug_html = pug_html + \"\\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(9741), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\";\n}\npug_html = pug_html + \"\\u003C\\u002Fdiv\\u003E\\u003Cp class=\\\"review__text\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.review) ? \"\" : pug_interp)) + \"\\u003C\\u002Fp\\u003E\\u003Cdiv class=\\\"review__author\\\"\\u003E \\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(58)(`./${item.image}`), true, true)+\" alt=\\\"\\\"\") + \"\\u003E\\u003Cdiv class=\\\"review__header\\\"\\u003E \\u003Cspan class=\\\"review__author-name\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.name) ? \"\" : pug_interp)) + \"\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\\"review__author-status\\\"\\u003E\" + (pug.escape(null == (pug_interp = item.status) ? \"\" : pug_interp)) + \"\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Farticle\\u003E\";\n    }\n  }\n}).call(this);\n;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBZ0Q7O0FBRWxFLDJCQUEyQixrQ0FBa0MsYUFBYTtBQUMxRSxFQUFFLHlRQUF5UTtBQUMzUSxFQUFFLCtSQUErUjtBQUNqUyxFQUFFLHdRQUF3UTtBQUMxUSxFQUFFLHNRQUFzUTtBQUN4USxFQUFFLG9RQUFvUTtBQUN0USxFQUFFLHNQQUFzUDtBQUN4UCxFQUFFLG9RQUFvUTtBQUN0USxFQUFFLG9SQUFvUjtBQUN0UixFQUFFLHFQQUFxUDtBQUN2UCxFQUFFLHlRQUF5UTtBQUMzUSxFQUFFLCtSQUErUjtBQUNqUyxFQUFFLHdRQUF3UTtBQUMxUSxFQUFFLHNRQUFzUTtBQUN4USxFQUFFLG9RQUFvUTtBQUN0USxFQUFFLHNQQUFzUDtBQUN4UCxFQUFFLG9RQUFvUTtBQUN0USxFQUFFLG9SQUFvUjtBQUN0UixFQUFFLHFQQUFxUDtBQUN2UDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0EscURBQXFELG1CQUFPLENBQUMsSUFBeUM7QUFDdEc7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLHFEQUFxRCxtQkFBTyxDQUFDLElBQTZDO0FBQzFHO0FBQ0Esb1BBQW9QLHdCQUFRLEdBQWdDLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDM1M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0EscURBQXFELG1CQUFPLENBQUMsSUFBeUM7QUFDdEc7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLHFEQUFxRCxtQkFBTyxDQUFDLElBQTZDO0FBQzFHO0FBQ0Esb1BBQW9QLHdCQUFRLEdBQWdDLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDM1M7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy9lbGVtZW50cy9yZXZpZXdzLnB1Zz9jY2FlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO2xldCByZXZpZXdzID0gW1xueyBuYW1lOiAnSGVuZHJhIFBhcnUgUGFydScsIGltYWdlOiAnMDEuanBnJywgc3RhdHVzOiAnVHJhdmVsIEVudGh1c2lhc3QnLCByYWl0aW5nOiA1LCByZXZpZXc6ICdcIkFuIG91dHN0YW5kaW5nIHJlc291cmNlIGZvciB0cmF2ZWwgZW50aHVzaWFzdHMhIFRoZSB3ZWJzaXRlXFwncyBkZXN0aW5hdGlvbiByZXZpZXdzIGFuZCB0cmF2ZWwgYWR2aWNlIHdlcmUgc3BvdC1vbi4gSSBub3cgdHJ1c3QgdGhlaXIgcmVjb21tZW5kYXRpb25zIGZvciBhbGwgbXkgdHJpcHMuLlwiJyB9LFxueyBuYW1lOiAnQWtiYXIgQ2VuZ2x1JywgaW1hZ2U6ICcwMi5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDQsIHJldmlldzogJ1wiSSBoYWQgYSBzZWFtbGVzcyBib29raW5nIHByb2Nlc3Mgd2l0aCB0aGlzIHRyYXZlbCB3ZWJzaXRlLiBUaGVpciB3ZWJzaXRlIHdhcyBlYXN5IHRvIG5hdmlnYXRlLCBhbmQgSSBnb3QgZmFudGFzdGljIGRlYWxzIG9uIGZsaWdodHMgYW5kIGFjY29tbW9kYXRpb24uIFdpbGwgZGVmaW5pdGVseSB1c2UgdGhlbSBmb3IgZnV0dXJlIHRyaXBzLlwiJyB9LFxueyBuYW1lOiAnSmFrZSBQYXVsJywgaW1hZ2U6ICcwMy5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDQsIHJldmlldzogJ1wiQW1hemluZyBleHBlcmllbmNlISBUaGUgdHJhdmVsIHdlYnNpdGUgbWFkZSBib29raW5nIG91ciB2YWNhdGlvbiBhIGJyZWV6ZS4gRXZlcnl0aGluZyB3YXMgd2VsbC1vcmdhbml6ZWQsIGFuZCB3ZSBoYWQgYSBmYW50YXN0aWMgdGltZSBleHBsb3JpbmcgbmV3IHBsYWNlcy4gSGlnaGx5IHJlY29tbWVuZCFcIicgfSxcbnsgbmFtZTogJ05pY2hvbGUgRWR3YXJkJywgaW1hZ2U6ICcwNC5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDIsIHJldmlldzogJ1wiSSBsb3ZlZCB0aGUgcGVyc29uYWxpemVkIGl0aW5lcmFyeSBmZWF0dXJlIG9mIHRoaXMgdHJhdmVsIHdlYnNpdGUuIEl0IGFsbG93ZWQgbWUgdG8gcGxhbiBteSB0cmlwIGFjY29yZGluZyB0byBteSBwcmVmZXJlbmNlcywgbWFraW5nIGl0IGEgdHJ1bHkgY3VzdG9taXplZCBleHBlcmllbmNlLlwiJyB9LFxueyBuYW1lOiAnSmVubmljZSBPbmcnLCBpbWFnZTogJzA1LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNCwgcmV2aWV3OiAnXCJBbiBvdXRzdGFuZGluZyByZXNvdXJjZSBmb3IgdHJhdmVsIGVudGh1c2lhc3RzISBUaGUgd2Vic2l0ZVxcJ3MgZGVzdGluYXRpb24gcmV2aWV3cyBhbmQgdHJhdmVsIGFkdmljZSB3ZXJlIHNwb3Qtb24uIEkgbm93IHRydXN0IHRoZWlyIHJlY29tbWVuZGF0aW9ucyBmb3IgYWxsIG15IHRyaXBzLi5cIicgfSxcbnsgbmFtZTogJ0ZpZ2EgVC4nLCBpbWFnZTogJzA2LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNSwgcmV2aWV3OiAnXCJBIG9uZS1zdG9wLXNob3AgZm9yIGFsbCB0aGluZ3MgdHJhdmVsISBUaGUgd2Vic2l0ZVxcJ3MgdmFyaWV0eSBvZiB0cmF2ZWwgb3B0aW9ucyBhbmQgdXNlciByZXZpZXdzIGhlbHBlZCBtZSBtYWtlIGluZm9ybWVkIGRlY2lzaW9ucyBhbmQgZW5zdXJlZCBhIHNtb290aCB0cmlwLlwiJyB9LFxueyBuYW1lOiAnSm9uYXRoYW4gUi4nLCBpbWFnZTogJzA3LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNSwgcmV2aWV3OiAnXCJBbiBvdXRzdGFuZGluZyByZXNvdXJjZSBmb3IgdHJhdmVsIGVudGh1c2lhc3RzISBUaGUgd2Vic2l0ZVxcJ3MgZGVzdGluYXRpb24gcmV2aWV3cyBhbmQgdHJhdmVsIGFkdmljZSB3ZXJlIHNwb3Qtb24uIEkgbm93IHRydXN0IHRoZWlyIHJlY29tbWVuZGF0aW9ucyBmb3IgYWxsIG15IHRyaXBzLi5cIicgfSxcbnsgbmFtZTogJ0FuZ2VsYSBDb2xlJywgaW1hZ2U6ICcwMi5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDEsIHJldmlldzogJ1wiVGhlIGRldGFpbGVkIHRyYXZlbCBndWlkZXMgcHJvdmlkZWQgYnkgdGhpcyB3ZWJzaXRlIHdlcmUgaW52YWx1YWJsZSBkdXJpbmcgb3VyIGpvdXJuZXkuIFdlIGZlbHQgY29uZmlkZW50IGV4cGxvcmluZyBhIG5ldyBkZXN0aW5hdGlvbiwgdGhhbmtzIHRvIHRoZWlyIGhlbHBmdWwgdGlwcyBhbmQgaW5zaWdodHMuIGVyYXQuXCInIH0sXG57IG5hbWU6ICdCYW1iYW5nIFN1c2lsbycsIGltYWdlOiAnMDMuanBnJywgc3RhdHVzOiAnVHJhdmVsIEVudGh1c2lhc3QnLCByYWl0aW5nOiAyLCByZXZpZXc6ICdcIkhhbmRzIGRvd24gdGhlIGJlc3QgdHJhdmVsIHdlYnNpdGUgSVxcJ3ZlIGV2ZXIgdXNlZCEgVGhlIHVzZXIgaW50ZXJmYWNlIHdhcyBzbyBpbnR1aXRpdmUsIGFuZCBJIHdhcyBhYmxlIHRvIGJvb2sgbXkgZHJlYW0gdmFjYXRpb24gZWZmb3J0bGVzc2x5LiBlcmF0LlwiJyB9LFxueyBuYW1lOiAnSGVuZHJhIFBhcnUgUGFydScsIGltYWdlOiAnMDEuanBnJywgc3RhdHVzOiAnVHJhdmVsIEVudGh1c2lhc3QnLCByYWl0aW5nOiA1LCByZXZpZXc6ICdcIkFuIG91dHN0YW5kaW5nIHJlc291cmNlIGZvciB0cmF2ZWwgZW50aHVzaWFzdHMhIFRoZSB3ZWJzaXRlXFwncyBkZXN0aW5hdGlvbiByZXZpZXdzIGFuZCB0cmF2ZWwgYWR2aWNlIHdlcmUgc3BvdC1vbi4gSSBub3cgdHJ1c3QgdGhlaXIgcmVjb21tZW5kYXRpb25zIGZvciBhbGwgbXkgdHJpcHMuLlwiJyB9LFxueyBuYW1lOiAnQWtiYXIgQ2VuZ2x1JywgaW1hZ2U6ICcwMi5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDQsIHJldmlldzogJ1wiSSBoYWQgYSBzZWFtbGVzcyBib29raW5nIHByb2Nlc3Mgd2l0aCB0aGlzIHRyYXZlbCB3ZWJzaXRlLiBUaGVpciB3ZWJzaXRlIHdhcyBlYXN5IHRvIG5hdmlnYXRlLCBhbmQgSSBnb3QgZmFudGFzdGljIGRlYWxzIG9uIGZsaWdodHMgYW5kIGFjY29tbW9kYXRpb24uIFdpbGwgZGVmaW5pdGVseSB1c2UgdGhlbSBmb3IgZnV0dXJlIHRyaXBzLlwiJyB9LFxueyBuYW1lOiAnSmFrZSBQYXVsJywgaW1hZ2U6ICcwMy5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDQsIHJldmlldzogJ1wiQW1hemluZyBleHBlcmllbmNlISBUaGUgdHJhdmVsIHdlYnNpdGUgbWFkZSBib29raW5nIG91ciB2YWNhdGlvbiBhIGJyZWV6ZS4gRXZlcnl0aGluZyB3YXMgd2VsbC1vcmdhbml6ZWQsIGFuZCB3ZSBoYWQgYSBmYW50YXN0aWMgdGltZSBleHBsb3JpbmcgbmV3IHBsYWNlcy4gSGlnaGx5IHJlY29tbWVuZCFcIicgfSxcbnsgbmFtZTogJ05pY2hvbGUgRWR3YXJkJywgaW1hZ2U6ICcwNC5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDIsIHJldmlldzogJ1wiSSBsb3ZlZCB0aGUgcGVyc29uYWxpemVkIGl0aW5lcmFyeSBmZWF0dXJlIG9mIHRoaXMgdHJhdmVsIHdlYnNpdGUuIEl0IGFsbG93ZWQgbWUgdG8gcGxhbiBteSB0cmlwIGFjY29yZGluZyB0byBteSBwcmVmZXJlbmNlcywgbWFraW5nIGl0IGEgdHJ1bHkgY3VzdG9taXplZCBleHBlcmllbmNlLlwiJyB9LFxueyBuYW1lOiAnSmVubmljZSBPbmcnLCBpbWFnZTogJzA1LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNCwgcmV2aWV3OiAnXCJBbiBvdXRzdGFuZGluZyByZXNvdXJjZSBmb3IgdHJhdmVsIGVudGh1c2lhc3RzISBUaGUgd2Vic2l0ZVxcJ3MgZGVzdGluYXRpb24gcmV2aWV3cyBhbmQgdHJhdmVsIGFkdmljZSB3ZXJlIHNwb3Qtb24uIEkgbm93IHRydXN0IHRoZWlyIHJlY29tbWVuZGF0aW9ucyBmb3IgYWxsIG15IHRyaXBzLi5cIicgfSxcbnsgbmFtZTogJ0ZpZ2EgVC4nLCBpbWFnZTogJzA2LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNSwgcmV2aWV3OiAnXCJBIG9uZS1zdG9wLXNob3AgZm9yIGFsbCB0aGluZ3MgdHJhdmVsISBUaGUgd2Vic2l0ZVxcJ3MgdmFyaWV0eSBvZiB0cmF2ZWwgb3B0aW9ucyBhbmQgdXNlciByZXZpZXdzIGhlbHBlZCBtZSBtYWtlIGluZm9ybWVkIGRlY2lzaW9ucyBhbmQgZW5zdXJlZCBhIHNtb290aCB0cmlwLlwiJyB9LFxueyBuYW1lOiAnSm9uYXRoYW4gUi4nLCBpbWFnZTogJzA3LmpwZycsIHN0YXR1czogJ1RyYXZlbCBFbnRodXNpYXN0JywgcmFpdGluZzogNSwgcmV2aWV3OiAnXCJBbiBvdXRzdGFuZGluZyByZXNvdXJjZSBmb3IgdHJhdmVsIGVudGh1c2lhc3RzISBUaGUgd2Vic2l0ZVxcJ3MgZGVzdGluYXRpb24gcmV2aWV3cyBhbmQgdHJhdmVsIGFkdmljZSB3ZXJlIHNwb3Qtb24uIEkgbm93IHRydXN0IHRoZWlyIHJlY29tbWVuZGF0aW9ucyBmb3IgYWxsIG15IHRyaXBzLi5cIicgfSxcbnsgbmFtZTogJ0FuZ2VsYSBDb2xlJywgaW1hZ2U6ICcwMi5qcGcnLCBzdGF0dXM6ICdUcmF2ZWwgRW50aHVzaWFzdCcsIHJhaXRpbmc6IDEsIHJldmlldzogJ1wiVGhlIGRldGFpbGVkIHRyYXZlbCBndWlkZXMgcHJvdmlkZWQgYnkgdGhpcyB3ZWJzaXRlIHdlcmUgaW52YWx1YWJsZSBkdXJpbmcgb3VyIGpvdXJuZXkuIFdlIGZlbHQgY29uZmlkZW50IGV4cGxvcmluZyBhIG5ldyBkZXN0aW5hdGlvbiwgdGhhbmtzIHRvIHRoZWlyIGhlbHBmdWwgdGlwcyBhbmQgaW5zaWdodHMuIGVyYXQuXCInIH0sXG57IG5hbWU6ICdCYW1iYW5nIFN1c2lsbycsIGltYWdlOiAnMDMuanBnJywgc3RhdHVzOiAnVHJhdmVsIEVudGh1c2lhc3QnLCByYWl0aW5nOiAyLCByZXZpZXc6ICdcIkhhbmRzIGRvd24gdGhlIGJlc3QgdHJhdmVsIHdlYnNpdGUgSVxcJ3ZlIGV2ZXIgdXNlZCEgVGhlIHVzZXIgaW50ZXJmYWNlIHdhcyBzbyBpbnR1aXRpdmUsIGFuZCBJIHdhcyBhYmxlIHRvIGJvb2sgbXkgZHJlYW0gdmFjYXRpb24gZWZmb3J0bGVzc2x5LiBlcmF0LlwiJyB9LFxuXVxubGV0IG1heFJhaXRpbmcgPSA1O1xuLy8gaXRlcmF0ZSByZXZpZXdzIFxuOyhmdW5jdGlvbigpe1xuICB2YXIgJCRvYmogPSByZXZpZXdzIDtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHB1Z19pbmRleDAgPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7IHB1Z19pbmRleDAgPCAkJGw7IHB1Z19pbmRleDArKykge1xuICAgICAgICB2YXIgaXRlbSA9ICQkb2JqW3B1Z19pbmRleDBdO1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2FydGljbGUgY2xhc3M9XFxcInN3aXBlci1zbGlkZSByZXZpZXdcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInJldmlld19fcmFpdGluZ1xcXCJcXHUwMDNFIFwiO1xuZm9yKGxldCBpID0gMDsgaSA8IGl0ZW0ucmFpdGluZzsgaSsrKVxue1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vLi4vaW1hZ2VzL3Rlc3RpbW9uaWFscy9zdGFyLnN2ZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcIjtcbn1cbmZvcihsZXQgaSA9IGl0ZW0ucmFpdGluZzsgaSA8IDU7IGkrKylcbntcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uLy4uL2ltYWdlcy90ZXN0aW1vbmlhbHMvc3Rhci1vZmYuc3ZnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVwiO1xufVxucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcInJldmlld19fdGV4dFxcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gaXRlbS5yZXZpZXcpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInJldmlld19fYXV0aG9yXFxcIlxcdTAwM0UgXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoYC4vLi4vLi4vLi4vaW1hZ2VzL3Rlc3RpbW9uaWFscy8ke2l0ZW0uaW1hZ2V9YCksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInJldmlld19faGVhZGVyXFxcIlxcdTAwM0UgXFx1MDAzQ3NwYW4gY2xhc3M9XFxcInJldmlld19fYXV0aG9yLW5hbWVcXFwiXFx1MDAzRVwiICsgKHB1Zy5lc2NhcGUobnVsbCA9PSAocHVnX2ludGVycCA9IGl0ZW0ubmFtZSkgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcInJldmlld19fYXV0aG9yLXN0YXR1c1xcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gaXRlbS5zdGF0dXMpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGYXJ0aWNsZVxcdTAwM0VcIjtcbiAgICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRsID0gMDtcbiAgICBmb3IgKHZhciBwdWdfaW5kZXgwIGluICQkb2JqKSB7XG4gICAgICAkJGwrKztcbiAgICAgIHZhciBpdGVtID0gJCRvYmpbcHVnX2luZGV4MF07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDYXJ0aWNsZSBjbGFzcz1cXFwic3dpcGVyLXNsaWRlIHJldmlld1xcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwicmV2aWV3X19yYWl0aW5nXFxcIlxcdTAwM0UgXCI7XG5mb3IobGV0IGkgPSAwOyBpIDwgaXRlbS5yYWl0aW5nOyBpKyspXG57XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi8uLi8uLi9pbWFnZXMvdGVzdGltb25pYWxzL3N0YXIuc3ZnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVwiO1xufVxuZm9yKGxldCBpID0gaXRlbS5yYWl0aW5nOyBpIDwgNTsgaSsrKVxue1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vLi4vaW1hZ2VzL3Rlc3RpbW9uaWFscy9zdGFyLW9mZi5zdmcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXCI7XG59XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwicmV2aWV3X190ZXh0XFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBpdGVtLnJldmlldykgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwicmV2aWV3X19hdXRob3JcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZShgLi8uLi8uLi8uLi9pbWFnZXMvdGVzdGltb25pYWxzLyR7aXRlbS5pbWFnZX1gKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwicmV2aWV3X19oZWFkZXJcXFwiXFx1MDAzRSBcXHUwMDNDc3BhbiBjbGFzcz1cXFwicmV2aWV3X19hdXRob3ItbmFtZVxcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gaXRlbS5uYW1lKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwicmV2aWV3X19hdXRob3Itc3RhdHVzXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBpdGVtLnN0YXR1cykgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZhcnRpY2xlXFx1MDAzRVwiO1xuICAgIH1cbiAgfVxufSkuY2FsbCh0aGlzKTtcbjtyZXR1cm4gcHVnX2h0bWw7fTtcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9062\n")},1426:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"footer__row\\"\\u003E \\u003Cdiv class=\\"footer__desc\\"\\u003E \\u003Cimg" + (" class=\\"footer__logo logo\\""+pug.attr("src", __webpack_require__(3734), true, true)) + "\\u003E\\u003Cp class=\\"footer__text\\"\\u003EWanderlust meets wander well – Experience seamless travel with our services.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"footer__nav\\"\\u003E \\u003Cdiv class=\\"footer__nav-item\\"\\u003E\\u003Ch4\\u003ECompany\\u003C\\u002Fh4\\u003E\\u003Cul class=\\"footer__nav-list\\"\\u003E ";\n// iterate [\'About Us\', \'Blog\', \'Customers\', \'Packages\', \'Community\']\n;(function(){\n  var $$obj = [\'About Us\', \'Blog\', \'Customers\', \'Packages\', \'Community\'];\n  if (\'number\' == typeof $$obj.length) {\n      for (var pug_index0 = 0, $$l = $$obj.length; pug_index0 < $$l; pug_index0++) {\n        var item = $$obj[pug_index0];\npug_html = pug_html + "\\u003Cli\\u003E \\u003Ca href=\\"#\\"\\u003E" + (pug.escape(null == (pug_interp = item) ? "" : pug_interp)) + "\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E";\n      }\n  } else {\n    var $$l = 0;\n    for (var pug_index0 in $$obj) {\n      $$l++;\n      var item = $$obj[pug_index0];\npug_html = pug_html + "\\u003Cli\\u003E \\u003Ca href=\\"#\\"\\u003E" + (pug.escape(null == (pug_interp = item) ? "" : pug_interp)) + "\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + "\\u003C\\u002Ful\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"footer__nav-item\\"\\u003E\\u003Ch4\\u003EHelp\\u003C\\u002Fh4\\u003E\\u003Cul class=\\"footer__nav-list\\"\\u003E ";\n// iterate [\'Support\', \'FAQs\', \'Refund Policy\']\n;(function(){\n  var $$obj = [\'Support\', \'FAQs\', \'Refund Policy\'];\n  if (\'number\' == typeof $$obj.length) {\n      for (var pug_index1 = 0, $$l = $$obj.length; pug_index1 < $$l; pug_index1++) {\n        var item = $$obj[pug_index1];\npug_html = pug_html + "\\u003Cli\\u003E \\u003Ca href=\\"#\\"\\u003E" + (pug.escape(null == (pug_interp = item) ? "" : pug_interp)) + "\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E";\n      }\n  } else {\n    var $$l = 0;\n    for (var pug_index1 in $$obj) {\n      $$l++;\n      var item = $$obj[pug_index1];\npug_html = pug_html + "\\u003Cli\\u003E \\u003Ca href=\\"#\\"\\u003E" + (pug.escape(null == (pug_interp = item) ? "" : pug_interp)) + "\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + "\\u003C\\u002Ful\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSxxTUFBcU0sbUJBQU8sQ0FBQyxJQUFnQztBQUN2VDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrSUFBa0k7QUFDbEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy9mb290ZXIucHVnPzJkNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1ZyA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1Zy1ydW50aW1lL2luZGV4LmpzXCIpO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHt2YXIgcHVnX2h0bWwgPSBcIlwiLCBwdWdfbWl4aW5zID0ge30sIHB1Z19pbnRlcnA7cHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9vdGVyX19yb3dcXFwiXFx1MDAzRSBcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb290ZXJfX2Rlc2NcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAoXCIgY2xhc3M9XFxcImZvb3Rlcl9fbG9nbyBsb2dvXFxcIlwiK3B1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vaW1hZ2VzL25hdmJhci9sb2dvLnN2ZycpLCB0cnVlLCB0cnVlKSkgKyBcIlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwiZm9vdGVyX190ZXh0XFxcIlxcdTAwM0VXYW5kZXJsdXN0IG1lZXRzIHdhbmRlciB3ZWxsIOKAkyBFeHBlcmllbmNlIHNlYW1sZXNzIHRyYXZlbCB3aXRoIG91ciBzZXJ2aWNlcy5cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9vdGVyX19uYXZcXFwiXFx1MDAzRSBcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb290ZXJfX25hdi1pdGVtXFxcIlxcdTAwM0VcXHUwMDNDaDRcXHUwMDNFQ29tcGFueVxcdTAwM0NcXHUwMDJGaDRcXHUwMDNFXFx1MDAzQ3VsIGNsYXNzPVxcXCJmb290ZXJfX25hdi1saXN0XFxcIlxcdTAwM0UgXCI7XG4vLyBpdGVyYXRlIFsnQWJvdXQgVXMnLCAnQmxvZycsICdDdXN0b21lcnMnLCAnUGFja2FnZXMnLCAnQ29tbXVuaXR5J11cbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0gWydBYm91dCBVcycsICdCbG9nJywgJ0N1c3RvbWVycycsICdQYWNrYWdlcycsICdDb21tdW5pdHknXTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHB1Z19pbmRleDAgPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7IHB1Z19pbmRleDAgPCAkJGw7IHB1Z19pbmRleDArKykge1xuICAgICAgICB2YXIgaXRlbSA9ICQkb2JqW3B1Z19pbmRleDBdO1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2xpXFx1MDAzRSBcXHUwMDNDYSBocmVmPVxcXCIjXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBpdGVtKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmxpXFx1MDAzRVwiO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyIHB1Z19pbmRleDAgaW4gJCRvYmopIHtcbiAgICAgICQkbCsrO1xuICAgICAgdmFyIGl0ZW0gPSAkJG9ialtwdWdfaW5kZXgwXTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NsaVxcdTAwM0UgXFx1MDAzQ2EgaHJlZj1cXFwiI1xcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gaXRlbSkgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRmFcXHUwMDNFXFx1MDAzQ1xcdTAwMkZsaVxcdTAwM0VcIjtcbiAgICB9XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NcXHUwMDJGdWxcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9vdGVyX19uYXYtaXRlbVxcXCJcXHUwMDNFXFx1MDAzQ2g0XFx1MDAzRUhlbHBcXHUwMDNDXFx1MDAyRmg0XFx1MDAzRVxcdTAwM0N1bCBjbGFzcz1cXFwiZm9vdGVyX19uYXYtbGlzdFxcXCJcXHUwMDNFIFwiO1xuLy8gaXRlcmF0ZSBbJ1N1cHBvcnQnLCAnRkFRcycsICdSZWZ1bmQgUG9saWN5J11cbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0gWydTdXBwb3J0JywgJ0ZBUXMnLCAnUmVmdW5kIFBvbGljeSddO1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcHVnX2luZGV4MSA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsgcHVnX2luZGV4MSA8ICQkbDsgcHVnX2luZGV4MSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gJCRvYmpbcHVnX2luZGV4MV07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDbGlcXHUwMDNFIFxcdTAwM0NhIGhyZWY9XFxcIiNcXFwiXFx1MDAzRVwiICsgKHB1Zy5lc2NhcGUobnVsbCA9PSAocHVnX2ludGVycCA9IGl0ZW0pID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZhXFx1MDAzRVxcdTAwM0NcXHUwMDJGbGlcXHUwMDNFXCI7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIgcHVnX2luZGV4MSBpbiAkJG9iaikge1xuICAgICAgJCRsKys7XG4gICAgICB2YXIgaXRlbSA9ICQkb2JqW3B1Z19pbmRleDFdO1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2xpXFx1MDAzRSBcXHUwMDNDYSBocmVmPVxcXCIjXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBpdGVtKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmxpXFx1MDAzRVwiO1xuICAgIH1cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ1xcdTAwMkZ1bFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1426\n')},5712:function(module,__unused_webpack_exports,__webpack_require__){eval("var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Cheader class=\\\"header\\\"\\u003E\\u003Cdiv class=\\\"container\\\"\\u003E\\u003Cnav class=\\\"nav\\\"\\u003E \\u003Ca class=\\\"logo\\\"\\u003E\\u003Cimg\" + (pug.attr(\"src\", __webpack_require__(3734), true, true)+\" alt=\\\"logo\\\"\") + \"\\u003E\\u003C\\u002Fa\\u003E\\u003Cul class=\\\"nav__list\\\"\\u003E\";\n// iterate {'Home': '/', 'About': '/about', 'Packages': '/packages', 'FAQ': '/faq', 'Community': '/community'}\n;(function(){\n  var $$obj = {'Home': '/', 'About': '/about', 'Packages': '/packages', 'FAQ': '/faq', 'Community': '/community'};\n  if ('number' == typeof $$obj.length) {\n      for (var key = 0, $$l = $$obj.length; key < $$l; key++) {\n        var item = $$obj[key];\npug_html = pug_html + \"\\u003Cli class=\\\"nav__item\\\"\\u003E\\u003Ca\" + (pug.attr(\"href\", item, true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\";\n      }\n  } else {\n    var $$l = 0;\n    for (var key in $$obj) {\n      $$l++;\n      var item = $$obj[key];\npug_html = pug_html + \"\\u003Cli class=\\\"nav__item\\\"\\u003E\\u003Ca\" + (pug.attr(\"href\", item, true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + \"\\u003C\\u002Ful\\u003E\\u003Cdiv class=\\\"nav__buttons\\\"\\u003E\";\n// iterate {'Login':['/login', 'login-button'], 'Sign Up':['/sidn', 'sign-button']}\n;(function(){\n  var $$obj = {'Login':['/login', 'login-button'], 'Sign Up':['/sidn', 'sign-button']};\n  if ('number' == typeof $$obj.length) {\n      for (var key = 0, $$l = $$obj.length; key < $$l; key++) {\n        var item = $$obj[key];\npug_html = pug_html + \"\\u003Ca\" + (pug.attr(\"class\", pug.classes([item[1]], [true]), false, true)+pug.attr(\"href\", item[0], true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\";\n      }\n  } else {\n    var $$l = 0;\n    for (var key in $$obj) {\n      $$l++;\n      var item = $$obj[key];\npug_html = pug_html + \"\\u003Ca\" + (pug.attr(\"class\", pug.classes([item[1]], [true]), false, true)+pug.attr(\"href\", item[0], true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + \"\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"nav__burger-icon\\\"\\u003E \\u003Cdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"nav__mobile-menu hidden\\\"\\u003E\\u003Cul class=\\\"nav__mobile-list\\\"\\u003E\";\n// iterate {'Home': '/', 'About': '/about', 'Packages': '/packages', 'FAQ': '/faq', 'Community': '/community'}\n;(function(){\n  var $$obj = {'Home': '/', 'About': '/about', 'Packages': '/packages', 'FAQ': '/faq', 'Community': '/community'};\n  if ('number' == typeof $$obj.length) {\n      for (var key = 0, $$l = $$obj.length; key < $$l; key++) {\n        var item = $$obj[key];\npug_html = pug_html + \"\\u003Cli class=\\\"nav__mobile-item\\\"\\u003E\\u003Ca\" + (pug.attr(\"href\", item, true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\";\n      }\n  } else {\n    var $$l = 0;\n    for (var key in $$obj) {\n      $$l++;\n      var item = $$obj[key];\npug_html = pug_html + \"\\u003Cli class=\\\"nav__mobile-item\\\"\\u003E\\u003Ca\" + (pug.attr(\"href\", item, true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + \"\\u003C\\u002Ful\\u003E\\u003Cdiv class=\\\"nav__mobile-buttons\\\"\\u003E\";\n// iterate {'Login':['/login', 'login-button'], 'Sign Up':['/sidn', 'sign-button']}\n;(function(){\n  var $$obj = {'Login':['/login', 'login-button'], 'Sign Up':['/sidn', 'sign-button']};\n  if ('number' == typeof $$obj.length) {\n      for (var key = 0, $$l = $$obj.length; key < $$l; key++) {\n        var item = $$obj[key];\npug_html = pug_html + \"\\u003Ca\" + (pug.attr(\"class\", pug.classes([item[1]], [true]), false, true)+pug.attr(\"href\", item[0], true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\";\n      }\n  } else {\n    var $$l = 0;\n    for (var key in $$obj) {\n      $$l++;\n      var item = $$obj[key];\npug_html = pug_html + \"\\u003Ca\" + (pug.attr(\"class\", pug.classes([item[1]], [true]), false, true)+pug.attr(\"href\", item[0], true, true)) + \"\\u003E\" + (pug.escape(null == (pug_interp = key) ? \"\" : pug_interp)) + \"\\u003C\\u002Fa\\u003E\";\n    }\n  }\n}).call(this);\n\npug_html = pug_html + \"\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fnav\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fheader\\u003E\";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcxMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSxxTEFBcUwsbUJBQU8sQ0FBQyxJQUFnQztBQUN2UyxZQUFZO0FBQ1osQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0lBQXNJO0FBQ3RJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9zcmMvaHRtbC9ibG9ja3MvaGVhZGVyLnB1Zz84MWViIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO3B1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NoZWFkZXIgY2xhc3M9XFxcImhlYWRlclxcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0VcXHUwMDNDbmF2IGNsYXNzPVxcXCJuYXZcXFwiXFx1MDAzRSBcXHUwMDNDYSBjbGFzcz1cXFwibG9nb1xcXCJcXHUwMDNFXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vaW1hZ2VzL25hdmJhci9sb2dvLnN2ZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcImxvZ29cXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZhXFx1MDAzRVxcdTAwM0N1bCBjbGFzcz1cXFwibmF2X19saXN0XFxcIlxcdTAwM0VcIjtcbi8vIGl0ZXJhdGUgeydIb21lJzogJy8nLCAnQWJvdXQnOiAnL2Fib3V0JywgJ1BhY2thZ2VzJzogJy9wYWNrYWdlcycsICdGQVEnOiAnL2ZhcScsICdDb21tdW5pdHknOiAnL2NvbW11bml0eSd9XG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IHsnSG9tZSc6ICcvJywgJ0Fib3V0JzogJy9hYm91dCcsICdQYWNrYWdlcyc6ICcvcGFja2FnZXMnLCAnRkFRJzogJy9mYXEnLCAnQ29tbXVuaXR5JzogJy9jb21tdW5pdHknfTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGtleSA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsga2V5IDwgJCRsOyBrZXkrKykge1xuICAgICAgICB2YXIgaXRlbSA9ICQkb2JqW2tleV07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDbGkgY2xhc3M9XFxcIm5hdl9faXRlbVxcXCJcXHUwMDNFXFx1MDAzQ2FcIiArIChwdWcuYXR0cihcImhyZWZcIiwgaXRlbSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0ga2V5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmxpXFx1MDAzRVwiO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciAkJGwgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiAkJG9iaikge1xuICAgICAgJCRsKys7XG4gICAgICB2YXIgaXRlbSA9ICQkb2JqW2tleV07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDbGkgY2xhc3M9XFxcIm5hdl9faXRlbVxcXCJcXHUwMDNFXFx1MDAzQ2FcIiArIChwdWcuYXR0cihcImhyZWZcIiwgaXRlbSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0ga2V5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmxpXFx1MDAzRVwiO1xuICAgIH1cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ1xcdTAwMkZ1bFxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJuYXZfX2J1dHRvbnNcXFwiXFx1MDAzRVwiO1xuLy8gaXRlcmF0ZSB7J0xvZ2luJzpbJy9sb2dpbicsICdsb2dpbi1idXR0b24nXSwgJ1NpZ24gVXAnOlsnL3NpZG4nLCAnc2lnbi1idXR0b24nXX1cbjsoZnVuY3Rpb24oKXtcbiAgdmFyICQkb2JqID0geydMb2dpbic6WycvbG9naW4nLCAnbG9naW4tYnV0dG9uJ10sICdTaWduIFVwJzpbJy9zaWRuJywgJ3NpZ24tYnV0dG9uJ119O1xuICBpZiAoJ251bWJlcicgPT0gdHlwZW9mICQkb2JqLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5ID0gMCwgJCRsID0gJCRvYmoubGVuZ3RoOyBrZXkgPCAkJGw7IGtleSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gJCRvYmpba2V5XTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NhXCIgKyAocHVnLmF0dHIoXCJjbGFzc1wiLCBwdWcuY2xhc3NlcyhbaXRlbVsxXV0sIFt0cnVlXSksIGZhbHNlLCB0cnVlKStwdWcuYXR0cihcImhyZWZcIiwgaXRlbVswXSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0ga2V5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcIjtcbiAgICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRsID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gJCRvYmopIHtcbiAgICAgICQkbCsrO1xuICAgICAgdmFyIGl0ZW0gPSAkJG9ialtrZXldO1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2FcIiArIChwdWcuYXR0cihcImNsYXNzXCIsIHB1Zy5jbGFzc2VzKFtpdGVtWzFdXSwgW3RydWVdKSwgZmFsc2UsIHRydWUpK3B1Zy5hdHRyKFwiaHJlZlwiLCBpdGVtWzBdLCB0cnVlLCB0cnVlKSkgKyBcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBrZXkpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZhXFx1MDAzRVwiO1xuICAgIH1cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwibmF2X19idXJnZXItaWNvblxcXCJcXHUwMDNFIFxcdTAwM0NkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwibmF2X19tb2JpbGUtbWVudSBoaWRkZW5cXFwiXFx1MDAzRVxcdTAwM0N1bCBjbGFzcz1cXFwibmF2X19tb2JpbGUtbGlzdFxcXCJcXHUwMDNFXCI7XG4vLyBpdGVyYXRlIHsnSG9tZSc6ICcvJywgJ0Fib3V0JzogJy9hYm91dCcsICdQYWNrYWdlcyc6ICcvcGFja2FnZXMnLCAnRkFRJzogJy9mYXEnLCAnQ29tbXVuaXR5JzogJy9jb21tdW5pdHknfVxuOyhmdW5jdGlvbigpe1xuICB2YXIgJCRvYmogPSB7J0hvbWUnOiAnLycsICdBYm91dCc6ICcvYWJvdXQnLCAnUGFja2FnZXMnOiAnL3BhY2thZ2VzJywgJ0ZBUSc6ICcvZmFxJywgJ0NvbW11bml0eSc6ICcvY29tbXVuaXR5J307XG4gIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgJCRvYmoubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgPSAwLCAkJGwgPSAkJG9iai5sZW5ndGg7IGtleSA8ICQkbDsga2V5KyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAkJG9ialtrZXldO1xucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2xpIGNsYXNzPVxcXCJuYXZfX21vYmlsZS1pdGVtXFxcIlxcdTAwM0VcXHUwMDNDYVwiICsgKHB1Zy5hdHRyKFwiaHJlZlwiLCBpdGVtLCB0cnVlLCB0cnVlKSkgKyBcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBrZXkpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZhXFx1MDAzRVxcdTAwM0NcXHUwMDJGbGlcXHUwMDNFXCI7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluICQkb2JqKSB7XG4gICAgICAkJGwrKztcbiAgICAgIHZhciBpdGVtID0gJCRvYmpba2V5XTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NsaSBjbGFzcz1cXFwibmF2X19tb2JpbGUtaXRlbVxcXCJcXHUwMDNFXFx1MDAzQ2FcIiArIChwdWcuYXR0cihcImhyZWZcIiwgaXRlbSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0ga2V5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmxpXFx1MDAzRVwiO1xuICAgIH1cbiAgfVxufSkuY2FsbCh0aGlzKTtcblxucHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ1xcdTAwMkZ1bFxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJuYXZfX21vYmlsZS1idXR0b25zXFxcIlxcdTAwM0VcIjtcbi8vIGl0ZXJhdGUgeydMb2dpbic6WycvbG9naW4nLCAnbG9naW4tYnV0dG9uJ10sICdTaWduIFVwJzpbJy9zaWRuJywgJ3NpZ24tYnV0dG9uJ119XG47KGZ1bmN0aW9uKCl7XG4gIHZhciAkJG9iaiA9IHsnTG9naW4nOlsnL2xvZ2luJywgJ2xvZ2luLWJ1dHRvbiddLCAnU2lnbiBVcCc6Wycvc2lkbicsICdzaWduLWJ1dHRvbiddfTtcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiAkJG9iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGtleSA9IDAsICQkbCA9ICQkb2JqLmxlbmd0aDsga2V5IDwgJCRsOyBrZXkrKykge1xuICAgICAgICB2YXIgaXRlbSA9ICQkb2JqW2tleV07XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDYVwiICsgKHB1Zy5hdHRyKFwiY2xhc3NcIiwgcHVnLmNsYXNzZXMoW2l0ZW1bMV1dLCBbdHJ1ZV0pLCBmYWxzZSwgdHJ1ZSkrcHVnLmF0dHIoXCJocmVmXCIsIGl0ZW1bMF0sIHRydWUsIHRydWUpKSArIFwiXFx1MDAzRVwiICsgKHB1Zy5lc2NhcGUobnVsbCA9PSAocHVnX2ludGVycCA9IGtleSkgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRmFcXHUwMDNFXCI7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICQkbCA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluICQkb2JqKSB7XG4gICAgICAkJGwrKztcbiAgICAgIHZhciBpdGVtID0gJCRvYmpba2V5XTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NhXCIgKyAocHVnLmF0dHIoXCJjbGFzc1wiLCBwdWcuY2xhc3NlcyhbaXRlbVsxXV0sIFt0cnVlXSksIGZhbHNlLCB0cnVlKStwdWcuYXR0cihcImhyZWZcIiwgaXRlbVswXSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0ga2V5KSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGYVxcdTAwM0VcIjtcbiAgICB9XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGbmF2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGaGVhZGVyXFx1MDAzRVwiOztyZXR1cm4gcHVnX2h0bWw7fTtcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5712\n")},6262:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Csection class=\\"partners\\"\\u003E \\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"partners__row\\"\\u003E \\u003Ch2 class=\\"partners__title title-4\\"\\u003EOur Travel Partner\\u003C\\u002Fh2\\u003E\\u003Cdiv class=\\"partners__content\\"\\u003E\\u003Cimg" + (pug.attr("src", __webpack_require__(7713), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (pug.attr("src", __webpack_require__(7196), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (pug.attr("src", __webpack_require__(2870), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (pug.attr("src", __webpack_require__(9841), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (pug.attr("src", __webpack_require__(1892), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI2Mi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSx5U0FBeVMsbUJBQU8sQ0FBQyxJQUF1QyxtRUFBbUUsbUJBQU8sQ0FBQyxJQUFvQyxtRUFBbUUsbUJBQU8sQ0FBQyxJQUFxQyxtRUFBbUUsbUJBQU8sQ0FBQyxJQUF3QyxtRUFBbUUsbUJBQU8sQ0FBQyxJQUErQyxnSUFBZ0k7QUFDOStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9zcmMvaHRtbC9ibG9ja3MvcGFydG5lcnMucHVnPzMxN2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1ZyA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1Zy1ydW50aW1lL2luZGV4LmpzXCIpO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHt2YXIgcHVnX2h0bWwgPSBcIlwiLCBwdWdfbWl4aW5zID0ge30sIHB1Z19pbnRlcnA7cHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ3NlY3Rpb24gY2xhc3M9XFxcInBhcnRuZXJzXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwicGFydG5lcnNfX3Jvd1xcXCJcXHUwMDNFIFxcdTAwM0NoMiBjbGFzcz1cXFwicGFydG5lcnNfX3RpdGxlIHRpdGxlLTRcXFwiXFx1MDAzRU91ciBUcmF2ZWwgUGFydG5lclxcdTAwM0NcXHUwMDJGaDJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwicGFydG5lcnNfX2NvbnRlbnRcXFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uL2ltYWdlcy9wYXJ0bmVycy90cmF2ZWxva2Euc3ZnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uL2ltYWdlcy9wYXJ0bmVycy9haXJibmIuc3ZnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uL2ltYWdlcy9wYXJ0bmVycy9leHBlZGlhLnN2ZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi8uLi9pbWFnZXMvcGFydG5lcnMvc2t5c2Nhbm5lci5zdmcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vaW1hZ2VzL3BhcnRuZXJzL2FtZXJpY2FuLWFpcmxpbmVzLnN2ZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNlY3Rpb25cXHUwMDNFXCI7O3JldHVybiBwdWdfaHRtbDt9O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6262\n')},3098:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Csection class=\\"popular\\"\\u003E \\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"popular__header\\"\\u003E \\u003Cdiv class=\\"popular__title\\"\\u003E \\u003Ch2 class=\\"title-3\\"\\u003EPopular Destinations\\u003C\\u002Fh2\\u003E\\u003Cp class=\\"text\\"\\u003ESee our popular destinations that our client choose\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"popular__buttons\\"\\u003E \\u003Cbutton class=\\"popular__prew\\" type=\\"button\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(1268), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cbutton class=\\"popular__next\\" type=\\"button\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(6063), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"popular__content\\"\\u003E \\u003Cdiv class=\\"swiper\\"\\u003E \\u003Cdiv class=\\"swiper-wrapper\\"\\u003E " + (null == (pug_interp = (__webpack_require__(4345).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA5OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSx1ZkFBdWYsbUJBQU8sQ0FBQyxJQUFzQyxzSkFBc0osbUJBQU8sQ0FBQyxJQUFzQywrU0FBK1MsZ0NBQTBDLHNKQUFzSjtBQUNseUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy9wb3B1bGFyLnB1Zz8wOTFkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO3B1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NzZWN0aW9uIGNsYXNzPVxcXCJwb3B1bGFyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwicG9wdWxhcl9faGVhZGVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwicG9wdWxhcl9fdGl0bGVcXFwiXFx1MDAzRSBcXHUwMDNDaDIgY2xhc3M9XFxcInRpdGxlLTNcXFwiXFx1MDAzRVBvcHVsYXIgRGVzdGluYXRpb25zXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwidGV4dFxcXCJcXHUwMDNFU2VlIG91ciBwb3B1bGFyIGRlc3RpbmF0aW9ucyB0aGF0IG91ciBjbGllbnQgY2hvb3NlXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInBvcHVsYXJfX2J1dHRvbnNcXFwiXFx1MDAzRSBcXHUwMDNDYnV0dG9uIGNsYXNzPVxcXCJwb3B1bGFyX19wcmV3XFxcIiB0eXBlPVxcXCJidXR0b25cXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi8uLi9pbWFnZXMvaWNvbnMvYnV0dG9uX3ByZXcuc3ZnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGYnV0dG9uXFx1MDAzRVxcdTAwM0NidXR0b24gY2xhc3M9XFxcInBvcHVsYXJfX25leHRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCJcXHUwMDNFIFxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uL2ltYWdlcy9pY29ucy9idXR0b24tbmV4dC5zdmcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZidXR0b25cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJwb3B1bGFyX19jb250ZW50XFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwic3dpcGVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwic3dpcGVyLXdyYXBwZXJcXFwiXFx1MDAzRSBcIiArIChudWxsID09IChwdWdfaW50ZXJwID0gcmVxdWlyZShcIi4vZWxlbWVudHMvZGVzdGluYXRpb24ucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VjdGlvblxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3098\n')},4591:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Csection class=\\"services\\"\\u003E\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"services__blocks\\"\\u003E \\u003Cdiv class=\\"services__description\\"\\u003E \\u003Ch2 class=\\"title-2 services__title\\"\\u003EEmbark on unforgettable journeys with our premium travel services\\u003C\\u002Fh2\\u003E\\u003Cp class=\\"text services__text\\"\\u003EPicture-perfect getaways are just a click away. Find your slice of paradise, whether it\'s a tropical island, a charming city, or an enchanting countryside retreat.\\u003C\\u002Fp\\u003E\\u003Cdiv class=\\"services__advantages\\"\\u003E \\u003Cdiv class=\\"service__advantage-item\\"\\u003E \\u003Cspan\\u003E1\\u003C\\u002Fspan\\u003E\\u003Ch3\\u003EBest Choice\\u003C\\u002Fh3\\u003E\\u003Cp\\u003EWe always prioritize our customer comfort and satisfaction. That’s why we only accept the best hotel and destination\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"service__advantage-item\\"\\u003E \\u003Cspan\\u003E2\\u003C\\u002Fspan\\u003E\\u003Ch3\\u003ECompetitive Prices\\u003C\\u002Fh3\\u003E\\u003Cp\\u003EAltough the price tends to be cheaper but it will not affect the quality of service\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"service__advantage-item\\"\\u003E\\u003Cspan\\u003E3\\u003C\\u002Fspan\\u003E\\u003Ch3\\u003ERefund and Reschedule\\u003C\\u002Fh3\\u003E\\u003Cp\\u003EDon’t worry if suddenly you have problem and want to reschule or refund, you can get fully.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"services__image\\"\\u003E\\u003Cimg" + (" class=\\"services__image-1\\""+pug.attr("src", __webpack_require__(3651), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (" class=\\"services__image\\""+pug.attr("src", __webpack_require__(9172), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cimg" + (" class=\\"services__image\\""+pug.attr("src", __webpack_require__(2897), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cdiv class=\\"services__custtomers\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(1727), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cp class=\\"services__custtomers-text\\"\\u003E\\u003Cspan\\u003E10K+\\u003C\\u002Fspan\\u003E Satisfied Customer\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU5MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSxta0RBQW1rRCxtQkFBTyxDQUFDLElBQWdDLGdHQUFnRyxtQkFBTyxDQUFDLElBQWdDLGdHQUFnRyxtQkFBTyxDQUFDLElBQWdDLGtIQUFrSCxtQkFBTyxDQUFDLElBQXVDLHNSQUFzUjtBQUM1M0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy9zZXJ2aWNlcy5wdWc/NjdlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHVnID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanNcIik7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge3ZhciBwdWdfaHRtbCA9IFwiXCIsIHB1Z19taXhpbnMgPSB7fSwgcHVnX2ludGVycDtwdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDc2VjdGlvbiBjbGFzcz1cXFwic2VydmljZXNcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwic2VydmljZXNfX2Jsb2Nrc1xcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcInNlcnZpY2VzX19kZXNjcmlwdGlvblxcXCJcXHUwMDNFIFxcdTAwM0NoMiBjbGFzcz1cXFwidGl0bGUtMiBzZXJ2aWNlc19fdGl0bGVcXFwiXFx1MDAzRUVtYmFyayBvbiB1bmZvcmdldHRhYmxlIGpvdXJuZXlzIHdpdGggb3VyIHByZW1pdW0gdHJhdmVsIHNlcnZpY2VzXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwidGV4dCBzZXJ2aWNlc19fdGV4dFxcXCJcXHUwMDNFUGljdHVyZS1wZXJmZWN0IGdldGF3YXlzIGFyZSBqdXN0IGEgY2xpY2sgYXdheS4gRmluZCB5b3VyIHNsaWNlIG9mIHBhcmFkaXNlLCB3aGV0aGVyIGl0J3MgYSB0cm9waWNhbCBpc2xhbmQsIGEgY2hhcm1pbmcgY2l0eSwgb3IgYW4gZW5jaGFudGluZyBjb3VudHJ5c2lkZSByZXRyZWF0LlxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJzZXJ2aWNlc19fYWR2YW50YWdlc1xcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcInNlcnZpY2VfX2FkdmFudGFnZS1pdGVtXFxcIlxcdTAwM0UgXFx1MDAzQ3NwYW5cXHUwMDNFMVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDaDNcXHUwMDNFQmVzdCBDaG9pY2VcXHUwMDNDXFx1MDAyRmgzXFx1MDAzRVxcdTAwM0NwXFx1MDAzRVdlIGFsd2F5cyBwcmlvcml0aXplIG91ciBjdXN0b21lciBjb21mb3J0IGFuZCBzYXRpc2ZhY3Rpb24uIFRoYXTigJlzIHdoeSB3ZSBvbmx5IGFjY2VwdCB0aGUgYmVzdCBob3RlbCBhbmQgZGVzdGluYXRpb25cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwic2VydmljZV9fYWR2YW50YWdlLWl0ZW1cXFwiXFx1MDAzRSBcXHUwMDNDc3BhblxcdTAwM0UyXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NoM1xcdTAwM0VDb21wZXRpdGl2ZSBQcmljZXNcXHUwMDNDXFx1MDAyRmgzXFx1MDAzRVxcdTAwM0NwXFx1MDAzRUFsdG91Z2ggdGhlIHByaWNlIHRlbmRzIHRvIGJlIGNoZWFwZXIgYnV0IGl0IHdpbGwgbm90IGFmZmVjdCB0aGUgcXVhbGl0eSBvZiBzZXJ2aWNlXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInNlcnZpY2VfX2FkdmFudGFnZS1pdGVtXFxcIlxcdTAwM0VcXHUwMDNDc3BhblxcdTAwM0UzXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NoM1xcdTAwM0VSZWZ1bmQgYW5kIFJlc2NoZWR1bGVcXHUwMDNDXFx1MDAyRmgzXFx1MDAzRVxcdTAwM0NwXFx1MDAzRURvbuKAmXQgd29ycnkgaWYgc3VkZGVubHkgeW91IGhhdmUgcHJvYmxlbSBhbmQgd2FudCB0byByZXNjaHVsZSBvciByZWZ1bmQsIHlvdSBjYW4gZ2V0IGZ1bGx5LlxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJzZXJ2aWNlc19faW1hZ2VcXFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChcIiBjbGFzcz1cXFwic2VydmljZXNfX2ltYWdlLTFcXFwiXCIrcHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi8uLi9pbWFnZXMvc2VydmljZXMvMDEuanBnJyksIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChcIiBjbGFzcz1cXFwic2VydmljZXNfX2ltYWdlXFxcIlwiK3B1Zy5hdHRyKFwic3JjXCIsIHJlcXVpcmUoJy4vLi4vLi4vaW1hZ2VzL3NlcnZpY2VzLzAyLmpwZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDaW1nXCIgKyAoXCIgY2xhc3M9XFxcInNlcnZpY2VzX19pbWFnZVxcXCJcIitwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uLy4uL2ltYWdlcy9zZXJ2aWNlcy8wMy5qcGcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwic2VydmljZXNfX2N1c3R0b21lcnNcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi8uLi9pbWFnZXMvc2VydmljZXMvY3VzdG9tZXJzLnBuZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwic2VydmljZXNfX2N1c3R0b21lcnMtdGV4dFxcXCJcXHUwMDNFXFx1MDAzQ3NwYW5cXHUwMDNFMTBLK1xcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0UgU2F0aXNmaWVkIEN1c3RvbWVyXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VjdGlvblxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4591\n')},8761:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Csection class=\\"subscribe\\"\\u003E\\u003Cdiv class=\\"subscribe__bg\\"\\u003E\\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"subscribe__row\\"\\u003E \\u003Cdiv class=\\"subscribe__desc\\"\\u003E \\u003Ch2 class=\\"subscribe__title\\"\\u003EJoin our newsletter to stay up&nbsp;to&nbsp;date \\u003C\\u002Fh2\\u003E\\u003Cp class=\\"subscribe__text\\"\\u003EStay connected with our brand\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cform class=\\"subscribe__form\\" action=\\"mail\\"\\u003E\\u003Cinput class=\\"subscribe__input\\" type=\\"text\\" placeholder=\\"Enter your email\\"\\u003E\\u003Cbutton class=\\"button subscribe__button\\" type=\\"submit\\"\\u003ESubscribe \\u003C\\u002Fbutton\\u003E\\u003C\\u002Fform\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSx5U0FBeVMsUUFBUSxrZkFBa2Y7QUFDNzJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9zcmMvaHRtbC9ibG9ja3Mvc3Vic2NyaWJlLnB1Zz82YjIwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO3B1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NzZWN0aW9uIGNsYXNzPVxcXCJzdWJzY3JpYmVcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInN1YnNjcmliZV9fYmdcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcInN1YnNjcmliZV9fcm93XFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwic3Vic2NyaWJlX19kZXNjXFxcIlxcdTAwM0UgXFx1MDAzQ2gyIGNsYXNzPVxcXCJzdWJzY3JpYmVfX3RpdGxlXFxcIlxcdTAwM0VKb2luIG91ciBuZXdzbGV0dGVyIHRvIHN0YXkgdXAmbmJzcDt0byZuYnNwO2RhdGUgXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwic3Vic2NyaWJlX190ZXh0XFxcIlxcdTAwM0VTdGF5IGNvbm5lY3RlZCB3aXRoIG91ciBicmFuZFxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZm9ybSBjbGFzcz1cXFwic3Vic2NyaWJlX19mb3JtXFxcIiBhY3Rpb249XFxcIm1haWxcXFwiXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwic3Vic2NyaWJlX19pbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIkVudGVyIHlvdXIgZW1haWxcXFwiXFx1MDAzRVxcdTAwM0NidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBzdWJzY3JpYmVfX2J1dHRvblxcXCIgdHlwZT1cXFwic3VibWl0XFxcIlxcdTAwM0VTdWJzY3JpYmUgXFx1MDAzQ1xcdTAwMkZidXR0b25cXHUwMDNFXFx1MDAzQ1xcdTAwMkZmb3JtXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VjdGlvblxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8761\n')},2815:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Csection class=\\"testimonials\\"\\u003E \\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"testimonials__blocks\\"\\u003E \\u003Cdiv class=\\"testimonials__first-block\\"\\u003E\\u003Cdiv class=\\"swiper-wrapper smooth-transition\\"\\u003E " + (null == (pug_interp = (__webpack_require__(9062).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"testimonials__second-block\\"\\u003E\\u003Cdiv class=\\"swiper-wrapper smooth-transition\\"\\u003E " + (null == (pug_interp = (__webpack_require__(9062).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"testimonials__third-block\\"\\u003E\\u003Cdiv class=\\"swiper-wrapper smooth-transition\\"\\u003E " + (null == (pug_interp = (__webpack_require__(9062).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"testimonials__horizontal-slider\\"\\u003E\\u003Cdiv class=\\"swiper-wrapper smooth-transition\\"\\u003E " + (null == (pug_interp = (__webpack_require__(9062).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgxNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBNkM7O0FBRS9ELDJCQUEyQixrQ0FBa0MsYUFBYSw4UkFBOFIsZ0NBQXNDLDBOQUEwTixnQ0FBc0MseU5BQXlOLGdDQUFzQyxvUEFBb1AsZ0NBQXNDLGlJQUFpSTtBQUN4eUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwYWNrX3dlYi8uL3NyYy9odG1sL2Jsb2Nrcy90ZXN0aW1vbmlhbHMucHVnPzRiYTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1ZyA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1Zy1ydW50aW1lL2luZGV4LmpzXCIpO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHt2YXIgcHVnX2h0bWwgPSBcIlwiLCBwdWdfbWl4aW5zID0ge30sIHB1Z19pbnRlcnA7cHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ3NlY3Rpb24gY2xhc3M9XFxcInRlc3RpbW9uaWFsc1xcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcInRlc3RpbW9uaWFsc19fYmxvY2tzXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwidGVzdGltb25pYWxzX19maXJzdC1ibG9ja1xcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwic3dpcGVyLXdyYXBwZXIgc21vb3RoLXRyYW5zaXRpb25cXFwiXFx1MDAzRSBcIiArIChudWxsID09IChwdWdfaW50ZXJwID0gcmVxdWlyZShcIi4vZWxlbWVudHMvcmV2aWV3cy5wdWdcIikuY2FsbCh0aGlzLCBsb2NhbHMpKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSArIFwiXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwidGVzdGltb25pYWxzX19zZWNvbmQtYmxvY2tcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInN3aXBlci13cmFwcGVyIHNtb290aC10cmFuc2l0aW9uXFxcIlxcdTAwM0UgXCIgKyAobnVsbCA9PSAocHVnX2ludGVycCA9IHJlcXVpcmUoXCIuL2VsZW1lbnRzL3Jldmlld3MucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInRlc3RpbW9uaWFsc19fdGhpcmQtYmxvY2tcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInN3aXBlci13cmFwcGVyIHNtb290aC10cmFuc2l0aW9uXFxcIlxcdTAwM0UgXCIgKyAobnVsbCA9PSAocHVnX2ludGVycCA9IHJlcXVpcmUoXCIuL2VsZW1lbnRzL3Jldmlld3MucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInRlc3RpbW9uaWFsc19faG9yaXpvbnRhbC1zbGlkZXJcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInN3aXBlci13cmFwcGVyIHNtb290aC10cmFuc2l0aW9uXFxcIlxcdTAwM0UgXCIgKyAobnVsbCA9PSAocHVnX2ludGVycCA9IHJlcXVpcmUoXCIuL2VsZW1lbnRzL3Jldmlld3MucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VjdGlvblxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2815\n')},4278:function(module,__unused_webpack_exports,__webpack_require__){eval('var pug = __webpack_require__(7766);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003C!DOCTYPE html\\u003E\\u003Chtml lang=\\"en\\"\\u003E\\u003Chead\\u003E\\u003Cmeta charset=\\"UTF-8\\"\\u003E\\u003Cmeta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\"\\u003E\\u003Ctitle\\u003ETravel agent\\u003C\\u002Ftitle\\u003E\\u003C\\u002Fhead\\u003E\\u003Cbody\\u003E" + (null == (pug_interp = (__webpack_require__(5712).call)(this, locals)) ? "" : pug_interp) + "\\u003Cmain class=\\"main\\"\\u003E\\u003Csection class=\\"discover\\"\\u003E\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"discover__blocks\\"\\u003E\\u003Cdiv class=\\"discover__desc\\"\\u003E \\u003Cdiv class=\\"discover__title\\"\\u003E \\u003Ch1 class=\\"title-1 title-1--decor\\"\\u003EDiscover your favorite place with us\\u003C\\u002Fh1\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"discover__text text\\"\\u003E \\u003Cp\\u003EYour journey begins here with our curated travel experiences. Discover new horizons, create lasting memories, and explore the world with our expertly crafted itineraries.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"discover__form\\"\\u003E \\u003Cform class=\\"search-form\\" action=\\"search-form\\" mehod=\\"\\"\\u003E\\u003Clabel class=\\"search-form__label search-form__label--map\\" for=\\"location\\" name=\\"location\\"\\u003E\\u003Cspan\\u003ELocations\\u003C\\u002Fspan\\u003E\\u003Cinput id=\\"location\\" autocomplete=\\"off\\" type=\\"text\\" placeholder=\\"e.g Bali, Indonesia\\"\\u003E\\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\"search-form__devider\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Clabel class=\\"search-form__label search-form__label--calendar\\" for=\\"date\\" name=\\"date\\"\\u003E\\u003Cspan\\u003EDate and time\\u003C\\u002Fspan\\u003E\\u003Cinput id=\\"date\\" autocomplete=\\"off\\" type=\\"text\\" placeholder=\\"DD\\u002FMM\\u002FYYYY\\"\\u003E\\u003C\\u002Flabel\\u003E\\u003Cbutton class=\\"search-form__button\\" type=\\"submit\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(6980), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fform\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"discover__picture\\"\\u003E\\u003Cdiv class=\\"discover__image\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(3867), true, true)+" alt=\\"\\"") + "\\u003E\\u003C\\u002Fdiv\\u003E";\npug_mixins["marketing-element"] = pug_interp = function(name, img, price, raiting){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\npug_html = pug_html + "\\u003Cdiv" + (pug.attr("class", pug.classes(["marketing",name], [false,true]), false, true)) + "\\u003E\\u003Cimg" + (pug.attr("src", img, true, true)+" alt=\\"\\"") + "\\u003E\\u003Cdiv class=\\"marketing__description\\"\\u003E \\u003Cdiv class=\\"marketing__title\\"\\u003E Heaven Resort\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"marketing__price\\"\\u003E Starts from \\u003Cspan class=\\"explore-marketing__price--dollor\\"\\u003E$\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"explore-marketing__price--summ\\"\\u003E" + (pug.escape(null == (pug_interp = price) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"marketing__rating\\"\\u003E" + (pug.escape(null == (pug_interp = raiting) ? "" : pug_interp)) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";\n};\npug_mixins["marketing-element"](\'discover-marketing\', __webpack_require__(5190), 400, (4.5));\npug_html = pug_html + "\\u003Cdiv class=\\"discover__scroll\\"\\u003E \\u003Cdiv class=\\"scroll__block\\"\\u003E\\u003Cimg" + (" class=\\"scroll__text\\""+pug.attr("src", __webpack_require__(5896), true, true)) + "\\u003E\\u003Cimg" + (" class=\\"scroll__icon\\""+pug.attr("src", __webpack_require__(8056), true, true)) + "\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fsection\\u003E" + (null == (pug_interp = (__webpack_require__(6262).call)(this, locals)) ? "" : pug_interp) + (null == (pug_interp = (__webpack_require__(3098).call)(this, locals)) ? "" : pug_interp) + (null == (pug_interp = (__webpack_require__(4591).call)(this, locals)) ? "" : pug_interp) + "\\u003Cdiv class=\\"explore\\"\\u003E \\u003Cdiv class=\\"container\\"\\u003E \\u003Cdiv class=\\"explore__blocks\\"\\u003E \\u003Cdiv class=\\"explore__image\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(6198), true, true)+" alt=\\"\\"") + "\\u003E";\npug_mixins["marketing-element"] = pug_interp = function(name, img, price, raiting){\nvar block = (this && this.block), attributes = (this && this.attributes) || {};\npug_html = pug_html + "\\u003Cdiv" + (pug.attr("class", pug.classes(["marketing",name], [false,true]), false, true)) + "\\u003E\\u003Cimg" + (pug.attr("src", img, true, true)+" alt=\\"\\"") + "\\u003E\\u003Cdiv class=\\"marketing__description\\"\\u003E \\u003Cdiv class=\\"marketing__title\\"\\u003E Heaven Resort\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"marketing__price\\"\\u003E Starts from \\u003Cspan class=\\"explore-marketing__price--dollor\\"\\u003E$\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"explore-marketing__price--summ\\"\\u003E" + (pug.escape(null == (pug_interp = price) ? "" : pug_interp)) + "\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"marketing__rating\\"\\u003E" + (pug.escape(null == (pug_interp = raiting) ? "" : pug_interp)) + "\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";\n};\npug_mixins["marketing-element"](\'explore__marketing\', __webpack_require__(9184), 450, (4.8));\npug_html = pug_html + "\\u003Cdiv class=\\"explore__tour-guide\\"\\u003E \\u003Cimg" + (pug.attr("src", __webpack_require__(1079), true, true)+" alt=\\"\\"") + "\\u003E\\u003Cdiv class=\\"explore__guide-title\\"\\u003E \\u003Cspan class=\\"explore__name\\"\\u003EJake Anderson\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"explore__post\\"\\u003EBest Tour Guide\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"explore__title\\"\\u003E \\u003Ch2 class=\\"title-2\\"\\u003EWith Our Service We Will Explore Something Different\\u003C\\u002Fh2\\u003E\\u003Cp class=\\"text\\"\\u003EUncover hidden gems and immerse yourself in vibrant cultures. From breathtaking landscapes to awe-inspiring destinations, let us guide you to the most extraordinary places on the planet\\u003C\\u002Fp\\u003E\\u003Cbutton class=\\"button explore__button\\" type=\\"button\\"\\u003EExplore more\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E" + (null == (pug_interp = (__webpack_require__(2815).call)(this, locals)) ? "" : pug_interp) + (null == (pug_interp = (__webpack_require__(8761).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Fmain\\u003E\\u003Cfooter class=\\"footer\\"\\u003E " + (null == (pug_interp = (__webpack_require__(1426).call)(this, locals)) ? "" : pug_interp) + "\\u003C\\u002Ffooter\\u003E\\u003C\\u002Fbody\\u003E\\u003C\\u002Fhtml\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsSUFBMEM7O0FBRTVELDJCQUEyQixrQ0FBa0MsYUFBYSx1VUFBdVUsZ0NBQW1DLG05Q0FBbTlDLG1CQUFPLENBQUMsSUFBK0IsZ1BBQWdQLG1CQUFPLENBQUMsSUFBaUM7QUFDdnNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsSUFBK0I7QUFDN0YsaUtBQWlLLG1CQUFPLENBQUMsSUFBeUMsaUZBQWlGLG1CQUFPLENBQUMsSUFBc0Msc0xBQXNMLGdDQUFxQyw0REFBNEQsZ0NBQW9DLDREQUE0RCxnQ0FBcUMsNk5BQTZOLG1CQUFPLENBQUMsSUFBK0I7QUFDai9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsSUFBdUM7QUFDckcsbUdBQW1HLG1CQUFPLENBQUMsSUFBdUMsMDNCQUEwM0IsZ0NBQXlDLDREQUE0RCxnQ0FBc0MsMkhBQTJILGdDQUFtQyw2R0FBNkc7QUFDbDZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9zcmMvaHRtbC9pbmRleC5wdWc/YWI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHVnID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanNcIik7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge3ZhciBwdWdfaHRtbCA9IFwiXCIsIHB1Z19taXhpbnMgPSB7fSwgcHVnX2ludGVycDtwdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDIURPQ1RZUEUgaHRtbFxcdTAwM0VcXHUwMDNDaHRtbCBsYW5nPVxcXCJlblxcXCJcXHUwMDNFXFx1MDAzQ2hlYWRcXHUwMDNFXFx1MDAzQ21ldGEgY2hhcnNldD1cXFwiVVRGLThcXFwiXFx1MDAzRVxcdTAwM0NtZXRhIG5hbWU9XFxcInZpZXdwb3J0XFxcIiBjb250ZW50PVxcXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXFxcIlxcdTAwM0VcXHUwMDNDdGl0bGVcXHUwMDNFVHJhdmVsIGFnZW50XFx1MDAzQ1xcdTAwMkZ0aXRsZVxcdTAwM0VcXHUwMDNDXFx1MDAyRmhlYWRcXHUwMDNFXFx1MDAzQ2JvZHlcXHUwMDNFXCIgKyAobnVsbCA9PSAocHVnX2ludGVycCA9IHJlcXVpcmUoXCIuL2Jsb2Nrcy9oZWFkZXIucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NtYWluIGNsYXNzPVxcXCJtYWluXFxcIlxcdTAwM0VcXHUwMDNDc2VjdGlvbiBjbGFzcz1cXFwiZGlzY292ZXJcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZGlzY292ZXJfX2Jsb2Nrc1xcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZGlzY292ZXJfX2Rlc2NcXFwiXFx1MDAzRSBcXHUwMDNDZGl2IGNsYXNzPVxcXCJkaXNjb3Zlcl9fdGl0bGVcXFwiXFx1MDAzRSBcXHUwMDNDaDEgY2xhc3M9XFxcInRpdGxlLTEgdGl0bGUtMS0tZGVjb3JcXFwiXFx1MDAzRURpc2NvdmVyIHlvdXIgZmF2b3JpdGUgcGxhY2Ugd2l0aCB1c1xcdTAwM0NcXHUwMDJGaDFcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZGlzY292ZXJfX3RleHQgdGV4dFxcXCJcXHUwMDNFIFxcdTAwM0NwXFx1MDAzRVlvdXIgam91cm5leSBiZWdpbnMgaGVyZSB3aXRoIG91ciBjdXJhdGVkIHRyYXZlbCBleHBlcmllbmNlcy4gRGlzY292ZXIgbmV3IGhvcml6b25zLCBjcmVhdGUgbGFzdGluZyBtZW1vcmllcywgYW5kIGV4cGxvcmUgdGhlIHdvcmxkIHdpdGggb3VyIGV4cGVydGx5IGNyYWZ0ZWQgaXRpbmVyYXJpZXMuXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImRpc2NvdmVyX19mb3JtXFxcIlxcdTAwM0UgXFx1MDAzQ2Zvcm0gY2xhc3M9XFxcInNlYXJjaC1mb3JtXFxcIiBhY3Rpb249XFxcInNlYXJjaC1mb3JtXFxcIiBtZWhvZD1cXFwiXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWwgY2xhc3M9XFxcInNlYXJjaC1mb3JtX19sYWJlbCBzZWFyY2gtZm9ybV9fbGFiZWwtLW1hcFxcXCIgZm9yPVxcXCJsb2NhdGlvblxcXCIgbmFtZT1cXFwibG9jYXRpb25cXFwiXFx1MDAzRVxcdTAwM0NzcGFuXFx1MDAzRUxvY2F0aW9uc1xcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDaW5wdXQgaWQ9XFxcImxvY2F0aW9uXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcImUuZyBCYWxpLCBJbmRvbmVzaWFcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwic2VhcmNoLWZvcm1fX2RldmlkZXJcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NsYWJlbCBjbGFzcz1cXFwic2VhcmNoLWZvcm1fX2xhYmVsIHNlYXJjaC1mb3JtX19sYWJlbC0tY2FsZW5kYXJcXFwiIGZvcj1cXFwiZGF0ZVxcXCIgbmFtZT1cXFwiZGF0ZVxcXCJcXHUwMDNFXFx1MDAzQ3NwYW5cXHUwMDNFRGF0ZSBhbmQgdGltZVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDaW5wdXQgaWQ9XFxcImRhdGVcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiRERcXHUwMDJGTU1cXHUwMDJGWVlZWVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDYnV0dG9uIGNsYXNzPVxcXCJzZWFyY2gtZm9ybV9fYnV0dG9uXFxcIiB0eXBlPVxcXCJzdWJtaXRcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi9pbWFnZXMvaGVhZGVyL3NlYXJjaC5zdmcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZidXR0b25cXHUwMDNFXFx1MDAzQ1xcdTAwMkZmb3JtXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImRpc2NvdmVyX19waWN0dXJlXFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJkaXNjb3Zlcl9faW1hZ2VcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi9pbWFnZXMvaGVhZGVyL3N1YnRyYWN0LnBuZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcIjtcbnB1Z19taXhpbnNbXCJtYXJrZXRpbmctZWxlbWVudFwiXSA9IHB1Z19pbnRlcnAgPSBmdW5jdGlvbihuYW1lLCBpbWcsIHByaWNlLCByYWl0aW5nKXtcbnZhciBibG9jayA9ICh0aGlzICYmIHRoaXMuYmxvY2spLCBhdHRyaWJ1dGVzID0gKHRoaXMgJiYgdGhpcy5hdHRyaWJ1dGVzKSB8fCB7fTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NkaXZcIiArIChwdWcuYXR0cihcImNsYXNzXCIsIHB1Zy5jbGFzc2VzKFtcIm1hcmtldGluZ1wiLG5hbWVdLCBbZmFsc2UsdHJ1ZV0pLCBmYWxzZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXFx1MDAzQ2ltZ1wiICsgKHB1Zy5hdHRyKFwic3JjXCIsIGltZywgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwibWFya2V0aW5nX19kZXNjcmlwdGlvblxcXCJcXHUwMDNFIFxcdTAwM0NkaXYgY2xhc3M9XFxcIm1hcmtldGluZ19fdGl0bGVcXFwiXFx1MDAzRSBIZWF2ZW4gUmVzb3J0XFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwibWFya2V0aW5nX19wcmljZVxcXCJcXHUwMDNFIFN0YXJ0cyBmcm9tIFxcdTAwM0NzcGFuIGNsYXNzPVxcXCJleHBsb3JlLW1hcmtldGluZ19fcHJpY2UtLWRvbGxvclxcXCJcXHUwMDNFJFxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZXhwbG9yZS1tYXJrZXRpbmdfX3ByaWNlLS1zdW1tXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSBwcmljZSkgPyBcIlwiIDogcHVnX2ludGVycCkpICsgXCJcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwibWFya2V0aW5nX19yYXRpbmdcXFwiXFx1MDAzRVwiICsgKHB1Zy5lc2NhcGUobnVsbCA9PSAocHVnX2ludGVycCA9IHJhaXRpbmcpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXCI7XG59O1xucHVnX21peGluc1tcIm1hcmtldGluZy1lbGVtZW50XCJdKCdkaXNjb3Zlci1tYXJrZXRpbmcnLCByZXF1aXJlKCcuLy4uL2ltYWdlcy9oZWFkZXIvaGVhdmVuLmpwZycpLCA0MDAsICg0LjUpKTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NkaXYgY2xhc3M9XFxcImRpc2NvdmVyX19zY3JvbGxcXFwiXFx1MDAzRSBcXHUwMDNDZGl2IGNsYXNzPVxcXCJzY3JvbGxfX2Jsb2NrXFxcIlxcdTAwM0VcXHUwMDNDaW1nXCIgKyAoXCIgY2xhc3M9XFxcInNjcm9sbF9fdGV4dFxcXCJcIitwdWcuYXR0cihcInNyY1wiLCByZXF1aXJlKCcuLy4uL2ltYWdlcy9oZWFkZXIvc2Nyb2xsLWRvd24tdGV4dC5zdmcnKSwgdHJ1ZSwgdHJ1ZSkpICsgXCJcXHUwMDNFXFx1MDAzQ2ltZ1wiICsgKFwiIGNsYXNzPVxcXCJzY3JvbGxfX2ljb25cXFwiXCIrcHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi9pbWFnZXMvaGVhZGVyL3Njcm9sbC1idXR0b24uc3ZnJyksIHRydWUsIHRydWUpKSArIFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VjdGlvblxcdTAwM0VcIiArIChudWxsID09IChwdWdfaW50ZXJwID0gcmVxdWlyZShcIi4vYmxvY2tzL3BhcnRuZXJzLnB1Z1wiKS5jYWxsKHRoaXMsIGxvY2FscykpID8gXCJcIiA6IHB1Z19pbnRlcnApICsgKG51bGwgPT0gKHB1Z19pbnRlcnAgPSByZXF1aXJlKFwiLi9ibG9ja3MvcG9wdWxhci5wdWdcIikuY2FsbCh0aGlzLCBsb2NhbHMpKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSArIChudWxsID09IChwdWdfaW50ZXJwID0gcmVxdWlyZShcIi4vYmxvY2tzL3NlcnZpY2VzLnB1Z1wiKS5jYWxsKHRoaXMsIGxvY2FscykpID8gXCJcIiA6IHB1Z19pbnRlcnApICsgXCJcXHUwMDNDZGl2IGNsYXNzPVxcXCJleHBsb3JlXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZXhwbG9yZV9fYmxvY2tzXFxcIlxcdTAwM0UgXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZXhwbG9yZV9faW1hZ2VcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi9pbWFnZXMvZXhwbG9yZS9pbWFnZS5qcGcnKSwgdHJ1ZSwgdHJ1ZSkrXCIgYWx0PVxcXCJcXFwiXCIpICsgXCJcXHUwMDNFXCI7XG5wdWdfbWl4aW5zW1wibWFya2V0aW5nLWVsZW1lbnRcIl0gPSBwdWdfaW50ZXJwID0gZnVuY3Rpb24obmFtZSwgaW1nLCBwcmljZSwgcmFpdGluZyl7XG52YXIgYmxvY2sgPSAodGhpcyAmJiB0aGlzLmJsb2NrKSwgYXR0cmlidXRlcyA9ICh0aGlzICYmIHRoaXMuYXR0cmlidXRlcykgfHwge307XG5wdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDZGl2XCIgKyAocHVnLmF0dHIoXCJjbGFzc1wiLCBwdWcuY2xhc3NlcyhbXCJtYXJrZXRpbmdcIixuYW1lXSwgW2ZhbHNlLHRydWVdKSwgZmFsc2UsIHRydWUpKSArIFwiXFx1MDAzRVxcdTAwM0NpbWdcIiArIChwdWcuYXR0cihcInNyY1wiLCBpbWcsIHRydWUsIHRydWUpK1wiIGFsdD1cXFwiXFxcIlwiKSArIFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcIm1hcmtldGluZ19fZGVzY3JpcHRpb25cXFwiXFx1MDAzRSBcXHUwMDNDZGl2IGNsYXNzPVxcXCJtYXJrZXRpbmdfX3RpdGxlXFxcIlxcdTAwM0UgSGVhdmVuIFJlc29ydFxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcIm1hcmtldGluZ19fcHJpY2VcXFwiXFx1MDAzRSBTdGFydHMgZnJvbSBcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZXhwbG9yZS1tYXJrZXRpbmdfX3ByaWNlLS1kb2xsb3JcXFwiXFx1MDAzRSRcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImV4cGxvcmUtbWFya2V0aW5nX19wcmljZS0tc3VtbVxcXCJcXHUwMDNFXCIgKyAocHVnLmVzY2FwZShudWxsID09IChwdWdfaW50ZXJwID0gcHJpY2UpID8gXCJcIiA6IHB1Z19pbnRlcnApKSArIFwiXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcIm1hcmtldGluZ19fcmF0aW5nXFxcIlxcdTAwM0VcIiArIChwdWcuZXNjYXBlKG51bGwgPT0gKHB1Z19pbnRlcnAgPSByYWl0aW5nKSA/IFwiXCIgOiBwdWdfaW50ZXJwKSkgKyBcIlxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVwiO1xufTtcbnB1Z19taXhpbnNbXCJtYXJrZXRpbmctZWxlbWVudFwiXSgnZXhwbG9yZV9fbWFya2V0aW5nJywgcmVxdWlyZSgnLi8uLi9pbWFnZXMvZXhwbG9yZS9oZWF2ZW4tcmVzb3J0LmpwZycpLCA0NTAsICg0LjgpKTtcbnB1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NkaXYgY2xhc3M9XFxcImV4cGxvcmVfX3RvdXItZ3VpZGVcXFwiXFx1MDAzRSBcXHUwMDNDaW1nXCIgKyAocHVnLmF0dHIoXCJzcmNcIiwgcmVxdWlyZSgnLi8uLi9pbWFnZXMvZXhwbG9yZS9qYWtlLWFuZGVyc29uLmpwZycpLCB0cnVlLCB0cnVlKStcIiBhbHQ9XFxcIlxcXCJcIikgKyBcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJleHBsb3JlX19ndWlkZS10aXRsZVxcXCJcXHUwMDNFIFxcdTAwM0NzcGFuIGNsYXNzPVxcXCJleHBsb3JlX19uYW1lXFxcIlxcdTAwM0VKYWtlIEFuZGVyc29uXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJleHBsb3JlX19wb3N0XFxcIlxcdTAwM0VCZXN0IFRvdXIgR3VpZGVcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZXhwbG9yZV9fdGl0bGVcXFwiXFx1MDAzRSBcXHUwMDNDaDIgY2xhc3M9XFxcInRpdGxlLTJcXFwiXFx1MDAzRVdpdGggT3VyIFNlcnZpY2UgV2UgV2lsbCBFeHBsb3JlIFNvbWV0aGluZyBEaWZmZXJlbnRcXHUwMDNDXFx1MDAyRmgyXFx1MDAzRVxcdTAwM0NwIGNsYXNzPVxcXCJ0ZXh0XFxcIlxcdTAwM0VVbmNvdmVyIGhpZGRlbiBnZW1zIGFuZCBpbW1lcnNlIHlvdXJzZWxmIGluIHZpYnJhbnQgY3VsdHVyZXMuIEZyb20gYnJlYXRodGFraW5nIGxhbmRzY2FwZXMgdG8gYXdlLWluc3BpcmluZyBkZXN0aW5hdGlvbnMsIGxldCB1cyBndWlkZSB5b3UgdG8gdGhlIG1vc3QgZXh0cmFvcmRpbmFyeSBwbGFjZXMgb24gdGhlIHBsYW5ldFxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDYnV0dG9uIGNsYXNzPVxcXCJidXR0b24gZXhwbG9yZV9fYnV0dG9uXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiXFx1MDAzRUV4cGxvcmUgbW9yZVxcdTAwM0NcXHUwMDJGYnV0dG9uXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVwiICsgKG51bGwgPT0gKHB1Z19pbnRlcnAgPSByZXF1aXJlKFwiLi9ibG9ja3MvdGVzdGltb25pYWxzLnB1Z1wiKS5jYWxsKHRoaXMsIGxvY2FscykpID8gXCJcIiA6IHB1Z19pbnRlcnApICsgKG51bGwgPT0gKHB1Z19pbnRlcnAgPSByZXF1aXJlKFwiLi9ibG9ja3Mvc3Vic2NyaWJlLnB1Z1wiKS5jYWxsKHRoaXMsIGxvY2FscykpID8gXCJcIiA6IHB1Z19pbnRlcnApICsgXCJcXHUwMDNDXFx1MDAyRm1haW5cXHUwMDNFXFx1MDAzQ2Zvb3RlciBjbGFzcz1cXFwiZm9vdGVyXFxcIlxcdTAwM0UgXCIgKyAobnVsbCA9PSAocHVnX2ludGVycCA9IHJlcXVpcmUoXCIuL2Jsb2Nrcy9mb290ZXIucHVnXCIpLmNhbGwodGhpcywgbG9jYWxzKSkgPyBcIlwiIDogcHVnX2ludGVycCkgKyBcIlxcdTAwM0NcXHUwMDJGZm9vdGVyXFx1MDAzRVxcdTAwM0NcXHUwMDJGYm9keVxcdTAwM0VcXHUwMDNDXFx1MDAyRmh0bWxcXHUwMDNFXCI7O3JldHVybiBwdWdfaHRtbDt9O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4278\n')},7766:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\nvar pug_has_own_property = Object.prototype.hasOwnProperty;\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = pug_merge;\nfunction pug_merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = pug_merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n\n  for (var key in b) {\n    if (key === 'class') {\n      var valA = a[key] || [];\n      a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || []);\n    } else if (key === 'style') {\n      var valA = pug_style(a[key]);\n      valA = valA && valA[valA.length - 1] !== ';' ? valA + ';' : valA;\n      var valB = pug_style(b[key]);\n      valB = valB && valB[valB.length - 1] !== ';' ? valB + ';' : valB;\n      a[key] = valA + valB;\n    } else {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Process array, object, or string as a string of classes delimited by a space.\n *\n * If `val` is an array, all members of it and its subarrays are counted as\n * classes. If `escaping` is an array, then whether or not the item in `val` is\n * escaped depends on the corresponding item in `escaping`. If `escaping` is\n * not an array, no escaping is done.\n *\n * If `val` is an object, all the keys whose value is truthy are counted as\n * classes. No escaping is done.\n *\n * If `val` is a string, it is counted as a class. No escaping is done.\n *\n * @param {(Array.<string>|Object.<string, boolean>|string)} val\n * @param {?Array.<string>} escaping\n * @return {String}\n */\nexports.classes = pug_classes;\nfunction pug_classes_array(val, escaping) {\n  var classString = '', className, padding = '', escapeEnabled = Array.isArray(escaping);\n  for (var i = 0; i < val.length; i++) {\n    className = pug_classes(val[i]);\n    if (!className) continue;\n    escapeEnabled && escaping[i] && (className = pug_escape(className));\n    classString = classString + padding + className;\n    padding = ' ';\n  }\n  return classString;\n}\nfunction pug_classes_object(val) {\n  var classString = '', padding = '';\n  for (var key in val) {\n    if (key && val[key] && pug_has_own_property.call(val, key)) {\n      classString = classString + padding + key;\n      padding = ' ';\n    }\n  }\n  return classString;\n}\nfunction pug_classes(val, escaping) {\n  if (Array.isArray(val)) {\n    return pug_classes_array(val, escaping);\n  } else if (val && typeof val === 'object') {\n    return pug_classes_object(val);\n  } else {\n    return val || '';\n  }\n}\n\n/**\n * Convert object or string to a string of CSS styles delimited by a semicolon.\n *\n * @param {(Object.<string, string>|string)} val\n * @return {String}\n */\n\nexports.style = pug_style;\nfunction pug_style(val) {\n  if (!val) return '';\n  if (typeof val === 'object') {\n    var out = '';\n    for (var style in val) {\n      /* istanbul ignore else */\n      if (pug_has_own_property.call(val, style)) {\n        out = out + style + ':' + val[style] + ';';\n      }\n    }\n    return out;\n  } else {\n    return val + '';\n  }\n};\n\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = pug_attr;\nfunction pug_attr(key, val, escaped, terse) {\n  if (val === false || val == null || !val && (key === 'class' || key === 'style')) {\n    return '';\n  }\n  if (val === true) {\n    return ' ' + (terse ? key : key + '=\"' + key + '\"');\n  }\n  var type = typeof val;\n  if ((type === 'object' || type === 'function') && typeof val.toJSON === 'function') {\n    val = val.toJSON();\n  }\n  if (typeof val !== 'string') {\n    val = JSON.stringify(val);\n    if (!escaped && val.indexOf('\"') !== -1) {\n      return ' ' + key + '=\\'' + val.replace(/'/g, '&#39;') + '\\'';\n    }\n  }\n  if (escaped) val = pug_escape(val);\n  return ' ' + key + '=\"' + val + '\"';\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} terse whether to use HTML5 terse boolean attributes\n * @return {String}\n */\nexports.attrs = pug_attrs;\nfunction pug_attrs(obj, terse){\n  var attrs = '';\n\n  for (var key in obj) {\n    if (pug_has_own_property.call(obj, key)) {\n      var val = obj[key];\n\n      if ('class' === key) {\n        val = pug_classes(val);\n        attrs = pug_attr(key, val, false, terse) + attrs;\n        continue;\n      }\n      if ('style' === key) {\n        val = pug_style(val);\n      }\n      attrs += pug_attr(key, val, false, terse);\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar pug_match_html = /[\"&<>]/;\nexports.escape = pug_escape;\nfunction pug_escape(_html){\n  var html = '' + _html;\n  var regexResult = pug_match_html.exec(html);\n  if (!regexResult) return _html;\n\n  var result = '';\n  var i, lastIndex, escape;\n  for (i = regexResult.index, lastIndex = 0; i < html.length; i++) {\n    switch (html.charCodeAt(i)) {\n      case 34: escape = '&quot;'; break;\n      case 38: escape = '&amp;'; break;\n      case 60: escape = '&lt;'; break;\n      case 62: escape = '&gt;'; break;\n      default: continue;\n    }\n    if (lastIndex !== i) result += html.substring(lastIndex, i);\n    lastIndex = i + 1;\n    result += escape;\n  }\n  if (lastIndex !== i) return result + html.substring(lastIndex, i);\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the pug in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @param {String} str original source\n * @api private\n */\n\nexports.rethrow = pug_rethrow;\nfunction pug_rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || (__webpack_require__(3365).readFileSync)(filename, 'utf8')\n  } catch (ex) {\n    pug_rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Pug') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc2Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFrRDtBQUM3RCxXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QyxZQUFZO0FBQ1o7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBLCtCQUErQixHQUFHO0FBQ2xDLDhCQUE4QixHQUFHO0FBQ2pDLDZCQUE2QixHQUFHO0FBQ2hDLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBMEI7QUFDM0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicGFja193ZWIvLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanM/NzA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBwdWdfaGFzX293bl9wcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTWVyZ2UgdHdvIGF0dHJpYnV0ZSBvYmplY3RzIGdpdmluZyBwcmVjZWRlbmNlXG4gKiB0byB2YWx1ZXMgaW4gb2JqZWN0IGBiYC4gQ2xhc3NlcyBhcmUgc3BlY2lhbC1jYXNlZFxuICogYWxsb3dpbmcgZm9yIGFycmF5cyBhbmQgbWVyZ2luZy9qb2luaW5nIGFwcHJvcHJpYXRlbHlcbiAqIHJlc3VsdGluZyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IHB1Z19tZXJnZTtcbmZ1bmN0aW9uIHB1Z19tZXJnZShhLCBiKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGF0dHJzID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHJzID0gcHVnX21lcmdlKGF0dHJzLCBhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICB2YXIgdmFsQSA9IGFba2V5XSB8fCBbXTtcbiAgICAgIGFba2V5XSA9IChBcnJheS5pc0FycmF5KHZhbEEpID8gdmFsQSA6IFt2YWxBXSkuY29uY2F0KGJba2V5XSB8fCBbXSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgIHZhciB2YWxBID0gcHVnX3N0eWxlKGFba2V5XSk7XG4gICAgICB2YWxBID0gdmFsQSAmJiB2YWxBW3ZhbEEubGVuZ3RoIC0gMV0gIT09ICc7JyA/IHZhbEEgKyAnOycgOiB2YWxBO1xuICAgICAgdmFyIHZhbEIgPSBwdWdfc3R5bGUoYltrZXldKTtcbiAgICAgIHZhbEIgPSB2YWxCICYmIHZhbEJbdmFsQi5sZW5ndGggLSAxXSAhPT0gJzsnID8gdmFsQiArICc7JyA6IHZhbEI7XG4gICAgICBhW2tleV0gPSB2YWxBICsgdmFsQjtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIGFycmF5LCBvYmplY3QsIG9yIHN0cmluZyBhcyBhIHN0cmluZyBvZiBjbGFzc2VzIGRlbGltaXRlZCBieSBhIHNwYWNlLlxuICpcbiAqIElmIGB2YWxgIGlzIGFuIGFycmF5LCBhbGwgbWVtYmVycyBvZiBpdCBhbmQgaXRzIHN1YmFycmF5cyBhcmUgY291bnRlZCBhc1xuICogY2xhc3Nlcy4gSWYgYGVzY2FwaW5nYCBpcyBhbiBhcnJheSwgdGhlbiB3aGV0aGVyIG9yIG5vdCB0aGUgaXRlbSBpbiBgdmFsYCBpc1xuICogZXNjYXBlZCBkZXBlbmRzIG9uIHRoZSBjb3JyZXNwb25kaW5nIGl0ZW0gaW4gYGVzY2FwaW5nYC4gSWYgYGVzY2FwaW5nYCBpc1xuICogbm90IGFuIGFycmF5LCBubyBlc2NhcGluZyBpcyBkb25lLlxuICpcbiAqIElmIGB2YWxgIGlzIGFuIG9iamVjdCwgYWxsIHRoZSBrZXlzIHdob3NlIHZhbHVlIGlzIHRydXRoeSBhcmUgY291bnRlZCBhc1xuICogY2xhc3Nlcy4gTm8gZXNjYXBpbmcgaXMgZG9uZS5cbiAqXG4gKiBJZiBgdmFsYCBpcyBhIHN0cmluZywgaXQgaXMgY291bnRlZCBhcyBhIGNsYXNzLiBObyBlc2NhcGluZyBpcyBkb25lLlxuICpcbiAqIEBwYXJhbSB7KEFycmF5LjxzdHJpbmc+fE9iamVjdC48c3RyaW5nLCBib29sZWFuPnxzdHJpbmcpfSB2YWxcbiAqIEBwYXJhbSB7P0FycmF5LjxzdHJpbmc+fSBlc2NhcGluZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmNsYXNzZXMgPSBwdWdfY2xhc3NlcztcbmZ1bmN0aW9uIHB1Z19jbGFzc2VzX2FycmF5KHZhbCwgZXNjYXBpbmcpIHtcbiAgdmFyIGNsYXNzU3RyaW5nID0gJycsIGNsYXNzTmFtZSwgcGFkZGluZyA9ICcnLCBlc2NhcGVFbmFibGVkID0gQXJyYXkuaXNBcnJheShlc2NhcGluZyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgY2xhc3NOYW1lID0gcHVnX2NsYXNzZXModmFsW2ldKTtcbiAgICBpZiAoIWNsYXNzTmFtZSkgY29udGludWU7XG4gICAgZXNjYXBlRW5hYmxlZCAmJiBlc2NhcGluZ1tpXSAmJiAoY2xhc3NOYW1lID0gcHVnX2VzY2FwZShjbGFzc05hbWUpKTtcbiAgICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nICsgcGFkZGluZyArIGNsYXNzTmFtZTtcbiAgICBwYWRkaW5nID0gJyAnO1xuICB9XG4gIHJldHVybiBjbGFzc1N0cmluZztcbn1cbmZ1bmN0aW9uIHB1Z19jbGFzc2VzX29iamVjdCh2YWwpIHtcbiAgdmFyIGNsYXNzU3RyaW5nID0gJycsIHBhZGRpbmcgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbCkge1xuICAgIGlmIChrZXkgJiYgdmFsW2tleV0gJiYgcHVnX2hhc19vd25fcHJvcGVydHkuY2FsbCh2YWwsIGtleSkpIHtcbiAgICAgIGNsYXNzU3RyaW5nID0gY2xhc3NTdHJpbmcgKyBwYWRkaW5nICsga2V5O1xuICAgICAgcGFkZGluZyA9ICcgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzU3RyaW5nO1xufVxuZnVuY3Rpb24gcHVnX2NsYXNzZXModmFsLCBlc2NhcGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHB1Z19jbGFzc2VzX2FycmF5KHZhbCwgZXNjYXBpbmcpO1xuICB9IGVsc2UgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBwdWdfY2xhc3Nlc19vYmplY3QodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsIHx8ICcnO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBvYmplY3Qgb3Igc3RyaW5nIHRvIGEgc3RyaW5nIG9mIENTUyBzdHlsZXMgZGVsaW1pdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICpcbiAqIEBwYXJhbSB7KE9iamVjdC48c3RyaW5nLCBzdHJpbmc+fHN0cmluZyl9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmV4cG9ydHMuc3R5bGUgPSBwdWdfc3R5bGU7XG5mdW5jdGlvbiBwdWdfc3R5bGUodmFsKSB7XG4gIGlmICghdmFsKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZSBpbiB2YWwpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHVnX2hhc19vd25fcHJvcGVydHkuY2FsbCh2YWwsIHN0eWxlKSkge1xuICAgICAgICBvdXQgPSBvdXQgKyBzdHlsZSArICc6JyArIHZhbFtzdHlsZV0gKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbCArICcnO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZXNjYXBlZFxuICogQHBhcmFtIHtCb29sZWFufSB0ZXJzZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmF0dHIgPSBwdWdfYXR0cjtcbmZ1bmN0aW9uIHB1Z19hdHRyKGtleSwgdmFsLCBlc2NhcGVkLCB0ZXJzZSkge1xuICBpZiAodmFsID09PSBmYWxzZSB8fCB2YWwgPT0gbnVsbCB8fCAhdmFsICYmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodmFsID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICcgJyArICh0ZXJzZSA/IGtleSA6IGtleSArICc9XCInICsga2V5ICsgJ1wiJyk7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAoKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsID0gdmFsLnRvSlNPTigpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbCk7XG4gICAgaWYgKCFlc2NhcGVkICYmIHZhbC5pbmRleE9mKCdcIicpICE9PSAtMSkge1xuICAgICAgcmV0dXJuICcgJyArIGtleSArICc9XFwnJyArIHZhbC5yZXBsYWNlKC8nL2csICcmIzM5OycpICsgJ1xcJyc7XG4gICAgfVxuICB9XG4gIGlmIChlc2NhcGVkKSB2YWwgPSBwdWdfZXNjYXBlKHZhbCk7XG4gIHJldHVybiAnICcgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIic7XG59O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IHRlcnNlIHdoZXRoZXIgdG8gdXNlIEhUTUw1IHRlcnNlIGJvb2xlYW4gYXR0cmlidXRlc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmF0dHJzID0gcHVnX2F0dHJzO1xuZnVuY3Rpb24gcHVnX2F0dHJzKG9iaiwgdGVyc2Upe1xuICB2YXIgYXR0cnMgPSAnJztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKHB1Z19oYXNfb3duX3Byb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICAgIGlmICgnY2xhc3MnID09PSBrZXkpIHtcbiAgICAgICAgdmFsID0gcHVnX2NsYXNzZXModmFsKTtcbiAgICAgICAgYXR0cnMgPSBwdWdfYXR0cihrZXksIHZhbCwgZmFsc2UsIHRlcnNlKSArIGF0dHJzO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgnc3R5bGUnID09PSBrZXkpIHtcbiAgICAgICAgdmFsID0gcHVnX3N0eWxlKHZhbCk7XG4gICAgICB9XG4gICAgICBhdHRycyArPSBwdWdfYXR0cihrZXksIHZhbCwgZmFsc2UsIHRlcnNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0cnM7XG59O1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBodG1sYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHB1Z19tYXRjaF9odG1sID0gL1tcIiY8Pl0vO1xuZXhwb3J0cy5lc2NhcGUgPSBwdWdfZXNjYXBlO1xuZnVuY3Rpb24gcHVnX2VzY2FwZShfaHRtbCl7XG4gIHZhciBodG1sID0gJycgKyBfaHRtbDtcbiAgdmFyIHJlZ2V4UmVzdWx0ID0gcHVnX21hdGNoX2h0bWwuZXhlYyhodG1sKTtcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIF9odG1sO1xuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGksIGxhc3RJbmRleCwgZXNjYXBlO1xuICBmb3IgKGkgPSByZWdleFJlc3VsdC5pbmRleCwgbGFzdEluZGV4ID0gMDsgaSA8IGh0bWwubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGh0bWwuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAzNDogZXNjYXBlID0gJyZxdW90Oyc7IGJyZWFrO1xuICAgICAgY2FzZSAzODogZXNjYXBlID0gJyZhbXA7JzsgYnJlYWs7XG4gICAgICBjYXNlIDYwOiBlc2NhcGUgPSAnJmx0Oyc7IGJyZWFrO1xuICAgICAgY2FzZSA2MjogZXNjYXBlID0gJyZndDsnOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpKSByZXN1bHQgKz0gaHRtbC5zdWJzdHJpbmcobGFzdEluZGV4LCBpKTtcbiAgICBsYXN0SW5kZXggPSBpICsgMTtcbiAgICByZXN1bHQgKz0gZXNjYXBlO1xuICB9XG4gIGlmIChsYXN0SW5kZXggIT09IGkpIHJldHVybiByZXN1bHQgKyBodG1sLnN1YnN0cmluZyhsYXN0SW5kZXgsIGkpO1xuICBlbHNlIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJlLXRocm93IHRoZSBnaXZlbiBgZXJyYCBpbiBjb250ZXh0IHRvIHRoZVxuICogdGhlIHB1ZyBpbiBgZmlsZW5hbWVgIGF0IHRoZSBnaXZlbiBgbGluZW5vYC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGxpbmVub1xuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBvcmlnaW5hbCBzb3VyY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmV0aHJvdyA9IHB1Z19yZXRocm93O1xuZnVuY3Rpb24gcHVnX3JldGhyb3coZXJyLCBmaWxlbmFtZSwgbGluZW5vLCBzdHIpe1xuICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IGVycjtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnIHx8ICFmaWxlbmFtZSkgJiYgIXN0cikge1xuICAgIGVyci5tZXNzYWdlICs9ICcgb24gbGluZSAnICsgbGluZW5vO1xuICAgIHRocm93IGVycjtcbiAgfVxuICB0cnkge1xuICAgIHN0ciA9IHN0ciB8fCByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKVxuICB9IGNhdGNoIChleCkge1xuICAgIHB1Z19yZXRocm93KGVyciwgbnVsbCwgbGluZW5vKVxuICB9XG4gIHZhciBjb250ZXh0ID0gM1xuICAgICwgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpXG4gICAgLCBzdGFydCA9IE1hdGgubWF4KGxpbmVubyAtIGNvbnRleHQsIDApXG4gICAgLCBlbmQgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIGxpbmVubyArIGNvbnRleHQpO1xuXG4gIC8vIEVycm9yIGNvbnRleHRcbiAgdmFyIGNvbnRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaSl7XG4gICAgdmFyIGN1cnIgPSBpICsgc3RhcnQgKyAxO1xuICAgIHJldHVybiAoY3VyciA9PSBsaW5lbm8gPyAnICA+ICcgOiAnICAgICcpXG4gICAgICArIGN1cnJcbiAgICAgICsgJ3wgJ1xuICAgICAgKyBsaW5lO1xuICB9KS5qb2luKCdcXG4nKTtcblxuICAvLyBBbHRlciBleGNlcHRpb24gbWVzc2FnZVxuICBlcnIucGF0aCA9IGZpbGVuYW1lO1xuICBlcnIubWVzc2FnZSA9IChmaWxlbmFtZSB8fCAnUHVnJykgKyAnOicgKyBsaW5lbm9cbiAgICArICdcXG4nICsgY29udGV4dCArICdcXG5cXG4nICsgZXJyLm1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7766\n")},2507:function(e,n,l){var t={"./bali.jpg":3807,"./bangkok.jpg":5990,"./dubai.jpg":5874,"./new-york.jpg":5539,"./paris.jpg":7856,"./santorini.jpg":508,"./venice.jpg":1893};function c(e){var n=i(e);return l(n)}function i(e){if(!l.o(t,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t[e]}c.keys=function(){return Object.keys(t)},c.resolve=i,e.exports=c,c.id=2507},58:function(e,n,l){var t={"./01.jpg":2283,"./02.jpg":8236,"./03.jpg":1961,"./04.jpg":9370,"./05.jpg":2023,"./06.jpg":9448,"./07.jpg":357,"./star-off.svg":9741,"./star.svg":2713};function c(e){var n=i(e);return l(n)}function i(e){if(!l.o(t,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t[e]}c.keys=function(){return Object.keys(t)},c.resolve=i,e.exports=c,c.id=58},8056:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDkiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCA0OSA4MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMTIuNSIgeT0iMTguNSIgd2lkdGg9IjIzIiBoZWlnaHQ9IjQzIiByeD0iMTEuNSIgc3Ryb2tlPSIjMTgxODE4IiBzdHJva2Utd2lkdGg9IjMiLz4KPGNpcmNsZSBjeD0iMjQiIGN5PSI1MCIgcj0iNiIgZmlsbD0iIzE4MTgxOCIvPgo8L3N2Zz4K"},5896:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik01OS44NjkxIDEzLjE3MzFDNTkuNjM4NyAxMy4yMDc5IDU5LjQyODQgMTMuMTU2MyA1OS4yMzgxIDEzLjAxODRDNTkuMDQ3MyAxMi44Nzc3IDU4LjkzNDMgMTIuNjkwOCA1OC44OTkyIDEyLjQ1NzdDNTguODY0NCAxMi4yMjczIDU4LjkxNzYgMTIuMDE4MiA1OS4wNTg3IDExLjgzMDJDNTkuMTk5NCAxMS42Mzk0IDU5LjM4NSAxMS41MjY2IDU5LjYxNTMgMTEuNDkxOEM1OS44NDU3IDExLjQ1NzEgNjAuMDU2MiAxMS41MSA2MC4yNDcgMTEuNjUwN0M2MC40MzczIDExLjc4ODYgNjAuNTQ5OCAxMS45NzI3IDYwLjU4NDYgMTIuMjAzMUM2MC42MDc5IDEyLjM1NzYgNjAuNTkgMTIuNTA1NCA2MC41MzA4IDEyLjY0NjVDNjAuNDc0MSAxMi43ODQzIDYwLjM4ODIgMTIuOTAwNyA2MC4yNzMyIDEyLjk5NTdDNjAuMTU4MyAxMy4wOTA2IDYwLjAyMzYgMTMuMTQ5OCA1OS44NjkxIDEzLjE3MzFaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0zNi4wOTMyIDE4LjI5NTJMMzcuOTY2NSAyMS43MDAzTDM2Ljg1MDMgMjIuMzE0OEwzMy42OTU0IDE2LjU3OTlMMzQuNzY2NyAxNS45OUwzNS4yODAyIDE2LjkyMzRMMzUuMzUxMiAxNi44ODQ0QzM1LjMxNiAxNi41MDgxIDM1LjM4ODQgMTYuMTUwNCAzNS41NjgyIDE1LjgxMTRDMzUuNzUwNiAxNS40NzEgMzYuMDU3MSAxNS4xODIzIDM2LjQ4NzYgMTQuOTQ1M0MzNi44NzgzIDE0LjczMDEgMzcuMjY1NyAxNC42MjM5IDM3LjY0OTggMTQuNjI2NUMzOC4wMzI0IDE0LjYyNjYgMzguMzkzIDE0Ljc0MjcgMzguNzMxNCAxNC45NzQ3QzM5LjA2OTggMTUuMjA2OCAzOS4zNjkxIDE1LjU1OTIgMzkuNjI5MiAxNi4wMzIyTDQxLjYzNiAxOS42OEw0MC41MTk4IDIwLjI5NDVMMzguNTg3IDE2Ljc4MTFDMzguMzU4MyAxNi4zNjU0IDM4LjA3MTQgMTYuMTAwMiAzNy43MjYyIDE1Ljk4NTRDMzcuMzc5NiAxNS44NjgyIDM3LjAxNzEgMTUuOTEzNyAzNi42Mzg4IDE2LjEyMTlDMzYuMzggMTYuMjY0NCAzNi4xODA2IDE2LjQ0NzIgMzYuMDQwNyAxNi42NzAyQzM1LjkwMzIgMTYuODkxOCAzNS44MzU1IDE3LjE0MzEgMzUuODM3NyAxNy40MjRDMzUuODQxIDE3LjcwMTEgMzUuOTI2MiAxNy45OTE1IDM2LjA5MzIgMTguMjk1MloiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTIxLjQ0NyAzNy45MDE5TDE1LjIyOSAzNS4wOTQ5TDE2LjA4NzIgMzQuMDk2MkwyMC41Njc2IDM2LjI1NzZMMjAuNjA5MyAzNi4yMDkxTDE3LjgwMzYgMzIuMDk4OEwxOC42NjE4IDMxLjEwMDFMMjMuMTIzMyAzMy4yNTA5TDIzLjE2NDkgMzMuMjAyNEwyMC4zNjcxIDI5LjExNTdMMjEuMjI1MiAyOC4xMTdMMjQuOTM1MyAzMy44NDI2TDI0LjA4ODIgMzQuODI4M0wxOS42Mzg3IDMyLjc1NTJMMTkuNTc0OCAzMi44Mjk2TDIyLjI5MTMgMzYuOTE5NEwyMS40NDcgMzcuOTAxOVoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTE0LjczMzQgNTMuMzg5OEMxNC41MjIzIDUzLjk2NiAxNC4yMDYxIDU0LjQyMDUgMTMuNzg0OCA1NC43NTMyQzEzLjM2MzQgNTUuMDg1OSAxMi44NzE4IDU1LjI4MzkgMTIuMzEwMSA1NS4zNDczQzExLjc0ODMgNTUuNDEwNyAxMS4xNSA1NS4zMjYgMTAuNTE1MiA1NS4wOTMzQzkuODc3NzEgNTQuODU5NiA5LjM2MzcxIDU0LjUzNjYgOC45NzMyMSA1NC4xMjQyQzguNTgyNzEgNTMuNzExNyA4LjMzNDA3IDUzLjI0MjQgOC4yMjczMSA1Mi43MTYxQzguMTIwNTQgNTIuMTg5OCA4LjE3MjY4IDUxLjYzODYgOC4zODM3MiA1MS4wNjI0QzguNTk0NzYgNTAuNDg2MiA4LjkxMDk3IDUwLjAzMTcgOS4zMzIzNCA0OS42OTlDOS43NTM3MSA0OS4zNjYzIDEwLjI0NjYgNDkuMTY4OCAxMC44MTEgNDkuMTA2NEMxMS4zNzU0IDQ5LjA0NCAxMS45NzY0IDQ5LjEyOTYgMTIuNjEzOSA0OS4zNjMzQzEzLjI0ODcgNDkuNTk2IDEzLjc2MDEgNDkuOTE4MSAxNC4xNDc5IDUwLjMyOTVDMTQuNTM1NyA1MC43NDEgMTQuNzgzIDUxLjIwOTggMTQuODg5OCA1MS43MzYxQzE0Ljk5NjYgNTIuMjYyNCAxNC45NDQ0IDUyLjgxMzYgMTQuNzMzNCA1My4zODk4Wk0xMy43MzA2IDUzLjAxNzdDMTMuODY3NCA1Mi42NDQyIDEzLjg4MiA1Mi4yOTg2IDEzLjc3NDUgNTEuOTgwOUMxMy42NjcgNTEuNjYzMSAxMy40NzA3IDUxLjM4NTQgMTMuMTg1NiA1MS4xNDc3QzEyLjkwMTUgNTAuOTA3NCAxMi41NjIxIDUwLjcxNDkgMTIuMTY3MyA1MC41NzAyQzExLjc3NTIgNTAuNDI2NSAxMS4zOTMxIDUwLjM1NDUgMTEuMDIxMSA1MC4zNTQzQzEwLjY0NzMgNTAuMzUwNSAxMC4zMTU1IDUwLjQzNDYgMTAuMDI1NSA1MC42MDY3QzkuNzM1NTkgNTAuNzc4OCA5LjUyMjIzIDUxLjA1MTUgOS4zODU0NSA1MS40MjVDOS4yNDc2OCA1MS44MDExIDkuMjMzNCA1Mi4xNDk5IDkuMzQyNTggNTIuNDcxM0M5LjQ1Mjc1IDUyLjc5MDEgOS42NTEyMiA1My4wNzAxIDkuOTM4MDEgNTMuMzExNEMxMC4yMjMxIDUzLjU0OSAxMC41NjE3IDUzLjczOTcgMTAuOTUzOCA1My44ODM0QzExLjM0ODYgNTQuMDI4MSAxMS43MzE1IDU0LjEwMTkgMTIuMTAyNiA1NC4xMDQ4QzEyLjQ3NDYgNTQuMTA1IDEyLjgwNDMgNTQuMDE4NiAxMy4wOTE2IDUzLjg0NTVDMTMuMzc5OCA1My42Njk4IDEzLjU5MjggNTMuMzkzOCAxMy43MzA2IDUzLjAxNzdaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0xMi4yNTg3IDcxLjU0NzdDMTIuMjM2IDcyLjA3NTYgMTIuMDgwOSA3Mi41NDEgMTEuNzkzNSA3Mi45NDM4QzExLjUwMzMgNzMuMzQzNiAxMS4xMDE5IDczLjY1MDUgMTAuNTg5NCA3My44NjQ0QzEwLjA3NDIgNzQuMDc1NCA5LjQ2MzI0IDc0LjE2NTcgOC43NTY1MSA3NC4xMzUzQzguMDQ5NzggNzQuMTA0OSA3LjQ1MDI5IDczLjk2MTEgNi45NTgwNCA3My43MDM5QzYuNDY1OTIgNzMuNDQzOCA2LjA5NTM3IDczLjEwMDkgNS44NDY0IDcyLjY3NUM1LjU5NzQyIDcyLjI0OTEgNS40ODQyMiA3MS43NzM3IDUuNTA2ODEgNzEuMjQ4NkM1LjUyNDI2IDcwLjg0MjcgNS42MDY0MiA3MC41MTkyIDUuNzUzMjggNzAuMjc4MkM1Ljg5NzQyIDcwLjAzNDEgNi4wNjE4MyA2OS44NDc4IDYuMjQ2NSA2OS43MTkzQzYuNDMxMjkgNjkuNTg3OSA2LjU5MzQ1IDY5LjQ4NjkgNi43MzI5OSA2OS40MTYxTDYuNzM2MjggNjkuMzM5NUwzLjQ5NjM5IDY5LjJMMy41NTExMyA2Ny45MjdMMTIuMjcwMyA2OC4zMDIzTDEyLjIxNjkgNjkuNTQ1NUwxMS4xOTkzIDY5LjUwMTdMMTEuMTk0OCA2OS42MDgxQzExLjMzMDUgNjkuNjkwOCAxMS40ODQ3IDY5LjgwODMgMTEuNjU3MyA2OS45NjA3QzExLjgzIDcwLjExMDMgMTEuOTc3NyA3MC4zMTI5IDEyLjEwMDQgNzAuNTY4NEMxMi4yMjMgNzAuODIzOSAxMi4yNzU4IDcxLjE1MDQgMTIuMjU4NyA3MS41NDc3Wk0xMS4xODUyIDcxLjIyQzExLjIwMDkgNzAuODUzOSAxMS4xMTc3IDcwLjU0MDMgMTAuOTM1NiA3MC4yNzk0QzEwLjc1MDcgNzAuMDE1NSAxMC40ODggNjkuODEwOSAxMC4xNDczIDY5LjY2NTRDOS44MDY3NyA2OS41MTcxIDkuNDA2NiA2OS40MzMxIDguOTQ2OCA2OS40MTMzQzguNDkyNjggNjkuMzkzNyA4LjA5MjUxIDY5LjQ0MTkgNy43NDYzIDY5LjU1NzhDNy40MDAwOSA2OS42NzM3IDcuMTI2NDcgNjkuODUzOSA2LjkyNTQ0IDcwLjA5ODNDNi43MjQ0MSA3MC4zNDI3IDYuNjE1OSA3MC42NTA4IDYuNTk5OTEgNzEuMDIyNkM2LjU4MzQzIDcxLjQwNTggNi42NjkwNCA3MS43Mjk0IDYuODU2NzMgNzEuOTkzNEM3LjA0NDQzIDcyLjI1NzQgNy4zMDcxOCA3Mi40NjIxIDcuNjQ1IDcyLjYwNzRDNy45ODI5NCA3Mi43NDk5IDguMzY3NjEgNzIuODMwNCA4Ljc5OTAzIDcyLjg0OUM5LjIzNjEzIDcyLjg2NzggOS42MzIwNCA3Mi44MTk1IDkuOTg2NzYgNzIuNzAzOUMxMC4zNDE1IDcyLjU4ODQgMTAuNjI2NSA3Mi40MDczIDEwLjg0MTkgNzIuMTYwN0MxMS4wNTQ1IDcxLjkxMSAxMS4xNjg5IDcxLjU5NzUgMTEuMTg1MiA3MS4yMloiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTYuOTA0MjcgOTEuMDI1NUwxNS4yMTgyIDg4LjM3MTRMMTUuNjA1NCA4OS41ODUyTDcuMjkxNDkgOTIuMjM5NEw2LjkwNDI3IDkxLjAyNTVaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik05Ljk5NzE0IDk4LjcxMjlMMTcuOTE2OCA5NS4wNDYzTDE4LjQ1MTggOTYuMjAyN0wxMC41MzIxIDk5Ljg2OTNMOS45OTcxNCA5OC43MTI5WiIgZmlsbD0iIzE4MTgxOCIvPgo8cGF0aCBkPSJNMjYuMDgwNSAxMDcuNTQ5QzI2LjQ1MDMgMTA4LjAzOSAyNi42NjA3IDEwOC41NTEgMjYuNzExOSAxMDkuMDg2QzI2Ljc2MzEgMTA5LjYyIDI2LjY2MzEgMTEwLjE0MSAyNi40MTIgMTEwLjY0OEMyNi4xNjA5IDExMS4xNTQgMjUuNzY1NiAxMTEuNjExIDI1LjIyNjIgMTEyLjAxOUMyNC42ODQ0IDExMi40MjggMjQuMTM0NSAxMTIuNjg1IDIzLjU3NjQgMTEyLjc5QzIzLjAxODQgMTEyLjg5NSAyMi40ODkzIDExMi44NSAyMS45ODkzIDExMi42NTRDMjEuNDg5NCAxMTIuNDU5IDIxLjA1NDUgMTEyLjExNiAyMC42ODQ4IDExMS42MjZDMjAuMzE1IDExMS4xMzYgMjAuMTA0NSAxMTAuNjI0IDIwLjA1MzQgMTEwLjA5QzIwLjAwMjIgMTA5LjU1NSAyMC4xMDMzIDEwOS4wMzQgMjAuMzU2NiAxMDguNTI1QzIwLjYxIDEwOC4wMTcgMjEuMDA3NiAxMDcuNTU4IDIxLjU0OTMgMTA3LjE0OUMyMi4wODg4IDEwNi43NDEgMjIuNjM2NCAxMDYuNDg2IDIzLjE5MjIgMTA2LjM4M0MyMy43NDggMTA2LjI4IDI0LjI3NTkgMTA2LjMyNiAyNC43NzU5IDEwNi41MjFDMjUuMjc1OSAxMDYuNzE3IDI1LjcxMDggMTA3LjA2IDI2LjA4MDUgMTA3LjU0OVpNMjUuMjI0NiAxMDguMTkxQzI0Ljk4NDkgMTA3Ljg3MyAyNC43MDI1IDEwNy42NzQgMjQuMzc3MyAxMDcuNTkyQzI0LjA1MjEgMTA3LjUxIDIzLjcxMjQgMTA3LjUyNCAyMy4zNTgzIDEwNy42MzVDMjMuMDAyNSAxMDcuNzQ0IDIyLjY1NjggMTA3LjkyNSAyMi4zMjEzIDEwOC4xNzhDMjEuOTg4MSAxMDguNDMgMjEuNzIwNyAxMDguNzEyIDIxLjUxODkgMTA5LjAyNUMyMS4zMTMxIDEwOS4zMzcgMjEuMjA0IDEwOS42NjIgMjEuMTkxNSAxMDkuOTk5QzIxLjE3OSAxMTAuMzM2IDIxLjI5MjUgMTEwLjY2MyAyMS41MzIyIDExMC45ODFDMjEuNzczNSAxMTEuMyAyMi4wNTg4IDExMS41MDEgMjIuMzg4IDExMS41ODRDMjIuNzE1NSAxMTEuNjY0IDIzLjA1ODMgMTExLjY0OSAyMy40MTY0IDExMS41MzhDMjMuNzcwNSAxMTEuNDI4IDI0LjExNDEgMTExLjI0NiAyNC40NDczIDExMC45OTRDMjQuNzgyOCAxMTAuNzQxIDI1LjA1MjMgMTEwLjQ1OSAyNS4yNTU4IDExMC4xNDlDMjUuNDU3NSAxMDkuODM2IDI1LjU2MzUgMTA5LjUxMiAyNS41NzM4IDEwOS4xNzdDMjUuNTgyMyAxMDguODM5IDI1LjQ2NTkgMTA4LjUxIDI1LjIyNDYgMTA4LjE5MVoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTM2LjY4MjkgMTE3LjQyNEwzMi41ODU2IDEyMi41MjhMMzEuNjI1NSAxMjEuNzU3TDMyLjI3NjMgMTIwLjk0NkwzMi4yMjMyIDEyMC45MDNDMzEuOTA5NiAxMjEuMTAzIDMxLjU3MjQgMTIxLjE4OCAzMS4yMTEzIDEyMS4xNTZDMzAuODQ2MyAxMjEuMTI1IDMwLjUxNDMgMTIwLjk5IDMwLjIxNTMgMTIwLjc1QzMwLjE1MzMgMTIwLjcgMzAuMDgyIDEyMC42MzkgMzAuMDAxNCAxMjAuNTY3QzI5LjkxODYgMTIwLjQ5MyAyOS44NTU1IDEyMC40MzMgMjkuODEyMSAxMjAuMzg3TDMwLjU3NSAxMTkuNDM3QzMwLjYwNiAxMTkuNDggMzAuNjY3IDExOS41NDkgMzAuNzU4MyAxMTkuNjQ0QzMwLjg0NzcgMTE5Ljc0MiAzMC45NDMzIDExOS44MzEgMzEuMDQ1MiAxMTkuOTEzQzMxLjI4IDEyMC4xMDIgMzEuNTI5MyAxMjAuMjIgMzEuNzkzMSAxMjAuMjY4QzMyLjA1MyAxMjAuMzE2IDMyLjMwNjMgMTIwLjI5NiAzMi41NTMxIDEyMC4yMDZDMzIuNzk4MiAxMjAuMTE5IDMzLjAwOTYgMTE5Ljk2NCAzMy4xODc0IDExOS43NDNMMzUuNjg5NiAxMTYuNjI2TDM2LjY4MjkgMTE3LjQyNFoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTQ4LjMxNTcgMTIzLjU5NUM0OC44ODk0IDEyMy44NjMgNDkuMzIyNSAxMjQuMjI1IDQ5LjYxNSAxMjQuNjc5QzQ5LjkwMzggMTI1LjEzNCA1MC4wNTEgMTI1LjY0NCA1MC4wNTY3IDEyNi4yMDhDNTAuMDYyNCAxMjYuNzcyIDQ5LjkyNjEgMTI3LjM1MSA0OS42NDc5IDEyNy45NDZDNDkuMzY2MSAxMjguNTQ4IDQ5LjAwNDIgMTI5LjAyNiA0OC41NjIyIDEyOS4zODFDNDguMTE5IDEyOS43MzggNDcuNjMwOCAxMjkuOTUgNDcuMDk3NSAxMzAuMDE3QzQ2LjU2NDMgMTMwLjA4NCA0Ni4wMTg1IDEyOS45ODcgNDUuNDYwMyAxMjkuNzI1QzQ1LjAxMDEgMTI5LjUxNCA0NC42NDc5IDEyOS4yNDIgNDQuMzczNyAxMjguOTFDNDQuMDk4MyAxMjguNTggNDMuOTIyNCAxMjguMjE2IDQzLjg0NiAxMjcuODE2QzQzLjc2NzEgMTI3LjQxNSA0My44MDA0IDEyNy4wMDYgNDMuOTQ1OSAxMjYuNTg3TDQ1LjA2ODggMTI3LjExM0M0NS4wMDA1IDEyNy40MiA0NS4wMyAxMjcuNzI2IDQ1LjE1NzMgMTI4LjAzQzQ1LjI4MiAxMjguMzMzIDQ1LjUyODMgMTI4LjU3MSA0NS44OTYyIDEyOC43NDNDNDYuMjE3OCAxMjguODk0IDQ2LjUzOTIgMTI4Ljk0MSA0Ni44NjA2IDEyOC44ODVDNDcuMTc4MSAxMjguODI5IDQ3LjQ3NjYgMTI4LjY3NyA0Ny43NTYxIDEyOC40MjlDNDguMDM0NCAxMjguMTgzIDQ4LjI3MjMgMTI3Ljg0OSA0OC40Njk4IDEyNy40MjdDNDguNjcyMiAxMjYuOTk0IDQ4Ljc4MTIgMTI2LjU5MSA0OC43OTY5IDEyNi4yMTVDNDguODEyNyAxMjUuODQgNDguNzQxMiAxMjUuNTEgNDguNTgyNyAxMjUuMjI2QzQ4LjQyMTUgMTI0Ljk0IDQ4LjE3NzYgMTI0LjcyIDQ3Ljg1MDkgMTI0LjU2N0M0Ny42MzIyIDEyNC40NjUgNDcuNDE1NSAxMjQuNDEyIDQ3LjIwMDYgMTI0LjQwOUM0Ni45ODIgMTI0LjQwNyA0Ni43NzY3IDEyNC40NTMgNDYuNTg0NyAxMjQuNTQ4QzQ2LjM5MDIgMTI0LjY0MiA0Ni4yMTg1IDEyNC43ODUgNDYuMDY5NiAxMjQuOTc1TDQ0Ljk0NjcgMTI0LjQ0OUM0NS4xNjczIDEyNC4wODUgNDUuNDUyMyAxMjMuODAxIDQ1LjgwMTUgMTIzLjU5OEM0Ni4xNTA4IDEyMy4zOTUgNDYuNTQwOCAxMjMuMjg5IDQ2Ljk3MTMgMTIzLjI4QzQ3LjM5OTMgMTIzLjI3IDQ3Ljg0NzQgMTIzLjM3NSA0OC4zMTU3IDEyMy41OTVaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik02MC40NjczIDEzMi4xMTRMNjEuNjQgMTMyLjA5OEM2MS42NjM5IDEzMi4yNTEgNjEuNzE3MSAxMzIuNDAyIDYxLjc5OTQgMTMyLjU1MUM2MS44NzkgMTMyLjY5OSA2MS45OTg4IDEzMi44MjkgNjIuMTU5IDEzMi45NDJDNjIuMzE5MiAxMzMuMDU0IDYyLjUyOTcgMTMzLjEzMiA2Mi43OTA1IDEzMy4xNzRDNjMuMTQ2NiAxMzMuMjMyIDYzLjQ1NjggMTMzLjIgNjMuNzIxMSAxMzMuMDc5QzYzLjk4NSAxMzIuOTYxIDY0LjEzNzIgMTMyLjc3NyA2NC4xNzc3IDEzMi41MjdDNjQuMjEyOCAxMzIuMzEyIDY0LjE2MTEgMTMyLjEyNSA2NC4wMjI3IDEzMS45NjdDNjMuODg0MyAxMzEuODA5IDYzLjY0MzkgMTMxLjY1OSA2My4zMDE0IDEzMS41MTdMNjIuMzEzNCAxMzEuMTE1QzYxLjc0MTIgMTMwLjg4MSA2MS4zMzI2IDEzMC41OTcgNjEuMDg3NCAxMzAuMjY0QzYwLjg0MjMgMTI5LjkzIDYwLjc1NjggMTI5LjUzNSA2MC44MzExIDEyOS4wNzhDNjAuODk0IDEyOC42OTEgNjEuMDYyMiAxMjguMzY0IDYxLjMzNTcgMTI4LjA5OEM2MS42MDYgMTI3LjgzNCA2MS45NTQxIDEyNy42NDkgNjIuMzgwMSAxMjcuNTQyQzYyLjgwMzIgMTI3LjQzNSA2My4yNzU2IDEyNy40MjQgNjMuNzk3MiAxMjcuNTA5QzY0LjUyMDYgMTI3LjYyNyA2NS4wODU4IDEyNy44NzcgNjUuNDkyOCAxMjguMjZDNjUuODk5MyAxMjguNjQ2IDY2LjEwNzkgMTI5LjEzMyA2Ni4xMTg3IDEyOS43MjJMNjQuODczMSAxMjkuNzA5QzY0Ljg0ODkgMTI5LjM4IDY0LjczMjIgMTI5LjExNSA2NC41MjMxIDEyOC45MTRDNjQuMzEzNSAxMjguNzE2IDY0LjAxOTQgMTI4LjU4NiA2My42NDA5IDEyOC41MjRDNjMuMjI4NyAxMjguNDU3IDYyLjg4NTMgMTI4LjQ4OSA2Mi42MTA4IDEyOC42MkM2Mi4zMzU3IDEyOC43NTQgNjIuMTc4IDEyOC45NDYgNjIuMTM3NCAxMjkuMTk1QzYyLjEwNDYgMTI5LjM5NyA2Mi4xNTI4IDEyOS41NzkgNjIuMjgxOSAxMjkuNzQxQzYyLjQwODIgMTI5LjkwMyA2Mi42MTk4IDEzMC4wNDQgNjIuOTE2OSAxMzAuMTY0TDYzLjk3MTUgMTMwLjU4MUM2NC41NTIxIDEzMC44MTcgNjQuOTYyNCAxMzEuMTA4IDY1LjIwMjUgMTMxLjQ1NUM2NS40Mzk3IDEzMS44MDIgNjUuNTIxIDEzMi4yMDUgNjUuNDQ2MyAxMzIuNjY1QzY1LjM4NDMgMTMzLjA0NiA2NS4yMjM2IDEzMy4zNjIgNjQuOTY0IDEzMy42MTRDNjQuNzA0NCAxMzMuODY1IDY0LjM3MzcgMTM0LjA0IDYzLjk3MiAxMzQuMTM5QzYzLjU2OTkgMTM0LjI0IDYzLjEyNjIgMTM0LjI1MiA2Mi42NDExIDEzNC4xNzNDNjEuOTQyOSAxMzQuMDU5IDYxLjQxNzkgMTMzLjgxOSA2MS4wNjYxIDEzMy40NTFDNjAuNzEzOSAxMzMuMDg1IDYwLjUxNDMgMTMyLjY0IDYwLjQ2NzMgMTMyLjExNFoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTgxLjc4NzcgMTI2LjY0M0M4Mi4wMTcxIDEyNi42MDIgODIuMjI4NyAxMjYuNjQ4IDgyLjQyMjYgMTI2Ljc4MUM4Mi42MTcxIDEyNi45MTcgODIuNzM1IDEyNy4xMDEgODIuNzc2NCAxMjcuMzMzQzgyLjgxNzMgMTI3LjU2MiA4Mi43Njk4IDEyNy43NzIgODIuNjMzNyAxMjcuOTY0QzgyLjQ5ODEgMTI4LjE1OSA4Mi4zMTU3IDEyOC4yNzYgODIuMDg2NCAxMjguMzE3QzgxLjg1NyAxMjguMzU4IDgxLjY0NTEgMTI4LjMxMSA4MS40NTA3IDEyOC4xNzVDODEuMjU2OCAxMjguMDQzIDgxLjEzOTMgMTI3Ljg2MiA4MS4wOTg0IDEyNy42MzJDODEuMDcxIDEyNy40NzggODEuMDg0OSAxMjcuMzMgODEuMTQwMyAxMjcuMTg4QzgxLjE5MzMgMTI3LjA0OCA4MS4yNzYxIDEyNi45MyA4MS4zODg0IDEyNi44MzJDODEuNTAwOCAxMjYuNzM0IDgxLjYzMzkgMTI2LjY3MSA4MS43ODc3IDEyNi42NDNaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0xMDUuNDE5IDEyMC44ODdMMTAzLjQ1NSAxMTcuNTMzTDEwNC41NTQgMTE2Ljg4OUwxMDcuODYxIDEyMi41MzdMMTA2LjgwNiAxMjMuMTU2TDEwNi4yNjggMTIyLjIzNkwxMDYuMTk4IDEyMi4yNzdDMTA2LjI0MyAxMjIuNjUzIDEwNi4xODEgMTIzLjAxMiAxMDYuMDEgMTIzLjM1NkMxMDUuODM3IDEyMy43MDEgMTA1LjUzOCAxMjMuOTk4IDEwNS4xMTQgMTI0LjI0NkMxMDQuNzI5IDEyNC40NzIgMTA0LjM0NSAxMjQuNTg4IDEwMy45NjEgMTI0LjU5NkMxMDMuNTc4IDEyNC42MDYgMTAzLjIxNSAxMjQuNSAxMDIuODcgMTI0LjI3N0MxMDIuNTI2IDEyNC4wNTQgMTAyLjIxNyAxMjMuNzEgMTAxLjk0NCAxMjMuMjQ0TDk5Ljg0MDcgMTE5LjY1MUwxMDAuOTQgMTE5LjAwN0wxMDIuOTY2IDEyMi40NjdDMTAzLjIwNiAxMjIuODc3IDEwMy41IDEyMy4xMzQgMTAzLjg0OCAxMjMuMjRDMTA0LjE5OCAxMjMuMzQ3IDEwNC41NTkgMTIzLjI5MiAxMDQuOTMxIDEyMy4wNzRDMTA1LjE4NiAxMjIuOTI1IDEwNS4zODEgMTIyLjczNyAxMDUuNTE1IDEyMi41MUMxMDUuNjQ2IDEyMi4yODUgMTA1LjcwNyAxMjIuMDMyIDEwNS42OTcgMTIxLjc1MUMxMDUuNjg3IDEyMS40NzQgMTA1LjU5NCAxMjEuMTg2IDEwNS40MTkgMTIwLjg4N1oiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTExOS41MzUgMTAwLjg5NUwxMjUuODI2IDEwMy41MzVMMTI0Ljk5NCAxMDQuNTU2TDEyMC40NTggMTAyLjUxNUwxMjAuNDE3IDEwMi41NjVMMTIzLjMzMiAxMDYuNTk5TDEyMi41MDEgMTA3LjYyTDExNy45ODMgMTA1LjU4OUwxMTcuOTQzIDEwNS42MzlMMTIwLjg0OSAxMDkuNjQ5TDEyMC4wMTggMTEwLjY3TDExNi4xNTYgMTA1LjA0NkwxMTYuOTc3IDEwNC4wMzhMMTIxLjQ4IDEwNS45OTFMMTIxLjU0MiAxMDUuOTE1TDExOC43MTcgMTAxLjlMMTE5LjUzNSAxMDAuODk1WiIgZmlsbD0iIzE4MTgxOCIvPgo8cGF0aCBkPSJNMTI1LjgzMiA4NS4yMzMyQzEyNi4wMjggODQuNjUxNSAxMjYuMzMyIDg0LjE4ODggMTI2Ljc0NCA4My44NDQ5QzEyNy4xNTYgODMuNTAxMSAxMjcuNjQyIDgzLjI5IDEyOC4yMDIgODMuMjExNkMxMjguNzYyIDgzLjEzMzIgMTI5LjM2MiA4My4yMDE4IDEzMC4wMDMgODMuNDE3NEMxMzAuNjQ3IDgzLjYzMzkgMTMxLjE2OSA4My45NDMxIDEzMS41NzEgODQuMzQ1QzEzMS45NzIgODQuNzQ2OCAxMzIuMjMzIDg1LjIwOTMgMTMyLjM1NCA4NS43MzI1QzEzMi40NzUgODYuMjU1OCAxMzIuNDM3IDg2LjgwODIgMTMyLjI0MiA4Ny4zODk5QzEzMi4wNDYgODcuOTcxNSAxMzEuNzQyIDg4LjQzNDIgMTMxLjMzIDg4Ljc3ODFDMTMwLjkxOCA4OS4xMjE5IDEzMC40MyA4OS4zMzI2IDEyOS44NjggODkuNDEwMUMxMjkuMzA1IDg5LjQ4NzYgMTI4LjcwMiA4OS40MTgxIDEyOC4wNTkgODkuMjAxNUMxMjcuNDE4IDg4Ljk4NTkgMTI2Ljg5OCA4OC42Nzc2IDEyNi40OTkgODguMjc2N0MxMjYuMTAxIDg3Ljg3NTggMTI1Ljg0MSA4Ny40MTM3IDEyNS43MiA4Ni44OTA1QzEyNS41OTkgODYuMzY3MiAxMjUuNjM3IDg1LjgxNDggMTI1LjgzMiA4NS4yMzMyWk0xMjYuODQ1IDg1LjU3ODNDMTI2LjcxOCA4NS45NTUzIDEyNi43MTIgODYuMzAxMiAxMjYuODI4IDg2LjYxNkMxMjYuOTQ0IDg2LjkzMDcgMTI3LjE0OCA4Ny4yMDMxIDEyNy40MzkgODcuNDMzQzEyNy43MyA4Ny42NjU2IDEyOC4wNzQgODcuODQ5IDEyOC40NzMgODcuOTgzMUMxMjguODY5IDg4LjExNjIgMTI5LjI1MiA4OC4xNzggMTI5LjYyNCA4OC4xNjgyQzEyOS45OTggODguMTYyMSAxMzAuMzI4IDg4LjA2OTEgMTMwLjYxMyA4Ny44ODkzQzEzMC44OTggODcuNzA5NSAxMzEuMTA0IDg3LjQzMTEgMTMxLjIzMSA4Ny4wNTQyQzEzMS4zNTggODYuNjc0NSAxMzEuMzYzIDg2LjMyNTQgMTMxLjI0NiA4Ni4wMDcxQzEzMS4xMjcgODUuNjkxNCAxMzAuOTIxIDg1LjQxNjggMTMwLjYyOCA4NS4xODMzQzEzMC4zMzcgODQuOTUzMyAxMjkuOTkzIDg0Ljc3MTggMTI5LjU5NyA4NC42Mzg2QzEyOS4xOTkgODQuNTA0NSAxMjguODE0IDg0LjQ0MSAxMjguNDQzIDg0LjQ0OEMxMjguMDcxIDg0LjQ1NzggMTI3Ljc0NCA4NC41NTMgMTI3LjQ2MSA4NC43MzM3QzEyNy4xNzggODQuOTE3MSAxMjYuOTcyIDg1LjE5ODYgMTI2Ljg0NSA4NS41NzgzWiIgZmlsbD0iIzE4MTgxOCIvPgo8cGF0aCBkPSJNMTI3LjgyIDY3LjAxNTZDMTI3LjgyOSA2Ni40ODczIDEyNy45NzEgNjYuMDE3OSAxMjguMjQ4IDY1LjYwNzZDMTI4LjUyNyA2NS4yMDAxIDEyOC45MiA2NC44ODI2IDEyOS40MjcgNjQuNjU1QzEyOS45MzYgNjQuNDMwMyAxMzAuNTQ1IDY0LjMyMzcgMTMxLjI1MiA2NC4zMzUyQzEzMS45NTkgNjQuMzQ2NyAxMzIuNTYyIDY0LjQ3NDQgMTMzLjA2MSA2NC43MTgzQzEzMy41NiA2NC45NjUxIDEzMy45NCA2NS4yOTggMTM0LjIgNjUuNzE3MUMxMzQuNDYgNjYuMTM2MSAxMzQuNTg2IDY2LjYwODQgMTM0LjU3OCA2Ny4xMzM5QzEzNC41NzEgNjcuNTQwMSAxMzQuNDk3IDY3Ljg2NTcgMTM0LjM1NyA2OC4xMTA2QzEzNC4yMiA2OC4zNTg0IDEzNC4wNiA2OC41NDkgMTMzLjg3OSA2OC42ODI0QzEzMy42OTggNjguODE4NyAxMzMuNTM4IDY4LjkyNDEgMTMzLjQwMSA2OC45OTg2TDEzMy40IDY5LjA3NTNMMTM2LjY0MiA2OS4xMjhMMTM2LjYyMSA3MC40MDE5TDEyNy44OTUgNzAuMjYwMUwxMjcuOTE1IDY5LjAxNkwxMjguOTM0IDY5LjAzMjVMMTI4LjkzNiA2OC45MjZDMTI4Ljc5OCA2OC44NDcxIDEyOC42NCA2OC43MzM3IDEyOC40NjQgNjguNTg1OUMxMjguMjg3IDY4LjQ0MSAxMjguMTM0IDY4LjI0MjUgMTI4LjAwNSA2Ny45OTAzQzEyNy44NzUgNjcuNzM4MiAxMjcuODE0IDY3LjQxMzMgMTI3LjgyIDY3LjAxNTZaTTEyOC45MDIgNjcuMzE0NUMxMjguODk2IDY3LjY4MDkgMTI4Ljk4OCA2Ny45OTIxIDEyOS4xNzcgNjguMjQ4QzEyOS4zNjkgNjguNTA2OSAxMjkuNjM3IDY4LjcwNDQgMTI5Ljk4MSA2OC44NDA3QzEzMC4zMjUgNjguOTc5OSAxMzAuNzI4IDY5LjA1MzIgMTMxLjE4OCA2OS4wNjA2QzEzMS42NDIgNjkuMDY4IDEzMi4wNDEgNjkuMDA5MiAxMzIuMzg0IDY4Ljg4NEMxMzIuNzI3IDY4Ljc1ODkgMTMyLjk5NiA2OC41NzE1IDEzMy4xOSA2OC4zMjE4QzEzMy4zODUgNjguMDcyMSAxMzMuNDg1IDY3Ljc2MTEgMTMzLjQ5MSA2Ny4zODlDMTMzLjQ5NyA2Ny4wMDU2IDEzMy40MDMgNjYuNjg0NCAxMzMuMjA4IDY2LjQyNTVDMTMzLjAxNCA2Ni4xNjY2IDEzMi43NDUgNjUuOTY5MSAxMzIuNDA0IDY1LjgzMjhDMTMyLjA2MiA2NS42OTk0IDEzMS42NzUgNjUuNjI5MiAxMzEuMjQ0IDY1LjYyMjJDMTMwLjgwNiA2NS42MTUxIDEzMC40MTIgNjUuNjc0IDEzMC4wNiA2NS43OTlDMTI5LjcwOSA2NS45MjQgMTI5LjQyOSA2Ni4xMTI2IDEyOS4yMiA2Ni4zNjVDMTI5LjAxNCA2Ni42MjAyIDEyOC45MDggNjYuOTM2NyAxMjguOTAyIDY3LjMxNDVaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0xMzIuNjUyIDQ3LjQwMTNMMTI0LjQxMiA1MC4yNzdMMTIzLjk5MiA0OS4wNzM5TDEzMi4yMzIgNDYuMTk4MkwxMzIuNjUyIDQ3LjQwMTNaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0xMjkuMzU0IDM5Ljc5OTRMMTIxLjUzNiA0My42NzY3TDEyMC45NyA0Mi41MzVMMTI4Ljc4OSAzOC42NTc3TDEyOS4zNTQgMzkuNzk5NFoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTExMy4wNDEgMzEuMzk2N0MxMTIuNjU4IDMwLjkxNzEgMTEyLjQzNCAzMC40MTA3IDExMi4zNjggMjkuODc3N0MxMTIuMzAzIDI5LjM0NDcgMTEyLjM4OSAyOC44MjE2IDExMi42MjYgMjguMzA4NEMxMTIuODY0IDI3Ljc5NTIgMTEzLjI0NyAyNy4zMjc3IDExMy43NzUgMjYuOTA1OEMxMTQuMzA2IDI2LjQ4MjEgMTE0Ljg0OSAyNi4yMTA1IDExNS40MDQgMjYuMDkwOEMxMTUuOTU5IDI1Ljk3MTEgMTE2LjQ4OSAyNi4wMDIzIDExNi45OTQgMjYuMTg0NEMxMTcuNDk5IDI2LjM2NjQgMTE3Ljk0MyAyNi42OTczIDExOC4zMjUgMjcuMTc2OUMxMTguNzA4IDI3LjY1NjYgMTE4LjkzMiAyOC4xNjMgMTE4Ljk5OCAyOC42OTZDMTE5LjA2MyAyOS4yMjkgMTE4Ljk3NiAyOS43NTMgMTE4LjczNiAzMC4yNjc5QzExOC40OTcgMzAuNzgyOSAxMTguMTEyIDMxLjI1MjIgMTE3LjU4MSAzMS42NzU5QzExNy4wNTMgMzIuMDk3NyAxMTYuNTEyIDMyLjM2NzYgMTE1Ljk1OSAzMi40ODU1QzExNS40MDYgMzIuNjAzNCAxMTQuODc3IDMyLjU3MTMgMTE0LjM3MiAzMi4zODkzQzExMy44NjcgMzIuMjA3MyAxMTMuNDIzIDMxLjg3NjQgMTEzLjA0MSAzMS4zOTY3Wk0xMTMuODc5IDMwLjczMjdDMTE0LjEyNyAzMS4wNDM2IDExNC40MTUgMzEuMjM1NiAxMTQuNzQyIDMxLjMwODdDMTE1LjA3IDMxLjM4MTggMTE1LjQwOSAzMS4zNTgyIDExNS43NiAzMS4yMzc5QzExNi4xMTIgMzEuMTE5OCAxMTYuNDUzIDMwLjkyOTYgMTE2Ljc4MiAzMC42NjcyQzExNy4xMDggMzAuNDA2NiAxMTcuMzY4IDMwLjExNzQgMTE3LjU2MSAyOS43OTk0QzExNy43NTkgMjkuNDgxOSAxMTcuODU5IDI5LjE1NDUgMTE3Ljg2MiAyOC44MTcyQzExNy44NjYgMjguNDggMTE3Ljc0NCAyOC4xNTU5IDExNy40OTYgMjcuODQ1QzExNy4yNDYgMjcuNTMxOSAxMTYuOTU1IDI3LjMzODUgMTE2LjYyNCAyNy4yNjVDMTE2LjI5NCAyNy4xOTM2IDExNS45NTIgMjcuMjE3OSAxMTUuNTk3IDI3LjMzNzhDMTE1LjI0NiAyNy40NTgxIDExNC45MDcgMjcuNjQ4NSAxMTQuNTgxIDI3LjkwOTFDMTE0LjI1MyAyOC4xNzE1IDExMy45OTEgMjguNDYwNSAxMTMuNzk2IDI4Ljc3NjNDMTEzLjYwMiAyOS4wOTQyIDExMy41MDUgMjkuNDIwOSAxMTMuNTA0IDI5Ljc1NjRDMTEzLjUwNCAzMC4wOTQxIDExMy42MjkgMzAuNDE5NSAxMTMuODc5IDMwLjczMjdaIiBmaWxsPSIjMTgxODE4Ii8+CjxwYXRoIGQ9Ik0xMDIuMTc4IDIxLjgwOTVMMTA2LjEzNyAxNi41OTczTDEwNy4xMTggMTcuMzQyN0wxMDYuNDg5IDE4LjE3MDZMMTA2LjU0MyAxOC4yMTE5QzEwNi44NTEgMTguMDAzNiAxMDcuMTg2IDE3LjkxMDMgMTA3LjU0OCAxNy45MzE5QzEwNy45MTMgMTcuOTUzIDEwOC4yNDkgMTguMDc5NiAxMDguNTU0IDE4LjMxMTdDMTA4LjYxOCAxOC4zNTk4IDEwOC42OTEgMTguNDE4OCAxMDguNzczIDE4LjQ4ODdDMTA4Ljg1OCAxOC41NjAyIDEwOC45MjIgMTguNjE4MyAxMDguOTY3IDE4LjY2M0wxMDguMjMgMTkuNjMzNUMxMDguMTk4IDE5LjU5MTIgMTA4LjEzNSAxOS41MjM3IDEwOC4wNDEgMTkuNDMxMUMxMDcuOTQ5IDE5LjMzNjEgMTA3Ljg1MSAxOS4yNDkxIDEwNy43NDcgMTkuMTcwMUMxMDcuNTA3IDE4Ljk4NzggMTA3LjI1NSAxOC44NzYyIDEwNi45OSAxOC44MzUzQzEwNi43MjkgMTguNzkzOSAxMDYuNDc2IDE4LjgyMTMgMTA2LjIzMiAxOC45MTc0QzEwNS45ODkgMTkuMDExNCAxMDUuNzgyIDE5LjE3MTQgMTA1LjYxIDE5LjM5NzdMMTAzLjE5MiAyMi41ODA2TDEwMi4xNzggMjEuODA5NVoiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTkwLjM4NDIgMTUuOTUyM0M4OS44MDM1IDE1LjY5OSA4OS4zNjA5IDE1LjM0OTQgODkuMDU2MyAxNC45MDM1Qzg4Ljc1NTQgMTQuNDU2MSA4OC41OTQ2IDEzLjk1MDUgODguNTczOSAxMy4zODY2Qzg4LjU1MzEgMTIuODIyOCA4OC42NzM4IDEyLjI0MDEgODguOTM2MSAxMS42Mzg1Qzg5LjIwMTcgMTEuMDI5MSA4OS41NTA2IDEwLjU0MTMgODkuOTgzIDEwLjE3NTFDOTAuNDE2NCA5LjgwNjI0IDkwLjg5ODggOS41ODExOCA5MS40MzAxIDkuNDk5ODlDOTEuOTYxNCA5LjQxODU5IDkyLjUwOTUgOS41MDExOSA5My4wNzQ2IDkuNzQ3NjdDOTMuNTMwMyA5Ljk0NjQ0IDkzLjg5OTYgMTAuMjA4MyA5NC4xODI2IDEwLjUzMzJDOTQuNDY2NyAxMC44NTU1IDk0LjY1MjIgMTEuMjE1NCA5NC43MzkzIDExLjYxMjlDOTQuODI5IDEyLjAxMTUgOTQuODA2NyAxMi40MjE3IDk0LjY3MjQgMTIuODQzNkw5My41MzU4IDEyLjM0NzhDOTMuNTk1OSAxMi4wMzkzIDkzLjU1ODIgMTEuNzM0NiA5My40MjI4IDExLjQzMzhDOTMuMjkgMTEuMTM0MSA5My4wMzc0IDEwLjkwMyA5Mi42NjUxIDEwLjc0MDZDOTIuMzM5NiAxMC41OTg2IDkyLjAxNyAxMC41NjAyIDkxLjY5NzMgMTAuNjI1M0M5MS4zODEzIDEwLjY4ODkgOTEuMDg3IDEwLjg0ODggOTAuODE0MiAxMS4xMDQ4QzkwLjU0MjYgMTEuMzU4MyA5MC4zMTM3IDExLjY5ODYgOTAuMTI3NiAxMi4xMjU3Qzg5LjkzNjkgMTIuNTYzMiA4OS44Mzg3IDEyLjk2OTggODkuODMzIDEzLjM0NTRDODkuODI3MyAxMy43MjExIDg5LjkwNzUgMTQuMDQ5IDkwLjA3MzYgMTQuMzI5MUM5MC4yNDI0IDE0LjYxMDMgOTAuNDkyMSAxNC44MjMxIDkwLjgyMjggMTQuOTY3NEM5MS4wNDQxIDE1LjA2MzkgOTEuMjYyMiAxNS4xMTEgOTEuNDc3MSAxNS4xMDg2QzkxLjY5NTcgMTUuMTA0OCA5MS44OTk3IDE1LjA1MjggOTIuMDg5IDE0Ljk1MjVDOTIuMjgxIDE0Ljg1MzQgOTIuNDQ4OCAxNC43MDY1IDkyLjU5MjUgMTQuNTExOUw5My43MjkxIDE1LjAwNzdDOTMuNTE4MyAxNS4zNzc2IDkzLjI0MTEgMTUuNjY4OSA5Mi44OTczIDE1Ljg4MTZDOTIuNTUzNiAxNi4wOTQzIDkyLjE2NjYgMTYuMjEwNiA5MS43MzY1IDE2LjIzMDdDOTEuMzA4OSAxNi4yNTE4IDkwLjg1ODEgMTYuMTU5IDkwLjM4NDIgMTUuOTUyM1oiIGZpbGw9IiMxODE4MTgiLz4KPHBhdGggZD0iTTc4LjAwOTEgNy43NjExNkw3Ni44MzczIDcuODA5MUM3Ni44MDkyIDcuNjU2MjMgNzYuNzUyIDcuNTA2NTkgNzYuNjY1NyA3LjM2MDE4Qzc2LjU4MjMgNy4yMTQxNiA3Ni40NTkgNy4wODcxMSA3Ni4yOTU4IDYuOTc5MDVDNzYuMTMyNyA2Ljg3MDk4IDc1LjkyMDIgNi43OTkyNCA3NS42NTg0IDYuNzYzODRDNzUuMzAwOSA2LjcxNTQ4IDc0Ljk5MTYgNi43NTUzNiA3NC43MzA2IDYuODgzNDdDNzQuNDcgNy4wMDg3NyA3NC4zMjI4IDcuMTk2NyA3NC4yODg5IDcuNDQ3MjZDNzQuMjU5NiA3LjY2NDA0IDc0LjMxNjMgNy44NDk0NCA3NC40NTg5IDguMDAzNDZDNzQuNjAxNSA4LjE1NzQ4IDc0Ljg0NTggOC4zMDA5IDc1LjE5MTkgOC40MzM3Mkw3Ni4xOTA0IDguODA5NTVDNzYuNzY4NiA5LjAyODIyIDc3LjE4NDcgOS4zMDA5MyA3Ny40Mzg3IDkuNjI3NjlDNzcuNjkyNiA5Ljk1NDQ1IDc3Ljc4ODYgMTAuMzQ3MyA3Ny43MjY2IDEwLjgwNjJDNzcuNjc0MSAxMS4xOTQ3IDc3LjUxNDcgMTEuNTI1NyA3Ny4yNDg0IDExLjc5OTNDNzYuOTg1MyAxMi4wNzA1IDc2LjY0MjIgMTIuMjY0OSA3Ni4yMTkzIDEyLjM4MjZDNzUuNzk5MSAxMi41MDA2IDc1LjMyNzIgMTIuNTI0MyA3NC44MDM2IDEyLjQ1MzRDNzQuMDc3MiAxMi4zNTUyIDczLjUwNTUgMTIuMTIwMiA3My4wODg1IDExLjc0ODVDNzIuNjcxOCAxMS4zNzM5IDcyLjQ1MDIgMTAuODkyNCA3Mi40MjM3IDEwLjMwNEw3My42NjkyIDEwLjI4MzNDNzMuNzAyMiAxMC42MTE3IDczLjgyNTkgMTAuODczNSA3NC4wNDA0IDExLjA2ODhDNzQuMjU1MiAxMS4yNjEyIDc0LjU1MjYgMTEuMzgzMiA3NC45MzI2IDExLjQzNDZDNzUuMzQ2NSAxMS40OTA1IDc1LjY4ODkgMTEuNDQ5NCA3NS45NTk4IDExLjMxMTJDNzYuMjMxMiAxMS4xNzAxIDc2LjM4MzggMTAuOTc0MyA3Ni40MTc2IDEwLjcyMzhDNzYuNDQ1IDEwLjUyMSA3Ni4zOTIgMTAuMzQwNCA3Ni4yNTg2IDEwLjE4MTlDNzYuMTI4MSAxMC4wMjM4IDc1LjkxMjcgOS44ODg2IDc1LjYxMjUgOS43NzYzNEw3NC41NDcxIDkuMzg3MTRDNzMuOTYwNSA5LjE2NzM0IDczLjU0MjUgOC44ODcyIDczLjI5MzIgOC41NDY3NUM3My4wNDY4IDguMjA2NjcgNzIuOTU0OCA3LjgwNTc4IDczLjAxNzEgNy4zNDQwN0M3My4wNjg5IDYuOTYxMTggNzMuMjIxMSA2LjY0MDYzIDczLjQ3MzkgNi4zODI0QzczLjcyNjcgNi4xMjQxOCA3NC4wNTI1IDUuOTQwMzQgNzQuNDUxNCA1LjgzMDg4Qzc0Ljg1MDggNS43MTg2MSA3NS4yOTM5IDUuNjk1NDEgNzUuNzgxIDUuNzYxMjhDNzYuNDgyIDUuODU2MDggNzcuMDEzMiA2LjA4MjczIDc3LjM3NDcgNi40NDEyM0M3Ny43MzY2IDYuNzk2OTEgNzcuOTQ4MSA3LjIzNjg5IDc4LjAwOTEgNy43NjExNloiIGZpbGw9IiMxODE4MTgiLz4KPC9zdmc+Cg=="},6980:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDgiIHZpZXdCb3g9IjAgMCA0OCA0OCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeT0iNi4xMDM1MmUtMDUiIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgcng9IjEwIiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGQ9Ik0yMy41IDMzLjc1MDFDMTcuODUgMzMuNzUwMSAxMy4yNSAyOS4xNTAxIDEzLjI1IDIzLjUwMDFDMTMuMjUgMTcuODUwMSAxNy44NSAxMy4yNTAxIDIzLjUgMTMuMjUwMUMyOS4xNSAxMy4yNTAxIDMzLjc1IDE3Ljg1MDEgMzMuNzUgMjMuNTAwMUMzMy43NSAyOS4xNTAxIDI5LjE1IDMzLjc1MDEgMjMuNSAzMy43NTAxWk0yMy41IDE0Ljc1MDFDMTguNjcgMTQuNzUwMSAxNC43NSAxOC42ODAxIDE0Ljc1IDIzLjUwMDFDMTQuNzUgMjguMzIwMSAxOC42NyAzMi4yNTAxIDIzLjUgMzIuMjUwMUMyOC4zMyAzMi4yNTAxIDMyLjI1IDI4LjMyMDEgMzIuMjUgMjMuNTAwMUMzMi4yNSAxOC42ODAxIDI4LjMzIDE0Ljc1MDEgMjMuNSAxNC43NTAxWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMzLjk5OTkgMzQuNzUwMUMzMy44MDk5IDM0Ljc1MDEgMzMuNjE5OSAzNC42ODAxIDMzLjQ2OTkgMzQuNTMwMUwzMS40Njk5IDMyLjUzMDFDMzEuMTc5OSAzMi4yNDAxIDMxLjE3OTkgMzEuNzYwMSAzMS40Njk5IDMxLjQ3MDFDMzEuNzU5OSAzMS4xODAxIDMyLjIzOTkgMzEuMTgwMSAzMi41Mjk5IDMxLjQ3MDFMMzQuNTI5OSAzMy40NzAxQzM0LjgxOTkgMzMuNzYwMSAzNC44MTk5IDM0LjI0MDEgMzQuNTI5OSAzNC41MzAxQzM0LjM3OTkgMzQuNjgwMSAzNC4xODk5IDM0Ljc1MDEgMzMuOTk5OSAzNC43NTAxWiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg=="},6063:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDkiIHZpZXdCb3g9IjAgMCA0OCA0OSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeT0iMC41MDAxMjIiIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgcng9IjI0IiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGQ9Ik0yNCAxNi41MDAxTDIyLjU5IDE3LjkxMDFMMjguMTcgMjMuNTAwMUgxNlYyNS41MDAxSDI4LjE3TDIyLjU5IDMxLjA5MDFMMjQgMzIuNTAwMUwzMiAyNC41MDAxTDI0IDE2LjUwMDFaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K"},1268:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDgiIGhlaWdodD0iNDkiIHZpZXdCb3g9IjAgMCA0OCA0OSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMC41IiB5PSIxLjAwMDEyIiB3aWR0aD0iNDciIGhlaWdodD0iNDciIHJ4PSIyMy41IiBzdHJva2U9IiNCOUI5QjkiLz4KPHBhdGggZD0iTTMyIDIzLjUwMDFIMTkuODNMMjUuNDIgMTcuOTEwMUwyNCAxNi41MDAxTDE2IDI0LjUwMDFMMjQgMzIuNTAwMUwyNS40MSAzMS4wOTAxTDE5LjgzIDI1LjUwMDFIMzJWMjMuNTAwMVoiIGZpbGw9IiNCOUI5QjkiLz4KPC9zdmc+Cg=="},3734:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIyIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMTIyIDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjMzMzQgNy4wMTExOEMxNC4zNDY3IDYuMzUxOSAxMy4xODY3IDYgMTIgNlYwQzE0LjM3MzQgMCAxNi42OTM0IDAuNzAzNzg4IDE4LjY2NjggMi4wMjIzN0MyMC42NDAyIDMuMzQwOTQgMjIuMTc4MyA1LjIxNTA5IDIzLjA4NjYgNy40MDc3OEMyMy45OTQ4IDkuNjAwNDggMjQuMjMyNCAxMi4wMTMzIDIzLjc2OTQgMTQuMzQxMUMyMy4zMDY0IDE2LjY2ODggMjIuMTYzNSAxOC44MDcxIDIwLjQ4NTMgMjAuNDg1M0MxOC44MDcxIDIyLjE2MzUgMTYuNjY4OCAyMy4zMDY0IDE0LjM0MTEgMjMuNzY5NEMxMi4wMTMzIDI0LjIzMjQgOS42MDA0OCAyMy45OTQ4IDcuNDA3NzggMjMuMDg2NkM1LjIxNTA4IDIyLjE3ODMgMy4zNDA5NCAyMC42NDAyIDIuMDIyMzcgMTguNjY2OEMwLjcwMzc4OCAxNi42OTM0IDAgMTQuMzczNCAwIDEySDZDNiAxMy4xODY3IDYuMzUxOSAxNC4zNDY3IDcuMDExMTggMTUuMzMzNEM3LjY3MDQ2IDE2LjMyMDEgOC42MDc1NCAxNy4wODkxIDkuNzAzOTIgMTcuNTQzM0MxMC44MDAyIDE3Ljk5NzQgMTIuMDA2NyAxOC4xMTYyIDEzLjE3MDUgMTcuODg0N0MxNC4zMzQ0IDE3LjY1MzIgMTUuNDAzNSAxNy4wODE4IDE2LjI0MjcgMTYuMjQyN0MxNy4wODE4IDE1LjQwMzUgMTcuNjUzMiAxNC4zMzQ0IDE3Ljg4NDcgMTMuMTcwNUMxOC4xMTYyIDEyLjAwNjcgMTcuOTk3NCAxMC44MDAyIDE3LjU0MzMgOS43MDM5MkMxNy4wODkxIDguNjA3NTQgMTYuMzIwMSA3LjY3MDQ2IDE1LjMzMzQgNy4wMTExOFoiIGZpbGw9IiMzNUFGRjQiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDMuMTcwOTZlLTA2QzYgMC43ODc5MzQgNS44NDQ4MSAxLjU2ODE1IDUuNTQzMjggMi4yOTYxMUM1LjI0MTc1IDMuMDI0MDYgNC43OTk3OSAzLjY4NTQ5IDQuMjQyNjQgNC4yNDI2NEMzLjY4NTQ5IDQuNzk5OCAzLjAyNDA2IDUuMjQxNzUgMi4yOTYxIDUuNTQzMjhDMS41NjgxNCA1Ljg0NDgxIDAuNzg3OTI5IDYgMi42MjI2NmUtMDcgNkwwIDEyQzEuNTc1ODYgMTIgMy4xMzYyOSAxMS42ODk2IDQuNTkyMiAxMS4wODY2QzYuMDQ4MTIgMTAuNDgzNSA3LjM3MSA5LjU5OTU4IDguNDg1MjYgOC40ODUyNkM5LjU5OTU4IDcuMzcxIDEwLjQ4MzUgNi4wNDgxMiAxMS4wODY2IDQuNTkyMkMxMS42ODk2IDMuMTM2MjkgMTIgMS41NzU4NiAxMiAwTDYgMy4xNzA5NmUtMDZaIiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGQ9Ik03NS4zNzE0IDguNjcxNUg3Mi40NjAyVjE3LjkxODlINzUuMzcxNFY4LjY3MTVaIiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGQ9Ik03Mi43ODQyIDYuOTM5OTZDNzMuMDg4NCA3LjI0NDQgNzMuNDY4OCA3LjM5NjYyIDczLjkyNTQgNy4zOTY2MkM3NC4zODIgNy4zOTY2MiA3NC43NTY0IDcuMjQ0NCA3NS4wNDggNi45Mzk5NkM3NS4zNDAyIDYuNjIyODYgNzUuNDg2IDYuMjQyMjggNzUuNDg2IDUuNzk4MzFDNzUuNDg2IDUuMzQxNjYgNzUuMzQwMiA0Ljk2MTA5IDc1LjA0OCA0LjY1NjY3Qzc0Ljc1NjQgNC4zNTIyMSA3NC4zODIgNC4yIDczLjkyNTQgNC4yQzczLjQ2ODggNC4yIDczLjA4ODQgNC4zNTIyMSA3Mi43ODQyIDQuNjU2NjdDNzIuNDkyIDQuOTYxMDkgNzIuMzQ2MiA1LjM0MTY2IDcyLjM0NjIgNS43OTgzMUM3Mi4zNDYyIDYuMjQyMjggNzIuNDkyIDYuNjIyODYgNzIuNzg0MiA2LjkzOTk2WiIgZmlsbD0iIzM1QUZGNCIvPgo8cGF0aCBkPSJNMzAuNjkzNiAxNy45MTg5VjQuNDg1NDFIMzMuNjgwOVYxNS4yOTMxSDM5LjYzNjZWMTcuOTE4OUgzMC42OTM2WiIgZmlsbD0iIzM1QUZGNCIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTQ1LjAxNjQgMTguMTI4MkM0NC4wNjUgMTguMTI4MiA0My4yMDI1IDE3LjkxODkgNDIuNDI4NiAxNy41MDAzQzQxLjY2NzUgMTcuMDY5IDQxLjA2NSAxNi40ODU1IDQwLjYyMSAxNS43NDk3QzQwLjE3NzEgMTUuMDE0IDM5Ljk1NTEgMTQuMTg5NSAzOS45NTUxIDEzLjI3NjFDMzkuOTU1MSAxMi4zNjI4IDQwLjE3NzEgMTEuNTQ0NyA0MC42MjEgMTAuODIxNkM0MS4wNjUgMTAuMDk4NSA0MS42Njc1IDkuNTI3NyA0Mi40Mjg2IDkuMTA5MTRDNDMuMTg5NyA4LjY3NzggNDQuMDUyNCA4LjQ2MjE2IDQ1LjAxNjQgOC40NjIxNkM0NS45ODA1IDguNDYyMTYgNDYuODQzIDguNjcxNSA0Ny42MDQxIDkuMDkwMDZDNDguMzY1MiA5LjUwODY4IDQ4Ljk2NzggMTAuMDg1OSA0OS40MTE3IDEwLjgyMTZDNDkuODU1NyAxMS41NDQ3IDUwLjA3NzcgMTIuMzYyOCA1MC4wNzc3IDEzLjI3NjFDNTAuMDc3NyAxNC4xODk1IDQ5Ljg1NTcgMTUuMDE0IDQ5LjQxMTcgMTUuNzQ5N0M0OC45Njc4IDE2LjQ4NTUgNDguMzY1MiAxNy4wNjkgNDcuNjA0MSAxNy41MDAzQzQ2Ljg0MyAxNy45MTg5IDQ1Ljk4MDUgMTguMTI4MiA0NS4wMTY0IDE4LjEyODJaTTQ1LjAxNjQgMTUuNDgzNEM0NS40MzUgMTUuNDgzNCA0NS44MDI5IDE1LjM5NDYgNDYuMTIgMTUuMjE3QzQ2LjQzNzEgMTUuMDI2NyA0Ni42NzgxIDE0Ljc2NjcgNDYuODQzIDE0LjQzNjhDNDcuMDIwNiAxNC4wOTQ0IDQ3LjEwOTQgMTMuNzA3NCA0Ny4xMDk0IDEzLjI3NjFDNDcuMTA5NCAxMi44NDQ5IDQ3LjAyMDYgMTIuNDcwNiA0Ni44NDMgMTIuMTUzNUM0Ni42NjU0IDExLjgyMzcgNDYuNDE4MSAxMS41NyA0Ni4xMDA5IDExLjM5MjRDNDUuNzk2NSAxMS4yMDIxIDQ1LjQzNSAxMS4xMDcgNDUuMDE2NCAxMS4xMDdDNDQuNjEwNSAxMS4xMDcgNDQuMjQ5IDExLjIwMjEgNDMuOTMxOCAxMS4zOTI0QzQzLjYxNDcgMTEuNTcgNDMuMzY3MyAxMS44MjM3IDQzLjE4OTcgMTIuMTUzNUM0My4wMTIxIDEyLjQ4MzQgNDIuOTIzNCAxMi44NjM5IDQyLjkyMzQgMTMuMjk1MkM0Mi45MjM0IDEzLjcxMzggNDMuMDEyMSAxNC4wOTQ0IDQzLjE4OTcgMTQuNDM2OEM0My4zNjczIDE0Ljc2NjcgNDMuNjE0NyAxNS4wMjY3IDQzLjkzMTggMTUuMjE3QzQ0LjI0OSAxNS4zOTQ2IDQ0LjYxMDUgMTUuNDgzNCA0NS4wMTY0IDE1LjQ4MzRaIiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNTIuMzgzNSAyMS41MzQxQzUzLjE1NzMgMjEuODg5MyA1NC4wNTE2IDIyLjA2NjkgNTUuMDY2NCAyMi4wNjY5QzU2LjA1NTggMjIuMDY2OSA1Ni45Mzc0IDIxLjg3MDIgNTcuNzExMiAyMS40NzdDNTguNDg1IDIxLjA4MzggNTkuMDkzOCAyMC41Mzg0IDU5LjUzNzggMTkuODQwN0M1OS45ODE4IDE5LjE0MyA2MC4yMDQxIDE4LjMxODUgNjAuMjA0MSAxNy4zNjcxVjguNjcxNUg1Ny4zNDk2VjkuMjkyOEM1Ny4xMzc0IDkuMTE0MTIgNTYuODk2MyA4Ljk2NDEyIDU2LjYyNjYgOC44NDI3NEM1Ni4xMzE5IDguNjAxNzIgNTUuNTY3NCA4LjQ4MTE4IDU0LjkzMzIgOC40ODExOEM1NC4wODMzIDguNDgxMTggNTMuMzI4NSA4LjY4NDE2IDUyLjY2ODkgOS4wOTAwNkM1Mi4wMDkyIDkuNDgzMyA1MS40ODkyIDEwLjAyODggNTEuMTA4NiAxMC43MjY0QzUwLjcyOCAxMS40MTE1IDUwLjUzNzggMTIuMTg1MiA1MC41Mzc4IDEzLjA0NzhDNTAuNTM3OCAxMy44OTc3IDUwLjcyOCAxNC42NzE1IDUxLjEwODYgMTUuMzY5MkM1MS40ODkyIDE2LjA2NjkgNTIuMDA5MiAxNi42MTg3IDUyLjY2ODkgMTcuMDI0NkM1My4zMjg1IDE3LjQzMDUgNTQuMDgzMyAxNy42MzM1IDU0LjkzMzIgMTcuNjMzNUM1NS41NTQ3IDE3LjYzMzUgNTYuMTE5MiAxNy41MTMgNTYuNjI2NiAxNy4yNzJDNTYuODcyNCAxNy4xNTUyIDU3LjA5NDQgMTcuMDE3NiA1Ny4yOTI2IDE2Ljg1OTJWMTcuNDQzMkM1Ny4yOTI2IDE4LjA5MDEgNTcuMDgzMyAxOC41OTEyIDU2LjY2NDcgMTguOTQ2NEM1Ni4yNTg4IDE5LjMwMTYgNTUuNjk0MyAxOS40NzkxIDU0Ljk3MTIgMTkuNDc5MUM1NC4zODc3IDE5LjQ3OTEgNTMuODg2NyAxOS4zNzc3IDUzLjQ2ODEgMTkuMTc0N0M1My4wNjIyIDE4Ljk3MTggNTIuNjk0MiAxOC42NzM2IDUyLjM2NDQgMTguMjgwNEw1MC41NzU5IDIwLjA2OUM1MS4wMTk4IDIwLjcwMzIgNTEuNjIyNCAyMS4xOTE2IDUyLjM4MzUgMjEuNTM0MVpNNTYuNTMxNSAxNC43NzkzQzU2LjIzOTcgMTQuOTU2OSA1NS44OTA5IDE1LjA0NTcgNTUuNDg1IDE1LjA0NTdDNTUuMDc5MSAxNS4wNDU3IDU0LjcyMzkgMTQuOTU2OSA1NC40MTk0IDE0Ljc3OTNDNTQuMTI3NiAxNC42MDE3IDUzLjg5OTMgMTQuMzYwNyA1My43MzQ1IDE0LjA1NjNDNTMuNTY5NSAxMy43MzkyIDUzLjQ4NzEgMTMuNDAzIDUzLjQ4NzEgMTMuMDQ3OEM1My40ODcxIDEyLjY2NzMgNTMuNTY5NSAxMi4zMjQ4IDUzLjczNDUgMTIuMDIwM0M1My44OTkzIDExLjcxNTkgNTQuMTM0IDExLjQ3NDkgNTQuNDM4NCAxMS4yOTczQzU0Ljc0MjkgMTEuMTE5NyA1NS4wOTE3IDExLjAzMDkgNTUuNDg1IDExLjAzMDlDNTUuODkwOSAxMS4wMzA5IDU2LjIzOTcgMTEuMTE5NyA1Ni41MzE1IDExLjI5NzNDNTYuODM1OSAxMS40NzQ5IDU3LjA2NDIgMTEuNzE1OSA1Ny4yMTY1IDEyLjAyMDNDNTcuMzgxNCAxMi4zMjQ4IDU3LjQ2MzggMTIuNjY3MyA1Ny40NjM4IDEzLjA0NzhDNTcuNDYzOCAxMy40Mjg0IDU3LjM4MTQgMTMuNzcwOCA1Ny4yMTY1IDE0LjA3NTNDNTcuMDY0MiAxNC4zNjcxIDU2LjgzNTkgMTQuNjAxNyA1Ni41MzE1IDE0Ljc3OTNaIiBmaWxsPSIjMzVBRkY0Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNjYuMzMwNiAxOC4xMjgyQzY1LjM3OSAxOC4xMjgyIDY0LjUxNjIgMTcuOTE4OSA2My43NDI4IDE3LjUwMDNDNjIuOTgxNCAxNy4wNjkgNjIuMzc5IDE2LjQ4NTUgNjEuOTM1IDE1Ljc0OTdDNjEuNDkxIDE1LjAxNCA2MS4yNjkgMTQuMTg5NSA2MS4yNjkgMTMuMjc2MUM2MS4yNjkgMTIuMzYyOCA2MS40OTEgMTEuNTQ0NyA2MS45MzUgMTAuODIxNkM2Mi4zNzkgMTAuMDk4NSA2Mi45ODE0IDkuNTI3NyA2My43NDI4IDkuMTA5MTRDNjQuNTAzNiA4LjY3NzggNjUuMzY2NCA4LjQ2MjE2IDY2LjMzMDYgOC40NjIxNkM2Ny4yOTQyIDguNDYyMTYgNjguMTU3IDguNjcxNSA2OC45MTc4IDkuMDkwMDZDNjkuNjc5MiA5LjUwODY4IDcwLjI4MTYgMTAuMDg1OSA3MC43MjU2IDEwLjgyMTZDNzEuMTY5NiAxMS41NDQ3IDcxLjM5MTYgMTIuMzYyOCA3MS4zOTE2IDEzLjI3NjFDNzEuMzkxNiAxNC4xODk1IDcxLjE2OTYgMTUuMDE0IDcwLjcyNTYgMTUuNzQ5N0M3MC4yODE2IDE2LjQ4NTUgNjkuNjc5MiAxNy4wNjkgNjguOTE3OCAxNy41MDAzQzY4LjE1NyAxNy45MTg5IDY3LjI5NDIgMTguMTI4MiA2Ni4zMzA2IDE4LjEyODJaTTY2LjMzMDYgMTUuNDgzNEM2Ni43NDg4IDE1LjQ4MzQgNjcuMTE2NiAxNS4zOTQ2IDY3LjQzNCAxNS4yMTdDNjcuNzUwOCAxNS4wMjY3IDY3Ljk5MiAxNC43NjY3IDY4LjE1NyAxNC40MzY4QzY4LjMzNDYgMTQuMDk0NCA2OC40MjM0IDEzLjcwNzQgNjguNDIzNCAxMy4yNzYxQzY4LjQyMzQgMTIuODQ0OSA2OC4zMzQ2IDEyLjQ3MDYgNjguMTU3IDEyLjE1MzVDNjcuOTc5NCAxMS44MjM3IDY3LjczMjIgMTEuNTcgNjcuNDE0OCAxMS4zOTI0QzY3LjExMDYgMTEuMjAyMSA2Ni43NDg4IDExLjEwNyA2Ni4zMzA2IDExLjEwN0M2NS45MjQ0IDExLjEwNyA2NS41NjI2IDExLjIwMjEgNjUuMjQ1OCAxMS4zOTI0QzY0LjkyODQgMTEuNTcgNjQuNjgxMiAxMS44MjM3IDY0LjUwMzYgMTIuMTUzNUM2NC4zMjYgMTIuNDgzNCA2NC4yMzcyIDEyLjg2MzkgNjQuMjM3MiAxMy4yOTUyQzY0LjIzNzIgMTMuNzEzOCA2NC4zMjYgMTQuMDk0NCA2NC41MDM2IDE0LjQzNjhDNjQuNjgxMiAxNC43NjY3IDY0LjkyODQgMTUuMDI2NyA2NS4yNDU4IDE1LjIxN0M2NS41NjI2IDE1LjM5NDYgNjUuOTI0NCAxNS40ODM0IDY2LjMzMDYgMTUuNDgzNFoiIGZpbGw9IiMzNUFGRjQiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Mi4zNjg3IDE4LjEwOTFDODEuNzQ3NyAxOC4xMDkxIDgxLjE3NjUgMTcuOTg4NyA4MC42NTYzIDE3Ljc0NzZDODAuMzgyNyAxNy42MjA4IDgwLjEzNTUgMTcuNDY5NCA3OS45MTQ3IDE3LjI5MzNWMjEuODE5NUg3Ny4wNDEzVjguNjcxNUg3OS45NTI1VjkuMzA5NzJDODAuMTYzNyA5LjEzNjk4IDgwLjM5ODMgOC45ODc2NCA4MC42NTYzIDguODYxNzZDODEuMTc2NSA4LjYwODAyIDgxLjc0NzcgOC40ODExOCA4Mi4zNjg3IDguNDgxMThDODMuMjQ0MSA4LjQ4MTE4IDg0LjAxODEgOC42OTA1MiA4NC42OTAxIDkuMTA5MTRDODUuMzc1MyA5LjUyNzcgODUuOTA4MSAxMC4wOTg1IDg2LjI4ODUgMTAuODIxNkM4Ni42ODIxIDExLjU0NDcgODYuODc4MyAxMi4zNjkyIDg2Ljg3ODMgMTMuMjk1MkM4Ni44NzgzIDE0LjIyMTIgODYuNjgyMSAxNS4wNDU3IDg2LjI4ODUgMTUuNzY4OEM4NS45MDgxIDE2LjQ5MTggODUuMzc1MyAxNy4wNjI2IDg0LjY5MDEgMTcuNDgxMkM4NC4wMTgxIDE3Ljg5OTkgODMuMjQ0MSAxOC4xMDkxIDgyLjM2ODcgMTguMTA5MVpNODEuODM2NSAxNS40ODM0QzgyLjI1NDcgMTUuNDgzNCA4Mi42MTY1IDE1LjM4ODIgODIuOTIwNyAxNS4xOTc5QzgzLjIzODEgMTUuMDA3NyA4My40ODUzIDE0Ljc0NzYgODMuNjYyOSAxNC40MTc4QzgzLjg0MDUgMTQuMDg4IDgzLjkyOTMgMTMuNzEzOCA4My45MjkzIDEzLjI5NTJDODMuOTI5MyAxMi44NjM5IDgzLjg0MDUgMTIuNDgzNCA4My42NjI5IDEyLjE1MzVDODMuNDg1MyAxMS44MjM3IDgzLjIzODEgMTEuNTcgODIuOTIwNyAxMS4zOTI0QzgyLjYxNjUgMTEuMjAyMSA4Mi4yNjEzIDExLjEwNyA4MS44NTUxIDExLjEwN0M4MS40NDk1IDExLjEwNyA4MS4wODc3IDExLjIwMjEgODAuNzcwOSAxMS4zOTI0QzgwLjQ2NjEgMTEuNTcgODAuMjI1NSAxMS44MjM3IDgwLjA0NzkgMTIuMTUzNUM3OS44NzAzIDEyLjQ4MzQgNzkuNzgxNSAxMi44NjM5IDc5Ljc4MTUgMTMuMjk1MkM3OS43ODE1IDEzLjcxMzggNzkuODYzNyAxNC4wODggODAuMDI4NyAxNC40MTc4QzgwLjIwNjMgMTQuNzQ3NiA4MC40NTM1IDE1LjAwNzcgODAuNzcwOSAxNS4xOTc5QzgxLjA4NzcgMTUuMzg4MiA4MS40NDI5IDE1LjQ4MzQgODEuODM2NSAxNS40ODM0WiIgZmlsbD0iIzM1QUZGNCIvPgo8cGF0aCBkPSJNODkuNzI3NiAxNy45Mzc5QzkwLjI2MDQgMTguMDc3NSA5MC43OTkyIDE4LjE0NzIgOTEuMzQ0NiAxOC4xNDcyQzkyLjQ5OSAxOC4xNDcyIDkzLjQxMjIgMTcuODgwOCA5NC4wODQ4IDE3LjM0OEM5NC43Njk0IDE2LjgxNTMgOTUuMTEyIDE2LjA5ODYgOTUuMTEyIDE1LjE5NzlDOTUuMTEyIDE0LjYxNDQgOTUuMDA0NiAxNC4xNDUxIDk0Ljc4ODYgMTMuNzg5OUM5NC41NzMyIDEzLjQyMjEgOTQuMjk0MiAxMy4xMzAzIDkzLjk1MTYgMTIuOTE0NkM5My42MDkgMTIuNjk5IDkzLjI0NzIgMTIuNTI3NyA5Mi44NjY4IDEyLjQwMDlDOTIuNDg2NCAxMi4yNzQgOTIuMTI0NiAxMi4xNjYyIDkxLjc4MjYgMTIuMDc3NEM5MS40NCAxMS45ODg2IDkxLjE2MSAxMS44ODcxIDkwLjk0NSAxMS43NzNDOTAuNzI5NiAxMS42NTg4IDkwLjYyMTYgMTEuNTA2NiA5MC42MjE2IDExLjMxNjNDOTAuNjIxNiAxMS4xMzg3IDkwLjcwNDQgMTEuMDA1NSA5MC44Njg4IDEwLjkxNjdDOTEuMDMzOCAxMC44MTUyIDkxLjI4MSAxMC43NjQ1IDkxLjYxMSAxMC43NjQ1QzkxLjk1MzYgMTAuNzY0NSA5Mi4zMDIyIDEwLjgzNDMgOTIuNjU3NCAxMC45NzM4QzkzLjAyNTIgMTEuMTEzMyA5My4zNTUyIDExLjM1NDQgOTMuNjQ2OCAxMS42OTY5TDk1LjMwMjIgMTAuMDIyNUM5NC44ODQgOS40ODk2NiA5NC4zMzg2IDkuMDkwMDYgOTMuNjY2IDguODIzNzJDOTMuMDA2NiA4LjU0NDY2IDkyLjI4MzYgOC40MDUxIDkxLjQ5NyA4LjQwNTFDOTAuNzQ4OCA4LjQwNTEgOTAuMDk1NCA4LjUzMTk0IDg5LjUzNzQgOC43ODU2MkM4OC45Nzg4IDkuMDM5MzYgODguNTQ3NCA5LjM4ODIgODguMjQzMiA5LjgzMjE0Qzg3LjkzOSAxMC4yNjM0IDg3Ljc4NjYgMTAuNzc3MiA4Ny43ODY2IDExLjM3MzRDODcuNzg2NiAxMS45MzE1IDg3Ljg5NDYgMTIuMzk0NiA4OC4xMSAxMi43NjI0Qzg4LjMyNTQgMTMuMTE3NiA4OC42MDUgMTMuMzk2NyA4OC45NDcgMTMuNTk5NkM4OS4yODk2IDEzLjgwMjYgODkuNjUxNCAxMy45NjEyIDkwLjAzMTggMTQuMDc1M0M5MC40MTIyIDE0LjE4OTUgOTAuNzc0IDE0LjI5NzMgOTEuMTE2NiAxNC4zOTg4QzkxLjQ1ODYgMTQuNDg3NiA5MS43MzgyIDE0LjU5NTQgOTEuOTUzNiAxNC43MjIzQzkyLjE4MjIgMTQuODM2NCA5Mi4yOTYyIDE1LjAwNzcgOTIuMjk2MiAxNS4yMzZDOTIuMjk2MiAxNS40MTM2IDkyLjIwMDggMTUuNTUzMSA5Mi4wMTA2IDE1LjY1NDZDOTEuODMzIDE1Ljc1NjEgOTEuNTczMiAxNS44MDY4IDkxLjIzMDYgMTUuODA2OEM5MC43MzU2IDE1LjgwNjggOTAuMjc5IDE1LjcxOCA4OS44NjA4IDE1LjU0MDRDODkuNDQyIDE1LjM1MDIgODkuMDgwMiAxNS4wOTAxIDg4Ljc3NiAxNC43NjAzTDg3LjEyMDYgMTYuNDM0N0M4Ny40MzggMTYuNzc3MiA4Ny44MTg0IDE3LjA4MTcgODguMjYyNCAxNy4zNDhDODguNzE5IDE3LjYwMTcgODkuMjA3NCAxNy43OTgzIDg5LjcyNzYgMTcuOTM3OVoiIGZpbGw9IiMzNUFGRjQiLz4KPHBhdGggZD0iTTEwMC40MjEgMTguMTI4MkM5OS41NzEyIDE4LjEyODIgOTguODE2NCAxNy45NTY5IDk4LjE1NyAxNy42MTQ0Qzk3LjUwOTYgMTcuMjU5MiA5Ny4wMDI2IDE2Ljc3NzIgOTYuNjM0OCAxNi4xNjgzQzk2LjI2NjQgMTUuNTQ2OCA5Ni4wODI4IDE0LjgzNjQgOTYuMDgyOCAxNC4wMzcyVjguNjcxNUg5OC45OTRWMTMuOTk5MkM5OC45OTQgMTQuMzE2MyA5OS4wNDQ0IDE0LjU4OTEgOTkuMTQ2NCAxNC44MTc0Qzk5LjI2MDQgMTUuMDQ1NyA5OS40MjU0IDE1LjIyMzMgOTkuNjQwOCAxNS4zNTAyQzk5Ljg1NjggMTUuNDc3IDEwMC4xMTcgMTUuNTQwNCAxMDAuNDIxIDE1LjU0MDRDMTAwLjg1MiAxNS41NDA0IDEwMS4xOTUgMTUuNDA3MiAxMDEuNDQ5IDE1LjE0MDhDMTAxLjcwMiAxNC44NjE4IDEwMS44MjkgMTQuNDgxMiAxMDEuODI5IDEzLjk5OTJWOC42NzE1SDEwNC43NFYxNC4wMTgyQzEwNC43NCAxNC44MzAxIDEwNC41NTcgMTUuNTQ2OCAxMDQuMTg4IDE2LjE2ODNDMTAzLjgyIDE2Ljc3NzIgMTAzLjMxMyAxNy4yNTkyIDEwMi42NjYgMTcuNjE0NEMxMDIuMDE5IDE3Ljk1NjkgMTAxLjI3MSAxOC4xMjgyIDEwMC40MjEgMTguMTI4MloiIGZpbGw9IiMzNUFGRjQiLz4KPHBhdGggZD0iTTEwOS4wOTkgOC42NzE1SDEwNi4xODhWMTcuOTE4OUgxMDkuMDk5VjEyLjUxNUMxMDkuMDk5IDEyLjE5NzkgMTA5LjE2MiAxMS45MzE1IDEwOS4yODkgMTEuNzE1OUMxMDkuNDI5IDExLjUwMDMgMTA5LjYxMyAxMS4zMzUzIDEwOS44NDEgMTEuMjIxMkMxMTAuMDY5IDExLjA5NDMgMTEwLjMyOSAxMS4wMzA5IDExMC42MjEgMTEuMDMwOUMxMTEuMDQgMTEuMDMwOSAxMTEuMzg4IDExLjE2NDEgMTExLjY2NyAxMS40MzA1QzExMS45NTkgMTEuNjg0MiAxMTIuMTA1IDEyLjA0NTcgMTEyLjEwNSAxMi41MTVWMTcuOTE4OUgxMTUuMDE2VjEyLjUxNUMxMTUuMDE2IDEyLjE5NzkgMTE1LjA4IDExLjkzMTUgMTE1LjIwNyAxMS43MTU5QzExNS4zNDYgMTEuNTAwMyAxMTUuNTMgMTEuMzM1MyAxMTUuNzU5IDExLjIyMTJDMTE1Ljk4NyAxMS4wOTQzIDExNi4yNDcgMTEuMDMwOSAxMTYuNTM5IDExLjAzMDlDMTE2Ljk1NyAxMS4wMzA5IDExNy4zMDYgMTEuMTY0MSAxMTcuNTg1IDExLjQzMDVDMTE3Ljg3NyAxMS42ODQyIDExOC4wMjIgMTIuMDQ1NyAxMTguMDIyIDEyLjUxNVYxNy45MTg5SDEyMC45MzRWMTIuMTkxNkMxMjAuOTM0IDExLjQxNzggMTIwLjc2OSAxMC43NTgyIDEyMC40MzkgMTAuMjEyN0MxMjAuMTIyIDkuNjU0NTQgMTE5LjY4NSA5LjIyOTYyIDExOS4xMjcgOC45Mzc5QzExOC41ODEgOC42MzM0IDExNy45NTMgOC40ODExOCAxMTcuMjQzIDguNDgxMThDMTE2LjUyIDguNDgxMTggMTE1Ljg2NiA4LjYzOTc2IDExNS4yODMgOC45NTY5MkMxMTQuOTA0IDkuMTU4OTQgMTE0LjU3MiA5LjQxOTcgMTE0LjI4OSA5LjczOTE0QzExNC4wMjQgOS40MDUgMTEzLjcwMiA5LjEzMTU4IDExMy4zMjMgOC45MTg4MkMxMTIuODE2IDguNjI3MSAxMTIuMjM4IDguNDgxMTggMTExLjU5MiA4LjQ4MTE4QzExMC45MDYgOC40ODExOCAxMTAuMjkxIDguNjI3MSAxMDkuNzQ2IDguOTE4ODJDMTA5LjUwOCA5LjA0MDIgMTA5LjI5MyA5LjE4NTU4IDEwOS4wOTkgOS4zNTQ5NlY4LjY3MTVaIiBmaWxsPSIjMzVBRkY0Ii8+Cjwvc3ZnPgo="},7196:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTEiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCA5MSAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzM4OV81OTIpIj4KPHBhdGggZD0iTTQ3LjY0MzcgNy4wMzUyNEM0Ny42NDM3IDguMDQ0MzQgNDYuODMwNiA4Ljg1Njg5IDQ1LjgyMTUgOC44NTY4OUM0NC44MTI0IDguODU2ODkgNDMuOTk5OSA4LjA0NDM0IDQzLjk5OTkgNy4wMzUyNEM0My45OTk5IDYuMDI2MTQgNDQuNzg0NyA1LjIxMzU5IDQ1LjgyMTUgNS4yMTM1OUM0Ni44NTkyIDUuMjQxNTkgNDcuNjQzNyA2LjA1NDQyIDQ3LjY0MzcgNy4wMzUyNFpNNDAuMTMyIDEwLjcwNzFWMTEuMTU1NkM0MC4xMzIgMTEuMTU1NiAzOS4yNjM1IDEwLjAzNCAzNy40MTM2IDEwLjAzNEMzNC4zNTg4IDEwLjAzNCAzMS45NzYxIDEyLjM2MDUgMzEuOTc2MSAxNS41ODM1QzMxLjk3NjEgMTguNzc4OCAzNC4zMzA4IDIxLjEzMjkgMzcuNDEzNiAyMS4xMzI5QzM5LjI5MTUgMjEuMTMyOSA0MC4xMzIgMTkuOTgzOSA0MC4xMzIgMTkuOTgzOVYyMC40NjAxQzQwLjEzMiAyMC42ODQ0IDQwLjMwMDYgMjAuODUyMSA0MC41MjQ2IDIwLjg1MjFINDIuNzk0NVYxMC4zMTM0SDQwLjUyNDZDNDAuMzAwNiAxMC4zMTQzIDQwLjEzMiAxMC41MTA4IDQwLjEzMiAxMC43MDcxWk00MC4xMzIgMTcuNDYxNEMzOS43MTIxIDE4LjA3ODIgMzguODcxIDE4LjYxMDggMzcuODYyMSAxOC42MTA4QzM2LjA2ODUgMTguNjEwOCAzNC42OTQ4IDE3LjQ4OTcgMzQuNjk0OCAxNS41ODM1QzM0LjY5NDggMTMuNjc3NSAzNi4wNjg1IDEyLjU1NjQgMzcuODYyMSAxMi41NTY0QzM4Ljg0MzIgMTIuNTU2NCAzOS43NDAxIDEzLjExNyA0MC4xMzIgMTMuNzA1NVYxNy40NjE0Wk00NC40NzY0IDEwLjMxNDNINDcuMTY2OVYyMC44NTNINDQuNDc2NFYxMC4zMTQzWk04NC42NjgyIDEwLjAzMzdDODIuODE4MyAxMC4wMzM3IDgxLjk0OTIgMTEuMTU1NCA4MS45NDkyIDExLjE1NTRWNS4yNDE1OUg3OS4yNTg3VjIwLjg1M0g4MS41MjkyQzgxLjc1MzUgMjAuODUzIDgxLjkyMTIgMjAuNjU2NyA4MS45MjEyIDIwLjQ2MDRWMTkuOTg0MUM4MS45MjEyIDE5Ljk4NDEgODIuNzkwMyAyMS4xMzMyIDg0LjYzOTcgMjEuMTMzMkM4Ny42OTUgMjEuMTMzMiA5MC4wNzcyIDE4Ljc3OTYgOTAuMDc3MiAxNS41ODQzQzkwLjA3NzIgMTIuMzg5IDg3LjY5NSAxMC4wMzM3IDg0LjY2ODIgMTAuMDMzN1pNODQuMjE5NyAxOC41ODI1QzgzLjE4MjMgMTguNTgyNSA4Mi4zNjk4IDE4LjA1MDUgODEuOTQ5MiAxNy40MzM0VjEzLjY3NzVDODIuMzY5OCAxMy4xMTcgODMuMjY2NiAxMi41Mjg0IDg0LjIxOTcgMTIuNTI4NEM4Ni4wMTMzIDEyLjUyODQgODcuMzg2NyAxMy42NDk1IDg3LjM4NjcgMTUuNTU1NUM4Ny4zODY3IDE3LjQ2MTQgODYuMDEzNiAxOC41ODI1IDg0LjIxOTcgMTguNTgyNVpNNzcuODU3NyAxNC42MDI5VjIwLjg4MUg3NS4xNjY2VjE0LjkxMDlDNzUuMTY2NiAxMy4xNzM2IDc0LjYwNjEgMTIuNDcyNSA3My4wOTM2IDEyLjQ3MjVDNzIuMjgxIDEyLjQ3MjUgNzEuNDM5OSAxMi44OTMgNzAuOTA2NSAxMy41MDk4VjIwLjg1MzJINjguMjE2NlYxMC4zMTQ1SDcwLjM0NkM3MC41NzAyIDEwLjMxNDUgNzAuNzM4NSAxMC41MTA4IDcwLjczODUgMTAuNzA3MVYxMS4xNTU2QzcxLjUyMzMgMTAuMzQyNSA3Mi41NjAyIDEwLjAzNCA3My41OTcgMTAuMDM0Qzc0Ljc3NDQgMTAuMDM0IDc1Ljc1NTUgMTAuMzcwOCA3Ni41NDAzIDExLjA0MzRDNzcuNDkyOCAxMS44MjgyIDc3Ljg1NzcgMTIuODM3IDc3Ljg1NzcgMTQuNjAyOVpNNjEuNjg1MiAxMC4wMzM3QzU5LjgzNTggMTAuMDMzNyA1OC45NjY3IDExLjE1NTQgNTguOTY2NyAxMS4xNTU0VjUuMjQxNTlINTYuMjc2M1YyMC44NTNINTguNTQ2MkM1OC43NzA0IDIwLjg1MyA1OC45Mzg3IDIwLjY1NjcgNTguOTM4NyAyMC40NjA0VjE5Ljk4NDFDNTguOTM4NyAxOS45ODQxIDU5LjgwNzggMjEuMTMzMiA2MS42NTcyIDIxLjEzMzJDNjQuNzEyNSAyMS4xMzMyIDY3LjA5NDcgMTguNzc5NiA2Ny4wOTQ3IDE1LjU4NDNDNjcuMTIyNyAxMi4zODg3IDY0Ljc0MDUgMTAuMDMzNyA2MS42ODUyIDEwLjAzMzdaTTYxLjIzNjYgMTguNTgyNUM2MC4xOTk4IDE4LjU4MjUgNTkuMzg3MyAxOC4wNTA1IDU4Ljk2NjcgMTcuNDMzNFYxMy42Nzc1QzU5LjM4NzMgMTMuMTE3IDYwLjI4NDEgMTIuNTI4NCA2MS4yMzY2IDEyLjUyODRDNjMuMDMwOCAxMi41Mjg0IDY0LjQwMzkgMTMuNjQ5NSA2NC40MDM5IDE1LjU1NTVDNjQuNDAzOSAxNy40NjE0IDYzLjAzMDggMTguNTgyNSA2MS4yMzY2IDE4LjU4MjVaTTUzLjk0OTggMTAuMDMzN0M1NC43NjIzIDEwLjAzMzcgNTUuMTgyOSAxMC4xNzQzIDU1LjE4MjkgMTAuMTc0M1YxMi42Njg0QzU1LjE4MjkgMTIuNjY4NCA1Mi45NDA3IDExLjkxMTYgNTEuNTM5NiAxMy41MDk1VjIwLjg4MDdINDguODQ4NlYxMC4zMTQzSDUxLjExOUM1MS4zNDMzIDEwLjMxNDMgNTEuNTExIDEwLjUxMDUgNTEuNTExIDEwLjcwNjhWMTEuMTU1NEM1Mi4wMTYxIDEwLjU2NjUgNTMuMTA5MiAxMC4wMzM3IDUzLjk0OTggMTAuMDMzN1pNMjYuMDA2NiAxOS44OTk5QzI1Ljg2NjYgMTkuNTYzNiAyNS43MjYzIDE5LjE5OTMgMjUuNTg2MyAxOC44OTA4QzI1LjM2MTggMTguMzg2NSAyNS4xMzc1IDE3LjkwOTcgMjQuOTQxOCAxNy40NjE0TDI0LjkxMzggMTcuNDMzNEMyMi45Nzk2IDEzLjIyOSAyMC45MDU5IDguOTY5MTYgMTguNzE5NSA0Ljc2NTMzTDE4LjYzNTUgNC41OTY3NkMxOC40MDU1IDQuMTYwNjYgMTguMTgxNCAzLjcyMTUgMTcuOTYzMiAzLjI3OTM5QzE3LjY4MjcgMi43NzQ1NiAxNy40MDI3IDIuMjQyNTcgMTYuOTU0MSAxLjczNzc0QzE2LjA1NzMgMC42MTY2NDUgMTQuNzY3OSAtMC4wMDAxODMxMDUgMTMuMzk0OCAtMC4wMDAxODMxMDVDMTEuOTkzMiAtMC4wMDAxODMxMDUgMTAuNzMyMSAwLjYxNjY0OCA5LjgwNzU0IDEuNjgxNDdDOS4zODY5OSAyLjE4NTc0IDkuMDc4NDMgMi43MTgyOSA4Ljc5ODQ0IDMuMjIzMTJDOC41Nzk2OSAzLjY2NDk1IDguMzU1NTkgNC4xMDQxIDguMTI2MTcgNC41NDA0OUw4LjA0MTg5IDQuNzA5MDRDNS44ODM3IDguOTEyODggMy43ODE3NyAxMy4xNzMgMS44NDc4NSAxNy4zNzcxTDEuODE5NTggMTcuNDMyOEMxLjYyMzU4IDE3Ljg4MTkgMS4zOTkwMiAxOC4zNTgyIDEuMTc0NzUgMTguODYyMkMxLjAzNDc1IDE5LjE3MDggMC44OTQ3NTUgMTkuNTA3IDAuNzU0NzU3IDE5Ljg3MTNDMC4zOTAyMDUgMjAuOTA4MSAwLjI3NzkyMiAyMS44ODkyIDAuNDE4NDc5IDIyLjg5ODZDMC43MjY3NTMgMjUuMDAwOCAyLjEyNzg0IDI2Ljc2NTkgNC4wNjIwNSAyNy41NTEzQzQuNzkwODcgMjcuODU5OCA1LjU0NzcgMjcuOTk5OCA2LjMzMjI0IDI3Ljk5OThDNi41NTY1MiAyNy45OTk4IDYuODM2NTIgMjcuOTcxOCA3LjA2MTA3IDI3Ljk0MzVDNy45ODYxOCAyNy44MzE1IDguOTM4OTkgMjcuNTIzNSA5Ljg2NDA5IDI2Ljk5MUMxMS4wMTMyIDI2LjM0NjIgMTIuMTA2MyAyNS40MjE2IDEzLjMzOTQgMjQuMDc2M0MxNC41NzI1IDI1LjQyMTYgMTUuNjkzNiAyNi4zNDYyIDE2LjgxNDcgMjYuOTkxQzE3Ljc0MDEgMjcuNTIzNSAxOC42OTI2IDI3LjgzMTUgMTkuNjE3NCAyNy45NDM1QzE5Ljg0MTcgMjcuOTcyMSAyMC4xMjIyIDI3Ljk5OTggMjAuMzQ2NSAyNy45OTk4QzIxLjEzMTMgMjcuOTk5OCAyMS45MTU5IDI3Ljg1OTggMjIuNjE2NCAyNy41NTEzQzI0LjU3ODYgMjYuNzY1OSAyNS45NTE3IDI0Ljk3MjggMjYuMjYwMyAyMi44OTg2QzI2LjQ4MjkgMjEuOTE3OCAyNi4zNzA5IDIwLjkzNzIgMjYuMDA2NiAxOS44OTk5Wk0xMy4zNjY1IDIxLjM1NzJDMTEuODUyOSAxOS40NTEzIDEwLjg3MTggMTcuNjU3NyAxMC41MzU4IDE2LjE0NDZDMTAuMzk1OCAxNS40OTk3IDEwLjM2NzUgMTQuOTM5MiAxMC40NTE4IDE0LjQzNDdDMTAuNTA3NSAxMy45ODYxIDEwLjY3NjEgMTMuNTkzNSAxMC45MDA0IDEzLjI1NzNDMTEuNDMyOSAxMi41MDEgMTIuMzI5NyAxMi4wMjQyIDEzLjM2NjggMTIuMDI0MkMxNC40MDQyIDEyLjAyNDIgMTUuMzI5IDEyLjQ3MjcgMTUuODMzNiAxMy4yNTczQzE2LjA1NzkgMTMuNTkzNSAxNi4yMjU4IDEzLjk4NjQgMTYuMjgyNCAxNC40MzQ3QzE2LjM2NjEgMTQuOTM5NSAxNi4zMzgxIDE1LjUyNzcgMTYuMTk4MSAxNi4xNDQ2QzE1Ljg2MDcgMTcuNjI5NyAxNC44Nzk2IDE5LjQyMzYgMTMuMzY2NSAyMS4zNTcyWk0yNC41NDkgMjIuNjc0NkMyNC4zNTMgMjQuMTMyIDIzLjM3MTkgMjUuMzkzNiAyMS45OTg4IDI1Ljk1NDJDMjEuMzI2MiAyNi4yMzQyIDIwLjU5NzEgMjYuMzE4NCAxOS44Njg5IDI2LjIzNDJDMTkuMTY4MyAyNi4xNDk5IDE4LjQ2NzIgMjUuOTI1NiAxNy43Mzg5IDI1LjUwNTZDMTYuNzI5OCAyNC45NDQ1IDE1LjcyMSAyNC4wNzYzIDE0LjU0MzYgMjIuNzg2NkMxNi4zOTMzIDIwLjUxNjcgMTcuNTE0NCAxOC40NDIyIDE3LjkzNDkgMTYuNTkyOEMxOC4xMzEyIDE1LjcyMzcgMTguMTU5NSAxNC45MzkyIDE4LjA3NDkgMTQuMjEwMUMxNy45NjMyIDEzLjUwOTUgMTcuNzEwNyAxMi44NjQ3IDE3LjMxODQgMTIuMzA0MkMxNi40NDkgMTEuMDQyNSAxNC45OTE0IDEwLjMxNDMgMTMuMzY2MyAxMC4zMTQzQzExLjc0MTIgMTAuMzE0MyAxMC4yODM1IDExLjA3MTEgOS40MTQ3IDEyLjMwNDJDOS4wMjI0MyAxMi44NjQ3IDguNzY5ODcgMTMuNTA5NSA4LjY1Nzg3IDE0LjIxMDFDOC41NDU4OCAxNC45MzkyIDguNTczNiAxNS43NTE3IDguNzk3ODcgMTYuNTkyOEM5LjIxODE0IDE4LjQ0MjIgMTAuMzY3MiAyMC41NDQ0IDEyLjE4ODkgMjIuODE0NkMxMS4wMzk4IDI0LjEwNCAxMC4wMDI3IDI0Ljk3MzEgOC45OTM1OSAyNS41MzM2QzguMjY0NzYgMjUuOTU0MiA3LjU2NDUgMjYuMTc4NSA2Ljg2Mzk2IDI2LjI2MjJDNi4xMDc0MSAyNi4zNDY1IDUuMzc4MyAyNi4yMzQyIDQuNzMzNzYgMjUuOTgyMkMzLjM2MDY2IDI1LjQyMTYgMi4zNzk1NiAyNC4xNiAyLjE4MzU3IDIyLjcwMjZDMi4wOTk1NyAyMi4wMDIxIDIuMTU1MjkgMjEuMzAxNSAyLjQzNTg0IDIwLjUxNjdDMi41MTk1NiAyMC4yMzYxIDIuNjYwMTIgMTkuOTU2MSAyLjgwMDExIDE5LjYxOTlDMi45OTYzOSAxOS4xNzEzIDMuMjIwMTEgMTguNjk0NSAzLjQ0NDY2IDE4LjIxODJMMy40NzI5NSAxOC4xNjI1QzUuNDA2NTkgMTMuOTg2MSA3LjQ4MDUgOS43MjU5OCA5LjYzODcgNS41NzgxNUw5LjcyMjcgNS40MDk1OUM5Ljk0NzI1IDQuOTg5NiAxMC4xNzE1IDQuNTQxMDUgMTAuMzk1NSA0LjEyMDVDMTAuNjE5OCAzLjY3MTk1IDEwLjg3MTggMy4yNTEzOSAxMS4xODAzIDIuODg2ODRDMTEuNzY4OSAyLjIxNDg1IDEyLjU1MzQgMS44NTAwMiAxMy40MjI1IDEuODUwMDJDMTQuMjkxNiAxLjg1MDAyIDE1LjA3NjIgMi4yMTQ4NSAxNS42NjQ3IDIuODg2ODRDMTUuOTczMyAzLjI1MjIzIDE2LjIyNTMgMy42NzI3OSAxNi40NDk2IDQuMTIwNUMxNi42NzQxIDQuNTQxMDUgMTYuODk4NCA0Ljk4OTYgMTcuMTIyMSA1LjQwOTU5TDE3LjIwNjQgNS41NzgxNUMxOS4zMzE3IDkuNzQzMjIgMjEuMzc4IDEzLjk0ODEgMjMuMzQ0NCAxOC4xOTA1VjE4LjIxODVDMjMuNTY5IDE4LjY2NzYgMjMuNzY1IDE5LjE3MTYgMjMuOTg5MyAxOS42MjA3QzI0LjEyOTIgMTkuOTU2NCAyNC4yNjk1IDIwLjIzNjQgMjQuMzUzNSAyMC41MTdDMjQuNTc3MiAyMS4yNDUgMjQuNjYxMiAyMS45NDYxIDI0LjU0OSAyMi42NzQ2WiIgZmlsbD0iIzkwOTA5MCIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzM4OV81OTIiPgo8cmVjdCB3aWR0aD0iODkuNzQzNiIgaGVpZ2h0PSIyOCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMzQ2NjggMC4wMDAxMjIwNykiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K"},1892:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTU0IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMTU0IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNNzYuODI3IDE3Ljk4MTdINzYuNzczNEw3NS4xNjc1IDIyLjUxNkg3OC40MTQ5TDc2LjgyNyAxNy45ODE3Wk03OS43MDMyIDI2LjA5NDRMNzguOTExNSAyMy44NjM3SDc0LjcxNThMNzMuOTI4NSAyNi4wOTQ0SDcyLjEzMDRMNzUuODk2NiAxNi4xNzU1SDc3Ljg5NjFMODEuNjA0MiAyNi4wOTQ0SDc5LjcwMzJaTTk0LjkyNDkgMTUuNzcyOUg5Ni42NzgzVjE3LjQzMzdIOTQuOTI0OVYxNS43NzI5Wk05NC45MjQ5IDE4LjUzNUg5Ni42MzhWMjYuMDk0NEg5NC45MjA0TDk0LjkyNDkgMTguNTM1Wk04Mi4yNjE3IDE1Ljc3MjlIODQuMDE5NlYxNy40MzM3SDgyLjI2MTdWMTUuNzcyOVpNODIuMjYxNyAxOC41MzVIODMuOTc5NFYyNi4wOTQ0SDgyLjI2MTdWMTguNTM1Wk05My4wMzI4IDE1Ljc4NDFIOTEuMzE5NlYyNi4wOTQ0SDkzLjAzMjhWMTUuNzg0MVpNODcuNTcxMiAyMi40MDk5VjI2LjA5NDRIODUuODQ0NlYyMC40ODA3Qzg1Ljg0NDYgMTkuOTM4NiA4NS43ODY1IDE4LjkwOTggODUuNzY0MSAxOC41NDA4SDg3LjE1MDhDODcuMjk4NCAxOC41NDA4IDg3LjM0NzYgMTguNjAyMSA4Ny4zNDc2IDE4Ljc0NzRWMTkuNjg2OEg4Ny40MDEyQzg3LjUzNTQgMTkuMzU3MSA4OC4wMjMgMTguMzc4NCA4OS40NDU0IDE4LjM3ODRDODkuOTI0IDE4LjM3ODQgOTAuMjc3NCAxOC41MzUgOTAuMzM1NiAxOC41NTczQzkwLjMzNTYgMTguODgxNiA5MC4yODE5IDE5LjU5NzMgOTAuMjgxOSAxOS43ODc0QzkwLjI4MTkgMTkuOTEwNCA5MC4yMTQ4IDE5Ljk0OTggOTAuMTU2NiAxOS45NDk4QzkwLjA5NCAxOS45NDk4IDkwLjA2NzIgMTkuOTQ5OCA5MC4wNDAzIDE5Ljg5MzlDODkuOTMzIDE5LjgzOCA4OS42ODI1IDE5Ljc3NjIgODkuMzMzNiAxOS43NzYyQzg4LjQxNjYgMTkuNzc2MiA4Ny41NjIzIDIwLjQzNiA4Ny41NjIzIDIyLjM4MThNMTAzLjE3OCAyNi4wNjY2VjIxLjE4NTJDMTAzLjE3OCAyMC4yNTE3IDEwMi43NTMgMTkuNjg2OCAxMDEuOTYxIDE5LjY4NjhDMTAwLjkwNSAxOS42ODY4IDEwMC4yMDggMjAuODEwOCAxMDAuMjA4IDIyLjMyMDVWMjYuMDY2Nkg5OC40ODk5VjIwLjUxNDNDOTguNDg5OSAxOS45MDUxIDk4LjQzMTcgMTkuMDEwNSA5OC40MDQ5IDE4LjUxMjZIOTkuNzgyNkM5OS45MzkxIDE4LjUxMjYgOTkuOTgzOSAxOC41NzQzIDk5Ljk4MzkgMTguNzEzOVYxOS42NTlIMTAwLjAzOEMxMDAuMjQzIDE5LjMwMTIgMTAwLjc3MSAxOC4zNTA3IDEwMi4zNTUgMTguMzUwN0MxMDMuOTc4IDE4LjM1MDcgMTA0Ljg5MSAxOS40NjMxIDEwNC44OTEgMjAuNzE1NlYyNi4wNjY2SDEwMy4xNzhaTTEwNy45MjggMjEuNTA5NUgxMTEuMTA0QzExMS4xNzEgMjAuMjkwNiAxMTAuNTI3IDE5LjYwODUgMTA5LjU2NSAxOS42MDg1QzEwOC41NTQgMTkuNjA4NSAxMDcuOTczIDIwLjM0MTIgMTA3LjkyOCAyMS41MDk1Wk0xMTIuMTU5IDI0LjQwNThDMTEyLjI1MyAyNC40MDU4IDExMi4yODUgMjQuNDg5OSAxMTIuMjg5IDI0LjU3MzZDMTEyLjM0MyAyNC44OTc4IDExMi4zNTIgMjUuNjI0NyAxMTIuMzQzIDI1LjgwOTRDMTEyLjE1OSAyNS44NzA3IDExMS4yMzggMjYuMjEyIDExMC4wMDMgMjYuMjEyQzEwNy41OTIgMjYuMjEyIDEwNi4xNDggMjQuOTY0OSAxMDYuMTQ4IDIyLjI4NjlDMTA2LjE0OCAxOS45ODg3IDEwNy4zNzggMTguMzUwNyAxMDkuNTk2IDE4LjM1MDdDMTExLjc3NSAxOC4zNTA3IDExMi44MTIgMTkuODA5OCAxMTIuODEyIDIxLjYxNkMxMTIuODEyIDIxLjgyODUgMTEyLjgxMiAyMi4xODYzIDExMi43NTQgMjIuNjY3MUgxMDcuOTA2QzEwNy45MDYgMjMuOTUzMSAxMDguNzMzIDI0Ljg4MTMgMTEwLjI0OSAyNC44ODEzQzExMS4wODYgMjQuODgxMyAxMTEuNzUyIDI0LjU3OTQgMTEyLjAxNiAyNC40NTA1QzExMi4wNyAyNC40NTA1IDExMi4wOTcgMjQuMzk0NiAxMTIuMTU5IDI0LjM5NDZNMTE2LjE4MSAyNi4yMDA4QzExOC40MTMgMjYuMjAwOCAxMTkuNDc3IDI1LjI4MzkgMTE5LjQ3NyAyMy45MzA4QzExOS40NzcgMjIuNTk0MiAxMTguNTI5IDIyLjAyOTcgMTE3LjUyMyAyMS42OTk2QzExNy4yMzYgMjEuNjA0OCAxMTYuOTUgMjEuNTA5NSAxMTYuNjkxIDIxLjQyMDFDMTE2LjAwMiAyMS4xOTY0IDExNS42NDQgMjAuODk0NSAxMTUuNjQ0IDIwLjQ0NzJDMTE1LjY0NCAxOS45Nzc1IDExNi4wNzMgMTkuNjQ3OSAxMTYuOTY4IDE5LjY0NzlDMTE3Ljc2NCAxOS42NDc5IDExOC40MTMgMTkuOTcyMiAxMTguNjY4IDIwLjA5NTJDMTE4LjcyNiAyMC4wOTUyIDExOC43NDQgMjAuMTUxMSAxMTguODExIDIwLjE1MTFDMTE4Ljg2OSAyMC4xNTExIDExOC45MzYgMjAuMDk1MiAxMTguOTQ5IDE5Ljk4ODdDMTE4Ljk0OSAxOS43MzE1IDExOS4wMDMgMTkuMjczIDExOS4wMDMgMTguODMxNUMxMTguNzkzIDE4LjczNjMgMTE4LjA0MSAxOC4zNTA3IDExNi44MzQgMTguMzUwN0MxMTQuOTkxIDE4LjM1MDcgMTEzLjg1NSAxOS4zMTI0IDExMy44NTUgMjAuNTc2QzExMy44NTUgMjEuODA2MSAxMTQuNjk2IDIyLjM2NTIgMTE1LjYyMiAyMi42NzI1QzExNS44MzIgMjIuNzQ1NCAxMTYuMjI1IDIyLjg3MzggMTE2LjQ1OCAyMi45NTIxQzExNy40MiAyMy4yNzEgMTE3LjY5MyAyMy41NjE4IDExNy42OTMgMjQuMDE0NEMxMTcuNjkzIDI0LjYwMTcgMTE3LjA2NiAyNC44OTI1IDExNS45ODggMjQuODkyNUMxMTUuMTA3IDI0Ljg5MjUgMTE0LjQ5OSAyNC41NjgyIDExNC4yNTcgMjQuNDUwNUMxMTQuMTk5IDI0LjQ1MDUgMTE0LjE3NyAyNC4zOTQ2IDExNC4xMDUgMjQuMzk0NkMxMTMuOTg0IDI0LjM5NDYgMTEzLjk3NSAyNC41NjI0IDExMy45NzUgMjQuNTkwNUMxMTMuOTc1IDI0LjY3NDIgMTEzLjkyMiAyNS40NTcgMTEzLjkyMiAyNS43MTQyQzExNC4xMjMgMjUuODAzNiAxMTUgMjYuMjAwOCAxMTYuMTcyIDI2LjIwMDhNMTUuMDgxNCAxNy45NDIzSDE1LjAyNzhMMTMuNDE3NSAyMi40NzdIMTYuNjYwNEwxNS4wODE0IDE3Ljk0MjNaTTE3Ljk1NzYgMjYuMDU1NUwxNy4xNzAzIDIzLjgyNDNIMTIuOTY1N0wxMi4xODI5IDI2LjA1NTVIMTAuMzg0OEwxNC4xNTEgMTYuMTMwN0gxNi4xNDZMMTkuODU0MiAyNi4wNTU1SDE3Ljk1NzZaTTQ1Ljk4MTEgMTUuNzM0SDQ3LjczNDVWMTcuMzk0NEg0NS45ODExVjE1LjczNFpNNDUuOTgxMSAxOC40OTYxSDQ3LjY5ODdWMjYuMDk0NEg0NS45ODExVjE4LjQ5NjFaTTQyLjI5OTggMjIuMzcwNlYyNi4wNTU1SDQwLjU4NjZWMjAuNDQxOEM0MC41ODY2IDE5Ljg5OTIgNDAuNTI0IDE4Ljg3MDQgNDAuNTAxNiAxOC40OTYxSDQxLjg4MzhDNDIuMDMxNCAxOC40OTYxIDQyLjA4MDYgMTguNTYzMiA0Mi4wODA2IDE4LjcwODVWMTkuNjQ3OUg0Mi4xMzQzQzQyLjI2ODUgMTkuMzE3NyA0Mi43NTYgMTguMzM5NSA0NC4xNzg0IDE4LjMzOTVDNDQuNjU3MSAxOC4zMzk1IDQ1LjAxNDkgMTguNDk2MSA0NS4wNjg2IDE4LjUxODRDNDUuMDY4NiAxOC44NDI3IDQ1LjAxNDkgMTkuNTU4NCA0NS4wMTQ5IDE5Ljc0ODVDNDUuMDE0OSAxOS44NzE1IDQ0Ljk0NzggMTkuOTEwNCA0NC44ODUyIDE5LjkxMDRDNDQuODIyNiAxOS45MTA0IDQ0Ljc5NTcgMTkuOTEwNCA0NC43Njg5IDE5Ljg1NDVDNDQuNjU3MSAxOS43OTg2IDQ0LjQxMSAxOS43MzE1IDQ0LjA2MjEgMTkuNzMxNUM0My4xNDk3IDE5LjczMTUgNDIuMjkwOCAyMC4zOTcxIDQyLjI5MDggMjIuMzQyOU0yOS42MTg4IDI2LjAyNzNWMjEuMTkxMUMyOS42MTg4IDIwLjMxODggMjkuMjU2NCAxOS42NDc5IDI4LjM2NjMgMTkuNjQ3OUMyNy4zNjg4IDE5LjY0NzkgMjYuNzg3MyAyMC43Mzc5IDI2Ljc4NzMgMjIuMjc1OFYyNi4wMjczSDI1LjA3NDJWMjEuMTc0MUMyNS4wNzQyIDIwLjM4NTkgMjQuNzQzMiAxOS42NDc5IDIzLjgyMTcgMTkuNjQ3OUMyMi44MTA4IDE5LjY0NzkgMjIuMjM4MyAyMC43Mzc5IDIyLjIzODMgMjIuMzMxN1YyNi4wMjczSDIwLjUyNTFWMjAuNTIwMUMyMC41MjUxIDE5LjgwOTggMjAuNDYyNSAxOC44MDkyIDIwLjQ0MDEgMTguNDY3OUgyMS44MDg5QzIxLjk2NTQgMTguNDY3OSAyMi4wMTQ2IDE4LjUyMzggMjIuMDIzNiAxOC42ODAzVjE5LjYxOTdIMjIuMDc3MkMyMi4xODQ2IDE5LjQwMTggMjIuNzQ4MiAxOC4zMTEzIDI0LjMyNzIgMTguMzExM0MyNS43ODk5IDE4LjMxMTMgMjYuMzQ5IDE5LjM2MjUgMjYuNDg3NiAxOS42ODY4QzI2LjYyMTggMTkuNDAxOCAyNy4yNzk0IDE4LjMxMTMgMjguNzU1NSAxOC4zMTEzQzMwLjI4OTcgMTguMzExMyAzMS4zNDA5IDE5LjEzODggMzEuMzQwOSAyMC43OTM4VjI2LjAyNzNIMjkuNjE4OFpNMzQuMzY5MSAyMS40NzA2SDM3LjU0NUMzNy42MTIgMjAuMjUxNyAzNi45NzI0IDE5LjU2OTYgMzYuMDA2MiAxOS41Njk2QzM0Ljk5NTMgMTkuNTY5NiAzNC40MTgzIDIwLjMwMTggMzQuMzY5MSAyMS40NzA2Wk0zOC42MDA2IDI0LjM2NjlDMzguNjk0NSAyNC4zNjY5IDM4LjcyMTQgMjQuNDUwNSAzOC43MzAzIDI0LjUzNDZDMzguNzg0IDI0Ljg1ODkgMzguNzg4NSAyNS41ODU4IDM4Ljc4NCAyNS43NzAxQzM4LjYwMDYgMjUuODMxOCAzNy42NzkxIDI2LjE3MjcgMzYuNDQwMSAyNi4xNzI3QzM0LjAzMzYgMjYuMTcyNyAzMi41ODg4IDI0LjkyNiAzMi41ODg4IDIyLjI0NzZDMzIuNTg4OCAxOS45NDk4IDMzLjgxODkgMTguMzExMyAzNi4wNDIgMTguMzExM0MzOC4yMTU5IDE4LjMxMTMgMzkuMjUzNiAxOS43NzA5IDM5LjI1MzYgMjEuNTc2NkMzOS4yNTM2IDIxLjc4OTEgMzkuMjUzNiAyMi4xNDY5IDM5LjE5MSAyMi42MjI0SDM0LjM1MTJDMzQuMzUxMiAyMy45MTM4IDM1LjE3NDMgMjQuODQxOSAzNi42ODYxIDI0Ljg0MTlDMzcuNTI3MSAyNC44NDE5IDM4LjE5MzUgMjQuNTQgMzguNDYxOSAyNC40MTE2QzM4LjUxNTYgMjQuNDExNiAzOC41MzggMjQuMzU1NyAzOC42MDUxIDI0LjM1NTdNNjAuMTE1OCAyMi4xODA1SDU5LjgyNTFDNTcuNjczNSAyMi4xODA1IDU3LjI0ODYgMjIuOTI5NyA1Ny4yNDg2IDIzLjY5MDFDNTcuMjQ4NiAyNC4zMTEgNTcuNjU1NyAyNC45MDM3IDU4LjQ2MDggMjQuOTAzN0M1OS41MzQzIDI0LjkwMzcgNjAuMTE1OCAyMy44NjkxIDYwLjExNTggMjIuNzg0M1YyMi4xODA1Wk02MC41MzE4IDI2LjAxNjFDNjAuMzkzMSAyNi4wMTYxIDYwLjI3NjggMjUuOTYwMiA2MC4yNTkgMjUuNzcwMUM2MC4yNTkgMjUuNTI0MSA2MC4yMDUzIDI1LjA0MzIgNjAuMjA1MyAyNS4wNDMyQzYwLjEwMjQgMjUuMTgzMiA1OS40NzYyIDI2LjE2MTUgNTcuOTA2MiAyNi4xNjE1QzU2LjQwMzIgMjYuMTYxNSA1NS41Mzk5IDI0Ljk5ODUgNTUuNTM5OSAyMy43Mjk1QzU1LjUzOTkgMjEuOTYyNiA1Ny4yNTMxIDIxLjA3OTIgNTkuNzk4MiAyMS4wNzkySDYwLjEzMzdWMjAuNzk5N0M2MC4xMzM3IDIwLjAxMTEgNTkuNTY1NiAxOS41ODYxIDU4LjUxOSAxOS41ODYxQzU3LjU3MDcgMTkuNTg2MSA1Ni43ODM0IDE5LjkxNjIgNTYuNDc5MyAyMC4wNzI4QzU2LjQ3OTMgMjAuMDcyOCA1Ni40MDMyIDIwLjEyODcgNTYuMzU0IDIwLjEyODdDNTYuMjY5IDIwLjEyODcgNTYuMjI0MyAyMC4wNzI4IDU2LjIxOTggMTkuOTg4N0M1Ni4yMTk4IDE5LjcwMzggNTYuMTYxNyAxOS4xNTU4IDU2LjE2MTcgMTguODA5MkM1Ni40NzQ4IDE4LjY5MTUgNTcuNDk5MSAxOC4zMTEzIDU4LjYyNjMgMTguMzExM0M2MC44NzYyIDE4LjMxMTMgNjEuODM3OSAxOS4zNTEzIDYxLjgzNzkgMjEuMDE3NVYyMy45NjQzQzYxLjgzNzkgMjUuMDM3OSA2MS45MzYzIDI1Ljc0MjQgNjEuOTc2NiAyNi4wMjczTDYwLjUzMTggMjYuMDE2MVpNNTQuNjA1MSAyNC4zNTU3QzU0LjY1ODcgMjQuMzU1NyA1NC43MTY5IDI0LjM1NTcgNTQuNzI1OCAyNC41MTc2QzU0Ljc3OTUgMjQuODc1NSA1NC43Nzk1IDI1LjQ2ODIgNTQuNzc5NSAyNS42NTI5QzU0LjQzOTYgMjUuODIwNiA1My42OTcgMjYuMTYxNSA1Mi43ODQ1IDI2LjE2MTVDNTAuNDk4OCAyNi4xNjE1IDQ5LjA5NDMgMjQuODMwNyA0OS4wOTQzIDIyLjIzMUM0OS4wOTQzIDE5Ljc5ODYgNTAuMzQyMyAxOC4zMDAxIDUyLjc4NDUgMTguMzAwMUM1My41OTg2IDE4LjMwMDEgNTQuMzQ1NiAxOC41ODU1IDU0Ljc3OTUgMTguODA5MkM1NC43Nzk1IDE5LjA3NzUgNTQuNzI1OCAxOS42ODY4IDU0LjcyNTggMTkuOTQ0QzU0LjcyNTggMjAuMDUwNCA1NC42Njc3IDIwLjEwMDUgNTQuNjA1MSAyMC4xMDA1QzU0LjUzMzUgMjAuMTAwNSA1NC41MTExIDIwLjEwMDUgNTQuNDY2NCAyMC4wNDQ2QzUzLjkyMDcgMTkuNzc2MiA1My40MDE4IDE5LjY0MiA1Mi45MzIxIDE5LjY0MkM1MS40Nzg0IDE5LjY0MiA1MC44NzQ2IDIwLjU5ODQgNTAuODc0NiAyMi4yMDg3QzUwLjg3NDYgMjMuNjQ1NCA1MS4zNTMyIDI0Ljc2OTUgNTIuOTMyMSAyNC43Njk1QzUzLjUzNiAyNC43Njk1IDU0LjA4MTcgMjQuNTU3IDU0LjQyMTcgMjQuMzk0NkM1NC41MjAxIDI0LjMzODcgNTQuNTI5IDI0LjMzMzQgNTQuNjA1MSAyNC4zMzM0TTY4LjAxMDcgMjUuOTkzN1YyMS4xMTI4QzY4LjAxMDcgMjAuMTc4OCA2Ny41ODU4IDE5LjYxNDMgNjYuNzk0IDE5LjYxNDNDNjUuNzMzOSAxOS42MTQzIDY1LjAzMTcgMjAuNzMyNiA2NS4wMzE3IDIyLjI0NzZWMjUuOTkzN0g2My4zMTg1VjIwLjQ0MThDNjMuMzE4NSAxOS44MzIxIDYzLjI2NDggMTguOTM3NSA2My4yMzggMTguNDM0M0g2NC42MTEyQzY0Ljc2NzggMTguNDM0MyA2NC44MTI1IDE4LjUwMTQgNjQuODEyNSAxOC42NDE0VjE5LjU4NjFINjQuODcwNkM2NS4wNzY0IDE5LjIyODMgNjUuNjA4NyAxOC4yNzc4IDY3LjE4MzIgMTguMjc3OEM2OC44MTU4IDE4LjI3NzggNjkuNzI4MyAxOS4zOTA3IDY5LjcyODMgMjAuNjQzMVYyNS45OTM3SDY4LjAxMDdaTTE0My40MzUgMjkuMjQyNUwxNDMuNjQ1IDI5Ljk3NDdMMTQzLjg1MSAyOS4yNDI1SDE0NC4wMjVMMTQ0LjE1OSAzMC4xNTk1SDE0NC4wMjVMMTQzLjkyMiAyOS40MTAyTDE0My43MTIgMzAuMTU5NUgxNDMuNTZMMTQzLjM1NCAyOS40MTU2TDE0My4yNiAzMC4xNTk1SDE0My4xMzFMMTQzLjI2NSAyOS4yNDI1SDE0My40MzVaTTE0My4wMDUgMjkuMjQyNVYyOS4zNTk3SDE0Mi43MzNWMzAuMTU5NUgxNDIuNTk4VjI5LjM1OTdIMTQyLjMzVjI5LjI0MjVIMTQzLjAwNVpNMTIwLjk0OSA5Ljg0MDc2TDEyNS4xOTQgMTYuNzkwNUMxMjUuODAyIDE3LjcxMzMgMTI2LjI5NCAxNy45NzU4IDEyNy44NiAxNy45NzU4SDEzMS42ODRDMTI4LjE1IDEzLjU2NDUgMTI2LjQ3OCAxMS4zMDU3IDEyNS45MzIgMTAuODAyNUMxMjUuNDQ0IDEwLjMyNyAxMjQuOTU3IDkuODQwNzYgMTIzLjc2NyA5Ljg0MDc2SDEyMC45NDlaTTEzMi43MzEgMTguMzM5NUMxMzAuOTg2IDE4LjMzOTUgMTI5LjI5MSAxOC41MTI2IDEyOC40NDYgMTguOTE1MkMxMjcuNzI2IDE5LjMwMTIgMTI3LjUzMyAxOS41NDE0IDEyNy41MzMgMTkuOTgzM0MxMjcuNTMzIDIwLjM4NTkgMTI3LjYwOSAyMC43MjY4IDEyNy44NiAyMS4xMjRMMTI5Ljk1OCAyNC41OTA1QzEyOS45NTggMjQuNTkwNSAxMjkuODEgMjQuMTgyMiAxMjkuODEgMjMuNzE4M0MxMjkuODEgMjEuNTIwNyAxMzIuMjAzIDIwLjA3MjggMTM1LjE5NSAyMC4wNzI4QzEzNi4xMzUgMjAuMDcyOCAxMzYuNTM3IDIwLjIzNDcgMTM2LjUzNyAyMC4yMzQ3QzEzNi4yNDcgMTkuMjUwNyAxMzUuNTY3IDE4LjMzOTUgMTMyLjczMSAxOC4zMzk1Wk0xMzMuODQgMjAuNjQzMUMxMzIuOTgxIDIwLjgwNSAxMzIuMjIxIDIxLjExODEgMTMxLjY1MyAyMS41NzEzQzEzMC43OSAyMi4yNDc2IDEzMC4zMTEgMjMuMjAzOSAxMzAuNDA1IDI0LjU1N0MxMzAuNDA1IDI0LjY5MTIgMTMwLjQ2NyAyNS4wNzE0IDEzMC41MzUgMjUuMzc4N0MxMzAuNTg4IDI1LjUwMTcgMTMwLjU4OCAyNS41MDc1IDEzMC41ODggMjUuNjAyM0wxMzIuMjg4IDI4LjQzMTVDMTMzLjAwOCAyOS41ODkxIDEzNC4xOTggMzAuMTIwMSAxMzUuNjg4IDMwLjEyMDFIMTQxLjY4MUwxMzQuNjU5IDIxLjYwNDhMMTMzLjg0IDIwLjY0MzFaIiBmaWxsPSIjOTA5MDkwIi8+Cjwvc3ZnPgo="},2870:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQyIiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMTQyIDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMzg5XzU5NCkiPgo8cGF0aCBkPSJNNjcuOTgxNiAzMS4yODk4SDYzLjU5MDdDNjMuNTYyOSAzMS4yODk4IDYzLjU2MjkgMzEuMjg5OCA2My41NDkgMzEuMjc2TDU5Ljc2OTYgMjYuNjYyOEw1NS45OTAxIDMxLjI3NkM1NS45NzYzIDMxLjI4OTggNTUuOTYyNCAzMS4yODk4IDU1Ljk0ODUgMzEuMjg5OEg1Mi40MzNDNTIuNDA1MiAzMS4yODk4IDUyLjM5MTMgMzEuMjc2IDUyLjM3NzQgMzEuMjYyMUM1Mi4zNzc0IDMxLjI0ODIgNTIuMzc3NCAzMS4yMjA0IDUyLjM5MTMgMzEuMjA2NUw1Ny45NjMyIDI0LjM3MDFMNTIuNDYwOCAxNy42MDMyQzUyLjQ0NjkgMTcuNTc1NSA1Mi40NDY5IDE3LjU2MTYgNTIuNDQ2OSAxNy41MzM4QzUyLjQ2MDggMTcuNTE5OSA1Mi40NzQ3IDE3LjUwNiA1Mi40ODg2IDE3LjUwNkg1Ni44Nzk0QzU2Ljg5MzMgMTcuNTA2IDU2LjkwNzIgMTcuNTE5OSA1Ni45MjExIDE3LjUzMzhMNjAuMjQyIDIxLjY0NjdMNjMuNjE4NSAxNy41MzM4QzYzLjYzMjQgMTcuNTE5OSA2My42NDYzIDE3LjUwNiA2My42NjAyIDE3LjUwNkg2Ny4yMzEyQzY3LjI0NTEgMTcuNTA2IDY3LjI3MjkgMTcuNTE5OSA2Ny4yODY4IDE3LjUzMzhDNjcuMzAwNyAxNy41NjE2IDY3LjI4NjggMTcuNTc1NSA2Ny4yNzI5IDE3LjYwMzJMNjIuMDYyMyAyMy44Njk5TDY4LjAzNzEgMzEuMjA2NUM2OC4wNTEgMzEuMjIwNCA2OC4wNTEgMzEuMjQ4MiA2OC4wNTEgMzEuMjYyMUM2OC4wMjMyIDMxLjI4OTggNjguMDA5MyAzMS4yODk4IDY3Ljk4MTYgMzEuMjg5OFoiIGZpbGw9IiM5MDkwOTAiLz4KPHBhdGggZD0iTTkxLjcyODIgMTkuOTIzN0M4OS43ODI5IDE5LjkyMzcgODguNDYyOSAyMS4xMDQ4IDg4LjA3MzggMjMuMTQ3NEg5NC42ODc5VjIzLjAwODRDOTQuNjg3OSAyMS4zODI3IDkzLjQ3OSAxOS45MjM3IDkxLjcyODIgMTkuOTIzN1pNOTguMDkyMiAyNS4yNTk0Qzk4LjA3ODMgMjUuMjczMyA5OC4wNjQ0IDI1LjI4NzIgOTguMDUwNSAyNS4yODcySDg4LjAwNDRDODguMjEyOCAyNy42MjE2IDg5LjcyNzMgMjguOTU1NSA5Mi4xODY4IDI4Ljk1NTVDOTMuNzAxMyAyOC45NTU1IDk1LjMxMzEgMjguNDQxNCA5Ny41NzggMjcuMjMyNUM5Ny42MTk3IDI3LjIwNDcgOTcuNjYxNCAyNy4yNDY0IDk3LjY2MTQgMjcuMjg4MVYzMC4zNzI4Qzk3LjY2MTQgMzAuNDAwNiA5Ny42NDc1IDMwLjQxNDUgOTcuNjMzNiAzMC40MTQ1Qzk1LjUyMTYgMzEuMzAzNyA5My4zOTU2IDMxLjkxNTEgOTEuNzI4MiAzMS45MTUxQzg3LjQwNjkgMzEuOTE1MSA4NC4yNjY2IDI4Ljc2MDkgODQuMjY2NiAyNC40MjU3Qzg0LjI2NjYgMjAuMDkwNCA4Ny40MDY5IDE2LjkzNjMgOTEuNzI4MiAxNi45MzYzQzk1LjY3NDQgMTYuOTM2MyA5OC4yMDMzIDE5LjU5MDIgOTguMjAzMyAyMy4yNDQ2Qzk4LjIwMzMgMjMuODQyMSA5OC4xMDYgMjUuMjE3NyA5OC4wOTIyIDI1LjI1OTRaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0xMTguNDkgMTQuNjQzNkMxMTcuMjUzIDE0LjY0MzYgMTE2LjI1MyAxMy42NTcgMTE2LjI1MyAxMi40NDgyQzExNi4yNTMgMTEuMTk3NiAxMTcuMjUzIDEwLjE4MzMgMTE4LjQ5IDEwLjE4MzNDMTE5LjcyNyAxMC4xODMzIDEyMC43MjcgMTEuMTk3NiAxMjAuNzI3IDEyLjQ0ODJDMTIwLjcyNyAxMy42NTcgMTE5LjcyNyAxNC42NDM2IDExOC40OSAxNC42NDM2Wk0xMTYuNjg0IDMxLjI4OThDMTE2LjY0MiAzMS4yODk4IDExNi42MjggMzEuMjc1OSAxMTYuNjI4IDMxLjIzNDNWMTcuNTQ3N0MxMTYuNjI4IDE3LjUxOTkgMTE2LjY0MiAxNy40OTIxIDExNi42NyAxNy40OTIxSDEyMC4yOTZDMTIwLjMyNCAxNy40OTIxIDEyMC4zMzggMTcuNTE5OSAxMjAuMzM4IDE3LjU0NzdWMzEuMjM0M0MxMjAuMzM4IDMxLjI3NTkgMTIwLjMxIDMxLjI4OTggMTIwLjI4MiAzMS4yODk4SDExNi42ODRaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik03NC42MjMzIDI5LjIzMzRDNzMuOTcwMiAyOS4yMzM0IDczLjMwMzMgMjkuMTM2MSA3Mi41MjUxIDI4Ljk0MTZMNzIuNTM5IDIwLjE1OTlDNzMuNDQyMiAxOS44NjgxIDc0LjIyMDMgMTkuNzQzMSA3NC45OTg0IDE5Ljc0MzFDNzcuNTEzNCAxOS43NDMxIDc5LjE5NDcgMjEuNTkxMSA3OS4xOTQ3IDI0LjM1NjJDNzkuMTk0NyAyNy4zMTU5IDc3LjQwMjMgMjkuMjMzNCA3NC42MjMzIDI5LjIzMzRaTTc1LjYwOTggMTYuOTM2M0M3NC41ODE2IDE2LjkzNjMgNzMuNTUzNCAxNy4xMTY5IDcyLjQ2OTYgMTcuNDkyMUg2OC44NTY4QzY4LjgyOTEgMTcuNDkyMSA2OC44MDEzIDE3LjUxOTkgNjguODAxMyAxNy41NDc3VjM5Ljk4ODFDNjkuODg1MSAzOS44MzUzIDcxLjIxOSAzOS40NDYyIDcyLjUyNTEgMzguNTI5MlYzMS43MDY3QzczLjQxNDQgMzEuODMxNyA3NC4xNTA5IDMxLjkxNTEgNzQuODU5NSAzMS45MTUxQzc5LjgwNjEgMzEuOTE1MSA4My4wMDIgMjguOTU1NSA4My4wMDIgMjQuMzcwMUM4My4wMDIgMTkuOTkzMiA3OS45NTkgMTYuOTM2MyA3NS42MDk4IDE2LjkzNjNaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0xMTAuMDgzIDI4LjA5NEMxMDguOTU4IDI4LjY5MTUgMTA3Ljk0MyAyOC45Njk0IDEwNi45OTkgMjguOTY5NEMxMDQuNzYyIDI4Ljk2OTQgMTAzLjQxNCAyNy4zODUzIDEwMy40MTQgMjQuNzMxNEMxMDMuNDE0IDIxLjY3NDUgMTA1LjEyMyAxOS42ODc1IDEwNy43NzcgMTkuNjg3NUMxMDguNTEzIDE5LjY4NzUgMTA5LjIyMiAxOS44NjgxIDExMC4wODMgMjAuMjU3MlYyOC4wOTRaTTExMC4wODMgMTAuMjUyOFYxNy40MDg3QzEwOS4wMjcgMTcuMTAzIDEwOC4wOTYgMTYuOTY0MSAxMDcuMTUxIDE2Ljk2NDFDMTAyLjg0NCAxNi45NjQxIDk5LjYwNjQgMjAuMjAxNiA5OS42MDY0IDI0LjUwOTFDOTkuNjA2NCAyOC43ODg3IDEwMi40NjkgMzEuOTAxMiAxMDYuNDE1IDMxLjkwMTJDMTA3Ljc3NyAzMS45MDEyIDEwOS4wNTUgMzEuNTUzOSAxMTAuNTU2IDMwLjc4OTZWMzIuMDI2M0MxMTEuNTQyIDMxLjgzMTggMTEyLjY4MiAzMS40NDI3IDExMy44MDcgMzAuNjM2OFY4Ljc3OTkxQzExMi43MDkgOC45MzI3NSAxMTEuNDAzIDkuMzA3OTIgMTEwLjA4MyAxMC4yNTI4WiIgZmlsbD0iIzkwOTA5MCIvPgo8cGF0aCBkPSJNMTMyLjkxMyAyOC4wNjYyQzEzMS44MTUgMjguNjkxNSAxMzAuODg0IDI4Ljk5NzEgMTMwLjA1MSAyOC45OTcxQzEyNy42NDcgMjguOTk3MSAxMjYuMjE1IDI3LjQxMzEgMTI2LjIxNSAyNC43NTkyQzEyNi4yMTUgMjEuNzQzOSAxMjcuOTExIDE5LjcxNTMgMTMwLjQyNiAxOS43MTUzQzEzMS4wOTMgMTkuNzE1MyAxMzEuOTEyIDE5Ljk3OTMgMTMyLjkxMyAyMC41MDczVjI4LjA2NjJaTTEzNi42MzcgMTcuMzI1M0MxMzYuNjM3IDE3LjI0MiAxMzYuNTY3IDE3LjE3MjUgMTM2LjQ4NCAxNy4xNzI1SDEzMy41NTJDMTMzLjQ2OSAxNy4xNzI1IDEzMy4zODUgMTcuMjQyIDEzMy4zODUgMTcuMzI1M1YxNy44MjU1SDEzMy4zMTZDMTMxLjk2OCAxNy4yMjgxIDEzMC44MDEgMTYuOTY0MSAxMjkuNjc1IDE2Ljk2NDFDMTI1LjYxOCAxNi45NjQxIDEyMi40MzYgMjAuMzI2NiAxMjIuNDM2IDI0LjYzNDFDMTIyLjQzNiAyOC45ODMyIDEyNS4yODUgMzEuOTAxMiAxMjkuNTIyIDMxLjkwMTJDMTMwLjY0OCAzMS45MDEyIDEzMi4xMDcgMzEuODE3OCAxMzMuNDY5IDMwLjI2MTZWMzIuMDI2M0MxMzQuNDI3IDMxLjgxNzggMTM1LjU2NyAzMS40MTQ5IDEzNi42MzcgMzAuNjM2OFYxNy4zMjUzWiIgZmlsbD0iIzkwOTA5MCIvPgo8cGF0aCBkPSJNNDIuNDAwOSAyNy44NzE3SDUxLjUwMjFDNTEuMzYzMiAyOC44ODYgNTEuMDE1OCAzMC4wODEgNTAuMjM3NyAzMS4yODk4SDQwLjc3NTJDMzkuNjIxOSAzMS4yODk4IDM4LjY2MzEgMzAuMzg2NyAzOC41NTIgMjkuMjYxMkMzOC41NTIgMjkuMjQ3MyAzOC41MzgxIDI5LjIzMzQgMzguNTM4MSAyOS4yMDU2VjExLjI1MzJDMzguNTM4MSAxMS4yMzkzIDM4LjU1MiAxMS4yMjU0IDM4LjU1MiAxMS4yMTE1QzM4LjY2MzEgMTAuMDcyMSAzOS42MjE5IDkuMTY4OTUgNDAuNzc1MiA5LjE2ODk1SDUxLjQ4ODJDNTEuMzQ5MyAxMC4xODMzIDUxLjAwMTkgMTEuNDA2IDUwLjIwOTkgMTIuNjE0OUg0Mi40MDA5VjE3LjUwNkg1MC4xNDA0QzUwLjE2ODIgMTcuNTA2IDUwLjE5NiAxNy41MzM4IDUwLjE5NiAxNy41NjE1VjIwLjk1MTlDNTAuMTk2IDIwLjk3OTcgNTAuMTY4MiAyMS4wMDc1IDUwLjE0MDQgMjEuMDA3NUg0Mi40MDA5VjI3Ljg3MTdaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0zMS4wMDY5IDMxLjU4MTZDMzAuMTAzOCAzMS41ODE2IDI5LjU0OCAzMC44NzMgMjkuNTQ4IDMwLjAxMTVDMjkuNTQ4IDI5LjA5NDQgMzAuMTg3MSAyOC40NDEzIDMxLjAwNjkgMjguNDQxM0MzMS44MTI5IDI4LjQ0MTMgMzIuNDUyIDI5LjA4MDUgMzIuNDUyIDMwLjAxMTVDMzIuNDUyIDMwLjk0MjQgMzEuODEyOSAzMS41ODE2IDMxLjAwNjkgMzEuNTgxNlpNMzEuMDA2OSAyOC4yNzQ2QzMwLjA4OTkgMjguMjc0NiAyOS4yOTc5IDI4Ljk2OTMgMjkuMjk3OSAzMC4wMTE1QzI5LjI5NzkgMzAuOTk4IDMwLjAwNjUgMzEuNzQ4NCAzMS4wMDY5IDMxLjc0ODRDMzEuOTEwMSAzMS43NDg0IDMyLjcwMjEgMzEuMDUzNiAzMi43MDIxIDMwLjAxMTVDMzIuNzAyMSAyOC45NjkzIDMxLjkyNCAyOC4yNzQ2IDMxLjAwNjkgMjguMjc0NloiIGZpbGw9IiM5MDkwOTAiLz4KPHBhdGggZD0iTTMwLjYwMzggMjkuODcyNVYyOS4yMzM0SDMxLjAzNDVDMzEuMjU2OCAyOS4yMzM0IDMxLjUwNjkgMjkuMjYxMiAzMS41MDY5IDI5LjUyNTJDMzEuNTA2OSAyOS44NDQ3IDMxLjI3MDcgMjkuODU4NiAzMS4wMDY3IDI5Ljg1ODZDMzAuOTkyOCAyOS44NzI1IDMwLjYwMzggMjkuODcyNSAzMC42MDM4IDI5Ljg3MjVaTTMxLjgxMjYgMjkuNTY2OEMzMS44MTI2IDI5LjE1IDMxLjU2MjUgMjguOTY5NCAzMS4wNjIzIDI4Ljk2OTRIMzAuMjg0MlYzMS4wMjU4SDMwLjYxNzdWMzAuMTUwNEgzMC45MzcyTDMxLjQ2NTMgMzEuMDI1OEgzMS44NTQzTDMxLjI4NDYgMzAuMTIyNkMzMS41OTAzIDMwLjA5NDkgMzEuODEyNiAyOS45NDIgMzEuODEyNiAyOS41NjY4WiIgZmlsbD0iIzkwOTA5MCIvPgo8cGF0aCBkPSJNMTM5LjYzOCAxOS43NzA4QzEzOC43MzUgMTkuNzcwOCAxMzguMTc5IDE5LjA2MjIgMTM4LjE3OSAxOC4yMDA3QzEzOC4xNzkgMTcuMjgzNiAxMzguODE4IDE2LjYzMDYgMTM5LjYzOCAxNi42MzA2QzE0MC40NDQgMTYuNjMwNiAxNDEuMDgzIDE3LjI2OTcgMTQxLjA4MyAxOC4yMDA3QzE0MS4wODMgMTkuMTMxNyAxNDAuNDQ0IDE5Ljc3MDggMTM5LjYzOCAxOS43NzA4Wk0xMzkuNjM4IDE2LjQ3NzdDMTM4LjcyMSAxNi40Nzc3IDEzNy45MjkgMTcuMTcyNSAxMzcuOTI5IDE4LjIxNDZDMTM3LjkyOSAxOS4yMDExIDEzOC42MzggMTkuOTUxNSAxMzkuNjM4IDE5Ljk1MTVDMTQwLjU0MSAxOS45NTE1IDE0MS4zMzMgMTkuMjU2NyAxNDEuMzMzIDE4LjIxNDZDMTQxLjMzMyAxNy4xNTg2IDE0MC41NDEgMTYuNDc3NyAxMzkuNjM4IDE2LjQ3NzdaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0xMzkuMjIxIDE4LjA2MThWMTcuNDM2NUgxMzkuNjUyQzEzOS44NzQgMTcuNDM2NSAxNDAuMTI0IDE3LjQ2NDMgMTQwLjEyNCAxNy43MjgzQzE0MC4xMjQgMTguMDQ3OSAxMzkuODg4IDE4LjA2MTggMTM5LjYyNCAxOC4wNjE4SDEzOS4yMjFaTTE0MC40NDQgMTcuNzdDMTQwLjQ0NCAxNy4zNTMxIDE0MC4xOTQgMTcuMTcyNSAxMzkuNjk0IDE3LjE3MjVIMTM4LjkxNlYxOS4yMjg5SDEzOS4yNDlWMTguMzUzNkgxMzkuNTY5TDE0MC4wOTcgMTkuMjI4OUgxNDAuNDg2TDEzOS45MTYgMTguMzI1OEMxNDAuMjA4IDE4LjI5OCAxNDAuNDQ0IDE4LjE0NTEgMTQwLjQ0NCAxNy43N1oiIGZpbGw9IiM5MDkwOTAiLz4KPHBhdGggZD0iTTE5LjI2NTcgMTIuNjAxTDE4LjYxMjYgMTAuNzM5MUwxMi45OTkgMy4yNDk2NUwxMy45OTk1IDIuOTk5NTRMMjMuNjU2NSAxMS4zNTA0TDI5LjMzOTYgOS43MjQ3M0MzMC4wMDY1IDkuNTU3OTkgMzAuNzcwOCA5LjUxNjMgMzEuMzQwNSA5LjUxNjNDMjkuNTYxOSA1LjY2NzM4IDI2LjI4MjcgMi40OTkzMiAyMS45NzUyIDAuOTcwODYyQzEzLjQ1NzYgLTIuMDcyMTUgNC4wNzg0MiAyLjM4ODE1IDEuMDQ5MyAxMC45MTk3QzAuMTA0NDM4IDEzLjU1OTggLTAuMTAzOTg3IDE2LjI4MzIgMC4yODUwNzQgMTguODY3N0wxMy44ODgzIDE0LjE0MzNMMTkuMjY1NyAxMi42MDFaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0zMS45NTE2IDEwLjk4OTJDMzEuNDUxNCAxMS4zMDg4IDMwLjcxNSAxMS43Mzk1IDI5Ljk5MjQgMTEuOTc1N0wyNC4yOTU1IDEzLjYwMTVMMjAuNTAyMSAyNS44MDEzTDE5LjUxNTYgMjYuMTIwOUwyMC4zMjE1IDE2LjgxMTJMMTkuODc2OSAxNC44Nzk4TDE0LjU0MTIgMTYuNDA4M0wwLjQyMzgyOCAxOS43MDE0QzEuNTQ5MzMgMjUuMTIwNCA1LjM4NDM1IDI5Ljg1ODYgMTAuOTg0IDMxLjg0NTZDMTkuNTE1NiAzNC44ODg2IDI4Ljg4MDggMzAuNDI4MyAzMS45MjM4IDIxLjg5NjhDMzMuMjMgMTguMjQyNCAzMy4xNDY2IDE0LjQwNzQgMzEuOTUxNiAxMC45ODkyWiIgZmlsbD0iIzkwOTA5MCIvPgo8cGF0aCBkPSJNMTkuODYzIDE0Ljg2NTlMMjAuMzA3NiAxNi43OTczTDE5LjUwMTcgMjYuMTA3TDIwLjQ4ODMgMjUuNzg3NEwyNC4yODE2IDEzLjU4NzZMMjkuOTc4NiAxMS45NjE4QzMwLjcwMTEgMTEuNzI1NiAzMS40Mzc1IDExLjMwODggMzEuOTM3OCAxMC45NzUzQzMxLjc1NzEgMTAuNDc1MSAzMS41NjI2IDkuOTg4NzUgMzEuMzQwMyA5LjUwMjQyQzMwLjc1NjcgOS41MDI0MiAzMC4wMDY0IDkuNTMwMjEgMjkuMzM5NCA5LjcxMDg1TDIzLjY1NjMgMTEuMzM2NkwxMy45OTkzIDIuOTg1NjZMMTIuOTk4OCAzLjIzNTc3TDE4LjU5ODUgMTAuNzI1MkwxOS4yNTE2IDEyLjU4NzFMMTMuODc0MiAxNC4xMjk1TDAuMjcwOTk2IDE4Ljg1MzhDMC4zMTI2ODEgMTkuMTMxNyAwLjM2ODI2MSAxOS40MjM1IDAuNDIzODQxIDE5LjcwMTRMMTQuNTI3MyAxNi4zODA1TDE5Ljg2MyAxNC44NjU5WiIgZmlsbD0iIzkwOTA5MCIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzM4OV81OTQiPgo8cmVjdCB3aWR0aD0iMTQxLjI0MyIgaGVpZ2h0PSI0MCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDkwMzMyIDAuMDAwMTIyMDcpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="},9841:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTU2IiBoZWlnaHQ9IjI4IiB2aWV3Qm94PSIwIDAgMTU2IDI4IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMzg5XzYwOSkiPgo8cGF0aCBkPSJNMTcuNDA4NyAyMi45NjQxQzE3Ljc2NjggMjIuOTY0MSAxOC4xMDggMjIuODc4OSAxOC40MzIxIDIyLjY5MTJMMjIuMTY3OCAyMC41NDE5QzIyLjkxODMgMjAuMTE1NCAyMy43ODgzIDE5LjkyNzggMjQuNjU4MyAyMC4wMzAxQzI5LjE5NTcgMjAuNTU5IDMyLjM2ODUgMjEuNDExOSAzMy4zMDY3IDIxLjY4NDlDMzMuNDk0MyAyMS43MzYgMzMuNzE2MSAyMS42Njc4IDMzLjgzNTUgMjEuNTE0MkMzMy45ODkgMjEuMzI2NiAzNC4xNzY3IDIxLjAxOTYgMzQuMzMwMiAyMC41NzZDMzQuNDY2NyAyMC4xNDk1IDM0LjQ4MzcgMTkuNzkxMyAzNC40NjY3IDE5LjUzNTRDMzQuNDQ5NiAxOS4zMzA3IDM0LjMxMzEgMTkuMTQzMSAzNC4xMDg0IDE5LjA5MTlDMzIuNjQxNCAxOC42NjU0IDI2LjE0MjQgMTYuOTA4NSAxNy40MDg3IDE2LjkwODVDOC42NzQ5OCAxNi45MDg1IDIuMTc1ODIgMTguNjY1NSAwLjcwODg5MiAxOS4wOTE5QzAuNTA0MTkgMTkuMTQzMSAwLjM2NzY5NiAxOS4zMzA3IDAuMzUwNjg4IDE5LjUzNTVDMC4zMzM1OTQgMTkuNzc0MiAwLjM1MDY4OCAyMC4xMzI1IDAuNDg3MDk5IDIwLjU3NkMwLjYyMzUwOSAyMS4wMTk2IDAuODI4Mjk2IDIxLjMyNjYgMC45ODE4IDIxLjUxNDJDMS4xMDEyIDIxLjY2NzggMS4zMjMgMjEuNzM2IDEuNTEwNiAyMS42ODQ4QzIuNDQ4ODEgMjEuNDExOSA1LjYzODY1IDIwLjU1OSAxMC4xNTkgMjAuMDMwMUMxMS4wMjg5IDE5LjkyNzggMTEuODk4OSAyMC4xMTU0IDEyLjY0OTQgMjAuNTQxOUwxNi4zODUyIDIyLjY5MTJDMTYuNzA5MyAyMi44Nzg5IDE3LjA2NzUgMjIuOTY0MSAxNy40MDg3IDIyLjk2NDFaTTExLjE4MjUgMTAuODdDMTEuMzg3MiAxMS4yMjgyIDExLjcxMTMgMTEuNDY3MSAxMi4wODY1IDExLjU2OTRDMTIuNDYxNyAxMS42NzE3IDEyLjg1NDEgMTEuNjIwNiAxMy4yMTIzIDExLjQxNTlDMTMuNTcwNSAxMS4yMTEyIDEzLjgwOTQgMTAuODg3MSAxMy45MTE3IDEwLjUxMThDMTQuMDE0IDEwLjEzNjUgMTMuOTYyOSA5Ljc0NDIzIDEzLjc1ODIgOS4zODU5NEwxMC4zOTc4IDMuNTY5MThDMTAuMjk1NSAzLjM4MTU3IDEwLjA3MzcgMy4zMTMzNiA5Ljg2OSAzLjMzMDM3QzkuNTk2MDkgMy4zNDc0NyA5LjIyMDc5IDMuNDgzODggOC43NzcyOSAzLjczOTc4QzguMzMzNzggMy45OTU2NyA4LjAyNjc3IDQuMjUxNDkgNy44NzMyNyA0LjQ3MzI4QzcuNzUzNzggNC42NDM4OCA3LjcxOTY4IDQuODY1NTkgNy44MjE5OSA1LjA1MzJMMTEuMTgyNSAxMC44N1pNOC4xMTIwNyAxNS4wMzIyQzguNDcwMTkgMTUuMjM2OSA4Ljg3OTU5IDE1LjI3MSA5LjIzNzg4IDE1LjE4NTdDOS42MTMxIDE1LjA4MzMgOS45MzcyIDE0Ljg0NDUgMTAuMTQxOSAxNC40ODYzQzEwLjM0NjYgMTQuMTI4MSAxMC4zODA4IDEzLjcxODggMTAuMjk1NSAxMy4zNjA1QzEwLjIxMDIgMTMuMDAyMiA5Ljk1NDMgMTIuNjYxMSA5LjU5NjA5IDEyLjQ1NjRMMy43NzkzMyA5LjA5NTk0QzMuNTkxNjMgOC45OTM2MyAzLjM2OTkyIDkuMDI3NzMgMy4xOTkzMiA5LjE0NzIyQzIuOTc3NjEgOS4zMDA2NCAyLjcyMTcyIDkuNjA3NzQgMi40NjU4MiAxMC4wNTEyQzIuMjA5OTIgMTAuNDk0NyAyLjA3MzUxIDEwLjg3IDIuMDU2NDIgMTEuMTQzQzIuMDM5MzIgMTEuMzY0NyAyLjEyNDcxIDExLjU2OTQgMi4yOTUyMiAxMS42NzE4TDguMTEyMDcgMTUuMDMyMlpNMTguODkyNyA4LjgwNjAyQzE4Ljg5MjcgOS4yMTU0MyAxOC43MjIxIDkuNTkwNjQgMTguNDY2MiA5Ljg2MzU1QzE4LjE5MzMgMTAuMTM2NSAxNy44MzUxIDEwLjI5IDE3LjQwODcgMTAuMjlDMTYuOTk5MyAxMC4yOSAxNi42MjQxIDEwLjExOTQgMTYuMzUxMSA5Ljg2MzU1QzE2LjA3ODIgOS41OTA2NCAxNS45MjQ2IDkuMjMyNDQgMTUuOTI0NiA4LjgwNjAyVjIuMTAyMTdDMTUuOTI0NiAxLjg4MDQ2IDE2LjA2MTEgMS43MDk4NiAxNi4yNjU4IDEuNjI0NTZDMTYuNTA0NiAxLjUwNTE2IDE2Ljg5NjkgMS40MzY5NSAxNy40MDg3IDEuNDM2OTVDMTcuOTIwNSAxLjQzNjk1IDE4LjMxMjcgMS41MDUxNiAxOC41NTE1IDEuNjI0NTZDMTguNzM5MiAxLjcyNjk1IDE4Ljg5MjcgMS44ODA0NiAxOC44OTI3IDIuMTAyMTdWOC44MDYwMlpNMjMuNjM0OCAxMC44N0MyMy40MzAxIDExLjIyODIgMjMuMTA2IDExLjQ2NzEgMjIuNzMwNyAxMS41Njk0QzIyLjM1NTQgMTEuNjcxNyAyMS45NjMxIDExLjYyMDYgMjEuNjA0OSAxMS40MTU5QzIxLjI0NjcgMTEuMjExMiAyMS4wMDc5IDEwLjg4NzEgMjAuOTA1NSAxMC41MTE4QzIwLjgwMzEgMTAuMTM2NSAyMC44NTQzIDkuNzQ0MjMgMjEuMDU5IDkuMzg1OTRMMjQuNDE5NSAzLjU2OTE4QzI0LjUyMTggMy4zODE1NyAyNC43NDM2IDMuMzEzMzYgMjQuOTQ4MyAzLjMzMDM3QzI1LjIyMTIgMy4zNDc0NyAyNS41OTY1IDMuNDgzODggMjYuMDQgMy43Mzk3OEMyNi40ODM1IDMuOTk1NjcgMjYuNzkwNiA0LjI1MTQ5IDI2Ljk0NDEgNC40NzMyOEMyNy4wNjM1IDQuNjQzODggMjcuMDk3NiA0Ljg2NTU5IDI2Ljk5NTMgNS4wNTMyTDIzLjYzNDggMTAuODdaTTI2LjcwNTMgMTUuMDMyMkMyNi4zNDcxIDE1LjIzNjkgMjUuOTM3NyAxNS4yNzEgMjUuNTc5NSAxNS4xODU3QzI1LjIwNDIgMTUuMDgzMyAyNC44ODAxIDE0Ljg0NDUgMjQuNjc1NCAxNC40ODYzQzI0LjQ3MDYgMTQuMTI4MSAyNC40MzY1IDEzLjcxODggMjQuNTIxOCAxMy4zNjA1QzI0LjYyNDIgMTIuOTg1MyAyNC44NjMgMTIuNjYxMSAyNS4yMjEyIDEyLjQ1NjRMMzEuMDM4IDkuMDk1OTRDMzEuMjI1NiA4Ljk5MzYzIDMxLjQ0NzQgOS4wMjc3MyAzMS42MTc5IDkuMTQ3MjJDMzEuODM5NyA5LjMwMDY0IDMyLjA5NTUgOS42MDc3NCAzMi4zNTE0IDEwLjA1MTJDMzIuNjA3MyAxMC40OTQ3IDMyLjc0MzcgMTAuODcgMzIuNzYwOCAxMS4xNDNDMzIuNzc3OSAxMS4zNjQ3IDMyLjY5MjYgMTEuNTY5NCAzMi41MjIgMTEuNjcxOEwyNi43MDUzIDE1LjAzMjJaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik02My44MDY0IDEwLjQwOTVINjYuNjAzOUM2Ni43MDYzIDEwLjQwOTUgNjYuNzkxNiAxMC40Nzc3IDY2Ljg0MjggMTAuNTYzTDY5LjYyMzIgMTcuNjkzMkw3Mi4zMTg0IDEwLjU2M0M3Mi4zNTI1IDEwLjQ2MDcgNzIuNDU0OCAxMC40MDk1IDcyLjU1NzIgMTAuNDA5NUg3NS4zMDM2Qzc1LjQ5MTIgMTAuNDA5NSA3NS42MTA2IDEwLjU5NzEgNzUuNTI1MyAxMC43NTA3TDY4LjcwMjEgMjYuNDA5OEM2OC42Njc5IDI2LjQ5NTEgNjguNTY1NiAyNi41NjMzIDY4LjQ4MDMgMjYuNTYzM0g2Ni4wNTgxQzY1Ljg4NzYgMjYuNTYzMyA2NS43NTExIDI2LjM3NTcgNjUuODM2NCAyNi4yMjIyTDY4LjE3MzMgMjAuNzQ2NUw2My42MDE3IDEwLjc1MDZDNjMuNDk5NCAxMC41OTcgNjMuNjE4OCAxMC40MDk1IDYzLjgwNjQgMTAuNDA5NVpNMTA1LjEwNCAxMS45OTU5VjEwLjY2NTNDMTA1LjEwNCAxMC41Mjg4IDEwNS4yMjMgMTAuNDA5NCAxMDUuMzYgMTAuNDA5NEgxMDcuODMzQzEwNy45NyAxMC40MDk0IDEwOC4wODkgMTAuNTI4OCAxMDguMDg5IDEwLjY2NTNWMjEuMjkyNEMxMDguMDg5IDIxLjQyODggMTA3Ljk3IDIxLjU0ODIgMTA3LjgzMyAyMS41NDgySDEwNS4zNkMxMDUuMjIzIDIxLjU0ODIgMTA1LjEwNCAyMS40Mjg4IDEwNS4xMDQgMjEuMjkyNFYxOS44OTM2QzEwNC41NzUgMjAuNzEyNCAxMDMuNDE1IDIxLjc4NzEgMTAxLjUyMiAyMS43ODcxQzk3LjkwNTQgMjEuNzg3MSA5Ni4wMjkgMTkuMDIzNyA5Ni4wMjkgMTUuOTM2MUM5Ni4wMjkgMTEuOTEwNSA5OC44MjY0IDEwLjE4NzYgMTAxLjQzNiAxMC4xODc2QzEwMy4xNTkgMTAuMTcwNSAxMDQuMzUzIDEwLjk4OTMgMTA1LjEwNCAxMS45OTU4VjExLjk5NTlaTTk5LjAxNDEgMTUuOTUzM0M5OS4wMTQxIDE3Ljg2MzggMTAwLjE5MSAxOS4zMzA4IDEwMi4wODUgMTkuMzMwOEMxMDMuOTc4IDE5LjMzMDggMTA1LjE4OSAxOC4wNTE1IDEwNS4xODkgMTYuMDg5N0MxMDUuMTg5IDE0LjEyOCAxMDQuMDEyIDEyLjYyNyAxMDEuOTk5IDEyLjYyN0MxMDAuMTA2IDEyLjYyNyA5OS4wMTQxIDE0LjA5NCA5OS4wMTQxIDE1Ljk1MzNaTTExMC4zMjQgMjEuMjkyNVYxMC42NjUzQzExMC4zMjQgMTAuNTI4OCAxMTAuNDQzIDEwLjQwOTQgMTEwLjU3OSAxMC40MDk0SDExMy4wNTNDMTEzLjE4OSAxMC40MDk0IDExMy4zMDkgMTAuNTI4OCAxMTMuMzA5IDEwLjY2NTNWMTIuMTE1MkMxMTMuODg5IDExLjEwODggMTE0Ljk4IDEwLjE4NzYgMTE2Ljg0IDEwLjE4NzZDMTE4Ljc1IDEwLjE4NzYgMTIwLjg4MiAxMS4xMjU4IDEyMC44ODIgMTUuNDQxNFYyMS4yOTI0QzEyMC44ODIgMjEuNDI4OCAxMjAuNzYzIDIxLjU0ODIgMTIwLjYyNyAyMS41NDgySDExOC4xNTNDMTE4LjAxNyAyMS41NDgyIDExNy44OTcgMjEuNDI4OCAxMTcuODk3IDIxLjI5MjRWMTUuNDkyNkMxMTcuODk3IDE0LjQ1MjEgMTE3LjY0MiAxMi42NjEgMTE1Ljc5OSAxMi42NjFDMTEzLjk1NyAxMi42NjEgMTEzLjMwOSAxNC4yODE1IDExMy4zMDkgMTUuNzgyNlYyMS4yOTI0QzExMy4zMDkgMjEuNDI4OCAxMTMuMTg5IDIxLjU0ODIgMTEzLjA1MyAyMS41NDgySDExMC41NzlDMTEwLjQyNiAyMS41MzExIDExMC4zMjQgMjEuNDI4OCAxMTAuMzI0IDIxLjI5MjRMMTEwLjMyNCAyMS4yOTI1Wk0xMjIuOTk4IDIxLjI5MjVWMTAuNjY1M0MxMjIuOTk4IDEwLjUyODggMTIzLjExNyAxMC40MDk0IDEyMy4yNTQgMTAuNDA5NEgxMjUuNzI3QzEyNS44NjMgMTAuNDA5NCAxMjUuOTgzIDEwLjUyODggMTI1Ljk4MyAxMC42NjUzVjEyLjExNTJDMTI2LjU2MyAxMS4xMDg4IDEyNy42NTUgMTAuMTg3NiAxMjkuNTE0IDEwLjE4NzZDMTMxLjQyNCAxMC4xODc2IDEzMy41NTcgMTEuMTI1OCAxMzMuNTU3IDE1LjQ0MTRWMjEuMjkyNEMxMzMuNTU3IDIxLjQyODggMTMzLjQzNyAyMS41NDgyIDEzMy4zMDEgMjEuNTQ4MkgxMzAuODI3QzEzMC42OTEgMjEuNTQ4MiAxMzAuNTcxIDIxLjQyODggMTMwLjU3MSAyMS4yOTI0VjE1LjQ5MjZDMTMwLjU3MSAxNC40NTIxIDEzMC4zMTYgMTIuNjYxIDEyOC40NzMgMTIuNjYxQzEyNi42MzEgMTIuNjYxIDEyNS45ODMgMTQuMjgxNSAxMjUuOTgzIDE1Ljc4MjZWMjEuMjkyNEMxMjUuOTgzIDIxLjQyODggMTI1Ljg2MyAyMS41NDgyIDEyNS43MjcgMjEuNTQ4MkgxMjMuMjUzQzEyMy4xMTcgMjEuNTMxMSAxMjIuOTk4IDIxLjQyODkgMTIyLjk5OCAyMS4yOTI1Wk0xNDguOTc3IDEwLjQwOTVIMTUxLjM4MkMxNTEuNTE5IDEwLjQwOTUgMTUxLjYzOCAxMC41Mjg5IDE1MS42MzggMTAuNjY1NFYxMi44NjU4QzE1Mi4xMTYgMTAuNjgyNCAxNTMuOTkyIDkuOTMxODYgMTU1LjM1NyAxMC4yNTZDMTU1LjQ3NiAxMC4yNzMxIDE1NS41NDQgMTAuMzc1NCAxNTUuNTQ0IDEwLjQ5NDhWMTIuOTE3QzE1NS41NDQgMTMuMDcwNSAxNTUuNDA4IDEzLjE4OTkgMTU1LjIzNyAxMy4xNTU4QzE1Mi43MTMgMTIuNjYxMSAxNTEuNjg5IDE0LjAyNTggMTUxLjY4OSAxNS45MzYyVjIxLjI5MjVDMTUxLjY4OSAyMS40Mjg5IDE1MS41NyAyMS41NDgzIDE1MS40MzMgMjEuNTQ4M0gxNDguOTZDMTQ4LjgyMyAyMS41NDgzIDE0OC43MDQgMjEuNDI4OSAxNDguNzA0IDIxLjI5MjVWMTAuNjY1M0MxNDguNzIxIDEwLjUyODggMTQ4Ljg0MSAxMC40MDk1IDE0OC45NzcgMTAuNDA5NVpNNDcuNDEzOCAxMi44MzE3QzQ2LjY0NjIgMTIuNTc1OCA0Ni4yMzY4IDEyLjQyMjMgNDUuNjIyNiAxMi4yMTc2QzQ0Ljk5MTUgMTEuOTk1OSA0My45MTY4IDExLjM4MTcgNDMuOTE2OCAxMC4zOTI0QzQzLjkxNjggOS40MDMwNiA0NC41OTkxIDguNzcxODYgNDUuOTgwOSA4Ljc3MTg2QzQ3LjI0MzIgOC43NzE4NiA0Ny45NDI1IDkuMzg1OTYgNDguNDAzMSAxMC4zNzUzQzQ4LjQ3MTMgMTAuNTExOCA0OC42MjQ5IDEwLjU2MyA0OC43NjEzIDEwLjQ5NDhMNTAuNzkxMiA5LjMxNzc2QzUwLjg5MzUgOS4yNDk1NSA1MC45NDQ3IDkuMTEzMDYgNTAuODkzNSA4Ljk5MzY2QzUwLjI3OTUgNy42NDYwNSA0OC44NDY2IDYuMDI1NTMgNDYuMDE1IDYuMDI1NTNDNDIuODU5MiA2LjAyNTUzIDQwLjg4MDUgNy45MDE5NCA0MC44ODA1IDEwLjM3NTRDNDAuODgwNSAxMi44MzE4IDQyLjUwMSAxNC4xMTEgNDQuNzAxNSAxNC44NjE2QzQ1LjUwMzIgMTUuMTM0NSA0NS44Mjc0IDE1LjI1MzkgNDYuNTA5NyAxNS40NzU3QzQ3LjgwNjEgMTUuOTE5MiA0OC40MDMxIDE2LjQ5OTEgNDguNDAzMSAxNy4zMDA5QzQ4LjQwMzEgMTguMTAyNyA0Ny44OTE0IDE5LjA1NzkgNDUuODc4NSAxOS4wNTc5QzQ0LjAzNjIgMTkuMDU3OSA0My4zODggMTguMDg1NiA0My4wMTI3IDE3LjE2NDRDNDIuOTYxNiAxNy4wMjc5IDQyLjc5MSAxNi45NTk3IDQyLjY1NDYgMTcuMDQ1TDQwLjUyMjMgMTguMjczMkM0MC40MiAxOC4zNDE1IDQwLjM2ODggMTguNDYwOSA0MC40MiAxOC41ODAzQzQxLjIzODggMjAuNTkzMSA0My40NzMzIDIxLjc4NzEgNDUuOTgwOSAyMS43ODcxQzQ4LjkzMTkgMjEuNzg3MSA1MS40MjIzIDIwLjI4NjEgNTEuNDIyMyAxNy4yNDk3QzUxLjQyMjMgMTQuMjEzNCA0OC4xODEzIDEzLjA4NzYgNDcuNDEzOCAxMi44MzE4VjEyLjgzMTdaTTYzLjcwNDEgMTguNjMxNUM2My42MzU4IDE4LjUxMjEgNjMuNDY1MyAxOC40NjA5IDYzLjM0NTggMTguNTQ2MkM2Mi4zOTA2IDE5LjI0NTUgNjEuMjY0OCAxOS4yNjI2IDYwLjQxMTkgMTcuOTQ5MUM1OS42OTU1IDE2Ljg0MDMgNTguODI1NiAxNS40NzU2IDU4LjgyNTYgMTUuNDc1Nkw2Mi41NzgyIDEwLjgxODlDNjIuNzE0NyAxMC42NDgzIDYyLjU5NTMgMTAuNDA5NSA2Mi4zOTA2IDEwLjQwOTVINTkuNDU2OEM1OS4zNzE1IDEwLjQwOTUgNTkuMzAzMiAxMC40NDM3IDU5LjI1MjEgMTAuNTExOEw1Ni4wMTEgMTQuOTYzOVY2LjAwODUyQzU2LjAxMSA1Ljg3MjAzIDU1Ljg5MTYgNS43NTI2MiA1NS43NTUxIDUuNzUyNjJINTMuMjgxN0M1My4xNDUzIDUuNzUyNjIgNTMuMDI1OSA1Ljg3MjAzIDUzLjAyNTkgNi4wMDg1MlYyMS4yOTI1QzUzLjAyNTkgMjEuNDI4OSA1My4xNDUzIDIxLjU0ODMgNTMuMjgxNyAyMS41NDgzSDU1Ljc3MjJDNTUuOTA4NyAyMS41NDgzIDU2LjAyODEgMjEuNDI4OSA1Ni4wMjgxIDIxLjI5MjVWMTYuMzI4NUM1Ni4wMjgxIDE2LjMyODUgNTcuNjgyOCAxOC45Mzg0IDU4LjMxMzkgMTkuOTEwN0M1OS4xNjY4IDIxLjI0MTIgNjAuMzYwOSAyMS43ODcxIDYxLjY1NzIgMjEuNzg3MUM2Mi44ODU0IDIxLjc4NzEgNjMuNjcgMjEuNDYzIDY0LjYwODIgMjAuNTQxOEM2NC42OTM1IDIwLjQ1NjUgNjQuNzEwNiAyMC4zMzcxIDY0LjY1OTQgMjAuMjM0OEw2My43MDQxIDE4LjYzMTVaTTgxLjQ2MTQgMTUuMTE3NEM4MC42NzY4IDE0LjgyNzUgODAuNDAzOSAxNC43MjUxIDc5LjgwNjggMTQuNTAzNEM3OS4yMDk3IDE0LjI4MTcgNzguNjgxIDEzLjk1NzUgNzguNjgxIDEzLjQ3OTlDNzguNjgxIDEzLjAwMjMgNzkuMTI0NiAxMi40NzM1IDgwLjAyODYgMTIuNDczNUM4MC44MTMyIDEyLjQ3MzUgODEuMjkwOSAxMi43ODA1IDgxLjU2MzggMTMuMzI2NEM4MS42MzIgMTMuNDYyOCA4MS43ODU1IDEzLjQ5NyA4MS45MDQ5IDEzLjQyODdMODMuNjQ0OSAxMi40MjIzQzgzLjc2NDMgMTIuMzU0MSA4My43OTg1IDEyLjIwMDYgODMuNzMwMiAxMi4wODEyQzgzLjI1MjYgMTEuMjQ1MyA4Mi4zMTQzIDEwLjE4NzcgODAuMDQ1NiAxMC4xODc3Qzc3LjI2NTMgMTAuMTg3NyA3NS44MzI0IDExLjc5MTEgNzUuODMyNCAxMy41NjUyQzc1LjgzMjQgMTUuMzM5MyA3Ny4yODIzIDE2LjE3NSA3OC42MTI3IDE2LjcwMzhDODAuMTEzOSAxNy4zMTc5IDgwLjIxNjIgMTcuMzUyIDgwLjQwMzkgMTcuNDIwM0M4MC44NjQ0IDE3LjYwNzkgODEuNDI3MyAxNy44OTc5IDgxLjQyNzMgMTguNDI2OEM4MS40MjczIDE4Ljk1NTYgODAuODEzMiAxOS40MzMyIDc5Ljg3NTEgMTkuNDMzMkM3OS4wMDUxIDE5LjQzMzIgNzguMDE1OCAxOS4wNzUgNzcuNjA2NCAxOC4wNjg1Qzc3LjU1NTIgMTcuOTMyIDc3LjM4NDYgMTcuODYzOCA3Ny4yNDgyIDE3Ljk0OTFMNzUuNDkxMiAxOC45NTU2Qzc1LjM4ODkgMTkuMDIzOCA3NS4zMzc3IDE5LjE0MzIgNzUuMzg4OSAxOS4yNjI2Qzc1LjkwMDYgMjAuNTkzMSA3Ny40MTg4IDIxLjc3MDEgNzkuODc1MSAyMS43NzAxQzgyLjUzNjEgMjEuNzcwMSA4NC4zMTAyIDIwLjM1NDMgODQuMzEwMiAxOC4zNTg1Qzg0LjMxMDIgMTYuMzYyNiA4Mi45NDU1IDE1LjY2MzMgODEuNDYxNCAxNS4xMTc0Wk05MS40NTc0IDEyLjgzMTdDOTIuNTY2MiAxMi44MzE3IDkzLjM4NSAxMy4xNzI5IDk0LjE1MjcgMTMuNzE4N0M5NC4yNzIxIDEzLjgwNCA5NC40NDI2IDEzLjc2OTkgOTQuNTEwOCAxMy42NTA1TDk1LjUzNDMgMTEuODc2NUM5NS42MDI2IDExLjc1NzEgOTUuNTY4NSAxMS42MjA2IDk1LjQ0OSAxMS41NTI0Qzk0LjM5MTUgMTAuODM1OSA5My4wNzggMTAuMTcwNyA5MS4zMDM5IDEwLjE3MDdDODkuNTQ2OSAxMC4xNzA3IDg3LjkyNjQgMTAuNjQ4MyA4Ni43NjY1IDExLjgyNTNDODUuNjA2NiAxMi45ODUyIDg1LjA3NzggMTQuMzY2OSA4NS4wNzc4IDE2LjAwNDVDODUuMDc3OCAxNy45ODMyIDg1Ljg5NjYgMTkuMjQ1NiA4Ni43ODM2IDIwLjEzMjZDODcuNjcwNiAyMS4wMTk2IDg5LjI3NCAyMS43NzAxIDkxLjMyMSAyMS43NzAxQzkzLjE2MzMgMjEuNzcwMSA5NC41Mjc5IDIxLjAwMjUgOTUuNDY2MSAyMC4zODg0Qzk1LjU2ODQgMjAuMzIwMiA5NS42MDI2IDIwLjE2NjcgOTUuNTM0MyAyMC4wNjQzTDk0LjUyNzkgMTguMzA3NEM5NC40NTk3IDE4LjE4NzkgOTQuMjg5MSAxOC4xMzY4IDk0LjE2OTggMTguMjIyMUM5My41MDQ1IDE4LjY5OTcgOTIuNTQ5MiAxOS4xMDkxIDkxLjQ3NDUgMTkuMTA5MUM5MC4yNjM0IDE5LjEwOTEgODguMDYyOSAxOC40MjY4IDg4LjA2MjkgMTUuOTcwM0M4OC4wNjI5IDEzLjUxMzkgOTAuMjQ2MyAxMi44MzE3IDkxLjQ1NzQgMTIuODMxN1pNMTQxLjY0MiAxOS4zMTM4QzE0MC42NTMgMTkuMzEzOCAxMzkuNzE1IDE5LjA3NSAxMzkuMDMyIDE4LjUyOTFDMTM4LjM1IDE3Ljk4MzMgMTM4LjAyNiAxNy40MjAzIDEzOC4wMjYgMTYuNzU1SDE0Ni44NjJDMTQ2Ljk5OCAxNi43NTUgMTQ3LjExOCAxNi42MzU2IDE0Ny4xMTggMTYuNDk5MUMxNDcuMDY3IDEzLjg3MjIgMTQ2LjIxNCAxMi42NDQxIDE0NS4zOTUgMTEuODA4MkMxNDQuNTQyIDEwLjk1NTMgMTQzLjA5MiAxMC4xNzA2IDE0MS4xODEgMTAuMTcwNkMxMzkuMjcxIDEwLjE3MDYgMTM3LjgwNCAxMC44NzAxIDEzNi43OTggMTEuODU5NUMxMzUuODA4IDEyLjg0ODggMTM1LjA1OCAxNC4xMTEgMTM1LjA1OCAxNi4wMjE1QzEzNS4wNTggMTcuOTMyIDEzNS44MjUgMTkuMTk0NCAxMzYuNzY0IDIwLjEzMjZDMTM3LjcwMiAyMS4wNzA4IDEzOS4yMzcgMjEuNzcwMSAxNDEuNDM3IDIxLjc3MDFDMTQzLjUxOCAyMS43NzAxIDE0NS4yNzUgMjEuMDM2NiAxNDYuNTM4IDE5LjU4NjdDMTQ2LjY0IDE5LjQ2NzMgMTQ2LjYwNiAxOS4yNzk3IDE0Ni40NyAxOS4yMTE1TDE0NC43MTMgMTguMTg3OUMxNDQuNjI3IDE4LjEzNjcgMTQ0LjUwOCAxOC4xMzY3IDE0NC40MjMgMTguMjIyMUMxNDMuNTUzIDE5LjA0MDkgMTQyLjQ0NCAxOS4zMTM4IDE0MS42NDIgMTkuMzEzOFpNMTQxLjE2NCAxMi41NTg4QzE0Mi41OCAxMi41NTg4IDE0My44NzcgMTMuNDExNyAxNDQuMDgxIDE0Ljk0NjhIMTM4LjEyOEMxMzguNTIgMTMuMjkyMyAxMzkuNzQ5IDEyLjU1ODggMTQxLjE2NCAxMi41NTg4WiIgZmlsbD0iIzkwOTA5MCIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzM4OV82MDkiPgo8cmVjdCB3aWR0aD0iMTU1LjIxMSIgaGVpZ2h0PSIyOCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMzMzNDk2IDAuMDAwMTIyMDcpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg=="},7713:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI3IiBoZWlnaHQ9IjI4IiB2aWV3Qm94PSIwIDAgMTI3IDI4IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMzg5XzU4MikiPgo8bWFzayBpZD0ibWFzazBfMzg5XzU4MiIgc3R5bGU9Im1hc2stdHlwZTpsdW1pbmFuY2UiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjciIHdpZHRoPSIxMDkiIGhlaWdodD0iMjIiPgo8cGF0aCBkPSJNMC4zNTEwNzQgNy44NDkwNkgxMDguMTdWMjguMDAwN0gwLjM1MTA3NFY3Ljg0OTA2WiIgZmlsbD0id2hpdGUiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzM4OV81ODIpIj4KPHBhdGggZD0iTTEwMS4xNTQgMjEuMjc5N0MxMDIuNDE1IDIwLjkwNjkgMTAzLjk2IDIwLjg4OTIgMTA0Ljk3NSAyMC44ODkySDEwNS4yNzdWMjEuMDI4QzEwNS4yNzcgMjIuMTc4NSAxMDQuODc3IDIzLjQwOTcgMTA0LjE0NCAyNC4zMDIxQzEwMy41MzMgMjUuMDQyOCAxMDIuNjg2IDI1LjU0NDYgMTAxLjY0MiAyNS41NDQ2QzEwMC44MzYgMjUuNTQ0NiAxMDAuMjI1IDI1LjMxMDcgOTkuODAzNiAyNC45NTRDOTkuMzM1NiAyNC41NTg3IDk5LjA5ODQgMjQuMDA2OCA5OS4wOTg0IDIzLjQ2NzhDOTkuMDk4NCAyMi4yNTI3IDEwMC4wMTUgMjEuNjE1MyAxMDEuMTU0IDIxLjI3OTdaTTk3LjcyODQgMjYuNzYzQzk4LjY4MjEgMjcuNTgyNyAxMDAuMDA0IDI4LjAwMDcgMTAxLjMyIDI4LjAwMDdDMTAyLjQ0NCAyOC4wMDA3IDEwMy40NDkgMjcuNjU4NiAxMDQuMjc3IDI3LjExMTVDMTA0LjY4MiAyNi44NDM2IDEwNS4wNDMgMjYuNTI1OCAxMDUuMzU2IDI2LjE3NFYyNy42ODExSDEwOC4wMzNWMTguNjY1NUMxMDguMDMzIDE2Ljg3MjcgMTA3LjU0MyAxNS40ODUgMTA2LjYxIDE0LjUzMTNDMTA1LjY2OCAxMy41Njk1IDEwNC4yOTggMTMuMDcyNSAxMDIuNTQ4IDEzLjA3MjVDMTAxLjYxMyAxMy4wNzI1IDEwMC42NDYgMTMuMjMzOSA5OS43Njk3IDEzLjUxMzFDOTguODc3MyAxMy43OTcxIDk4LjA3NjkgMTQuMjA2OSA5Ny40OTYgMTQuNjk3NUw5Ny4xOTEgMTQuOTU1N0w5Ny4zOTYgMTUuMjk3OEw5OC4yMjM4IDE2LjY3OTFMOTguNDg4NCAxNy4xMTk2TDk4LjkwMzEgMTYuODE2M0M5OS40MTc5IDE2LjQ0MTkgOTkuOTk3MiAxNi4xNDM0IDEwMC42MDkgMTUuOTM4NEMxMDEuMTk4IDE1Ljc0MTYgMTAxLjgxOSAxNS42MzUgMTAyLjQ0IDE1LjYzNUMxMDMuMzI2IDE1LjYzNSAxMDQuMDgzIDE1Ljg0MTYgMTA0LjU3OCAxNi4zNThDMTA1LjAwMyAxNi44MDE3IDEwNS4yNTkgMTcuNDk1NiAxMDUuMjc2IDE4LjUxMjJIMTA0Ljk0OEMxMDMuNjM0IDE4LjUxMjIgMTAxLjUzOCAxOC41ODE2IDk5Ljc0ODcgMTkuMjIwNkM5Ny44NTU5IDE5Ljg5NTIgOTYuMzE0OCAyMS4xODI5IDk2LjMxNDggMjMuNjI3NkM5Ni4zMTQ4IDI0Ljk3ODIgOTYuODczMSAyNi4wMjcxIDk3LjcyODQgMjYuNzYzWk04Ni43MDU0IDI3LjY4MTFIODQuNDIwNFY4LjA4NDY2SDg3LjE3NjZWMTguNDg2NEg4OC42MzY5TDkyLjQ5NTIgMTMuNTcyOEw5Mi42MzcyIDEzLjM5Mkg5Ni4wMzU2TDk1LjQxOTIgMTQuMTU4NUw5MC45NTA5IDE5LjcyMDlMOTUuOTE5NSAyNi45NDIxTDk2LjQyNzggMjcuNjgxMUg5My4wOTU1TDkyLjk1NTEgMjcuNDcxNEw4OC42NDE4IDIxLjAyMTVIODcuMTc2NlYyNy42ODExSDg2LjcwNTRaTTcxLjA0NDYgMTcuMDMyNUM3MC4yMDA3IDE3Ljg5NDIgNjkuNjc5NSAxOS4wOTY0IDY5LjY3OTUgMjAuNDY5NkM2OS42Nzk1IDIxLjg5MTMgNzAuMTk3NCAyMy4xMTkzIDcxLjAzNjYgMjMuOTkyM0M3MS44OTE4IDI0Ljg4MyA3My4wODQzIDI1LjQxMDcgNzQuNDA5MSAyNS40MTA3Qzc1LjczNTYgMjUuNDEwNyA3Ni45Mzc4IDI0Ljg4MTQgNzcuNzk5NSAyMy45ODkxQzc4LjY0MzQgMjMuMTE0NCA3OS4xNjQ2IDIxLjg4OTcgNzkuMTY0NiAyMC40Njk2Qzc5LjE2NDYgMTkuMDk5NiA3OC42NDAyIDE3Ljg5NzQgNzcuNzkxNCAxNy4wMzU3Qzc2LjkzMTMgMTYuMTYxMSA3NS43MzI0IDE1LjYzNSA3NC40MDkxIDE1LjYzNUM3My4wODkyIDE1LjYzNSA3MS44OTgzIDE2LjE2MTEgNzEuMDQ0NiAxNy4wMzI1Wk02OS4wNDUzIDI1LjgxNzNDNjcuNjk3OSAyNC40NzE1IDY2Ljg3IDIyLjYwMTMgNjYuODcgMjAuNDY5NkM2Ni44NyAxOC4zNzUxIDY3LjY5OTUgMTYuNTM3MSA2OS4wNDg1IDE1LjIxNTVDNzAuNDEzNyAxMy44Nzc4IDcyLjMwODEgMTMuMDcyNSA3NC40MDkxIDEzLjA3MjVDNzYuNTExOCAxMy4wNzI1IDc4LjQxNDMgMTMuODc5NCA3OS43ODU5IDE1LjIxNzFDODEuMTM5OCAxNi41NDAzIDgxLjk3NTcgMTguMzc2NyA4MS45NzU3IDIwLjQ2OTZDODEuOTc1NyAyMi41OTk3IDgxLjE0MTQgMjQuNDY4MyA3OS43OTA4IDI1LjgxNDFDNzguNDE5MSAyNy4xNzkzIDc2LjUxMzQgMjguMDAwNyA3NC40MDkxIDI4LjAwMDdDNzIuMzA2NSAyOC4wMDA3IDcwLjQxMDUgMjcuMTgwOSA2OS4wNDUzIDI1LjgxNzNaTTYyLjU1MzUgMjcuMTYxNUM2MS44MDQ3IDI2LjYzMDYgNjEuMjE1NyAyNS42OTQ3IDYxLjIxNTcgMjQuMDUyVjguMDg0NjZINjMuOTczNVYyMy42NTM0QzYzLjk3MzUgMjQuMzgyOCA2NC4xMjAzIDI0Ljc3ODEgNjQuMzI4NSAyNC45ODE1QzY0LjUxMDkgMjUuMTU3NCA2NC43NzM5IDI1LjE5OTMgNjUuMDIwOCAyNS4xOTkzQzY1LjA4MzcgMjUuMTk5MyA2NS4xNjEyIDI1LjE5OTMgNjUuMTk1MSAyNS4xOTc3QzY1LjI0OTkgMjUuMTk0NSA2NS4zMTEyIDI1LjE4OTYgNjUuMzcyNiAyNS4xNzk5TDY1LjkxOTYgMjUuMDg5NlYyNy42NjE4TDY1LjUyNDIgMjcuNzI2M0M2NS40Mzg3IDI3Ljc0MDkgNjUuMzM3MSAyNy43NTU0IDY1LjIwNjMgMjcuNzY2N0M2NS4wNzI0IDI3Ljc3OTYgNjQuOTI4OCAyNy43ODc2IDY0Ljc4MiAyNy43ODc2QzY0LjE2NzEgMjcuNzg3NiA2My4yOTQxIDI3LjY4NzYgNjIuNTUzNSAyNy4xNjE1Wk00OS44NjM1IDE2LjUxNjFDNDkuMjc2MSAxNy4wNDM4IDQ4LjgyNDMgMTcuNzc2NCA0OC41ODM5IDE4LjY5NzhINTUuOTI0NUM1NS44MTE1IDE3LjczOTMgNTUuNDc0MyAxNy4wMDM0IDU0Ljk5MzQgMTYuNDgyMkM1NC4zODgzIDE1LjgyNTUgNTMuNTQxMSAxNS41MDI3IDUyLjYxODEgMTUuNTAyN0M1MS41NzU2IDE1LjUwMjcgNTAuNjA1OCAxNS44NDk3IDQ5Ljg2MzUgMTYuNTE2MVpNNDcuNjg1IDI1Ljg4MDNDNDYuMzU4NiAyNC41NjUxIDQ1LjU1OTggMjIuNzE3NSA0NS41NTk4IDIwLjU1MDNDNDUuNTU5OCAxOC4zMDU3IDQ2LjMxMzQgMTYuNDg4NyA0Ny41MzAxIDE1LjIwNDJDNDguODM1NiAxMy44MjYxIDUwLjY2ODcgMTMuMDcyNSA1Mi42NzEzIDEzLjA3MjVDNTQuNTc1NCAxMy4wNzI1IDU2LjA0MzkgMTMuNzcxMyA1Ny4wNjM3IDE0Ljg5MjhDNTguMTgwNCAxNi4xMjA4IDU4Ljc0NTIgMTcuODQ0MiA1OC43NDUyIDE5LjY5OTlDNTguNzQ1MiAxOS44NDY3IDU4LjczNzEgMjAuMDExMyA1OC43Mjc0IDIwLjE4MDhDNTguNzE3OCAyMC4zMDk5IDU4LjcwMzIgMjAuNDc3NyA1OC42ODg3IDIwLjY0NTVMNTguNjQ4NCAyMS4wNzQ4SDQ4LjQyMjVDNDguNTQ1MSAyMi4zNDQ3IDQ5LjAyNiAyMy4zNTQ5IDQ5LjczNzYgMjQuMDc2MkM1MC41OTkzIDI0Ljk1MDggNTEuODA4IDI1LjQxMDcgNTMuMTI2NCAyNS40MTA3QzUzLjc5NiAyNS40MTA3IDU0LjQ3NyAyNS4yNzE5IDU1LjExNzYgMjUuMDIzNEM1NS43NzI4IDI0Ljc2NjggNTYuMzgyOCAyNC4zOTczIDU2Ljg5MTEgMjMuOTQwNkw1Ny4zMTU1IDIzLjU1OThMNTcuNjA5MiAyNC4wNDg4TDU4LjYzNTUgMjUuNzU5M0w1OC4zNDk4IDI2LjAxOTFDNTcuNjgxOCAyNi42MjU4IDU2LjgzMyAyNy4xMjEyIDU1LjkxOTYgMjcuNDYzM0M1NC45OTgyIDI3LjgwNyA1NC4wMTA3IDI3Ljk5OSA1My4wNzE1IDI3Ljk5OUM1MC45MjY5IDI4LjAwMDcgNDkuMDM1NyAyNy4yMTk2IDQ3LjY4NSAyNS44ODAzWk0zOS4zNjMzIDI3LjY4MTFIMzcuMDY4N0wzNi45NTA5IDI3LjM3OTRMMzEuNzc3NCAxNC4wMzI3TDMxLjUyNzMgMTMuMzkySDM0LjQ4NjhMMzQuNjAzIDEzLjY5N0wzOC4zMDk2IDIzLjQ4ODhMMzguMzExMiAyMy40OTM3QzM4LjMyOSAyMy41NDA1IDM4LjM0NTEgMjMuNTkwNSAzOC4zNjI4IDIzLjY0MDVDMzguMzc5IDIzLjU5MDUgMzguMzk2NyAyMy41NDA1IDM4LjQxNDUgMjMuNDkzN0wzOC40MTYxIDIzLjQ4ODhMNDIuMTIyNyAxMy42OTdMNDIuMjM4OSAxMy4zOTJINDUuMTY5M0w0NC45MjQgMTQuMDMxMUwzOS44MDM5IDI3LjM3NzhMMzkuNjg2MSAyNy42ODExSDM5LjM2MzNaTTIzLjM1MjQgMjEuMjc5N0MyMi4yMTMyIDIxLjYxNTMgMjEuMjk4MiAyMi4yNTI3IDIxLjI5ODIgMjMuNDY3OEMyMS4yOTgyIDI0LjAwNjggMjEuNTM1NCAyNC41NTg3IDIyLjAwMzQgMjQuOTU0QzIyLjQyMjkgMjUuMzA5IDIzLjAzNDUgMjUuNTQ0NiAyMy44Mzk4IDI1LjU0NDZDMjQuODg1NCAyNS41NDQ2IDI1LjczMjYgMjUuMDQyOCAyNi4zNDI2IDI0LjMwMjFDMjcuMDc2OCAyMy40MDk3IDI3LjQ3NTQgMjIuMTc4NSAyNy40NzU0IDIxLjAyOFYyMC44ODkySDI3LjE3MzZDMjYuMTYwMiAyMC44ODkyIDI0LjYxNDMgMjAuOTA2OSAyMy4zNTI0IDIxLjI3OTdaTTE5LjkyODIgMjYuNzYzQzE5LjA3MyAyNi4wMjcxIDE4LjUxNDYgMjQuOTc4MiAxOC41MTQ2IDIzLjYyNzZDMTguNTE0NiAyMS4xODI5IDIwLjA1NTcgMTkuODk1MiAyMS45NDg1IDE5LjIyMDZDMjMuNzM4MSAxOC41ODE2IDI1LjgzNDMgMTguNTEyMiAyNy4xNDc4IDE4LjUxMjJIMjcuNDc1NEMyNy40NTkyIDE3LjQ5NTYgMjcuMjAyNyAxNi44MDE3IDI2Ljc3NjYgMTYuMzU4QzI2LjI4MTIgMTUuODQxNiAyNS41MjYgMTUuNjM1IDI0LjY0MDEgMTUuNjM1QzI0LjAxNzMgMTUuNjM1IDIzLjM5NzYgMTUuNzQxNiAyMi44MDg2IDE1LjkzODRDMjIuMTk3IDE2LjE0MzQgMjEuNjE2MSAxNi40NDE5IDIxLjEwMyAxNi44MTYzTDIwLjY4NjYgMTcuMTE5NkwyMC40MjM2IDE2LjY3NzVMMTkuNTk1OCAxNS4yOTc4TDE5LjM5MDggMTQuOTU1N0wxOS42OTU4IDE0LjY5NzVDMjAuMjc2OCAxNC4yMDUzIDIxLjA3NzEgMTMuNzk3MSAyMS45Njk1IDEzLjUxMTRDMjIuODQ1NyAxMy4yMzM5IDIzLjgxMjMgMTMuMDcyNSAyNC43NDY2IDEzLjA3MjVDMjYuNDk3NSAxMy4wNzI1IDI3Ljg2NzUgMTMuNTY3OSAyOC44MDgzIDE0LjUzMTNDMjkuNzQyNiAxNS40ODUgMzAuMjMzMSAxNi44NzI3IDMwLjIzMzEgMTguNjY1NVYyNy42ODExSDI3LjU1NlYyNi4xNzRDMjcuMjQzIDI2LjUyNTggMjYuODc5OSAyNi44NDM2IDI2LjQ3NjUgMjcuMTExNUMyNS42NDcxIDI3LjY1ODYgMjQuNjQxNyAyNy45OTkgMjMuNTIwMiAyNy45OTlDMjIuMjAzNSAyOC4wMDA3IDIwLjg4MTkgMjcuNTgyNyAxOS45MjgyIDI2Ljc2M1pNMTIuNTg0NCAyNy42ODExSDEwLjI5OTRWMTMuMzkySDEzLjAyOTdWMTUuMzI2OEMxMy4yOTQ0IDE0Ljk2MjEgMTMuNTk0NSAxNC42MzMgMTMuOTI2OSAxNC4zNDg5QzE0LjcyMDkgMTMuNjcyOCAxNS42OTIzIDEzLjI1ODEgMTYuNzk5MyAxMy4yNTgxQzE2LjkzNDggMTMuMjU4MSAxNy4wODE3IDEzLjI2NjIgMTcuMjMwMSAxMy4yODM5QzE3LjM2ODkgMTMuMjk4NCAxNy41MDYxIDEzLjMyMSAxNy42MzE5IDEzLjM1MzNMMTcuOTkxOCAxMy40NDIxVjE2LjI0MDJMMTcuMzcyMSAxNi4wMzUyQzE3LjM2NTcgMTYuMDMzNiAxNy4zMDQ0IDE2LjAyNzIgMTcuMjE0IDE2LjAyMDdDMTcuMTA1OSAxNi4wMTI2IDE2Ljk3MzYgMTYuMDA2MiAxNi44NTI1IDE2LjAwNjJDMTUuNjg3NSAxNi4wMDYyIDE0LjgyMDkgMTYuNTkwMyAxNC4yMTc0IDE3LjQ0NEgxNC4yMTU4QzEzLjQxNyAxOC41NzM2IDEzLjA1NzIgMjAuMTY0NiAxMy4wNTcyIDIxLjU1NzJWMjcuNjgxMUgxMi41ODQ0Wk00LjA4MTg5IDI2Ljg5MzdDMi45ODk0NCAyNi4xMzIgMi4xMTE2IDI0Ljc3MDEgMi4xMTE2IDIyLjM1NDRWMTUuOTUyOUgwLjM1MTA3NFYxMy40OTY5SDIuMTM3NDFWOS43MDMxN0g0Ljg2Nzc1VjEzLjQ5NjlIOC4yNTY0OFYxNS45NTI5SDQuODY3NzVWMjIuMTY3MkM0Ljg2Nzc1IDIzLjI5MDMgNS4xNDM2OSAyNC4wMDM2IDUuNTMwOTggMjQuNDUzOEM2LjA4OTMxIDI1LjEwMDkgNi45MDc0NCAyNS4yMjUxIDcuNDM4MzQgMjUuMjI1MUM3LjUyODcxIDI1LjIyNTEgNy42MjA2OSAyNS4yMjUxIDcuNjkzMyAyNS4yMjAzSDcuNjk0OTJDNy43NzU2IDI1LjIxNTQgNy44NTk1MSAyNS4yMDQyIDcuOTQ5ODggMjUuMTg0OEw4LjUyMjczIDI1LjA1ODlWMjcuNjYxOEw4LjEyNzM4IDI3LjcyNjNDOC4wMjQxMSAyNy43NDQxIDcuODg2OTQgMjcuNzYwMiA3LjcyNTU4IDI3Ljc3MTVDNy41ODg0MSAyNy43ODEyIDcuNDM2NzMgMjcuNzg3NiA3LjI3Njk3IDI3Ljc4NzZDNi40Mzk0OCAyNy43ODc2IDUuMTY0NjcgMjcuNjQ3MyA0LjA4MTg5IDI2Ljg5MzdaIiBmaWxsPSIjOTA5MDkwIi8+CjwvZz4KPHBhdGggZD0iTTExOC40NzcgMTQuNzg2MkMxMTguNDkzIDE0Ljc3NjYgMTE4LjUwOSAxNC43NjY5IDExOC41MjUgMTQuNzU3MkMxMTcuODA2IDEyLjYwNzggMTIwLjc5OCA4Ljk3NTQgMTI2LjM0NyAyLjg5OTlDMTIxLjg2MSAzLjQ1MDE3IDExOC4zOSA0LjU4OTQyIDExNS45MzYgNi4zMTYwNkMxMTYuMTc0IDkuODM3MSAxMTcuMDIyIDEyLjY2MSAxMTguNDc3IDE0Ljc4NjJaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0xMTguNDc3IDE0Ljc4NjNDMTE4LjQ5MyAxNC43NzY2IDExOC41MDkgMTQuNzY2OSAxMTguNTI1IDE0Ljc1NzJDMTE4LjUwMSAxNC42ODQ2IDExOC40ODIgMTQuNjEwNCAxMTguNDY2IDE0LjUzNDZDMTE3Ljc2NSAxMS44NzIgMTE3LjQ4MSA4Ljc5NjMzIDExNy42MTQgNS4zMDc1NkMxMTcuMDEgNS42MTkgMTE2LjQ1IDUuOTU0NjQgMTE1LjkzNiA2LjMxNjFDMTE2LjE3NCA5LjgzNzE1IDExNy4wMjIgMTIuNjYxMSAxMTguNDc3IDE0Ljc4NjNaIiBmaWxsPSIjOTA5MDkwIi8+CjxwYXRoIGQ9Ik0xMjAuMzI1IDE3Ljg2ODRDMTIxLjUwOSAxOC40NzUxIDEyMi40OTIgMTguNzg4MiAxMjMuMzYyIDE4LjYzODFDMTE3LjUxNCAxNi4zNDUxIDExNS4wODcgMTAuMTMyNCAxMTYuMDgxIC0wLjAwMTQ2NDg0QzExMy45OCAwLjQxMTYzNiAxMTIuMjc2IDEuMzcxNzcgMTExLjA4OCAyLjk3MjU0QzExMC4wNTQgNC4zNjgzNyAxMTAuMzg2IDYuMTQwMTkgMTExLjIzMyA4LjUwNzQ1QzExMS4zNDggOC44MjM3MyAxMTEuNDgzIDEwLjUzNDIgMTEwLjc3NyAxMS4xN0MxMTAuNTE1IDExLjQwMjQgMTEwLjA5NyAxMS4yMTg0IDEwOS43MzYgMTAuOTgyOEMxMDguNDkzIDEwLjI3NiAxMDcuNDU5IDEwLjI4MjUgMTA2LjYzNiAxMS4wMDM4QzEwNC4zNjcgMTAuNjIxNCAxMDIuNzI0IDEwLjQxNDggMTAxLjcwNiAxMC4zNzkzQzEwMy4xNTggMTAuODM2IDEwNC44MzcgMTEuMzA3MiAxMDYuNzIgMTEuODU1OEMxMDcuNTI1IDEyLjA4OTggMTA4LjIxNCAxMi42NDMzIDEwOC43NTggMTMuNDc5MkMxMDkuODcxIDE1LjE4OTcgMTEzLjAyNiAxNi4xMTc1IDExNi4wODEgMTYuNTU4MUMxMTcuMjI2IDE2LjcyMjcgMTE4LjgxMyAxNy4wOTM4IDEyMC4zMjUgMTcuODY4NFoiIGZpbGw9IiM5MDkwOTAiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zODlfNTgyIj4KPHJlY3Qgd2lkdGg9IjEyNS45OTYiIGhlaWdodD0iMjgiIGZpbGw9IndoaXRlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjM1MTA3NCAwLjAwMDEyMjA3KSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo="},9741:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjEiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMSAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTkuNzM3MzggMS4xNjc3NkMxMC4wODExIDAuMzUxMzA1IDExLjI1MTkgMC4zNTEzMDYgMTEuNTk1NiAxLjE2Nzc3TDEzLjYyNDQgNS45ODY2NUMxMy43Njk0IDYuMzMwODUgMTQuMDk3MSA2LjU2NjAzIDE0LjQ3MzIgNi41OTU4MkwxOS43MzkyIDcuMDEyOUMyMC42MzE0IDcuMDgzNTYgMjAuOTkzMiA4LjE4MzU1IDIwLjMxMzQgOC43NTg4MkwxNi4zMDEzIDEyLjE1NDFDMTYuMDE0NyAxMi4zOTY2IDE1Ljg4OTUgMTIuNzc3MiAxNS45NzcxIDEzLjEzOThMMTcuMjAyOCAxOC4yMTY0QzE3LjQxMDUgMTkuMDc2NSAxNi40NjM0IDE5Ljc1NjQgMTUuNjk5NSAxOS4yOTU1TDExLjE5MSAxNi41NzVDMTAuODY5IDE2LjM4MDYgMTAuNDY0IDE2LjM4MDYgMTAuMTQyIDE2LjU3NUw1LjYzMzQ5IDE5LjI5NTVDNC44Njk2MiAxOS43NTY0IDMuOTIyNDYgMTkuMDc2NSA0LjEzMDE0IDE4LjIxNjRMNS4zNTU5MyAxMy4xMzk4QzUuNDQzNDggMTIuNzc3MiA1LjMxODMzIDEyLjM5NjYgNS4wMzE3NiAxMi4xNTQxTDEuMDE5NTcgOC43NTg4MkMwLjMzOTc4NiA4LjE4MzU1IDAuNzAxNTcyIDcuMDgzNTYgMS41OTM3OSA3LjAxMjlMNi44NTk4NiA2LjU5NTgyQzcuMjM2IDYuNTY2MDMgNy41NjM2NiA2LjMzMDg1IDcuNzA4NTcgNS45ODY2NUw5LjczNzM4IDEuMTY3NzZaIiBmaWxsPSIjQjBCMEIwIi8+Cjwvc3ZnPgo="},2713:function(e){"use strict";e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjEiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMSAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTkuNzM3MzggMS4xNjc3NkMxMC4wODExIDAuMzUxMzA1IDExLjI1MTkgMC4zNTEzMDYgMTEuNTk1NiAxLjE2Nzc3TDEzLjYyNDQgNS45ODY2NUMxMy43Njk0IDYuMzMwODUgMTQuMDk3MSA2LjU2NjAzIDE0LjQ3MzIgNi41OTU4MkwxOS43MzkyIDcuMDEyOUMyMC42MzE0IDcuMDgzNTYgMjAuOTkzMiA4LjE4MzU1IDIwLjMxMzQgOC43NTg4MkwxNi4zMDEzIDEyLjE1NDFDMTYuMDE0NyAxMi4zOTY2IDE1Ljg4OTUgMTIuNzc3MiAxNS45NzcxIDEzLjEzOThMMTcuMjAyOCAxOC4yMTY0QzE3LjQxMDUgMTkuMDc2NSAxNi40NjM0IDE5Ljc1NjQgMTUuNjk5NSAxOS4yOTU1TDExLjE5MSAxNi41NzVDMTAuODY5IDE2LjM4MDYgMTAuNDY0IDE2LjM4MDYgMTAuMTQyIDE2LjU3NUw1LjYzMzQ5IDE5LjI5NTVDNC44Njk2MiAxOS43NTY0IDMuOTIyNDYgMTkuMDc2NSA0LjEzMDE0IDE4LjIxNjRMNS4zNTU5MyAxMy4xMzk4QzUuNDQzNDggMTIuNzc3MiA1LjMxODMzIDEyLjM5NjYgNS4wMzE3NiAxMi4xNTQxTDEuMDE5NTcgOC43NTg4MkMwLjMzOTc4NiA4LjE4MzU1IDAuNzAxNTcyIDcuMDgzNTYgMS41OTM3OSA3LjAxMjlMNi44NTk4NiA2LjU5NTgyQzcuMjM2IDYuNTY2MDMgNy41NjM2NiA2LjMzMDg1IDcuNzA4NTcgNS45ODY2NUw5LjczNzM4IDEuMTY3NzZaIiBmaWxsPSIjRjlCODExIi8+Cjwvc3ZnPgo="},9184:function(e,n,l){"use strict";e.exports=l.p+"images/explore/heaven-resort.jpg"},6198:function(e,n,l){"use strict";e.exports=l.p+"images/explore/image.jpg"},1079:function(e,n,l){"use strict";e.exports=l.p+"images/explore/jake-anderson.jpg"},5190:function(e,n,l){"use strict";e.exports=l.p+"images/header/heaven.jpg"},3867:function(e,n,l){"use strict";e.exports=l.p+"images/header/subtract.png"},3807:function(e,n,l){"use strict";e.exports=l.p+"images/product/bali.jpg"},5990:function(e,n,l){"use strict";e.exports=l.p+"images/product/bangkok.jpg"},5874:function(e,n,l){"use strict";e.exports=l.p+"images/product/dubai.jpg"},5539:function(e,n,l){"use strict";e.exports=l.p+"images/product/new-york.jpg"},7856:function(e,n,l){"use strict";e.exports=l.p+"images/product/paris.jpg"},508:function(e,n,l){"use strict";e.exports=l.p+"images/product/santorini.jpg"},1893:function(e,n,l){"use strict";e.exports=l.p+"images/product/venice.jpg"},3651:function(e,n,l){"use strict";e.exports=l.p+"images/services/01.jpg"},9172:function(e,n,l){"use strict";e.exports=l.p+"images/services/02.jpg"},2897:function(e,n,l){"use strict";e.exports=l.p+"images/services/03.jpg"},1727:function(e,n,l){"use strict";e.exports=l.p+"images/services/customers.png"},2283:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/01.jpg"},8236:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/02.jpg"},1961:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/03.jpg"},9370:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/04.jpg"},2023:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/05.jpg"},9448:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/06.jpg"},357:function(e,n,l){"use strict";e.exports=l.p+"images/testimonials/07.jpg"},3365:function(){}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var l=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(l.exports,l,l.exports,__webpack_require__),l.exports}__webpack_require__.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=function(e,n){for(var l in n)__webpack_require__.o(n,l)&&!__webpack_require__.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:n[l]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},function(){var e;__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var n=__webpack_require__.g.document;if(!e&&n&&(n.currentScript&&(e=n.currentScript.src),!e)){var l=n.getElementsByTagName("script");if(l.length)for(var t=l.length-1;t>-1&&(!e||!/^http(s?):/.test(e));)e=l[t--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e}();var __webpack_exports__=__webpack_require__(5637)})();